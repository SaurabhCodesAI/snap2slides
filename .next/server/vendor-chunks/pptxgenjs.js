"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pptxgenjs";
exports.ids = ["vendor-chunks/pptxgenjs"];
exports.modules = {

/***/ "(rsc)/./node_modules/pptxgenjs/dist/pptxgen.es.js":
/*!***************************************************!*\
  !*** ./node_modules/pptxgenjs/dist/pptxgen.es.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PptxGenJS)\n/* harmony export */ });\n/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jszip */ \"(rsc)/./node_modules/jszip/lib/index.js\");\n/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jszip__WEBPACK_IMPORTED_MODULE_0__);\n/* PptxGenJS 4.0.1 @ 2025-06-25T23:35:35.098Z */\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\n/**\n * PptxGenJS Enums\n * NOTE: `enum` wont work for objects, so use `Object.freeze`\n */\n// CONST\nconst EMU = 914400; // One (1) inch (OfficeXML measures in EMU (English Metric Units))\nconst ONEPT = 12700; // One (1) point (pt)\nconst CRLF = '\\r\\n'; // AKA: Chr(13) & Chr(10)\nconst LAYOUT_IDX_SERIES_BASE = 2147483649;\nconst REGEX_HEX_COLOR = /^[0-9a-fA-F]{6}$/;\nconst LINEH_MODIFIER = 1.67; // AKA: Golden Ratio Typography\nconst DEF_BULLET_MARGIN = 27;\nconst DEF_CELL_BORDER = { type: 'solid', color: '666666', pt: 1 };\nconst DEF_CELL_MARGIN_IN = [0.05, 0.1, 0.05, 0.1]; // \"Normal\" margins in PPT-2021 (\"Narrow\" is `0.05` for all 4)\nconst DEF_CHART_BORDER = { color: '363636', pt: 1 };\nconst DEF_CHART_GRIDLINE = { color: '888888', style: 'solid', size: 1, cap: 'flat' };\nconst DEF_FONT_COLOR = '000000';\nconst DEF_FONT_SIZE = 12;\nconst DEF_FONT_TITLE_SIZE = 18;\nconst DEF_PRES_LAYOUT = 'LAYOUT_16x9';\nconst DEF_PRES_LAYOUT_NAME = 'DEFAULT';\nconst DEF_SHAPE_LINE_COLOR = '333333';\nconst DEF_SHAPE_SHADOW = { type: 'outer', blur: 3, offset: 23000 / 12700, angle: 90, color: '000000', opacity: 0.35, rotateWithShape: true };\nconst DEF_SLIDE_MARGIN_IN = [0.5, 0.5, 0.5, 0.5]; // TRBL-style\nconst DEF_TEXT_SHADOW = { color: '000000'};\nconst DEF_TEXT_GLOW = { size: 8, color: 'FFFFFF', opacity: 0.75 };\nconst AXIS_ID_VALUE_PRIMARY = '2094734552';\nconst AXIS_ID_VALUE_SECONDARY = '2094734553';\nconst AXIS_ID_CATEGORY_PRIMARY = '2094734554';\nconst AXIS_ID_CATEGORY_SECONDARY = '2094734555';\nconst AXIS_ID_SERIES_PRIMARY = '2094734556';\nconst LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');\nconst BARCHART_COLORS = [\n    'C0504D',\n    '4F81BD',\n    '9BBB59',\n    '8064A2',\n    '4BACC6',\n    'F79646',\n    '628FC6',\n    'C86360',\n    'C0504D',\n    '4F81BD',\n    '9BBB59',\n    '8064A2',\n    '4BACC6',\n    'F79646',\n    '628FC6',\n    'C86360'\n];\nconst PIECHART_COLORS = [\n    '5DA5DA',\n    'FAA43A',\n    '60BD68',\n    'F17CB0',\n    'B2912F',\n    'B276B2',\n    'DECF3F',\n    'F15854',\n    'A7A7A7',\n    '5DA5DA',\n    'FAA43A',\n    '60BD68',\n    'F17CB0',\n    'B2912F',\n    'B276B2',\n    'DECF3F',\n    'F15854',\n    'A7A7A7',\n];\nvar TEXT_HALIGN;\n(function (TEXT_HALIGN) {\n    TEXT_HALIGN[\"left\"] = \"left\";\n    TEXT_HALIGN[\"center\"] = \"center\";\n    TEXT_HALIGN[\"right\"] = \"right\";\n    TEXT_HALIGN[\"justify\"] = \"justify\";\n})(TEXT_HALIGN || (TEXT_HALIGN = {}));\nvar TEXT_VALIGN;\n(function (TEXT_VALIGN) {\n    TEXT_VALIGN[\"b\"] = \"b\";\n    TEXT_VALIGN[\"ctr\"] = \"ctr\";\n    TEXT_VALIGN[\"t\"] = \"t\";\n})(TEXT_VALIGN || (TEXT_VALIGN = {}));\nconst SLDNUMFLDID = '{F7021451-1387-4CA6-816F-3879F97B5CBC}';\n// ENUM\n// TODO: 3.5 or v4.0: rationalize ts-def exported enum names/case!\n// NOTE: First tsdef enum named correctly (shapes -> 'Shape', colors -> 'Color'), etc.\nvar OutputType;\n(function (OutputType) {\n    OutputType[\"arraybuffer\"] = \"arraybuffer\";\n    OutputType[\"base64\"] = \"base64\";\n    OutputType[\"binarystring\"] = \"binarystring\";\n    OutputType[\"blob\"] = \"blob\";\n    OutputType[\"nodebuffer\"] = \"nodebuffer\";\n    OutputType[\"uint8array\"] = \"uint8array\";\n})(OutputType || (OutputType = {}));\nvar ChartType;\n(function (ChartType) {\n    ChartType[\"area\"] = \"area\";\n    ChartType[\"bar\"] = \"bar\";\n    ChartType[\"bar3d\"] = \"bar3D\";\n    ChartType[\"bubble\"] = \"bubble\";\n    ChartType[\"bubble3d\"] = \"bubble3D\";\n    ChartType[\"doughnut\"] = \"doughnut\";\n    ChartType[\"line\"] = \"line\";\n    ChartType[\"pie\"] = \"pie\";\n    ChartType[\"radar\"] = \"radar\";\n    ChartType[\"scatter\"] = \"scatter\";\n})(ChartType || (ChartType = {}));\nvar ShapeType;\n(function (ShapeType) {\n    ShapeType[\"accentBorderCallout1\"] = \"accentBorderCallout1\";\n    ShapeType[\"accentBorderCallout2\"] = \"accentBorderCallout2\";\n    ShapeType[\"accentBorderCallout3\"] = \"accentBorderCallout3\";\n    ShapeType[\"accentCallout1\"] = \"accentCallout1\";\n    ShapeType[\"accentCallout2\"] = \"accentCallout2\";\n    ShapeType[\"accentCallout3\"] = \"accentCallout3\";\n    ShapeType[\"actionButtonBackPrevious\"] = \"actionButtonBackPrevious\";\n    ShapeType[\"actionButtonBeginning\"] = \"actionButtonBeginning\";\n    ShapeType[\"actionButtonBlank\"] = \"actionButtonBlank\";\n    ShapeType[\"actionButtonDocument\"] = \"actionButtonDocument\";\n    ShapeType[\"actionButtonEnd\"] = \"actionButtonEnd\";\n    ShapeType[\"actionButtonForwardNext\"] = \"actionButtonForwardNext\";\n    ShapeType[\"actionButtonHelp\"] = \"actionButtonHelp\";\n    ShapeType[\"actionButtonHome\"] = \"actionButtonHome\";\n    ShapeType[\"actionButtonInformation\"] = \"actionButtonInformation\";\n    ShapeType[\"actionButtonMovie\"] = \"actionButtonMovie\";\n    ShapeType[\"actionButtonReturn\"] = \"actionButtonReturn\";\n    ShapeType[\"actionButtonSound\"] = \"actionButtonSound\";\n    ShapeType[\"arc\"] = \"arc\";\n    ShapeType[\"bentArrow\"] = \"bentArrow\";\n    ShapeType[\"bentUpArrow\"] = \"bentUpArrow\";\n    ShapeType[\"bevel\"] = \"bevel\";\n    ShapeType[\"blockArc\"] = \"blockArc\";\n    ShapeType[\"borderCallout1\"] = \"borderCallout1\";\n    ShapeType[\"borderCallout2\"] = \"borderCallout2\";\n    ShapeType[\"borderCallout3\"] = \"borderCallout3\";\n    ShapeType[\"bracePair\"] = \"bracePair\";\n    ShapeType[\"bracketPair\"] = \"bracketPair\";\n    ShapeType[\"callout1\"] = \"callout1\";\n    ShapeType[\"callout2\"] = \"callout2\";\n    ShapeType[\"callout3\"] = \"callout3\";\n    ShapeType[\"can\"] = \"can\";\n    ShapeType[\"chartPlus\"] = \"chartPlus\";\n    ShapeType[\"chartStar\"] = \"chartStar\";\n    ShapeType[\"chartX\"] = \"chartX\";\n    ShapeType[\"chevron\"] = \"chevron\";\n    ShapeType[\"chord\"] = \"chord\";\n    ShapeType[\"circularArrow\"] = \"circularArrow\";\n    ShapeType[\"cloud\"] = \"cloud\";\n    ShapeType[\"cloudCallout\"] = \"cloudCallout\";\n    ShapeType[\"corner\"] = \"corner\";\n    ShapeType[\"cornerTabs\"] = \"cornerTabs\";\n    ShapeType[\"cube\"] = \"cube\";\n    ShapeType[\"curvedDownArrow\"] = \"curvedDownArrow\";\n    ShapeType[\"curvedLeftArrow\"] = \"curvedLeftArrow\";\n    ShapeType[\"curvedRightArrow\"] = \"curvedRightArrow\";\n    ShapeType[\"curvedUpArrow\"] = \"curvedUpArrow\";\n    ShapeType[\"custGeom\"] = \"custGeom\";\n    ShapeType[\"decagon\"] = \"decagon\";\n    ShapeType[\"diagStripe\"] = \"diagStripe\";\n    ShapeType[\"diamond\"] = \"diamond\";\n    ShapeType[\"dodecagon\"] = \"dodecagon\";\n    ShapeType[\"donut\"] = \"donut\";\n    ShapeType[\"doubleWave\"] = \"doubleWave\";\n    ShapeType[\"downArrow\"] = \"downArrow\";\n    ShapeType[\"downArrowCallout\"] = \"downArrowCallout\";\n    ShapeType[\"ellipse\"] = \"ellipse\";\n    ShapeType[\"ellipseRibbon\"] = \"ellipseRibbon\";\n    ShapeType[\"ellipseRibbon2\"] = \"ellipseRibbon2\";\n    ShapeType[\"flowChartAlternateProcess\"] = \"flowChartAlternateProcess\";\n    ShapeType[\"flowChartCollate\"] = \"flowChartCollate\";\n    ShapeType[\"flowChartConnector\"] = \"flowChartConnector\";\n    ShapeType[\"flowChartDecision\"] = \"flowChartDecision\";\n    ShapeType[\"flowChartDelay\"] = \"flowChartDelay\";\n    ShapeType[\"flowChartDisplay\"] = \"flowChartDisplay\";\n    ShapeType[\"flowChartDocument\"] = \"flowChartDocument\";\n    ShapeType[\"flowChartExtract\"] = \"flowChartExtract\";\n    ShapeType[\"flowChartInputOutput\"] = \"flowChartInputOutput\";\n    ShapeType[\"flowChartInternalStorage\"] = \"flowChartInternalStorage\";\n    ShapeType[\"flowChartMagneticDisk\"] = \"flowChartMagneticDisk\";\n    ShapeType[\"flowChartMagneticDrum\"] = \"flowChartMagneticDrum\";\n    ShapeType[\"flowChartMagneticTape\"] = \"flowChartMagneticTape\";\n    ShapeType[\"flowChartManualInput\"] = \"flowChartManualInput\";\n    ShapeType[\"flowChartManualOperation\"] = \"flowChartManualOperation\";\n    ShapeType[\"flowChartMerge\"] = \"flowChartMerge\";\n    ShapeType[\"flowChartMultidocument\"] = \"flowChartMultidocument\";\n    ShapeType[\"flowChartOfflineStorage\"] = \"flowChartOfflineStorage\";\n    ShapeType[\"flowChartOffpageConnector\"] = \"flowChartOffpageConnector\";\n    ShapeType[\"flowChartOnlineStorage\"] = \"flowChartOnlineStorage\";\n    ShapeType[\"flowChartOr\"] = \"flowChartOr\";\n    ShapeType[\"flowChartPredefinedProcess\"] = \"flowChartPredefinedProcess\";\n    ShapeType[\"flowChartPreparation\"] = \"flowChartPreparation\";\n    ShapeType[\"flowChartProcess\"] = \"flowChartProcess\";\n    ShapeType[\"flowChartPunchedCard\"] = \"flowChartPunchedCard\";\n    ShapeType[\"flowChartPunchedTape\"] = \"flowChartPunchedTape\";\n    ShapeType[\"flowChartSort\"] = \"flowChartSort\";\n    ShapeType[\"flowChartSummingJunction\"] = \"flowChartSummingJunction\";\n    ShapeType[\"flowChartTerminator\"] = \"flowChartTerminator\";\n    ShapeType[\"folderCorner\"] = \"folderCorner\";\n    ShapeType[\"frame\"] = \"frame\";\n    ShapeType[\"funnel\"] = \"funnel\";\n    ShapeType[\"gear6\"] = \"gear6\";\n    ShapeType[\"gear9\"] = \"gear9\";\n    ShapeType[\"halfFrame\"] = \"halfFrame\";\n    ShapeType[\"heart\"] = \"heart\";\n    ShapeType[\"heptagon\"] = \"heptagon\";\n    ShapeType[\"hexagon\"] = \"hexagon\";\n    ShapeType[\"homePlate\"] = \"homePlate\";\n    ShapeType[\"horizontalScroll\"] = \"horizontalScroll\";\n    ShapeType[\"irregularSeal1\"] = \"irregularSeal1\";\n    ShapeType[\"irregularSeal2\"] = \"irregularSeal2\";\n    ShapeType[\"leftArrow\"] = \"leftArrow\";\n    ShapeType[\"leftArrowCallout\"] = \"leftArrowCallout\";\n    ShapeType[\"leftBrace\"] = \"leftBrace\";\n    ShapeType[\"leftBracket\"] = \"leftBracket\";\n    ShapeType[\"leftCircularArrow\"] = \"leftCircularArrow\";\n    ShapeType[\"leftRightArrow\"] = \"leftRightArrow\";\n    ShapeType[\"leftRightArrowCallout\"] = \"leftRightArrowCallout\";\n    ShapeType[\"leftRightCircularArrow\"] = \"leftRightCircularArrow\";\n    ShapeType[\"leftRightRibbon\"] = \"leftRightRibbon\";\n    ShapeType[\"leftRightUpArrow\"] = \"leftRightUpArrow\";\n    ShapeType[\"leftUpArrow\"] = \"leftUpArrow\";\n    ShapeType[\"lightningBolt\"] = \"lightningBolt\";\n    ShapeType[\"line\"] = \"line\";\n    ShapeType[\"lineInv\"] = \"lineInv\";\n    ShapeType[\"mathDivide\"] = \"mathDivide\";\n    ShapeType[\"mathEqual\"] = \"mathEqual\";\n    ShapeType[\"mathMinus\"] = \"mathMinus\";\n    ShapeType[\"mathMultiply\"] = \"mathMultiply\";\n    ShapeType[\"mathNotEqual\"] = \"mathNotEqual\";\n    ShapeType[\"mathPlus\"] = \"mathPlus\";\n    ShapeType[\"moon\"] = \"moon\";\n    ShapeType[\"noSmoking\"] = \"noSmoking\";\n    ShapeType[\"nonIsoscelesTrapezoid\"] = \"nonIsoscelesTrapezoid\";\n    ShapeType[\"notchedRightArrow\"] = \"notchedRightArrow\";\n    ShapeType[\"octagon\"] = \"octagon\";\n    ShapeType[\"parallelogram\"] = \"parallelogram\";\n    ShapeType[\"pentagon\"] = \"pentagon\";\n    ShapeType[\"pie\"] = \"pie\";\n    ShapeType[\"pieWedge\"] = \"pieWedge\";\n    ShapeType[\"plaque\"] = \"plaque\";\n    ShapeType[\"plaqueTabs\"] = \"plaqueTabs\";\n    ShapeType[\"plus\"] = \"plus\";\n    ShapeType[\"quadArrow\"] = \"quadArrow\";\n    ShapeType[\"quadArrowCallout\"] = \"quadArrowCallout\";\n    ShapeType[\"rect\"] = \"rect\";\n    ShapeType[\"ribbon\"] = \"ribbon\";\n    ShapeType[\"ribbon2\"] = \"ribbon2\";\n    ShapeType[\"rightArrow\"] = \"rightArrow\";\n    ShapeType[\"rightArrowCallout\"] = \"rightArrowCallout\";\n    ShapeType[\"rightBrace\"] = \"rightBrace\";\n    ShapeType[\"rightBracket\"] = \"rightBracket\";\n    ShapeType[\"round1Rect\"] = \"round1Rect\";\n    ShapeType[\"round2DiagRect\"] = \"round2DiagRect\";\n    ShapeType[\"round2SameRect\"] = \"round2SameRect\";\n    ShapeType[\"roundRect\"] = \"roundRect\";\n    ShapeType[\"rtTriangle\"] = \"rtTriangle\";\n    ShapeType[\"smileyFace\"] = \"smileyFace\";\n    ShapeType[\"snip1Rect\"] = \"snip1Rect\";\n    ShapeType[\"snip2DiagRect\"] = \"snip2DiagRect\";\n    ShapeType[\"snip2SameRect\"] = \"snip2SameRect\";\n    ShapeType[\"snipRoundRect\"] = \"snipRoundRect\";\n    ShapeType[\"squareTabs\"] = \"squareTabs\";\n    ShapeType[\"star10\"] = \"star10\";\n    ShapeType[\"star12\"] = \"star12\";\n    ShapeType[\"star16\"] = \"star16\";\n    ShapeType[\"star24\"] = \"star24\";\n    ShapeType[\"star32\"] = \"star32\";\n    ShapeType[\"star4\"] = \"star4\";\n    ShapeType[\"star5\"] = \"star5\";\n    ShapeType[\"star6\"] = \"star6\";\n    ShapeType[\"star7\"] = \"star7\";\n    ShapeType[\"star8\"] = \"star8\";\n    ShapeType[\"stripedRightArrow\"] = \"stripedRightArrow\";\n    ShapeType[\"sun\"] = \"sun\";\n    ShapeType[\"swooshArrow\"] = \"swooshArrow\";\n    ShapeType[\"teardrop\"] = \"teardrop\";\n    ShapeType[\"trapezoid\"] = \"trapezoid\";\n    ShapeType[\"triangle\"] = \"triangle\";\n    ShapeType[\"upArrow\"] = \"upArrow\";\n    ShapeType[\"upArrowCallout\"] = \"upArrowCallout\";\n    ShapeType[\"upDownArrow\"] = \"upDownArrow\";\n    ShapeType[\"upDownArrowCallout\"] = \"upDownArrowCallout\";\n    ShapeType[\"uturnArrow\"] = \"uturnArrow\";\n    ShapeType[\"verticalScroll\"] = \"verticalScroll\";\n    ShapeType[\"wave\"] = \"wave\";\n    ShapeType[\"wedgeEllipseCallout\"] = \"wedgeEllipseCallout\";\n    ShapeType[\"wedgeRectCallout\"] = \"wedgeRectCallout\";\n    ShapeType[\"wedgeRoundRectCallout\"] = \"wedgeRoundRectCallout\";\n})(ShapeType || (ShapeType = {}));\n/**\n * TODO: FUTURE: v4.0: rename to `ThemeColor`\n */\nvar SchemeColor;\n(function (SchemeColor) {\n    SchemeColor[\"text1\"] = \"tx1\";\n    SchemeColor[\"text2\"] = \"tx2\";\n    SchemeColor[\"background1\"] = \"bg1\";\n    SchemeColor[\"background2\"] = \"bg2\";\n    SchemeColor[\"accent1\"] = \"accent1\";\n    SchemeColor[\"accent2\"] = \"accent2\";\n    SchemeColor[\"accent3\"] = \"accent3\";\n    SchemeColor[\"accent4\"] = \"accent4\";\n    SchemeColor[\"accent5\"] = \"accent5\";\n    SchemeColor[\"accent6\"] = \"accent6\";\n})(SchemeColor || (SchemeColor = {}));\nvar AlignH;\n(function (AlignH) {\n    AlignH[\"left\"] = \"left\";\n    AlignH[\"center\"] = \"center\";\n    AlignH[\"right\"] = \"right\";\n    AlignH[\"justify\"] = \"justify\";\n})(AlignH || (AlignH = {}));\nvar AlignV;\n(function (AlignV) {\n    AlignV[\"top\"] = \"top\";\n    AlignV[\"middle\"] = \"middle\";\n    AlignV[\"bottom\"] = \"bottom\";\n})(AlignV || (AlignV = {}));\nvar SHAPE_TYPE;\n(function (SHAPE_TYPE) {\n    SHAPE_TYPE[\"ACTION_BUTTON_BACK_OR_PREVIOUS\"] = \"actionButtonBackPrevious\";\n    SHAPE_TYPE[\"ACTION_BUTTON_BEGINNING\"] = \"actionButtonBeginning\";\n    SHAPE_TYPE[\"ACTION_BUTTON_CUSTOM\"] = \"actionButtonBlank\";\n    SHAPE_TYPE[\"ACTION_BUTTON_DOCUMENT\"] = \"actionButtonDocument\";\n    SHAPE_TYPE[\"ACTION_BUTTON_END\"] = \"actionButtonEnd\";\n    SHAPE_TYPE[\"ACTION_BUTTON_FORWARD_OR_NEXT\"] = \"actionButtonForwardNext\";\n    SHAPE_TYPE[\"ACTION_BUTTON_HELP\"] = \"actionButtonHelp\";\n    SHAPE_TYPE[\"ACTION_BUTTON_HOME\"] = \"actionButtonHome\";\n    SHAPE_TYPE[\"ACTION_BUTTON_INFORMATION\"] = \"actionButtonInformation\";\n    SHAPE_TYPE[\"ACTION_BUTTON_MOVIE\"] = \"actionButtonMovie\";\n    SHAPE_TYPE[\"ACTION_BUTTON_RETURN\"] = \"actionButtonReturn\";\n    SHAPE_TYPE[\"ACTION_BUTTON_SOUND\"] = \"actionButtonSound\";\n    SHAPE_TYPE[\"ARC\"] = \"arc\";\n    SHAPE_TYPE[\"BALLOON\"] = \"wedgeRoundRectCallout\";\n    SHAPE_TYPE[\"BENT_ARROW\"] = \"bentArrow\";\n    SHAPE_TYPE[\"BENT_UP_ARROW\"] = \"bentUpArrow\";\n    SHAPE_TYPE[\"BEVEL\"] = \"bevel\";\n    SHAPE_TYPE[\"BLOCK_ARC\"] = \"blockArc\";\n    SHAPE_TYPE[\"CAN\"] = \"can\";\n    SHAPE_TYPE[\"CHART_PLUS\"] = \"chartPlus\";\n    SHAPE_TYPE[\"CHART_STAR\"] = \"chartStar\";\n    SHAPE_TYPE[\"CHART_X\"] = \"chartX\";\n    SHAPE_TYPE[\"CHEVRON\"] = \"chevron\";\n    SHAPE_TYPE[\"CHORD\"] = \"chord\";\n    SHAPE_TYPE[\"CIRCULAR_ARROW\"] = \"circularArrow\";\n    SHAPE_TYPE[\"CLOUD\"] = \"cloud\";\n    SHAPE_TYPE[\"CLOUD_CALLOUT\"] = \"cloudCallout\";\n    SHAPE_TYPE[\"CORNER\"] = \"corner\";\n    SHAPE_TYPE[\"CORNER_TABS\"] = \"cornerTabs\";\n    SHAPE_TYPE[\"CROSS\"] = \"plus\";\n    SHAPE_TYPE[\"CUBE\"] = \"cube\";\n    SHAPE_TYPE[\"CURVED_DOWN_ARROW\"] = \"curvedDownArrow\";\n    SHAPE_TYPE[\"CURVED_DOWN_RIBBON\"] = \"ellipseRibbon\";\n    SHAPE_TYPE[\"CURVED_LEFT_ARROW\"] = \"curvedLeftArrow\";\n    SHAPE_TYPE[\"CURVED_RIGHT_ARROW\"] = \"curvedRightArrow\";\n    SHAPE_TYPE[\"CURVED_UP_ARROW\"] = \"curvedUpArrow\";\n    SHAPE_TYPE[\"CURVED_UP_RIBBON\"] = \"ellipseRibbon2\";\n    SHAPE_TYPE[\"CUSTOM_GEOMETRY\"] = \"custGeom\";\n    SHAPE_TYPE[\"DECAGON\"] = \"decagon\";\n    SHAPE_TYPE[\"DIAGONAL_STRIPE\"] = \"diagStripe\";\n    SHAPE_TYPE[\"DIAMOND\"] = \"diamond\";\n    SHAPE_TYPE[\"DODECAGON\"] = \"dodecagon\";\n    SHAPE_TYPE[\"DONUT\"] = \"donut\";\n    SHAPE_TYPE[\"DOUBLE_BRACE\"] = \"bracePair\";\n    SHAPE_TYPE[\"DOUBLE_BRACKET\"] = \"bracketPair\";\n    SHAPE_TYPE[\"DOUBLE_WAVE\"] = \"doubleWave\";\n    SHAPE_TYPE[\"DOWN_ARROW\"] = \"downArrow\";\n    SHAPE_TYPE[\"DOWN_ARROW_CALLOUT\"] = \"downArrowCallout\";\n    SHAPE_TYPE[\"DOWN_RIBBON\"] = \"ribbon\";\n    SHAPE_TYPE[\"EXPLOSION1\"] = \"irregularSeal1\";\n    SHAPE_TYPE[\"EXPLOSION2\"] = \"irregularSeal2\";\n    SHAPE_TYPE[\"FLOWCHART_ALTERNATE_PROCESS\"] = \"flowChartAlternateProcess\";\n    SHAPE_TYPE[\"FLOWCHART_CARD\"] = \"flowChartPunchedCard\";\n    SHAPE_TYPE[\"FLOWCHART_COLLATE\"] = \"flowChartCollate\";\n    SHAPE_TYPE[\"FLOWCHART_CONNECTOR\"] = \"flowChartConnector\";\n    SHAPE_TYPE[\"FLOWCHART_DATA\"] = \"flowChartInputOutput\";\n    SHAPE_TYPE[\"FLOWCHART_DECISION\"] = \"flowChartDecision\";\n    SHAPE_TYPE[\"FLOWCHART_DELAY\"] = \"flowChartDelay\";\n    SHAPE_TYPE[\"FLOWCHART_DIRECT_ACCESS_STORAGE\"] = \"flowChartMagneticDrum\";\n    SHAPE_TYPE[\"FLOWCHART_DISPLAY\"] = \"flowChartDisplay\";\n    SHAPE_TYPE[\"FLOWCHART_DOCUMENT\"] = \"flowChartDocument\";\n    SHAPE_TYPE[\"FLOWCHART_EXTRACT\"] = \"flowChartExtract\";\n    SHAPE_TYPE[\"FLOWCHART_INTERNAL_STORAGE\"] = \"flowChartInternalStorage\";\n    SHAPE_TYPE[\"FLOWCHART_MAGNETIC_DISK\"] = \"flowChartMagneticDisk\";\n    SHAPE_TYPE[\"FLOWCHART_MANUAL_INPUT\"] = \"flowChartManualInput\";\n    SHAPE_TYPE[\"FLOWCHART_MANUAL_OPERATION\"] = \"flowChartManualOperation\";\n    SHAPE_TYPE[\"FLOWCHART_MERGE\"] = \"flowChartMerge\";\n    SHAPE_TYPE[\"FLOWCHART_MULTIDOCUMENT\"] = \"flowChartMultidocument\";\n    SHAPE_TYPE[\"FLOWCHART_OFFLINE_STORAGE\"] = \"flowChartOfflineStorage\";\n    SHAPE_TYPE[\"FLOWCHART_OFFPAGE_CONNECTOR\"] = \"flowChartOffpageConnector\";\n    SHAPE_TYPE[\"FLOWCHART_OR\"] = \"flowChartOr\";\n    SHAPE_TYPE[\"FLOWCHART_PREDEFINED_PROCESS\"] = \"flowChartPredefinedProcess\";\n    SHAPE_TYPE[\"FLOWCHART_PREPARATION\"] = \"flowChartPreparation\";\n    SHAPE_TYPE[\"FLOWCHART_PROCESS\"] = \"flowChartProcess\";\n    SHAPE_TYPE[\"FLOWCHART_PUNCHED_TAPE\"] = \"flowChartPunchedTape\";\n    SHAPE_TYPE[\"FLOWCHART_SEQUENTIAL_ACCESS_STORAGE\"] = \"flowChartMagneticTape\";\n    SHAPE_TYPE[\"FLOWCHART_SORT\"] = \"flowChartSort\";\n    SHAPE_TYPE[\"FLOWCHART_STORED_DATA\"] = \"flowChartOnlineStorage\";\n    SHAPE_TYPE[\"FLOWCHART_SUMMING_JUNCTION\"] = \"flowChartSummingJunction\";\n    SHAPE_TYPE[\"FLOWCHART_TERMINATOR\"] = \"flowChartTerminator\";\n    SHAPE_TYPE[\"FOLDED_CORNER\"] = \"folderCorner\";\n    SHAPE_TYPE[\"FRAME\"] = \"frame\";\n    SHAPE_TYPE[\"FUNNEL\"] = \"funnel\";\n    SHAPE_TYPE[\"GEAR_6\"] = \"gear6\";\n    SHAPE_TYPE[\"GEAR_9\"] = \"gear9\";\n    SHAPE_TYPE[\"HALF_FRAME\"] = \"halfFrame\";\n    SHAPE_TYPE[\"HEART\"] = \"heart\";\n    SHAPE_TYPE[\"HEPTAGON\"] = \"heptagon\";\n    SHAPE_TYPE[\"HEXAGON\"] = \"hexagon\";\n    SHAPE_TYPE[\"HORIZONTAL_SCROLL\"] = \"horizontalScroll\";\n    SHAPE_TYPE[\"ISOSCELES_TRIANGLE\"] = \"triangle\";\n    SHAPE_TYPE[\"LEFT_ARROW\"] = \"leftArrow\";\n    SHAPE_TYPE[\"LEFT_ARROW_CALLOUT\"] = \"leftArrowCallout\";\n    SHAPE_TYPE[\"LEFT_BRACE\"] = \"leftBrace\";\n    SHAPE_TYPE[\"LEFT_BRACKET\"] = \"leftBracket\";\n    SHAPE_TYPE[\"LEFT_CIRCULAR_ARROW\"] = \"leftCircularArrow\";\n    SHAPE_TYPE[\"LEFT_RIGHT_ARROW\"] = \"leftRightArrow\";\n    SHAPE_TYPE[\"LEFT_RIGHT_ARROW_CALLOUT\"] = \"leftRightArrowCallout\";\n    SHAPE_TYPE[\"LEFT_RIGHT_CIRCULAR_ARROW\"] = \"leftRightCircularArrow\";\n    SHAPE_TYPE[\"LEFT_RIGHT_RIBBON\"] = \"leftRightRibbon\";\n    SHAPE_TYPE[\"LEFT_RIGHT_UP_ARROW\"] = \"leftRightUpArrow\";\n    SHAPE_TYPE[\"LEFT_UP_ARROW\"] = \"leftUpArrow\";\n    SHAPE_TYPE[\"LIGHTNING_BOLT\"] = \"lightningBolt\";\n    SHAPE_TYPE[\"LINE_CALLOUT_1\"] = \"borderCallout1\";\n    SHAPE_TYPE[\"LINE_CALLOUT_1_ACCENT_BAR\"] = \"accentCallout1\";\n    SHAPE_TYPE[\"LINE_CALLOUT_1_BORDER_AND_ACCENT_BAR\"] = \"accentBorderCallout1\";\n    SHAPE_TYPE[\"LINE_CALLOUT_1_NO_BORDER\"] = \"callout1\";\n    SHAPE_TYPE[\"LINE_CALLOUT_2\"] = \"borderCallout2\";\n    SHAPE_TYPE[\"LINE_CALLOUT_2_ACCENT_BAR\"] = \"accentCallout2\";\n    SHAPE_TYPE[\"LINE_CALLOUT_2_BORDER_AND_ACCENT_BAR\"] = \"accentBorderCallout2\";\n    SHAPE_TYPE[\"LINE_CALLOUT_2_NO_BORDER\"] = \"callout2\";\n    SHAPE_TYPE[\"LINE_CALLOUT_3\"] = \"borderCallout3\";\n    SHAPE_TYPE[\"LINE_CALLOUT_3_ACCENT_BAR\"] = \"accentCallout3\";\n    SHAPE_TYPE[\"LINE_CALLOUT_3_BORDER_AND_ACCENT_BAR\"] = \"accentBorderCallout3\";\n    SHAPE_TYPE[\"LINE_CALLOUT_3_NO_BORDER\"] = \"callout3\";\n    SHAPE_TYPE[\"LINE_CALLOUT_4\"] = \"borderCallout4\";\n    SHAPE_TYPE[\"LINE_CALLOUT_4_ACCENT_BAR\"] = \"accentCallout3=4\";\n    SHAPE_TYPE[\"LINE_CALLOUT_4_BORDER_AND_ACCENT_BAR\"] = \"accentBorderCallout4\";\n    SHAPE_TYPE[\"LINE_CALLOUT_4_NO_BORDER\"] = \"callout4\";\n    SHAPE_TYPE[\"LINE\"] = \"line\";\n    SHAPE_TYPE[\"LINE_INVERSE\"] = \"lineInv\";\n    SHAPE_TYPE[\"MATH_DIVIDE\"] = \"mathDivide\";\n    SHAPE_TYPE[\"MATH_EQUAL\"] = \"mathEqual\";\n    SHAPE_TYPE[\"MATH_MINUS\"] = \"mathMinus\";\n    SHAPE_TYPE[\"MATH_MULTIPLY\"] = \"mathMultiply\";\n    SHAPE_TYPE[\"MATH_NOT_EQUAL\"] = \"mathNotEqual\";\n    SHAPE_TYPE[\"MATH_PLUS\"] = \"mathPlus\";\n    SHAPE_TYPE[\"MOON\"] = \"moon\";\n    SHAPE_TYPE[\"NON_ISOSCELES_TRAPEZOID\"] = \"nonIsoscelesTrapezoid\";\n    SHAPE_TYPE[\"NOTCHED_RIGHT_ARROW\"] = \"notchedRightArrow\";\n    SHAPE_TYPE[\"NO_SYMBOL\"] = \"noSmoking\";\n    SHAPE_TYPE[\"OCTAGON\"] = \"octagon\";\n    SHAPE_TYPE[\"OVAL\"] = \"ellipse\";\n    SHAPE_TYPE[\"OVAL_CALLOUT\"] = \"wedgeEllipseCallout\";\n    SHAPE_TYPE[\"PARALLELOGRAM\"] = \"parallelogram\";\n    SHAPE_TYPE[\"PENTAGON\"] = \"homePlate\";\n    SHAPE_TYPE[\"PIE\"] = \"pie\";\n    SHAPE_TYPE[\"PIE_WEDGE\"] = \"pieWedge\";\n    SHAPE_TYPE[\"PLAQUE\"] = \"plaque\";\n    SHAPE_TYPE[\"PLAQUE_TABS\"] = \"plaqueTabs\";\n    SHAPE_TYPE[\"QUAD_ARROW\"] = \"quadArrow\";\n    SHAPE_TYPE[\"QUAD_ARROW_CALLOUT\"] = \"quadArrowCallout\";\n    SHAPE_TYPE[\"RECTANGLE\"] = \"rect\";\n    SHAPE_TYPE[\"RECTANGULAR_CALLOUT\"] = \"wedgeRectCallout\";\n    SHAPE_TYPE[\"REGULAR_PENTAGON\"] = \"pentagon\";\n    SHAPE_TYPE[\"RIGHT_ARROW\"] = \"rightArrow\";\n    SHAPE_TYPE[\"RIGHT_ARROW_CALLOUT\"] = \"rightArrowCallout\";\n    SHAPE_TYPE[\"RIGHT_BRACE\"] = \"rightBrace\";\n    SHAPE_TYPE[\"RIGHT_BRACKET\"] = \"rightBracket\";\n    SHAPE_TYPE[\"RIGHT_TRIANGLE\"] = \"rtTriangle\";\n    SHAPE_TYPE[\"ROUNDED_RECTANGLE\"] = \"roundRect\";\n    // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values\n    SHAPE_TYPE[\"ROUNDED_RECTANGULAR_CALLOUT\"] = \"wedgeRoundRectCallout\";\n    SHAPE_TYPE[\"ROUND_1_RECTANGLE\"] = \"round1Rect\";\n    SHAPE_TYPE[\"ROUND_2_DIAG_RECTANGLE\"] = \"round2DiagRect\";\n    SHAPE_TYPE[\"ROUND_2_SAME_RECTANGLE\"] = \"round2SameRect\";\n    SHAPE_TYPE[\"SMILEY_FACE\"] = \"smileyFace\";\n    SHAPE_TYPE[\"SNIP_1_RECTANGLE\"] = \"snip1Rect\";\n    SHAPE_TYPE[\"SNIP_2_DIAG_RECTANGLE\"] = \"snip2DiagRect\";\n    SHAPE_TYPE[\"SNIP_2_SAME_RECTANGLE\"] = \"snip2SameRect\";\n    SHAPE_TYPE[\"SNIP_ROUND_RECTANGLE\"] = \"snipRoundRect\";\n    SHAPE_TYPE[\"SQUARE_TABS\"] = \"squareTabs\";\n    SHAPE_TYPE[\"STAR_10_POINT\"] = \"star10\";\n    SHAPE_TYPE[\"STAR_12_POINT\"] = \"star12\";\n    SHAPE_TYPE[\"STAR_16_POINT\"] = \"star16\";\n    SHAPE_TYPE[\"STAR_24_POINT\"] = \"star24\";\n    SHAPE_TYPE[\"STAR_32_POINT\"] = \"star32\";\n    SHAPE_TYPE[\"STAR_4_POINT\"] = \"star4\";\n    SHAPE_TYPE[\"STAR_5_POINT\"] = \"star5\";\n    SHAPE_TYPE[\"STAR_6_POINT\"] = \"star6\";\n    SHAPE_TYPE[\"STAR_7_POINT\"] = \"star7\";\n    SHAPE_TYPE[\"STAR_8_POINT\"] = \"star8\";\n    SHAPE_TYPE[\"STRIPED_RIGHT_ARROW\"] = \"stripedRightArrow\";\n    SHAPE_TYPE[\"SUN\"] = \"sun\";\n    SHAPE_TYPE[\"SWOOSH_ARROW\"] = \"swooshArrow\";\n    SHAPE_TYPE[\"TEAR\"] = \"teardrop\";\n    SHAPE_TYPE[\"TRAPEZOID\"] = \"trapezoid\";\n    SHAPE_TYPE[\"UP_ARROW\"] = \"upArrow\";\n    SHAPE_TYPE[\"UP_ARROW_CALLOUT\"] = \"upArrowCallout\";\n    SHAPE_TYPE[\"UP_DOWN_ARROW\"] = \"upDownArrow\";\n    SHAPE_TYPE[\"UP_DOWN_ARROW_CALLOUT\"] = \"upDownArrowCallout\";\n    SHAPE_TYPE[\"UP_RIBBON\"] = \"ribbon2\";\n    SHAPE_TYPE[\"U_TURN_ARROW\"] = \"uturnArrow\";\n    SHAPE_TYPE[\"VERTICAL_SCROLL\"] = \"verticalScroll\";\n    SHAPE_TYPE[\"WAVE\"] = \"wave\";\n})(SHAPE_TYPE || (SHAPE_TYPE = {}));\nvar CHART_TYPE;\n(function (CHART_TYPE) {\n    CHART_TYPE[\"AREA\"] = \"area\";\n    CHART_TYPE[\"BAR\"] = \"bar\";\n    CHART_TYPE[\"BAR3D\"] = \"bar3D\";\n    CHART_TYPE[\"BUBBLE\"] = \"bubble\";\n    CHART_TYPE[\"BUBBLE3D\"] = \"bubble3D\";\n    CHART_TYPE[\"DOUGHNUT\"] = \"doughnut\";\n    CHART_TYPE[\"LINE\"] = \"line\";\n    CHART_TYPE[\"PIE\"] = \"pie\";\n    CHART_TYPE[\"RADAR\"] = \"radar\";\n    CHART_TYPE[\"SCATTER\"] = \"scatter\";\n})(CHART_TYPE || (CHART_TYPE = {}));\nvar SCHEME_COLOR_NAMES;\n(function (SCHEME_COLOR_NAMES) {\n    SCHEME_COLOR_NAMES[\"TEXT1\"] = \"tx1\";\n    SCHEME_COLOR_NAMES[\"TEXT2\"] = \"tx2\";\n    SCHEME_COLOR_NAMES[\"BACKGROUND1\"] = \"bg1\";\n    SCHEME_COLOR_NAMES[\"BACKGROUND2\"] = \"bg2\";\n    SCHEME_COLOR_NAMES[\"ACCENT1\"] = \"accent1\";\n    SCHEME_COLOR_NAMES[\"ACCENT2\"] = \"accent2\";\n    SCHEME_COLOR_NAMES[\"ACCENT3\"] = \"accent3\";\n    SCHEME_COLOR_NAMES[\"ACCENT4\"] = \"accent4\";\n    SCHEME_COLOR_NAMES[\"ACCENT5\"] = \"accent5\";\n    SCHEME_COLOR_NAMES[\"ACCENT6\"] = \"accent6\";\n})(SCHEME_COLOR_NAMES || (SCHEME_COLOR_NAMES = {}));\nvar MASTER_OBJECTS;\n(function (MASTER_OBJECTS) {\n    MASTER_OBJECTS[\"chart\"] = \"chart\";\n    MASTER_OBJECTS[\"image\"] = \"image\";\n    MASTER_OBJECTS[\"line\"] = \"line\";\n    MASTER_OBJECTS[\"rect\"] = \"rect\";\n    MASTER_OBJECTS[\"text\"] = \"text\";\n    MASTER_OBJECTS[\"placeholder\"] = \"placeholder\";\n})(MASTER_OBJECTS || (MASTER_OBJECTS = {}));\nvar SLIDE_OBJECT_TYPES;\n(function (SLIDE_OBJECT_TYPES) {\n    SLIDE_OBJECT_TYPES[\"chart\"] = \"chart\";\n    SLIDE_OBJECT_TYPES[\"hyperlink\"] = \"hyperlink\";\n    SLIDE_OBJECT_TYPES[\"image\"] = \"image\";\n    SLIDE_OBJECT_TYPES[\"media\"] = \"media\";\n    SLIDE_OBJECT_TYPES[\"online\"] = \"online\";\n    SLIDE_OBJECT_TYPES[\"placeholder\"] = \"placeholder\";\n    SLIDE_OBJECT_TYPES[\"table\"] = \"table\";\n    SLIDE_OBJECT_TYPES[\"tablecell\"] = \"tablecell\";\n    SLIDE_OBJECT_TYPES[\"text\"] = \"text\";\n    SLIDE_OBJECT_TYPES[\"notes\"] = \"notes\";\n})(SLIDE_OBJECT_TYPES || (SLIDE_OBJECT_TYPES = {}));\nvar PLACEHOLDER_TYPES;\n(function (PLACEHOLDER_TYPES) {\n    PLACEHOLDER_TYPES[\"title\"] = \"title\";\n    PLACEHOLDER_TYPES[\"body\"] = \"body\";\n    PLACEHOLDER_TYPES[\"image\"] = \"pic\";\n    PLACEHOLDER_TYPES[\"chart\"] = \"chart\";\n    PLACEHOLDER_TYPES[\"table\"] = \"tbl\";\n    PLACEHOLDER_TYPES[\"media\"] = \"media\";\n})(PLACEHOLDER_TYPES || (PLACEHOLDER_TYPES = {}));\n/**\n * NOTE: 20170304: BULLET_TYPES: Only default is used so far. I'd like to combine the two pieces of code that use these before implementing these as options\n * Since we close <p> within the text object bullets, its slightly more difficult than combining into a func and calling to get the paraProp\n * and i'm not sure if anyone will even use these... so, skipping for now.\n */\nvar BULLET_TYPES;\n(function (BULLET_TYPES) {\n    BULLET_TYPES[\"DEFAULT\"] = \"&#x2022;\";\n    BULLET_TYPES[\"CHECK\"] = \"&#x2713;\";\n    BULLET_TYPES[\"STAR\"] = \"&#x2605;\";\n    BULLET_TYPES[\"TRIANGLE\"] = \"&#x25B6;\";\n})(BULLET_TYPES || (BULLET_TYPES = {}));\n// IMAGES (base64)\nconst IMG_BROKEN = 'data:image/png;base64,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';\nconst IMG_PLAYBTN = 'data:image/png;base64,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AAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKREkRUAAACwrUpLSwuGDRvWfMCAAS26du3avKysrLiioqKkZcuWzZs1a1bcvHnz0tLS0rJsNtusuLi4ebNmzUoLCgo+8/eijY2N9Zs3b66pra2tqqur21xTU1NdVVVVs2nTptqNGzdWbdiwoeYvf/nL5hUrVlQtWLBgw6xZs6pqamoaJQYAAEDaKYABAACIiIghQ4aUHnTQQW379u3bql27dq3at2/fpkWLFq2bN29eWVpa2qpZs2bNCwsLm2ez2fLCwsLyoqKi8sLCwtKknK+hoaG6vr6+qqGh4S91dXV/aWhoqNq8eXNVTU3NuqqqqvUbNmxYu2rVqjWrV69e99Zbb6177rnnPpgzZ06NTwYAAABJogAGAADIA8OGDWt+xBFHdBwwYECnLl26dGjdunXHFi1adCgtLe1YUlLSvlmzZq0KCgqK07yDwsLCssLCwrKIaPdp/zuNjY21mzdvXrdp06ZVNTU172/YsGHl2rVr31+2bNnKBQsWrHjyySffnzVrVpVPGAAAAE1Fpuexsd9HfaF+ZcSal0ptCAAAIAE6deqUPf744zvtueeeXbp3796lbdu2XSorKzuXlpZ2KS0t7VBYWFhhSztGQ0PDxpqampU1NTXL169fv+yDDz5Y9s477yybPXv2sj/96U8rVqxYUWdLAAAAbE9t9q6Jog4f/TUFMAAAQEJks9nMt7/97Y4jRozo1bdv397t2rXrXl5e3rWsrKxzcXFx+4gosKUmp7G2tnZVTU3Nso0bNy5btWrV0tdff/2tJ598cvG999672noAAADYFgpgAACAhPne977X6a9Fb/v27Xu1bNmyV1lZWa8kvXOXLauvr9/wl7/8ZdG6desWL1u2bNHChQsX/fGPf1w8derUjbYDAADAliiAAQAAmqhsNps59dRTuxx66KH9+/Tp87n27dv3Ly8v719UVOSRzXlq06ZNKzZu3Pj6+++//8abb775xqOPPvrG3XffvcpmAAAA+CsFMAAAQBNx6qmndvniF784qHfv3v3btWv3uYqKis8VFhaW2wxbUl9fv37Dhg1vfPDBB68vXrz4jccee2z+jTfeuNxmAAAA8pMCGAAAYBc45phjWn/rW9/aq3///kPatGnTv6Kiop9HOLO9NDQ0VG/cuPGtNWvWLFy4cOGcO+6445WHHnporc0AAACknwIYAABgJzjjjDO6f+lLX9qrV69eg1u3bj2orKysR0RkbIadJFddXb103bp18xcvXjz30UcffeXqq69+x1oAAADSRwEMAACwnZWWlhb86le/2u3QQw8d1r17931btmw5qLCwsMxmaEoaGhqqP/zww/nvvPPOzGeeeWbW2LFj36ipqWm0GQAAgGRTAAMAAGwHP/7xj7t+9atf3bdXr15D27Ztu1c2m21jKyRJXV3dmg8++OCVRYsWvfznP/95xh/+8IdltgIAAJA8CmAAAIBtcOKJJ7Y75ZRTDujXr9+w1q1bD81ms61shTSpq6tbt3bt2pfffPPNWbfccsvUe++9d7WtAAAANH0KYAAAgE+hoqKi4IILLhg0YsSI/bp27bpfy5YtB2YymUKbIR/kcrmGDz/8cP6777474/nnn59x4YUXvrZx40aPiwYAAGiCFMAAAAAf4/jjj2/7/e9//8D+/fsf2Lp1630KCgpKbAUiGhsbN61fv37eW2+9NeWGG2545u67715lKwAAAE2DAhgAAOB/ZLPZzAUXXPC5I4888sDu3bsfWFFRsVtEFNgMbFl1dfWSd999d8qsWbNmnnvuuS+vW7euwVYAAAB2DQUwAACQ10pLSwsuvfTSQYcccsjBXbt2HVFWVtbDVmDb1dbWrnr//fdfmDp16uRf/vKXL65evbreVgAAAHYeBTAAAJB3Bg0aVHrBBRd8fs899zywQ4cOBxQVFbWwFdj+Ghsba9euXTtrzpw5T59//vmTX3755WpbAQAA2LEUwAAAQF4YNmxY8/POO+/gIUOGHOZ9vrDz/W0ZfNFFFz07a9asKlsBAADY/hTAAABAarVq1arwyiuv3HfEiBEjO3TocFBhYWGZrcCu19DQUP3+++8/O2XKlIk/+clPZm7cuLHRVgAAALYPBTAAAJAqrVq1Kvztb3+7/3777Xd4x44dRxQWFpbbCjRdDQ0NG99///0pM2bMeOqHP/zhC8pgAACAz0YBDAAApMJZZ53V45vf/OaRvXr1GllaWtrVRiB5ampq3l28ePHEO++8c9LVV1/9jo0AAABsPQUwAACQWMOHDy+/6KKLvjB48OCjW7RoMdBGID0+/PDDV+fNmzfhvPPOe3L69Ol/sREAAIBPRwEMAAAkSqtWrQpvuOGGQ/bbb79/atOmzX6ZTCZrK5BeuVyubs2aNTNmzJjx2JgxYyavW7euwVYAAAA+ngIYAABIhB//+Mddv/e9732lZ8+e/1RcXNzWRiD/1NbWfvD2228/dssttzz029/+9l0bAQAA+L8UwAAAQJNVUVFRcO21137+4IMPPrZ169b7ZTKZAlsBIqJxzZo1M59//vnxp5122hR3BQMAAPx/CmAAAKDJOeWUUzqefvrpx/bu3ftL2Wy2jY0AH6e+vn7j0qVLH/vd7373x+uvv36ZjQAAAPlOAQwAADQJ2Ww2c+uttx5wyCGHnNC6deu9I8LdvsDWaFy7du1L06ZN+/OPfvSjZ1evXl1vJQAAQD5SAAMAALtU//79S6655pp/2nPPPY8tLy/vayPAZ1VTU7NswYIF488999wHp06dutFGAACAfKIABgAAdomf//znPU855ZQTu3btemRhYWGZjQDbW2NjY92KFSuevOWWW+689NJLF9kIAACQDxTAAADATuMxz8Cusn79+rlPP/30f5188slT6+rqcjYCAACklQIYAADY4fr27Vv8hz/84a+Pee5nI8CuUlNT8+68efPu/8EPfvDgwoULN9kIAACQNgpgAABghxkyZEjpNddc89XBgwefWFxc3MFGgKaitrZ21dy5c+/5yU9+8uc5c+bU2AgAAJAWWyqAPYoNAADYJqNHj+4wb968n06ZMuXRYcOGnaH8BZqa4uLi9sOGDTtjypQpj86bN++nJ510UntbAQAA0s4dwAAAwFY599xze33/+9//dufOnY/IZDJZGwGSIpfL1S1fvvzJG2644fbLLrvsbRsBAACSyiOgAQCAz+y8887r+53vfOfbHTt2PDyTyRTaCJBUuVyuYcWKFU/cdNNN//XrX/96sY0AAABJowAGAAC22WWXXTboG9/4xg9at249zDaAtFm7du2su++++9pzzjnnNdsAAACSQgEMAABsNcUvkE8UwQAAQJIogAEAgE9N8Qvks7Vr18665557rvv5z38+3zYAAICmaksFcGHlwOj6UV9orIqoWZG1PQAAyBO/+MUvet9xxx3nHHrooT8pLS3tYiNAPiotLe2y7777HvP973+/X1lZ2ZIpU6assxUAAKCpKetcHwXlH/01BTAAAOS5M844o/u99957zpe//OWflZeX94qIjK0AeS5TXl7e8+CDDx71/e9/v3dEvDVjxowPrQUAAGgqFMAAAMD/ceKJJ7a77777fjJq1Kh/KS8v7xOKX4B/lCkvL+99+OGHj/rWt77VfvXq1Qvnz59fbS0AAMCutqUC2DuAAQAgzwwdOrTs+uuvP6l///4nFRYWltkI20NjY2Ns2rQpqquro6amJurr62PTpk2xefPmqK+vj+rq6qivr4/NmzfHpk2boqGhYZv/fxUWFkZJSUk0a9YsioqKoqysLIqKiqJZs2ZRUlISRUVFUVpa+r9/FRQUCIjtoqGhoeq11167a8yYMffMmTOnxkYAAIBdZUvvAFYAAwBAnujUqVP2nnvuGbXXXnudnM1mK22Ej9PQ0BAbN26MDRs2/J+/Nm7cGBs3boyamprYtGlTbNq0KWpqaqK2trbJnqe4uDhKSkqitLT0f/9eUVERFRUV0aJFi//zV0VFRRQWFvog8LHq6urWvvjii7eceOKJf169enW9jQAAADubAhgAAPLcXXfdddAXv/jF00tLS7vZRn7L5XKxYcOGWLt2baxbty7Wrl37d3+tW7cuNmzYkPd7atGiRbRu3TpatWoVrVu3jjZt2vzvf27dunW0aNHCh4morq5e+sgjj1zzne98Z6ptAAAAO5MCGAAA8tTVV189+MQTTzyzoqJioG3kj8bGxli5cmUsX748Pvjgg1i9evX//n3t2rXR2NhoSZ9RYWFhtGrVKtq1axdt27b937937tw5OnTo4LHTeWbDhg3z77333qvOPPPMebYBAADsDApgAADIM1/72tfaXHrppad27979qIjQRKVUQ0NDrFq1KlasWBHvv//+//595cqVTfqRzGlXXFwcHTp0iI4dO0bnzp2jY8eO0alTp2jXrp1HS6dYLpdrfOeddx76+c9/fv2ECRPW2QgAALAjKYABACBP9OrVq9ldd931jT322OM7hYWFZTaSHh9++GG88847sXTp0njvvfdixYoVsXr16mhoaLCchCgsLIz27dtHp06dolu3btG9e/fo3r27x0mnTENDQ9W8efNu++Y3v/nHJUuWbLYRAABgR1AAAwBAHrjrrrtG/NM//dOZJSUlXWwj2davXx9Lly6Nd955539L3w8//NBiUqqysvJ/y+C//tWqVSuLSbiamppljz322G9Gjx49xTYAAIDtTQEMAAAp9qtf/arPD3/4w5+1atVqL9tIno0bN8aSJUvirbfeikWLFsV7770XmzZtspg8V1JSEl27do0+ffpE3759o3fv3lFeXm4xCbRu3bqXr7322ivGjh27yDYAAIDtRQEMAAApNGjQoNI77rjju7vttttJBQUFWRtJhtWrV8ebb74ZixcvjiVLlsTy5cujsbHRYtiigoKC6Ny5c/Tu3Tt69+4d/fr1i7Zt21pMQjQ2Nta98cYbd33rW9+6ff78+TU2AgAAfFYKYAAASJHS0tKCBx988Jj99tvvn7PZbBsbaboaGhri7bffjrfeeisWLFgQS5YscXcv201FRUX06tUr+vbtG3379o2ePXtGYWGhxTRhdXV1a2bMmHHjV77ylYdqamr85gcAALDNFMAAAJASp59+erdf/vKX51ZWVu5jG03T6tWr47XXXouFCxfGm2++GRs3brQUdooWLVpE3759Y8CAATFw4EB3CDdh69evf/E//uM//vPqq69+xzYAAIBtoQAGAICEGzRoUOm99977w969ex+byWTc4teErF+/PubNmxcLFiyIN954Q+FLk9GiRYvo169fDBgwIPbYY4+orKy0lCYkl8s1LF68eNyJJ554rcdCAwAAW0sBDAAACXbNNdcMOemkk35RVlbWyzZ2vVwuF++++27MnTs3XnvttViyZIl3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B7lcrm7y5Mm//vKXv/yIbQAAwK63pXcAK4ABAMg7paWlBTNnzjyzT58+x9vG39uwYUOMGzcuZsyY4VHPQF7KZDKx3377xde//vWoqKiwkH+waNGiP+27775X1dTUeCwEAADsQgpgAAD4H926dctOnjz5V506dRppG/9fLpeLqVOnxp///OfYuHGjhQB5r6KiIkaNGhX777+/x0L/g+XLlz9+6KGHXvLuu+/W2QYAAOwaWyqAvQMYAIC8MXz48PInnnjiynbt2o2wjf/vnXfeiWuvvTaee+652Lx5s4UARMTmzZtjzpw58dprr0XPnj2jRYsWlvI/Kioq+n7rW98aMnXq1Ofee+89f3AAAMAusKV3ACuAAQDIC9/+9rc73n777X9o0aLFANv4b1VVVXHXXXfFvffeG+vXr7cQgI+wbt26eP7552P9+vWx2267RVFRkaVERElJSefjjjvuoA8++GDKK6+88hcbAQCAnUsBDABAXjv//PP7XXzxxX8oKSnpbBv/bfr06XHttdfGokWLLAPgU3jnnXdi2rRp0bp16+jc2R8nERHZbLbyC1/4whElJSUvTp48eY2NAADAzqMABgAgb/3ud7/b60c/+tFVRUVFrWwjYs2aNXHzzTfHpEmTora21kIAtkJtbW289NJL8c4770Tfvn2jtLQ073dSWFhYNnz48C/26dNn4UMPPbTMpwQAAHYOBTAAAHnp1ltv3f+b3/zmfxYWFjbP913kcrl4/vnn4/rrr4/ly5f7cAB8BitXroxp06ZFRUVFdOvWLTKZTF7vo6CgIDto0KBDBw0atOiBBx54xycEAAB2vC0VwJmex8Z+H/WF+pURa17ym6wAACTTww8//KXDDjvsXzKZTN6/rPGDDz6I22+/Pd544w0fDIDtbMCAAfGtb30r2rRpk/e7yOVyjVOmTPn1yJEjH/LJAACAHavN3jVR1OGjv6YABgAgdV555ZXTPve5z30r3/fQ0NAQjz32WDz++ONRV1fngwGwg2Sz2Tj66KPjC1/4QhQUFOT9Pl5//fU79tprr9/7ZAAAwI6jAAYAIC9ks9nMyy+/fFafPn2Oz/ddvPvuu3HbbbfFe++954MBsJN069YtvvOd70S3bt3yfhdLliy5f5999rmypqam0ScDAAC2PwUwAACpV1paWjBr1qyzevfufVw+7yGXy8WTTz4ZDz74oLt+AXaBbDYbxxxzTBxxxBF5fzfw0qVLHxg6dOjlSmAAANj+FMAAAKRar169mk2ePHlsu3btDsrnPaxcuTJuueWWePvtt30oAHaxnj17ximnnBIdOnTI6z2sXr16yiGHHPIvS5Ys2exTAQAA28+WCuDCyoHR9aO+0FgVUbMia3sAADRpQ4cOLXvqqacub9Omzf75uoNcLhfPPPNMXH/99bF27VofCoAmYP369TFlypQoKSmJnj17RiaTycs9NG/evPtJJ500ZPLkyc+sWLHCoykAAGA7KetcHwXlH/01BTAAAIk1ZMiQ0kceeeSKVq1a7Z2vO6iuro7bb789nnjiiWhs9IRNgKaksbEx5s+fH++//34MGDAgstn8/DlLaWlpp6997WuDn3rqqadXrlxZ75MBAACfnQIYAIDUOfTQQ1s8+OCDv2/ZsuUe+bqDOXPmxNVXX+2RzwBN3PLly+OFF16Ijh075u0joUtLSzudcMIJ+7/00ktPv/3227U+FQAA8NkogAEASJVhw4Y1v++++37TsmXLQfl4/vr6+hg/fnz88Y9/jNpaP0MHSILNmzfHiy++GJs3b47ddtstCgoK8m4HxcXFbY866qg9n3vuuaeXL1/ucdAAAPAZKIABAEiNI488snLcuHG/b9GixcB8PP97770XV111VcyZM8eHASCBFi1aFC+//HL069cvWrRokXfnLykp6XDcccftP2fOnGcWLVq0yScCAAC2jQIYAIBUOPLIIyvvvPPO35aXl++Wj+d/+umn48Ybb4wPP/zQhwEgwf7yl7/ECy+8ECUlJdGrV6+8O3+zZs3aHHXUUfspgQEAYNspgAEASLxjjz227W233faH5s2b98m3s1dVVcXNN98cTz31VDQ2NvowAKRAY2NjzJ8/P5YtWxYDBgyIZs2a5dX5mzVr1uaYY4458M0333xm4cKFNT4RAACwdRTAAAAk2qGHHtritttuuzofy9+33347rrnmmli8eLEPAkAKvf/++/HKK69Enz59orKyMq/Ons1mK4888sh9Zs6c+dTSpUs3+zQAAMCnpwAGACCxjjjiiJb33nvvteXl5f3y6dy5XC4mTZoUN998c1RVVfkgAKRYVVVVTJ06NbLZbPTp0ycymUzenL24uLjtV7/61c+/8sorTy1evLjWpwEAAD4dBTAAAIl06KGHtrj33nt/l2/lb3V1ddx0000xefLkyOVyPggAeSCXy8WCBQvi3Xffjd133z2y2fz5mUyzZs1aH3300fvNmDHjSXcCAwDAp6MABgAgcYYOHVo2fvz4qysqKgbk07mXLVsWV111lUc+A+SplStXxiuvvBKf+9znoqKiIm/O3axZszZHH3300GeeeebJFStW1PkkAADAlimAAQBIlCFDhpQ++uij17Rs2XL3fDr31KlT49prr42NGzf6EADksaqqqpg+fXq0bds2unTpkjfnLikpaT9q1KihTz755JMrV66s90kAAICPt6UCuMB6AABoSjp16pSdMGHCv1dWVu6RL2dubGyMcePGxR133BF1dW56AiCitrY2br755hg/fnw0NjbmzbkrKyv3mDBhwr9369bNXQkAALCNFMAAADQZrVq1Kpw+ffolbdq02T9fzlxdXR2/+93vYtKkSd73C8DfyeVy8fjjj8fvf//7qK6uzptzt2nTZv8pU6Zc0qpVq0KfAgAA2HoKYAAAmoSKioqC2bNnX9KuXbuD8uXMS5cujYsuuijmz5/vAwDAx3r11VfjoosuiqVLl+bNmdu1a3fQ7Nmz/72iosLPrgAAYCu5iAYAoEmYOXPmz9q1a3dIvpz35ZdfjiuuuCLWrVsnfAA+0bp16+KKK66Il19+OW/O3K5du4Nnzpz5M+kDAMDWUQADALDLvfjii2N69OgxKh/Omsvl4oEHHogbbrghamtrhQ/Ap1ZbWxs33HBDPPDAA3nz2oAePXqMevHFF8dIHwAAPj0FMAAAu9SkSZO+NnDgwFPy4ax1dXVx8803x8SJE73vF4BtksvlYuLEiXHLLbdEXV1dXpx54MCBJ0+aNOlr0gcAgE9HAQwAwC7z6KOPHnXggQeekw9nXbduXfz617+OWbNmCR6Az2zmzJnx61//Ol9eJZA58MADz3n00UePkjwAAHyywsqB0fWjvtBYFVGzImtDAADsEDfeeOO+Rx999EWZTKYw7Wddvnx5XHXVVbFy5UrBA7DdbNiwIWbPnh0DBw6MioqKtB8307179/179uz56sMPP7xc+gAA5LuyzvVRUP7RX1MAAwCw011xxRV7fPe7372qoKCgWdrPOmfOnPjtb38bGzduFDwA2111dXVMmzYtOnfuHB07dkz1WTOZTOHuu+9+eJs2bV6aNGnSKukDAJDPFMAAADQZZ5xxRvef/exnvy0sLCxP+1knTJgQd999d9TX1wsegB2moaEhXnrppchms9G3b99UnzWTyRTttddeB/3lL395dubMmRukDwBAvlIAAwDQJBx00EEVf/jDH64pLi7ulOZz5nK5eOCBB+Kxxx4TOgA77c+eBQsWRF1dXfTv3z8ymUxqz1pQUFBywAEHDJs+ffqkpUuXbpY+AAD5aEsFcIH1AACwMwwaNKj0vvvuu7qsrKxXms9ZV1cX1113XUyaNEnoAOx0EydOjOuvvz7q6upSfc6ysrJef/rTn67u379/idQBAODvKYABANjhKioqCh577LGLKyoqBqb5nNXV1XHNNdfE7NmzhQ7ALvPKK6/ElVdeGVVVVak+Z4sWLQZOnDhxbEVFhZ9vAQDA33CBDADADjdz5syftW3b9sA0n3HdunVx2WWXxRtvvCFwAHa5xYsXx2WXXRZr165N9TnbtWt34MyZM38mcQAA+P8UwAAA7FBPPvnkqB49eoxK8xlXrVoVV1xxRSxfvlzgADQZK1asiCuuuCJWrlyZ6nP26NFj1KRJk0ZJHAAA/lth5cDo+lFfaKyKqFmRtSEAALbZjTfeuO+XvvSlCzOZTGp/8fDdd9+NK6+8MtatWydwAJqc6urqmDVrVvTv3z8qKytTe85u3boN79mz57yHH37Yb2MBAJAXyjrXR0H5R39NAQwAwA5x3nnn9T311FOvLigoKE7rGV977bW45pprorq6WuAANFmbN2+OGTNmRI8ePaJ9+/apPGMmkykYNGjQIYWFhVOee+45v5UFAEDqKYABANipjjrqqFb/8R//8YdmzZq1SusZX3755bj++uujrq5O4AA0eQ0NDfHSSy9Fp06dolOnTqk8Y0FBQXbYsGGfnz9//qQ33nhjk9QBAEizLRXA3gEMAMB21a1bt+wNN9zwnyUlJR3TesYpU6bEjTfeGPX19QIHIDHq6+vjxhtvjKlTp6b2jCUlJZ1uuOGG/+jWrZu7GgAAyFsKYAAAtqunn376XyorK/dI6/kmTZoUd955ZzQ2NgobgMRpbGyMO+64I5588snUnrGysnLw008//UtpAwCQrxTAAABsN88///w3unTp8k9pPd/EiRNj3LhxkcvlhA1AYuVyubj//vtTXQJ36dLlS88+++yJ0gYAIB95BzAAANvFTTfdNPzII488L5PJZNJ4vsceeyzGjx8vaABS47XXXotmzZpF3759U3m+zp0779urV695Dz/88DJpAwCQNlt6B7ACGACAz+wXv/hF7x/+8IdXFxQUNEvj+R544IF45JFHBA1A6ixYsCDq6upiwIABqTtbJpPJDBo06ODGxsbnpk6dul7aAACkiQIYAIAd5oADDqj43e9+99tmzZq1TeP5xo0bF5MmTRI0AKm1aNGi2Lx5cwwcODB1ZysoKMjut99+w5577rnH33vvvc3SBgAgLbZUAHsHMAAA2yybzWbuvPPOfyktLe2exvNNmDBB+QtAXpg0aVI89NBDqTxbaWlpj3vuuedfstlsRtIAAOQDBTAAANvs+eef/06HDh0OTePZHn744Xj44YeFDEDeeOSRR+LPf/5zKs/WoUOHw5599tlvSxkAgHygAAYAYJvcd999hw8ePPjUNJ7t/vvvjwkTJggZgLzz2GOPxX333ZfKs+25554/+NOf/nSYlAEASDvvAAYAYKudccYZ3ceMGXN5QUFBcdrONnHixHjkkUeEDEDeWrx4cWSz2ejbt2/ajpbp06fPvn/5y18mz5w5c4OkAQBIsi29A1gBDADAVhk2bFjzG2+88Q/NmjVrl7azPfroo6l99CUAbI2FCxdGUVFR9OvXL1XnKigoKD7wwAP3e/LJJx9dsWJFnaQBAEiqLRXAHgENAMBWuffee39ZWlraPW3nevzxx+PBBx8UMAD8jz//+c8xceLE1J2rtLS0x3333fdLCQMAkFYKYAAAPrVJkyaN6tSp0xEpPFeMHz9ewADwD8aPHx+TJ09O3bk6der0hUmTJn1VwgAApJFHQAMA8Kmcd955fU888cR/z2QyRWk618yZM+Puu+8WMAB8jNdeey06duwYnTt3TtW5unbtuk9BQcHzzz333DopAwCQNN4BDADAZ3LEEUe0vOKKK67NZrOVaTrXyy+/HDfffHPkcjkhA8DHyOVyMXv27OjSpUt06tQpNefKZDJF++yzz/CpU6c+9u67726WNAAASeIdwAAAbLNsNpu55ZZb/q2kpKRjms61YMGCuPnmm6OxsVHIAPAJGhsb4+abb44333wzVecqLS3tcvfdd5+fzWYzUgYAIC0UwAAAbNGkSZO+3rZt2wPTdKZly5bFDTfcEPX19QIGgE+prq4urr322li+fHmqztWuXbsDH3/88VESBgAgLTwCGgCAj3XZZZcN+upXvzo2k8mk5hcH33///bjyyiujqqpKwACwlerq6uLll1+OIUOGRHl5eWrO1aVLl31LS0unPvPMM2ukDABAEngENAAAW61///4lJ5988q8ymUxRWs60YcOG+P3vfx8bN24UMABso40bN8bvfve7VP15WlBQkP3hD394ft++fYslDABA4q9vrQAAgI/y4IMPnl1WVtYrLeeprq6O3/zmN7Fq1SrhAsBntGrVqrjyyiujuro6NWcqKyvr8/DDD58lXQAAkk4BDADA/zF+/Pgju3XrdnRazlNfX5/KdxYCwK60fPnyuO6666K+vj41Z+rRo8dXx40bd4R0AQBIMgUwAAB/53vf+16nI4444py0nCeXy8Vtt90Wb7zxhnABYDt7/fXX47bbbotcLpeaMx155JHnfvvb3+4oXQAAkkoBDADA/6qoqCi4+OKLLywsLCxPy5nGjx8fs2bNEi4A7CCzZs2Khx56KDXnKSwsrPj1r399QUVFhZ+bAQCQSC5kAQD4XxMnThxdWVk5OC3nef7552PixImCBYAd7LHHHosXXnghNeeprKzc89FHHz1RsgAAJFFh5cDo+lFfaKyKqFmRtSEAgDxxwQUX7DZq1KgLM5lMYRrO8+qrr8Ytt9ySqkdSAkBT/7O3d+/e0a5du1Scp2PHjkNzudxzU6ZMWSddAACamrLO9VHwMc/wcwcwAADRt2/f4h//+McXZzKZVPwG4HvvvRc33HBDNDY2ChcAdpKGhoa47rrrYtmyZak4T0FBQfbss88e27dv32LpAgCQqGtZKwAAYPz48T8qKyvrkYazbNiwIX7/+99HbW2tYAFgJ9u0aVP8/ve/j40bN6biPGVlZb3GjRs3RrIAACSJAhgAIM/ddNNNw/v06XN8Gs5SX18f1157baxdu1awALCLrFmzJq699tqor69PxXn69ev3jd///vdDJQsAQFIogAEA8thBBx1Uceyxx/5rRGTScJ477rgjFi9eLFgA2MUWLVoUd955Z1qOU/CNb3zj34YNG9ZcsgAAJOIC1goAAPLXzTfffFZxcXG7NJxl4sSJMX36dKECQBMxbdq0mDRpUirOUlJS0unOO+88Q6oAACSBAhgAIE/913/914FdunT5UhrO8tprr8Wf//xnoQJAEzN+/PhYsGBBKs7SrVu3o2+66abhUgUAoKlTAAMA5KEvfelLlV/5yld+lYazrFixIq6//vpobGwULAA0MY2NjXHdddfFihUr0nCczHHHHfergw46qEKyAAA0ZQpgAIA8dPXVV5+ezWYrk36OmpqauPbaa2PTpk1CBYAmatOmTXHttddGTU1N4s+SzWbb3njjjT+RKgAATZkCGAAgz9x6663Du3Tp8uWknyOXy8Utt9wSK1euFCoANHErV66MW2+9NXK5XOLP4lHQAAA0dQpgAIA8MnTo0LKvfvWrv0jDWSZMmBBz584VKgAkxJw5c+Kxxx5LxVlGjRr1i6FDh5ZJFQCApkgBDACQR+64444fFRcXd0z6OV5++eV45JFHBAoACfPQQw+l4he4SkpKOt5xxx0/lCgAAE2RAhgAIE9cfvnlu/fs2XNU0s/xwQcfxB133JGKR0gCQL7J5XJx2223xZo1axJ/lp49ex57+eWX7y5VAACaGgUwAEAe6NatW/a73/3uv2YymURf/9XX18cNN9wQ1dXVQgWAhKqqqoobb7wx6uvrE32OTCZT8N3vfvdX3bp1y0oVAICmRAEMAJAHxo8ff0pZWVmvpJ/jnnvuiaVLlwoUABJuyZIlcd999yX+HGVlZT3Hjx9/ikQBAGhKFMAAACn385//vOeAAQNGJ/0c06dPjylTpggUAFJi8uTJMWPGjMSfY8CAAaN//vOf95QoAABNhQIYACDFstls5qyzzjo3k8kk+tGEK1asiLvvvlugAJAyd911V6xYsSLRZ8hkMtmzzjrr3Gw2m5EoAABNgQIYACDFxo0b98XKysq9knyG2trauOGGG6K2tlagAJAyf/1zfvPmzYk+R2Vl5V7jxo0bKVEAAJoCBTAAQEoNHz68/OCDDz4t6ee4//77Y/ny5QIFgJRavnx5jBs3LvHnGDFixI+HDRvWXKIAAOxqCmAAgJS69dZbT8tms22TfIYZM2bEc889J0wASLnJkyfHzJkzE32G4uLitrfffvtp0gQAYFdTAAMApNBVV121R48ePb6S5DOsXLky7rrrLmECQJ64++6744MPPkj0GXr27PnVK664Yg9pAgCwKymAAQBSprS0tOAb3/jGT5N8rdfY2Bi333679/4CQB6pqamJ2267LRobG5N8jIJvfvObZ5aWlvqZGwAAu+6i1AoAANJlwoQJX6uoqBiQ5DOMHz8+Fi1aJEwAyDNvvvlmPPjgg4k+Q4sWLQY9+OCDx0gTAIBdRQEMAJAiRx55ZOWwYcN+kOQzzJ07N5544glhAkCemjhxYixYsCDRZxg+fPiPjjjiiJbSBABgV1AAAwCkyBVXXHFyUVFRRVLnr6qqijvvvDNyuZwwASBP5XK5uP3226O6ujqxZygqKmrxm9/85mRpAgCwKyiAAQBS4vzzz+/Xu3fv45J8httvvz0+/PBDYQJAnlu3bl3cfvvtiT5D7969jz///PP7SRMAgJ1NAQwAkALZbDZz6qmn/jyTyST2+m769OkxZ84cYQIAERExe/bsmDFjRmLnz2QyBaeeeurPs9lsRpoAAOxMCmAAgBT44x//eERlZeXgpM6/du3auPfeewUJAPyde+65J9atW5fY+SsrKwf/6U9/+oIkAQDYmRTAAAAJ17dv3+JDDjnkR0k+w9133x01NTXCBAD+Tk1NTdx9992JPsPBBx/8o759+xZLEwCAnUUBDACQcHfdddc3S0pKOiV1/smTJ8e8efMECQB8pLlz58azzz6b2PlLSko63nPPPd+SJAAAO4sCGAAgwb70pS9VDhw48KSkzr9mzZoYP368IAGALXrggQdizZo1iZ2/f//+Jx111FGtJAkAwM6gAAYASLArrrji1MLCwvIkzp7L5eK2226LTZs2CRIA2KJNmzbFbbfdFrlcLpHzFxYWll1++eU/kCQAADuDAhgAIKF+8Ytf9O7evftXkjr/s88+G2+88YYgAYBP5Y033ojnn38+sfN369bt6F/96ld9JAkAwI6mAAYASKgf/vCHP8pkMom8nvvggw/igQceECIAsFXGjRsX69atS+TsmUym4NRTT/2xFAEA2NEUwAAACXTdddcNa9eu3YFJnD2Xy8Udd9wRtbW1ggQAtsqmTZvizjvvTOz8bdq02f+mm27aT5IAAOxICmAAgIQpLS0t+NrXvnZ6Uud/4YUXYuHChYIEALbJq6++GjNmzEjs/Mccc8zpFRUVfiYHAMAO42ITACBhbr/99oMrKip2S+LsGzZsiHHjxgkRAPhM7r///qiqqkrk7OXl5X3/67/+6wgpAgCwoyiAAQASpKKiouCwww47Nanz33vvvYn9YS0A0HRs2LAh7r///sTOf9BBB/1zq1atCiUJAMCOoAAGAEiQ+++//+iysrKeSZx9zpw58dJLLwkRANguXnjhhViwYEEiZy8tLe32xz/+8StSBABgR1AAAwAkRN++fYv33Xfff07i7LW1tXHvvfcKEQDYru6+++6oq6tL5Oz77bffKf379y+RIgAA25sCGAAgIW6++eZRxcXFbZM4+yOPPBJr164VIgCwXa1atSoee+yxRM6ezWbb3njjjV+TIgAA25sCGAAgAYYOHVq21157fSeJs7/33nvxxBNPCBEA2CEmTpwYK1asSOTsQ4YM+c7QoUPLpAgAwPakAAYASIBrr732xKKiosqkzZ3L5eKee+6JxsZGIQIAO0R9fX3cddddkcvlEjd7UVFR5bXXXnuCFAEA2J4UwAAATdwBBxxQMWDAgG8kcfYZM2bEW2+9JUQAYId6880348UXX0zk7AMGDPjG8OHDy6UIAMD2ogAGAGjirrrqqhOKiooqkjb3pk2b4oEHHhAgALBT3H///VFbW5u4uYuKilpcffXV7gIGAGC7UQADADRhBx10UEX//v0Teffvww8/HB9++KEQAYCdYv369TFhwoREzj5w4MBvHHDAARVSBABge1AAAwA0Yf/5n/95bGFhYfOkzb1q1aqYPHmyAAGAnerpp5+O1atXJ27uwsLC8ssuu2yUBAEA2B4UwAAATdQBBxxQMWjQoNFJnP3uu++O+vp6IQIAO1V9fX3cddddiZx99913/+bQoUPLpAgAwGelAAYAaKIuv/zyYwsLC8uTNvfcuXNjwYIFAgQAdokFCxbE3LlzEzd3UVFRi9/97ndflyAAAJ+VAhgAoAkaOnRo2aBBgxL37t+6urr405/+JEAAYJf605/+FHV1dYmbe/fdd//mkCFDSiUIAMBnoQAGAGiCfvOb33ylqKioZdLmfu655xL53j0AIF1Wr14dzz33XOLmLioqann11VcfLUEAAD4LBTAAQBPTq1evZoMHD/5m0uaurq6ORx55RIAAQJPwyCOPRHV1deLmHjJkyLe6deuWlSAAANtKAQwA0MTcdNNNxxQXF7dN2twTJkyIqqoqAQIATUJVVVUifzmtuLi43a233uouYAAAtpkCGACgCWnVqlXhXnvtdVLS5l61alU8++yzAgQAmpTJkyfHqlWrEjf30KFDR7dq1apQggAAbAsFMABAE3LLLbccXlJS0jlpcz/44INRX18vQACgSamvr48HH3wwcXOXlJR0vummmw6VIAAA20IBDADQRGSz2cwBBxzw7aTNvWjRonjppZcECAA0SS+99FIsXrw4cXOPGDHiO9lsNiNBAAC2lgIYAKCJuOaaa/YuLy/vm7S5H3roocjlcgIEAJqkXC6XyLuAy8vL+1111VV7SRAAgK2lAAYAaCK+8pWvfDdpM8+bNy8WLlwoPACgSVu4cGG8+uqrrg8BAMgLCmAAgCbgsssuG1RZWblPkmbO5XIxfvx44QEAifDAAw8k7qklrVu33veSSy7pLz0AALaGAhgAoAkYNWrUCUmbefbs2bFs2TLhAQCJsGzZsnjllVcSN/cJJ5xwovQAANgaCmAAgF3sn//5nzt37NjxiCTN3NjYGA888IDwAIBEGT9+fDQ0NCRq5k6dOn1h9OjRHaQHAMCnpQAGANjFfvSjH30tk8kk6rps2rRpsWrVKuEBAImyatWqeOGFFxI1cyaTKfzpT386SnoAAHxaCmAAgF1o0KBBpX369Plqkmaur6+PCRMmCA8ASKQJEyZEXV1dombu27fvV/r27VssPQAAPg0FMADALnTZZZcdXlRUVJGkmadOnRpr164VHgCQSOvXr48pU6YkauaioqLK3/zmN0dIDwCAT0MBDACwi2Sz2cy+++57UpJmrqurc/cvAJB4jz76aOLuAt5///1PymazGekBAPBJFMAAALvI1VdfPbSsrKx3kmaeMmVKbNiwQXgAQKJt2LAhnn/++UTNXFZW1ueqq67aS3oAAHwSBTAAwC7y5S9/+bgkzVtfXx8TJ04UHACQCo8//nji7gL+0pe+dLzkAAD4JApgAIBdYPTo0R3atm07IkkzT5s2LdatWyc8ACAVPvzww5g+fXqiZm7fvv2I0aNHd5AeAABbogAGANgFfvrTn47KZDKFSZm3vr4+HnnkEcEBAKnyyCOPRH19fWLmzWQyhT/96U+/JjkAALZEAQwAsJN16tQp26dPn6OTNLO7fwGANFq3bl1MmzYtUTP36dPnmE6dOmWlBwDAx1EAAwDsZFddddUB2Wy2dVLmbWxsjEmTJgmOVOvYsWN06OCJmgD5aNKkSdHY2JiYebPZbOurrrrqAMkBAPBxFMAAADvZiBEjvp6keV988cVYtWqV4Ei1Ll26xIUXXhinnXZadO3a1UIA8siqVavipZdecj0JAEBqKIABAHaiM844o3tlZeXeSZk3l8vFxIkTBUdeyGQyMXjw4PjVr34VY8aMcUcwQB55/PHHI5fLJWbeysrKvc8444zukgMA4KMogAEAdqJTTjnlqxGRScq8CxYsiPfee09w5JVMJhN77713XHjhhTFmzJho3769pQCk3HvvvRcLFy5M1B9X/3NdCQAA/4cCGABgJ+nVq1ezXr16fTlJM3v3L/nsr0XwBRdcECeffHK0bdvWUgBSLGnXPb169fpyr169mkkOAIB/pAAGANhJrrjiioOLiopaJmXeBN4JAztEYWFhDB8+PC688MIYPXp0VFZWWgpACi1YsCCWLVuWmHmLiopaXnnllYdIDgCAf6QABgDYSYYPH/6VJM2btHfhwY5WVFQUI0aMiEsuuSRGjx4dLVu2tBSAFMnlcvH4448naub99tvvK5IDAOAfKYABAHaC0aNHd6isrByalHnXrl0bL7/8suDgI/y1CL744ovjhBNOiBYtWlgKQEq89NJLsW7dusTMW1lZudfo0aM7SA4AgL+lAAYA2AlOP/30o5J07fXMM89EQ0OD4GALiouL47DDDouxY8fGqFGjoqyszFIAEq6hoSGeeeaZJI1c8D/XmQAA8P8vEq0AAGDHymazmX79+n05KfPW1tbGlClTBAefUnFxcYwcOTIuvfTSGDVqVJSWlloKQII9//zzUVtbm5h5+/Xr9+VsNpuRHAAAf6UABgDYwX7zm9/sWVJS0jkp886YMSOqq6sFB1uppKQkRo4cGZdcckkcffTRUVJSYikACVRdXR0zZ85M0p8/na+44orBkgMA4K8UwAAAO9gXvvCFLyVl1lwuF08//bTQ4DNo3rx5HHXUUXHJJZfEyJEjI5vNWgpAwjz11FORy+USM++RRx75ZakBAPBXCmAAgB1oyJAhpZ07dz4iKfO+/vrrsWLFCsHBdlBeXh6jRo2KSy+9VBEMkDArVqyI119/PTHzdunS5fD+/ft79AQAABGhAAYA2KHGjh17aGFhYWJeCOruX9j+KioqYtSoUXHxxRfH4YcfHkVFRZYC4LpouyosLGz+H//xHwdLDQCACAUwAMAOteeeex6ZlFnXrl0b8+bNExrsIK1atYrjjz8+LrroohgxYkQUFPh2DKApmzdvXqxZsyYx8+61115HSg0AgAgFMADADnPMMce0bt269b5Jmfe5556LxsZGwcEO1qZNmxg9enRcfPHFimCAJqyxsTGee+65JP35MvyYY45pLTkAAPykAQBgBznzzDMPz2Qyibjeqq+vj6lTpwoNdqK2bdvG6NGj47zzzovhw4crggGaoBdeeCHq6+sTMWsmkyk844wzDpUaAAB+wgAAsIP079//C0mZdc6cObFhwwahwS7QqVOnOPnkk+Pf/u3fYu+9945MJmMpAE3Ehg0bYvbs2YmZd8CAAR4DDQCAAhgAYEf43ve+16mysnKPpMybpMcbQlp17tw5xowZE7/61a8UwQBNyPPPP5+YWSsrKwd/73vf6yQ1AID8pgAGANgBTj755CMiIhHtzcqVK+P1118XGjQRXbt2jTFjxsQ555wTgwcPthCAXez111+PlStXJmXczMknn3y41AAA8psCGABgB+jXr19iHv88ZcqUyOVyQoMmpnfv3nHaaafFOeecE/3797cQgF0kl8vFlClTknQd6jHQAAB5TgEMALCdnX766d0qKip2S8Ks9fX1MW3aNKFBE9anT58466yz4pxzzonddtvNQgB2gWnTpkV9fX0iZq2oqNjt9NNP7yY1AID8pQAGANjORo8efURSZp03b15s3LhRaJAAffr0ibPPPjvOPPPM6Nmzp4UA7EQbN26MefPmuR4FACARFMAAANtZr169EvPetSQ9zhD4bwMGDIhf/vKXceaZZ0b37t0tBGAnmTp1apKuRw+TGABA/lIAAwBsR2eccUb38vLyvkmYdf369fHaa68JDRJqwIAB8S//8i9x2mmnRbdunvQJsKPNnz8/Pvzww0TMWl5e3u9HP/pRF6kBAOQnBTAAwHZ03HHHHZSUWWfMmBGNjY1CgwTLZDIxePDg+Nd//dcYM2ZMdOjQwVIAdpDGxsaYMWNGYub9xje+cYjUAADykwIYAGA76tOnz8FJmDOXyyXqMYbAlmUymdh7773jwgsvjDFjxkT79u0tBWAHeOGFF5J0XXqIxAAA8pMCGABgOznppJPat2zZcvckzLpkyZJYuXKl0CBl/loEX3DBBXHyySdH27ZtLQVgO1qxYkW8/fbbiZi1srJy0PHHH+8PAgCAPKQABgDYTr773e8eGBGZJMyapMcXAluvsLAwhg8fHhdeeGGMHj06KisrLQVgO5k+fXpSRi34/ve/f6DEAADyjwIYAGA72X333Q9Nwpz19fUxc+ZMgUEeKCoqihEjRsQll1wSo0ePjpYtW1oKwGc0c+bMqK+vT8SsAwcOPFRiAAD5RwEMALAdHHTQQRUtW7bcKwmzLly4MKqrq4UGeeSvRfDFF18cJ5xwQrRo0cJSALZRVVVVvP7664mYtVWrVkOHDx9eLjUAgPyiAAYA2A7OPvvsz2cymaIkzOrxz5C/iouL47DDDouxY8fGqFGjoqyszFIAtkFSnqaSyWSy55577uclBgCQXxTAAADbwe67735AEuasra2NOXPmCAzyXHFxcYwcOTIuvfRSRTDANpg9e3bU1dUlYtY99tjjAIkBAOQXBTAAwGfUqlWrwnbt2u2fhFnnzZsXtbW1QgMiIqKkpCRGjhwZY8eOjaOPPjpKSkosBeBT2LRpU8ybNy8Rs7Zv337/iooKPwMEAMgjLv4AAD6jCy+8cPeioqKKJMz64osvCgz4P5o3bx5HHXVUXHLJJTFy5MjIZrOWAvAJZs2alYg5i4qKWlx88cWDJAYAkD8UwAAAn9GBBx6YiMfqVVdXJ+ZOFWDXKC8vj1GjRsWll16qCAb4BPPmzYuamppEzHrQQQd5DDQAQB5RAAMAfEZdu3YdnoQ5582bF/X19QIDPlFFRUWMGjUqLr744jj88MOjqKjIUgD+QV1dXbz66quJmLVLly77SwwAIH8ogAEAPoNTTjmlY3l5+W5JmPXll18WGLBVWrVqFccff3xcdNFFMWLEiCgo8C0kwN966aWXEjFnRUXFbieddFJ7iQEA5AffvQMAfAYnnnji55MwZ21tbcyfP19gwDZp06ZNjB49OsaOHasIBvgb8+fPj9ra2iSMmvnud7/7eYkBAOQH37UDAHwGn/vc5/ZLwpwLFy6Muro6gQGfyV+L4PPOOy+GDx+uCAby3ubNm2PhwoWJmLVfv37DJQYAkB98tw4AsI1atWpV2Lp1672TMKvHPwPbU6dOneLkk0+Oc889NwYNGmQhQF6bPXt2IuZs06bN3hUVFX4WCACQB1z0AQBso/PPP39gYWFheVOfs76+PubMmSMwYLvr2bNn/OQnP4nzzjsv9t5778hkMpYC5J3Zs2dHfX19k5+zqKio4vzzzx8oMQCA9FMAAwBso/3333/fJMz5+uuvR01NjcCAHaZLly4xZsyYOOecc2Lw4MEWAuSV6urqeOONNxIx64EHHriPxAAA0k8BDACwjbp27ZqIxz/PnTtXWMBO0bt37zjttNPinHPOif79+1sIkDeScr3VvXv3vaUFAJB+CmAAgG0wZMiQ0srKyj2a+py5XM7jn4Gdrk+fPnHWWWfFOeecE7vttpuFAKk3e/bsyOVyTX7Oli1b7jlo0KBSiQEApJsCGABgG5x55pl7ZjKZbFOfc9myZbFu3TqBAbtEnz594uyzz44zzzwzevbsaSFAaq1bty6WL1/e5OfMZDLZs846a4jEAADSrcgKAAC23tChQ4clYc558+YJC9jlBgwYEAMGDIgFCxbE+PHjY+nSpZYCpM68efOiS5cuTX7OffbZZ5+ImC4xAID0cgcwAMA26Nix4z5JmHP+/PnCApqMAQMGxC9/+cs47bTTolu3bhYCpEpSrrs6deq0j7QAANJNAQwAsJWOOOKIlhUVFf2a+pxVVVWxaNEigQFNSiaTicGDB8e//uu/xpgxY6JDhw6WAqTCW2+9FVVVVU1+zoqKis8deuihLSQGAJBeCmAAgK108sknD46ITFOfc/78+dHY2CgwoEnKZDKx9957x4UXXhhjxoyJ9u3bWwqQaI2NjbFgwYJE/Cv4u9/97h4SAwBILwUwAMBW2n333fdMwpze/wskwV+L4AsuuCBOPvnkaNu2raUAiZWU66/BgwfvKS0AgPQqsgIAgK3Trl27wU19xlwul5Q7UAAiIqKwsDCGDx8e++yzT0ybNi0mTJgQ69evtxggURYsWBC5XC4ymab9sJgOHToMlhYAQHq5AxgAYCsMGjSotGXLlgOa+pzvvfdebNy4UWBA4hQVFcWIESPikksuidGjR0fLli0tBUiMDz/8MJYtW9bk52zZsuXA/v37l0gMACCdFMAAAFvhxz/+8aBMJtPkn6Li7l8g6f5aBI8dOzZOOOGEaNGihaUAibBw4cImP2Mmk8n+5Cc/GSAtAIB0UgADAGyFvffee88kzJmEHzwCfBrNmjWLww47LMaOHRujRo2KsrIySwGatKT8Il5SrmsBANh63gEMALAVunbtOqSpz1hfXx9vvvmmsIBUKS4ujpEjR8bBBx8czz77bDz++ONRXV1tMUCT8+abb0Z9fX0UFTXtH7t16dJlT2kBAKSTO4ABAD6lioqKgoqKikFNfc4lS5bE5s2bBQakUklJSYwcOTLGjh0bRx99dJSUeIUl0LTU1tbG0qVLm/ycLVu2HFRaWupngwAAKeQiDwDgUzr77LP7FhYWNvlnj7722mvCAlKvefPmcdRRR8Ull1wSI0eOjGbNmlkK4HpsKxQWFpafffbZvaQFAJA+CmAAgE9p//3375+EOV9//XVhAXmjvLw8Ro0aFf/+7/8eI0eOjGw2aymA67FP6fOf//xAaQEApI8CGADgU+rRo8fuTX3G2traePvtt4UF5J2KiooYNWpUXHzxxXH44Yc3+XdvAum2ePHiRLySo1evXoOkBQCQPgpgAIBPqXXr1k3+DoklS5ZEQ0ODsIC81apVqzj++OPj4osvjhEjRkRBgW97gZ2voaEhlixZ0uTnbNOmjQIYACCFfCcMAPApDBkypLR58+a9m/qcb775prAAIqJ169YxevToGDt2rCIYcF32MZo3b95n0KBBpdICAEgX3wEDAHwKp556av9MJtPkr53eeustYQH8jTZt2sTo0aPjvPPOi+HDhyuCAddlfyOTyRT84Ac/+Jy0AADSxXe+AACfwuDBg5v84/Hq6+tj0aJFwgL4CJ06dYqTTz45/u3f/i323nvvyGQylgLsUIsXL07Eqzn23HPPgdICAEgXBTAAwKfQpUuXAU19xnfeeSfq6uqEBbAFnTt3jjFjxiiCgR2utrY23n333SRc53oPMABAyiiAAQA+hZYtW/Zv6jN6/DPAp9elS5cYM2ZMnHvuuTF48GALAfL2+iwJ17kAAGwdBTAAwCcYPnx4eUlJSeemPqfHPwNsvV69esVpp50W55xzTvTvrwMB8u/6rLS0tPPw4cPLpQUAkB4KYACAT/Ctb31rt4ho8s8IXbx4sbAAtlGfPn3irLPOinPOOSd22203CwG2i4T8gl7m29/+dj9pAQCkhwIYAOAT7L777k2+CVi7dm1s2LBBWACfUZ8+feLss8+OM888M3r27GkhwGfy4Ycfxrp165r8nAMHDlQAAwCkSJEVAABsWadOnZr8D8TefvttQQFsRwMGDIgBAwbEggULYvz48bF06VJLAbb5Oq1Vq1audwEA2GkUwAAAn6CyslIBDJCnBgwYEP3794958+bFQw89FO+++66lAFtlyZIlsddeezX1613PvgcASBEFMADAFnTq1CnbvHnzXk19ziVLlggLYAfJZDIxePDg2GOPPeLll1+OBx98MFauXGkxQGqu05o3b967Xbt2RatXr66XGABA8nkHMADAFowZM6ZnJpPJNuUZGxsbPZoUYCfIZDKx9957x4UXXhhjxoyJ9u3bWwrwiZYuXRqNjY1NesaCgoLsqaee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k8nE7NmzY+LEibFmzRoNAXif/VNSzJo161kTAwBongTAAAC70O233/7KOeecszU/P78022sdMGBAtG/f3tWu0My9+uqrMWnSpFi1apVmALyPjh07xgEHHJCIWhsbG6u/8Y1v/NXUAACaJwEwAMAutHLlyob169fP6tat2+hsrzWVSsXhhx8ekyZNMjhohubMmROTJ0+OJUuWaAbAh3D44YdHKpVKRK3r16+fVVFR0WhqAADNU54WAADsWq+++mpirts77LDDDAyamTfffDP+/d//PX7yk58IfwE+pFQqFSNGjEhMva+88sozpgYA0Hw5AQwAsIvddNNNz5166qnV+fn5rbO91m7dukX//v1j4cKFBgc5btmyZfHYY4/F/PnzNQPgIzrggAOic+fOiai1sbFxy4033jjL1AAAmi8BMADALrZy5cqG8vLyGT179vx0Euo9+uijBcCQw5YvXx7jxo0T/AJ8wv1SUpSXlz9TXl7eYGoAAM2XABgAYDeYMWPGUxdccEEiAuAhQ4ZE69ato7q62uAgh6xcuTImTJgQc+fOjUwmoyEAH1ObNm3i0EMPTUy9zz777FOmBgDQvPkGMADAbvDVr371lYaGhk1JqLWgoCCOOOIIQ4McsW7duvj5z38ed955Z8yZM0f4C/AJjRw5MvLz8xNRa0NDw8abbrrpVVMDAGjenAAGANgNKisrm1atWjW9T58+5ySh3qOPPjqefPJJQREk2Pr16+Oxxx6L2bNn+3cZYBdJpVIxatSoxNS7cuXKadXV1WmTAwBo3pwABgDYTaZNm5aY6/c6duwYAwYMMDRIoA0bNsSvf/3r+Nd//dd49dVXhb8Au9CAAQOiY8eOian36aefftLUAAAQAAMA7CZf+9rX5tTX11ckpd6jjjrK0CBBqqqq4v77749vf/vb8eKLL0ZTU5OmAOxiRx55ZGJqra+vX/eNb3zjdVMDAMAV0AAAu0ltbW16xYoVT++///6fT0K9hx56aLRt2zaqqqoMD7LYli1bYsqUKfHcc8/F9u3bNQRgN2nbtm0MGTIkMfUuX778qdraWtc/AwDgBDAAwO70xz/+cUJSas3Pz4/jjjvO0CBL1dTUxKOPPhq33XZb/OUvfxH+Auxmxx57bOTn5yel3Myvf/3rCaYGAECEABgAYLe66667llZXV89PSr1HH310tGjRwuAgi7wd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qATAAABZ4umnn968fPnyxF3xN3r06GjXrp0BAgBZqUOHDnH88ccnru5ly5ZNmD59+hYTBADgoxIAAwBkkbvvvvtPmUymKUk1FxYWxumnn254AEBWOvPMMxP3yYpMJtN41113/dH0AAD4OATAAABZ5Be/+MWatWvXTkta3UcccUT06tXLAAGArNK7d+847LDDEld3eXn5X+6///51JggAwMchAAYAyDIPP/zwn5JWcyqVijPPPNPwAICsMmbMmEilUomr+8EHH/yT6QEA8HEJgAEAsszXv/71NzZs2DAraXUPHDgwDj74YAMEALLCoEGDYsCAAYmru6KiYuatt966wAQBAPi4BMAAAFlo3Lhxv01i3WPGjIm8PFtMAGDvysvLizFjxiSy9j//+c+/NUEAAD7RflgLAACyz/XXXz+nqqrqr0mru1evXnHUUUcZIACwVx1zzDHRvXv3xNW9adOmV2666aa5JggAwCchAAYAyFJ/+tOf7k1i3WPGjInS0lIDBAD2ijZt2sRZZ52VyNofeOCBe00QAIBPSgAMAJClbrrpprlJPAVcXFwcZ555pgECAHvFWWedFS1btkxc3Zs2bXrl5ptvnmeCAAB8UgJgAIAsNm7cuF8lse5Ro0ZF7969DRAA2KP69OkTI0eOTGTtjz322K9MEACAXUEADACQxcaOHTu7qqrqb0mrO5VKxfnnnx+pVMoQAYA9tv/4/Oc/n8j9R2Vl5d+uueaav5kiAAC7ggAYACDLTZ069bdJrLtv374xZMgQAwQA9ojDDjsssTeQTJ48+TcmCADAriIABgDIcpdeeumLVVVVryax9s9//vNRXFxsiADAblVaWhrnn39+Imuvqqr66+WXX/6SKQIAsKsIgAEAEuChhx76WRLrLisri9NPP90AAYDd6qyzzoqSkpIklp753e9+91MTBABgVxIAAwAkwA033DB3w4YNs5JY+3HHHRd9+vQxRABgt+jbt28cddRRiay9oqJi1te//vU3TBEAgF1JAAwAkBA///nPfxoR6aTVnUql4vOf/3zk5dl6AgC7Vn5+flx00UWRSqWSWH76F7/4xX+bIgAAu5q3cAAACXHHHXe8tW7duulJrL13795xzDHHGCIAsEudcMIJ0b1790TWXl5e/pc77rjjLVMEAGBXEwADACTI3XfffW8mk2lKYu1nnXVWtG3b1hABgF2iQ4cOcfrppyey9kwm03T33Xf/3BQBANgdBMAAAAlyzz33rCgvL386ibW3bNkyzj33XEMEAHaJc889N1q0aJHI2tesWTP1xz/+8UpTBABgdxAAAwAkzA9/+MOfZzKZhiTWPnz48Bg0aJAhAgCfyKGHHhpDhw5NZO3pdLrhBz/4wS9MEQCA3UUADACQMPfee+/qRYsWPZDU+i+++OIoKSkxSADgY2ndunVcfPHFia1/4cKFf7jvvvvKTRIAgN1FAAwAkECXXXbZrxsaGjYlsfaysjJXQQMAH9u5554bpaWliay9oaFh4+WXX/47UwQAYHcSAAMAJNDs2bNrXn311V8ntf4jjjgiDj74YIMEAD6SwYMHx+GHH57Y+l955ZX7Zs+eXWOSAADsTgJgAICEOueccx6tqalZmtT6L7roomjZsqVBAgAfSsuWLeNzn/tcYuuvqalZMmbMmMdMEgCA3U0ADACQUJWVlU3Tpk37RVLrb9++fZx++ukGCQB8KGeccUa0b98+sfU/+eST91ZXV6dNEgCA3U0ADACQYOedd960qqqqV5Ja/wknnOAqaADgAx188MFx/PHHJ7b+TZs2vXzBBRc8a5IAAOwJAmAAgIT74x//eG9EZJJYeyqVigsuuMBV0ADAe2rZsmVccMEFkUqlkrqEzP333/8zkwQAYE8RAAMAJNzNN988b9WqVU8ktf6OHTsm+nt+AMDudcEFF0THjh0TW/+KFSse//rXv/6GSQIAsKcIgAEAcsCNN974k6ampq1JrX/kyJExdOhQgwQA/pdPfepTMWLEiMTW39TUVH3zzTf/t0kCALAnCYABAHLAxIkTK//+97//KslruPDCC6OsrMwwAYCIiGjTpk18/vOfT/QaZs+efd/EiRMrTRMAgD1JAAwAkCPOPvvsh2pqapYntf7S0tK46KKLDBIAiFQqFV/84hejtLQ0sWuoqal566yzznrYNAEA2NMEwAAAOaKioqJx0qRJP07yGgYPHhwjR440TABo5o444og46KCDEr2GJ5544qeVlZVNpgkAwJ4mAAYAyCGXXHLJzIqKihlJXsMFF1wQ3bp1M0wAaKZ69uyZ+KufKyoqZnzhC1+YZZoAAOwNAmAAgBzzb//2b/ek0+ntSa2/RYsWceWVV0ZhYaFhAkAzU1hYGF/60pcSvQ9Ip9Pb/+3f/u0e0wQAYG8RAAMA5Jh777139aJFix5M8hq6d+8eZ555pmECQDNzxhlnRPfu3RO9hsWLFz947733rjZNAAD2FgEwAEAO+uxnP/vL2traRL94PPHEE2Pw4MGGCQDNxKBBg+Kkk05K9Bpqa2tXn3vuub80TQAA9iYBMABADlq8eHH9uHHj/j3Ja0ilUnHJJZdE27ZtDRQAclybNm3ikksuiVQqleh1jBs37t8XL15cb6IAAOxNAmAAgBx1+eWXv1RRUTEjyWsoLS2NL3zhC4l/GQwAvLe3f+mrdevWiV5HRUXFM5dffvlLJgoAwN4mAAYAyGE33HDDXU1NTVuTvIaDDjrI94ABIId95jOfiUMOOSTRa2hqaqq+4YYbfmiaAABkAwEwAEAOGzdu3MbZs2cn/jt0p5xyiu8BA0AOOuSQQ+LTn/504tfx17/+9efjxo3baKIAAGQDATAAQI77zGc+81B1dfXCJK8hlUrFF7/4xejQoYOBAkCO6NixY3zpS19K/KceNm/ePO+00057xEQBAMgWAmAAgBxXXV2dfuCBB34UEekkr6O4uDguvfTSyMuzhQWApMvPz4/LLrssiouLk76U9P333/+ftbW1aVMFACBbeHsGANAMXH/99XMWLVr0YNLXsf/++8e5555roACQcOedd1707ds38etYuHDhH7/61a++bqIAAGQTATAAQDNxySWX/Lyurq486es4/vjjfQ8YABJs2LBhccwxxyR+HXV1dWsuvPDC+0wUAIBsIwAGAGgmXnvttdoHHnjguxGRSfI6UqlUfOlLX4oePXoYKgAkTO/evePSSy9N/Hd/IyLzwAMPfO/111+vNVUAALKNABgAoBm5+uqr/7Z06dJHk76OoqKiGDt2bJSWlhoqACRE69at46qrrorCwsLEr2X58uXjrr766r+ZKgAA2UgADADQzJx33nn/r66ubnXS19GhQ4e4/PLLIy/PlhYAsl1eXl5cfvnl0b59+8Svpb6+ft0ll1zyE1MFACBr999aAADQvLz++uu1Dz744Pcj4VdBR0QMGDAgzjrrLEMFgCw3ZsyYOPDAA3NiLY899tgPXnnllW2mCgBAthIAAwA0Q1/5ylf+umbNmqm5sJaTTz45Dj30UEMFgCw1ZMiQOOmkk3JiLWvXrv3LpZde+oKpAgCQzQTAAADN1GWXXfYf9fX1FUlfRyqViksvvTS6d+9uqACQZXr06BFf/OIXI5VKJX4tDQ0Nm6655pofmioAANlOAAwA0EzNmDGj+oEHHvhO5MBV0C1btozrr78+2rZta7AAkCXatWsX1113XbRs2TIXlpN56KGH/nXSpElVJgsAQLYTAAMANGNf+cpX/rpkyZI/58Ja2rZtG1dffXW0aNHCYAFgL2vRokVcffXVOfPLWUuXLn30iiuueNlkAQBIAgEwAEAzd+655/6ktrZ2eS6spXfv3jlzzSQAJNXbn2fYZ599cmI9tbW1y88555wfmywAAEkhAAYAaOYWLFhQ97Of/ezbmUymMRfWM2zYsDjllFMMFgD2kk9/+tMxdOjQnFhLJpNp/NnPfvbtBQsW1JksAABJIQAGACBuvfXWBfPnz78/V9Zz5plnxuDBgw0WAPaw4cOHx2c+85mcWc/8+fN/d+utty4wWQAAkkQADABARESMGTPmvpqamrdyYS2pVCouu+yy6Nmzp8ECwB7Su3fvuPjii3PmUwxbt25ddPrpp//aZAEASBoBMAAAERGxcuXKhh/+8Ie3pdPpnLjisGXLlvEv//Iv0aVLF8MFgN2sS5cucf3110dRUVFOrKepqanmu9/97jfKy8sbTBcAgKQRAAMA8E933XXX0ueff/6eXFlPaWlpXHvttVFWVma4ALCblJWVxXXXXRclJSU5s6aZM2fe/f/+3/9bZboAACSRABgAgP/l5JNPHldeXv50rqynU6dOMXbs2Jw5kQQA2aSoqCiuueaa6NixY86sqby8/MlTTz11gukCAJBUAmAAAP6PSy655K66urq1ubKefffdN6644orIy7P9BYBdJS8vL6688sro3bt3zqyprq6u/JJLLvmh6QIAkOi9uhYAAPBus2bNqn7ooYfujIh0rqxp4MCBcd555xkuAOwi559/fhxyyCG5tKT0gw8+eOesWbOqTRcAgCTLb3tQ9NzpjndbRG15oQ4BADRTEydOXDNmzJi8Tp06Dc2VNfXp0yfy8/PjzTffNGAA+ATOOuusOOmkk3JqTa+//vp9Z5555kTTBQAgCYq7N0Ze6c5/5gQwAADv6dRTT/31li1bXs+lNZ122mlx9NFHGy4AfEzHHntsnHrqqTm1pi1btrxx2mmn/cZ0AQDIBQJgAADeU0VFReONN974jcbGxqpcWtcFF1wQRx55pAEDwEd05JFHxuc+97mcWlNjY2PVzTff/I2KiopGEwYAIBcIgAEAeF9//OMf1z/yyCPfiRz6HnAqlYqLLroohgwZYsAA8CENHTo0LrrookilUrm0rPQjjzzynfvvv3+dCQMAkCsEwAAAfKBLL730hQULFvwupzbCeXnxpS99Kfbff38DBoAPcNBBB8WXvvSlyMvLrVdJCxYs+N2ll176ggkDAJBLBMAAAHwoo0eP/mVVVdXcXFpTYWFhfOUrX4kePXoYMAC8h169esUVV1wRBQUFObWuqqqqOaNHj/6lCQMAkGsEwAAAfCgVFRWNV1111S0NDQ0bcmldJSUlcfPNN8c+++xjyADwLr17946bbropiouLc2pdDQ0NG6666qqv++4vAAC5SAAMAMCHNmHChE3333//tzKZTDqX1lVcXBzXXXdddO/e3ZABYIfu3bvHtddeG61atcqpdWUymfT999//rQkTJmwyZQAAcpEAGACAj2Ts2LGz58+f/9tcW1fr1q3juuuuiw4dOhgyAM1ehw4d4rrrrovWrVvn3Nrmz5//m7Fjx842ZQAAcpUAGACAj+y44477xaZNm17MtXW1a9cubrzxxmjXrp0hA9BstW3bNmf/Pty4ceOLxx13nO/+AgCQ0wTAAAB8ZNXV1emLL774W3V1datzbW0dO3aMG2+8Mdq0aWPQADQ7ZWVlceONN0bHjh1zbm21tbWrL7zwwturq6vTJg0AQC7Lb3tQ9NzZD9LbImrLC3UIAICdWrZsWf327dtfOvbYY0/Ny8trkUtrKykpiaFDh8Zrr70WNTU1hg1As9ChQ4f42te+Fp06dcq5tTU1NW39zne+M/bBBx9cb9IAAOSC4u6NkVe6858JgAEA+NhefPHFzYcccsiyAQMGnBgRqZzaRBcXx5AhQ4TAADQLHTt2jJtuuik6dOiQi8tLjx8//ravfvWrc0waAIBc8X4BsCugAQD4RC688MIZb7zxxm9ycW3t27ePm266KSdPQgHA2zp16pTL4W+88cYbv77wwgufM2kAAJoLATAAAJ/YqFGjfrFhw4aZubi2t0Pgzp07GzQAOadz585x0003Rfv27XNyfRs2bJg5atSo+0waAIDmRAAMAMAnVltbm77sssu+V1dXtzoX19euXbu44YYbomPHjoYNQM7o0KFDXH/99dGuXbtc3Z+s/sIXvvDd2tratGkDANCc+AYwAAC7xJIlS+oj4pVRo0admpeX1yLX1ldcXBxDhw6NuXPnxrZt2wwcgETr0qVL3HjjjTl77XNTU1P1nXfeec0f/vCHdaYNAEAuer9vAAuAAQDYZWbNmlXVo0ePuYceeujoVCqVn2vra9WqVYwYMSIWLVoUlZWVBg5AIu23335x0003RVlZWU6uL51ON/z617++4fbbb3/TtAEAyFUCYAAA9phJkyatPeqoozbsu+++R+fi+goLC2P48OGxbNmy2LBhg4EDkCgDBgyIa6+9Nlq1apWza5w2bdq/XXLJJc+ZNgAAuez9AmDfAAYAYJc77bTTHn/rrbcezNX1FRUVxTXXXBNDhgwxbAASY8iQIXHNNddEUVFRzq5xwYIFvzv99NOfMG0AAJozATAAALvFEUcccc+GDRtm5ur6CgoK4sorr4wjjjjCsAFIwt/LceWVV0ZBQUHOrrG8vPypESNG/LdpAwDQ3AmAAQDYLaqrq9MXXXTRd2pra1fk7GY6Ly8uvvjiOPLIIw0cgKw1atSouPjiiyMvL3dfA23dunXxZz/72e83NDRkTBwAgObON4ABANhtli9fvr2mpuaFY4899uT8/PyWubjGVCoVgwYNikwmE4sWLTJ0ALLK6aefHueee26kUqmcXWN9fX3FDTfccM3UqVOrTBwAgObi/b4BLAAGAGC3evnll7cUFBS8cMQRR4zOy8trkYtrTKVSccABB0SnTp1i7ty5kck4fATA3lVYWBhXXHFFHHPMMTm9zsbGxuo777zzKz/72c9WmzoAAM2JABgAgL1qxowZlb169Xp98ODBJ6dSqfxcXWfPnj2jb9++8fe//z0aGxsNHoC9olWrVnH11VfHwIEDc3qd6XS64be//e2Nt9122wJTBwCguREAAwCw1z3xxBPlw4cPX9OvX79jIyJn76Hs2LFjDBw4MObMmRN1dXUGD8Ae1a5du7jxxhujT58+ub7U9JQpU779xS9+8XlTBwCgOXq/ADhPewAA2FPGjBkz9Y033vh1rq+zZ8+eceONN0bHjh0NHYA9pkuXLnHTTTdF9+7dc36tc+fO/eU555zzF1MHAID/SwAMAMAe9alPfernS5cufTjX19mlS5e49dZb48ADDzR0AHa7gQMHxje/+c3o1KlTzq/1rbfeemjEiBG/MnUAANg5ATAAAHvcsccee8/GjRtfyPV1FhcXx7XXXhsjRowwdAB2m8MPPzyuuuqqaNmyZc6vdePGjc8fffTR95g6AAC8NwEwAAB7XEVFReNxxx339crKyr/l+loLCgrisssui/PPPz9SqZThA7DLpFKpOP/88+PSSy+NgoKCnF/vpk2bXj7ssMNuqaysbDJ9AAB4bwJgAAD2isWLF9efddZZN1dXV7/ZHNZ7/PHHx5e//OUoKioyfAA+sRYtWsSXv/zlOP7445vFequrq98cM2bMN8rLyxtMHwAA3l9+24Oi585+kN4WUVteqEMAAOw2a9asaVi1atWs0aNHH1dQUNA619fbrVu3OOCAA2LevHlRX1/vAQDgYykrK4trrrkmDjrooGax3rq6uvKxY8de89RTT202fQAA+Ifi7o2RV7rznwmAAQDYq+bNm1ezevXqZ04++eTjCwoKSnN9ve3atYuRI0fG8uXLY+PGjR4AAD6S/v37x0033RRdu3ZtFuutr69fd9111335T3/6U4XpAwDA/xAAAwCQ1ebMmbMtlUq9fOSRR56Ul5eX83ckt2jRIkaMGBG1tbWxdOlSDwAAH8rxxx8fX/rSl5rN5wQaGxu33HXXXdf99Kc/XWn6AADwvwmAAQDIejNnzqzs2bPn64MHDz4plUrl5/p6U6lUHHLIIdGqVatYsGBBZDIZDwEAO5WXlxef/exn4/TTT49UKtUs1pxOp7f//ve//+o3vvGN1z0BAADwfwmAAQBIhEmTJpXvs88+8wYOHHhCKpUqaA5r3m+//WLAgAExd+5c3wUG4P8oKyuL6667LoYNG9Zs1pxOp7f/8Y9/vOmqq676qycAAAB2TgAMAEBiTJw4cc3BBx+85MADDzwulUrlNYc1t2/fPoYOHRqLFi2KLVu2eAgAiIiIffbZJ66//vro2bNns1lzJpNpnDBhwm1f/OIXn/cEAADAexMAAwCQKI8++ujy/fff/42DDjrohOZwHXRERHFxcRx11FHR2NgYb731locAoJkbPXp0XHHFFVFSUtJs1pxOpxsefvjhr15yySWzPAEAAPD+BMAAACTO+PHjVw0cOHDpAQcccGxzOQmcSqViwIAB0aVLl3jjjTeiqanJgwDQzBQVFcWll14aJ554YrP53m/EP07+Pv7447dffPHFMz0FAADwwQTAAAAk0iOPPLLs0EMPXbb//vs3mxA4IqJHjx4xZMiQePPNN2Pr1q0eBIBmonv37vEv//IvccABBzSrdWcymaYnnnji9s997nPPeAoAAODDEQADAJBYDz/88NJjjjlmY+/evY+KiGZzFKq0tDSGDx8eq1evjvXr13sQAHLcwIED45prrol27do1t6VnZsyY8YOzzjprqqcAAAA+PAEwAACJdv/99795zDHHVO6zzz5HRDMKgVu0aBGHHXZYtGzZMhYuXBjpdNrDAJBjCgoK4pxzzonzzz8/WrRo0dyWn37uuefuOuWUUyZ4EgAA4KMRAAMAkHi///3v5w8bNmxF3759j2lO10GnUqno27dvDB06NBYvXhxbtmzxMADkiJ49e8YNN9wQgwcPblbf+434x7XPU6ZM+fbpp58+2ZMAAAAfnQAYAICc8OCDDy4ZNmzYin79+jWrEDgionXr1nHEEUdEfX19LF261MMAkGCpVCpOOOGEuOKKK6JNmzbNbv07wt9vnXPOOX/xNAAAwMcjAAYAIGc89NBDS4YNG7a8X79+xza3EDg/Pz8OPvjg6NWrV8yfPz8aGho8EAAJU1JSEpdffnmccMIJkZ+f3+zWn8lkGp944olvffazn53maQAAgI9PAAwAQE556KGHlo4cOXJdnz59RqWa252ZEdG1a9cYNmxYLFu2LCorKz0QAAnRt2/fuO6662K//fZrluvPZDLpp59++rvnnHPO054GAAD4ZATAAADknD/96U+LDj300KX7779/s7sOOiKiuLg4jjzyyCgpKYk333wz0um0hwIgSxUUFMRnP/vZuPDCC6OkpKRZ9iCdTjc88sgjt5x//vnTPREAAPDJCYABAMhJDz/88NId3wQelUqlmt09mqlUKvr06RMHH3xwLFy4MLZt2+ahAMgynTt3jrFjx8bQoUOjGV5aERH/CH+feOKJ2y+88MLnPBEAALBrCIABAMhZDz300JIePXq8NmjQoGPz8vJaNMcetG3bNkaNGhVNTU2xZMkSDwVAFkilUjF69Oi48soro0OHDs22D01NTdt++9vf/stll132oqcCAAB2HQEwAAA5bdKkSeXdu3efM3jw4GYbAufn58eAAQOiV69esWDBgti+fbsHA2Avad26dVx66aVx/PHHR35+frPtQ2NjY/WvfvWrf7nuuute81QAAMCuJQAGACDnTZ48eW1jY+OMI4444uiCgoKS5tqHrl27xqhRo2Lbtm2xcuVKDwbAHpRKpWLUqFExduzY6NWrV7PuRX19/fo77rjjK9/61rcWejIAAGDXEwADANAsPP/881UbNmx45rjjjjuqsLCwrLn2obCwMAYNGhT77bdfLF68OGpraz0cALtZ+/bt44orrogTTzwxCgub9/uU2tralTfffPPVP/nJT1Z7MgAAYPcQAAMA0Gz87W9/27p27doZJ5xwwsjCwsK2zbkXnTp1ipEjR0Z1dbXTwAC70ciRI+Pqq6+OHj16NPte1NTULL/hhhuu/e1vf7vOkwEAALuPABgAgGbltdde2zpv3rynTznllKFFRUWdmnMvCgsL49BDD4399tsvFi1a5DQwwC709qnfk08+udmf+o2I2Lx587yLL774unHjxm30dAAAwO71fgFwat9zYsTOftC4LmLjq610DwCAxOrVq1fhs88++69du3Y9QTciGhoaYurUqTF58uRobGzUEICPqaCgIE499dQYPXq04HeH8vLyp4499tjvrly5skE3AABg9+swrDYKuuz8ZwJgAAByWuvWrfNeeumlm/fdd9+zdeMfVq9eHffff38sWbJEMwA+ov322y8uuugi1z2/w8KFC38/fPjwnzY0NGR0AwAA9gwBMAAAzd7zzz9/8aGHHnp1RKR0IyKTycTMmTPjz3/+c9TV1WkIwAcoKSmJ8847L0aMGBGplL9Kdki//PLL9xx77LEPagUAAOxZ7xcA+wYwAADNwn333Tfn+OOP39yrV6/DQwgcqVQqevfuHcOHD49169ZFRUWFhwTgPRxyyCExduzY6N+/v/B3h0wm0/jMM8/828knnzxONwAAYM97v28AC4ABAGg2fve7370xePDgJf369Ts6lUrl60hEcXFxjBgxInr06BFLly6N2tpaTQHYoUOHDvGFL3whzjzzzCguLtaQHZqammoeeOCBWz73uc9N1w0AANg7BMAAALDDww8/vKygoOC54cOHH1FQUFCqI//QrVu3OO6446K0tDQWL14cTU1NmgI0Wy1btoxzzjknLr300ujevbuGvENtbe2K22677arbbrvtDd0AAIC9RwAMAADv8Oyzz25avHjx0yeddNKQoqKiTjryD3l5edGnT58YOXJkbN26NVatWqUpQLNz+OGHx1e+8pUYMGBA5OXlacg7VFVV/e3CCy+8/oEHHvDdAAAA2MsEwAAA8C7z58+vefbZZ58+44wz+hcXF/fSkf/RsmXLGDJkSOyzzz6xdOnSqKmp0RQg53Xs2DG++MUvximnnBItW7bUkHdZt27dMyeffPI3Xn755W26AQAAe9/7BcCpfc+JETv7QeO6iI2vttI9AAByWmFhYer555//0sEHH3y5bvxfTU1N8fzzz8f48eOjurpaQ4Cc07p16zjzzDPjyCOPdOJ35zJ///vff3rMMcfc39DQkNEOAADIDh2G1UZBl53/TAAMAAARMWnSpM8cc8wxt6RSKdfg7ERNTU1MmTIlpk2bFg0NDRoCJF5hYWGccsopcdJJJ0VRUZGG7EQ6na6fOnXqd88555y/6AYAAGSX9wuAXQENAAAR8Yc//GHhfvvt98aAAQOOysvLkwS8S2FhYQwYMCCGDh0amzZtinXr1mkKkFiDBw+Oq666KoYOHRoFBQUashONjY1Vv//972/5whe+MEs3AAAg+/gGMAAAfAgTJkxYXV1dPf3II4/8VGFhYTsd+b9KS0vjsMMOi/79+8eaNWti8+bNmgIkRu/evePyyy+PU045JUpLSzXkPWzdunXxLbfccs33vve9hboBAADZyTeAAQDgI+jTp0+LJ5988us9evQ4TTfe3/z58+ORRx6JlStXagaQtXr16hXnnHNODBgwQDM+wKpVq5444YQTfrBy5Ur3/QMAQBbzDWAAAPgYnnnmmfOHDx9+fSqVytON95bJZGL27Nkxbty4qKio0BAga3Tu3DnOOuusGDp0aKRSKQ15/z/Lm2bNmvXDk08++THdAACA7OcbwAAA8DH85je/eX3//fd//cADDzzSd4HfWyqViu7du8cxxxwT7dq1i2XLlkV9fb3GAHtN27Zt49xzz42LL744evToIfz9AI2NjdUPPvjgLZ/97Gf/ohsAAJAMvgEMAAAf0/jx41dFxPOHHXbYiMLCwjIdeW95eXnRu3fvOOqoo6KgoCBWrlwZjY2NGgPsMcXFxXHKKafEl770pejbt2/k5bnA4YPU1tau+MEPfnD9LbfcMk83AAAgQf/94xvAAADwyQwePLjVo48++s1u3bqdpBsfTn19fTzzzDMxderU2LZtm4YAu01ZWVmceuqpceSRR0ZRkQsbPqyVK1c+/ulPf/pHixcvdm0DAAAkjG8AAwDALvLkk0+edeSRR96USqVcl/MhCYKB3eXtE7/HHnus4PcjyGQyDbNmzfoP3/sFAIDk8g1gAADYRX7/+98v6NGjx2uHHHLIyPz8fL8x+SEUFBREv3794qijjoq8vLxYtWqVq6GBT6Rly5ZxwgknxBVXXBEHHXRQFBQUaMqH1NDQsOG3v/3t1z7/+c8/oxsAAJBcroAGAIBd7Lzzzut4991339m2bdvBuvHR1NTUxLPPPhvTpk2LLVu2aAjwoZWVlcXxxx8fxxxzTBQXF2vIR1RVVfW3a6+99vZHHnlkg24AAECyuQIaAAB2g06dOhVMmzZtbN++fT8XESkd+WgaGhri+eefjyeffDI2bJBFAO/7522cdNJJccQRR0RhodvKPobMokWL/nTsscf+pLKyskk7AAAg+QTAAACwG/3hD38Ydfrpp99WUFDQRjc+unQ6Ha+++mpMnTo1Vq5cqSHAP/Xq1StOOeWUGDp0aOTl5WnIx9DY2Fg1YcKEOy666KKZugEAALlDAAwAALvZaaed1vbee+/9docOHUbqxse3fPnymDZtWrz88suRTqc1BJqhvLy8OOyww+L444+P3r17a8gnsHHjxue//OUvf3fSpElVugEAALlFAAwAAHtAYWFh6qmnnjpv+PDh16RSKXeUfgIbNmyIGTNmxHPPPRc1NTUaAs1AcXFxjBo1Ko4++ujo2LGjhnwCmUym4ZVXXvl/J5100kMNDQ0ZHQEAgNzzfgFwftuDoufOfpDeFlFb7p0VAAB8WOl0On7zm9+8Xlpa+uLgwYM/VVhYWKYrH09xcXEMGDAgjj322GjTpk2sXbs2amtrNQZyUIcOHeKMM86ISy+9NAYOHBjFxcWa8gnU1tau+slPfnLjxRdf/IybFAAAIHcVd2+MvNKd/8wJYAAA2A1OPPHENvfdd9+tnTp1Olo3PrnGxsb429/+Fs8++2wsWrRIQyAH9OvXL44++ugYNmxYFBQUaMguUFFR8cwXv/jFf5s+ffoW3QAAgNzmCmgAANhLHn744RNGjx799YKCgta6sWusX78+Zs6cGc8//3xUV1drCCRIaWlpHHnkkXHUUUdF586dNWQXaWxs3DJ16tS7PvvZz/5FNwAAoHkQAAMAwF50ySWXdP3+97//rXbt2g3VjV2nsbExXnvttXjuuedi/vz5GgJZbMCAATFq1KgYPHiw0767WFVV1atf//rXv/e73/1urW4AAEDzIQAGAIC9rF27dvlTp0699OCDD740lUrl68iutXz58nj++efj5ZdfjpqaGg2BLFBSUhLDhw+PI444Inr37q0hu1gmk2mcN2/efSeeeOJvq6urfewXAACaGQEwAABkia9//ev73Xjjjf9aWlraXzd2vXQ6HW+++WY899xz8dprr0VjY6OmwB5UUFAQgwcPjlGjRsUBBxwQeXl5mrIbVFdXL/zP//zPf/3BD36wRDcAAKB5EgADAEAWOfjgg1v9+c9/vrZ3795jIiKlI7tHZWVlvPjii/HCCy/EunXrNAR2o65du8bIkSPj8MMPj7Zt22rI7pNZunTpn88888z/t3jx4nrtAACA5ksADAAAWejuu+8eePHFF9/WqlUrd6PuZuXl5fHqq6/GSy+9FOvXr9cQ2AU6d+4cI0aMiGHDhkW3bt00ZDerqalZ9tvf/vbOm266aa5uAAAAAmAAAMhS/fr1K3r44Ycv79+//4WpVMpdqXvA8uXL46WXXoqXX345qqurNQQ+grKyshg+fHiMGDHCd333kEwmk164cOEfzj777F8sXbp0u44AAAARAmAAAMh6P/3pT4d97nOf+2bLli176Mae0dDQEHPnzo2//vWvMXfu3Ni+Xa4CO9OyZcsYNGhQDBs2LA455JAoKCjQlD2ktrZ21R//+Mc7rr322r/rBgAA8E4CYAAASIA+ffq0ePTRR69wGnjPS6fTsXTp0nj11VedDIaIaNu2bQwbNiyGDRsWffr0ibw8fyTtSZlMpuG11177+ZlnnvmnioqKRh0BAADeTQAMAAAJ8uMf//jQCy644JutWrXaRzf2vLdPBs+ePTvmzp0bdXV1mkKzUFZWFoMHD45hw4ZF//79Iz8/X1P2gpqammX333//nTfccINv/QIAAO9JAAwAAAnTrl27/HHjxp37qU996qq8vDwb870kk8nEihUrYu7cuTFnzpxYsWJFZDIZjSEnpFKp6Nu3bwwbNiwGDRoUHTt21JS9qKmpqfbVV1/92ZgxY/5cWVnZpCMAAMD7EQADAEBCffnLX+5x++23f7V9+/aH68bet2XLlnjjjTdizpw5MW/evKivr9cUEqVly5Zx8MEHx6BBg+KQQw6J0tJSTckCGzdufPG73/3uv//iF79YoxsAAMCHIQAGAIAEKywsTE2cOPGMkSNHXlNQUNBaR7JDXV1dvPnmm/HGG2/EG2+8EevXr9cUslKXLl3ioIMOioMOOigOOOCAKCoq0pQs0djYuGXmzJk/PvPMMyc2NDS4XgAAAPjQBMAAAJADjjzyyNY/+9nPrujbt++5EZGnI9mluro6Fi5cGPPnz4958+ZFZWWlprBXtGvXLg455JAYMGBA9O/fP1q39nsjWSj91ltv/fmqq676xaxZs6q1AwAA+KgEwAAAkEN++ctfjhgzZsyNrVq16q0b2SmdTsfKlStj0aJFsXDhwli8eHFs27ZNY9gtSkpKol+/ftG/f//Yf//9o1evXpGX53dEslVNTc3yRx999EdXXnnlK7oBAAB8XAJgAADIMd26dSt8+OGHPzd48ODL8vPzbdyzXCaTiTVr1sTChQtj0aJFsWjRotiyZYvG8LGUlZVF//79/xn6du/ePVKplMZkuaampprXXnvtV2PGjHmgoqKiUUcAAIBPQgAMAAA56rjjjiv7r//6r8tdC508mzdvjuXLl8eKFSti+fLlsXjx4qipqdEY/pfi4uLo169f9O7dO/bZZ5/Yd999o6ysTGMSJJPJpJcsWfLn66677pfTp0/3mx8AAMAuIQAGAIAc99Of/nTIueeee3NpaWlf3UimxsbGWLlyZSxdujSWLVsWy5cvj3Xr1kUmk9GcZiKVSkWXLl1in332iT59+kSfPn2iV69eUVBQoDkJtXXr1sUPPvjgj6699tq/6wYAALArCYABAKAZaNeuXf64cePOGTp06BUFBQWtdST56uvrY+XKlf88KbxixYpYu3ZtpNNpzUm4vLy86Nq1a+yzzz7//KdXr17RsmVLzckBjY2NW/7617/+4pxzznm0srKySUcAAIBdTQAMAADNyIknntjmnnvuuXzfffcdk0qlHB3MMdu3b481a9bEmjVrYu3atbF27dooLy+PDRs2CIazUF5eXnTs2DG6desWXbt2jW7dukW3bt2iR48eUVhYqEE5JpPJNC5ZsuRR1z0DAAC7mwAYAACaoa9+9av7Xnfdddd16NDhCN3IfY2Njf8MhNetWxfr1q2LioqKWLduXWzbtk2DdrPS0tLo3LnzP//p0qVLdO3aNbp27eoK52Ziw4YNM//rv/7rxz/60Y+W6wYAALC7CYABAKAZ++UvfznirLPOuq64uNj3gZupmpqaWL9+/T//qaioiMrKyqisrIxNmzZFY2OjJn2AgoKCaN++fbRr1y7at28fHTt2jC5dukSnTp2ic+fOUVxcrEnN1NatW98aP378PVdcccXLugEAAOwpAmAAAGjm2rVrl//ggw+eOWLEiCsLCwvb6gjvtHnz5n+GwZs2bYrKysqorq6OLVu2xJYtW6K6ujqqq6sjk8nk3NpTqVS0bt06WrduHWVlZdGmTZsoLS39X2Fvu3btok2bNh4U/peGhobKl1566efnnHPO+OrqavevAwAAe5QAGAAAiIiIoUOHFt97770XHHjggRfk5+c7ssiHlk6n/xkEV1dXR01Nzfv+k8lkora2NtLpdNTX10dTU1PU1dXt0u8U5+XlRcuWLSM/Pz+KiooiLy8vWrVqFalUKoqLi3f6T0lJSbRq1eqfgW9paWnk5eUZMB9aU1NTzYIFC/745S9/+Y+zZ8+u0REAAGBvEAADAAD/y2mnndb2rrvuurRPnz5n5+XlFeoIe9LbgfDbtm/f/r7XUBcUFESLFi3++b/fDnxhT8pkMg1LliwZd8stt/xq0qRJVToCAADsTQJgAABgp0477bS2d95554X777//5wTBAP9XJpNpWLhw4QO33nrrHwS/AABAtni/ADi/7UHRc2c/SG+LqC33/gcAAHLZokWL6u69995X0un0swcddFCnkpKS3roC8A8VFRUz/7//7/+77aKLLpq6aNGiOh0BAACyRXH3xsgr3fnPBMAAAEDMnDmz8u67736qqalpWr9+/Ypbt27dN5VKpXQGaG4ymUx6zZo1U+65555/Peeccx6cOXNmpa4AAADZRgAMAAB8KDNnzqz88Y9//Gw6nZ4uCAaak7eD37vvvvtfzz///McEvwAAQDYTAAMAAB+JIBhoLgS/AABAEgmAAQCAj+XtILisrOyFvn37diwuLu4VEYJgIBdkKioqnrv33nu/PWbMmEcEvwAAQJK8XwCc2vecGLGzHzSui9j4aivdAwAA/unqq6/u8ZWvfOX8Pn36nJWXl9dCR4CkSafT9UuXLh3/X//1Xw/84he/WKMjAABAEnUYVhsFXXb+MwEwAADwkZ1xxhntb7/99rMPPPDA8/Pz81vrCJDtmpqaqhcsWPDgd77znUcmTpzotC8AAJBoAmAAAGC3GD58eMkPf/jDzwwePPjioqKijjoCZJv6+voNr7322u9vvPHGx2fPnl2jIwAAQC4QAAMAALvV0KFDi++5556zDjnkkPOKioq66giwt9XV1a19/fXXH7z++uvHC34BAIBcIwAGAAD2iFatWuXdc889w0455ZTzO3bseJSOAHtYZsOGDbOmTJny4PXXX/9qbW1tWksAAIBcJAAGAAD2uH/913/tf/7555/dq1ev0/Ly8lroCLC7pNPp+pUrV05+4IEHHvnOd76zSEcAAIBcJwAGAAD2mjPOOKP97bfffvYBBxzw2YKCgjY6AuwqjY2NVW+++eafv/e97z06YcKETToCAAA0FwJgAABgrxs+fHjJ97///dGDBg0aU1paur+OAB9XdXX1wtdee+3Rr371q1Nfe+21Wh0BAACaGwEwAACQVb761a/ue8EFF3y6b9++ZxUUFLTWEeCDNDY2bnnrrbfG/+EPf5j4ox/9aLmOAAAAzZkAGAAAyEpDhw4t/sEPfnDy4MGDz27dunV/HQHerbq6+s2XX375weuuu+7ppUuXbtcRAAAAATAAAJDlCgsLU3ffffeQ0aNHn9G1a9fj8vLyinQFmq90Ol1XXl4+bcqUKROuvfbav+sIAADA/yYABgAAEqNPnz4t/v3f/33UyJEjz2rfvv2nIiKlK9AsZDZt2vTXF1544bGvfe1rzzntCwAA8N4EwAAAQCJddNFFXa6++uqTDzzwwLNbtmzZTUcg99TV1a1ZsGDBuJ/+9KdP3n///et0BAAA4IMJgAEAgETr1q1b4d13333k4YcffmqHDh2OyMvLK9QVSK50Ot2wcePGWbNmzZp8/fXXz6qoqGjUFQAAgA9PAAwAAOSMo48+uvWtt956/CGHHHJKu3btBkdEnq5AIqQrKytfmzdv3uQ777xz+owZM6q1BAAA4OMRAAMAADnpuOOOK/vGN75x/CGHHHJa27ZtB4bvBUO2yVRVVc2dN2/epO9///vTpk+fvkVLAAAAPjkBMAAAkPNuu+22vmedddZJffr0Oa5Vq1a9dQT2ntra2uXLly+f/uijjz51xx13vKUjAAAAu5YAGAAAaFa+9KUvdbv44ouP7t+//wlOBsMekamqqpq7cOHCv/z+97+fcd9995VrCQAAwO4jAAYAAJqtSy65pOtll112jDAYdrl0VVXVvIULF/7lV7/61bO/+93v1moJAADAniEABgAAiIirr766x/nnnz9q//33P7JNmzZDUqlUga7Ah5fJZBoqKyv/vnjx4uf+9Kc/zbr33ntX6woAAMCeJwAGAAB4l379+hV97WtfGzRy5MhRPXv2PLaoqKizrsD/VV9fv37VqlXPvPDCC8/9+7//+5zFixfX6woAAMDeJQAGAAB4H61bt8678847Bx599NFHde/efURpaen+4apomq/M1q1bF69Zs+bF5557btY3v/nNOdXV1WltAQAAyB4CYAAAgI9g8ODBrcaOHXvI8OHDD+vevfvw1q1bHxACYXJXprq6+s01a9a88sorr7z8k5/8ZN5rr71Wqy0AAADZSwAMAADwCVx//fX7nHHGGYf169dvePv27Yfm5+e31hWSrLGxsXrjxo2vvvXWWy+PHz/+lR//+McrdQUAACA5BMAAAAC70Je//OUe55xzzvA+ffoM7tix45CioqKuukI2q6+vX7t27doXFy9ePGfixImv3Xvvvat1BQAAILkEwAAAALvRl7/85R6f+cxnBvfr129Qly5dDm/ZsqVAmL2qrq5u7bp16wS+AAAAOUoADAAAsIe0atUq75prrtnn2GOPPXi//fY7uH379oeUlpb2TaVS+brDbpKuqalZtnHjxnlvvfXW3GeffXbef/3Xfy2vra1Naw0AAEBuEgADAADsRQceeGDLq6+++oAhQ4Yc3LNnz4Pbtm17sGuj+biampqqq6qqXi8vL583Z86ceb/85S/nvfjii1t1BgAAoPkQAAMAAGSZoUOHFn/xi1/cf9CgQQf26NHjwHbt2h3YqlWr3qlUKk932CFdU1OzvLKycsHq1asXzJkzZ8Gf//znJTNmzKjWGgAAgOZNAAwAAJAAxx13XNkFF1xw4MEHH3xA165dDywtLd23pKRkn1QqVag7uS2TyTRs27ZtRXV19dJ169YtfOONNxZOmDBh4YQJEzbpDgAAAO8mAAYAAEiw8847r+OJJ57Yp3///vt16dKlT5s2bfZr3bp1v/z8/GLdSZampqaa6urqxZs3b16ybt26pQsXLlzy9NNPL33ooYc26A4AAAAflgAYAAAgx7Rr1y7/kksu6TFkyJCe++67b89OnTr1Kisr61VcXNyzZcuW3VKpVL4u7R2ZTKaprq6uvKamZtWWLVtWVlRUrFy6dOnK2bNnr7r//vvXVFZWNukSAAAAn4QAGAAAoBnp1KlTwec+97luQ4cO7bnPPvv0aNeuXafWrVt3Li4u7tqyZcvORUVFnfLy8lro1MeTTqe319fXr6+rq6uoqalZW11dvb6y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AACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoMY3JP//9K8My551lzpAk293a7QAAAAAAAAD8iIw3r+SL7TpPxuSt4/ibJJuz20QDBgAAAAAAAHhzrJPp6NvHYcyyjLl7dJTPbl/Jp6sPLufSsM+5ec7q5YOrF0OeP/SVaAAAAAAAAIA3weH7u6zfm79dWDIMSw6225w785vsx3XyzasOby5ssz69c4sAAAAAAAAAr9n69C6bC9sT93a7rKdnORin5Otxynzi1JQcfiwCAwAAAAAAALxO69O7HH68TaaT98cp85R8vbp3Nfszv8q0LHn7xMF1sjk/ZzUPmZ/MmWefhAYAAAAAAAD4oayPdjn7223Gn7x6ZrXPnetX8mBKkpv3cufDd/Pufn5FL56SzcVtNheT3dNt8tQlAwAAAAAAAHyv1sm0ySv/9XtsNWZ3I/lHkgzHi7/4XY7WYz5yiwAAAAAAAAA/Ivtcv/3nPEyS1fHa42t5+vNLyX7JoRsCAAAAAAAAePPt1/nbV3/KvePn1Xc371/NYxEYAAAAAAAA4M0yTHk2rvNo2WdzvHZqzN9v/SF3vju3evng/at5fPDLPDu1yuGyZHSVAAAAAAAAAK/XOGe4ueSvZ4e8M8xZbVe5ceuPufvy3Oqkw4+v5emDX+fuuTlLhhwsEYIBAAAAAAAAXpclGR8OuXP0TR4cPM/9z/+SRyfNDf/1TZezOp/87KdjzizJZkhO7edMy/w/nAUAAAAAAADg/zaMWcZkP8/ZLsmLacr2/MV8+cnvs/tP5/4FmLjAq1ifcioAAAAASUVORK5CYII=';\n\n/**\n * PptxGenJS: Utility Methods\n */\n/**\n * Translates any type of `x`/`y`/`w`/`h` prop to EMU\n * - guaranteed to return a result regardless of undefined, null, etc. (0)\n * - {number} - 12800 (EMU)\n * - {number} - 0.5 (inches)\n * - {string} - \"75%\"\n * @param {number|string} size - numeric (\"5.5\") or percentage (\"90%\")\n * @param {'X' | 'Y'} xyDir - direction\n * @param {PresLayout} layout - presentation layout\n * @returns {number} calculated size\n */\nfunction getSmartParseNumber(size, xyDir, layout) {\n    // FIRST: Convert string numeric value if reqd\n    if (typeof size === 'string' && !isNaN(Number(size)))\n        size = Number(size);\n    // CASE 1: Number in inches\n    // Assume any number less than 100 is inches\n    if (typeof size === 'number' && size < 100)\n        return inch2Emu(size);\n    // CASE 2: Number is already converted to something other than inches\n    // Assume any number greater than 100 sure isnt inches! Just return it (assume value is EMU already).\n    if (typeof size === 'number' && size >= 100)\n        return size;\n    // CASE 3: Percentage (ex: '50%')\n    if (typeof size === 'string' && size.includes('%')) {\n        if (xyDir && xyDir === 'X')\n            return Math.round((parseFloat(size) / 100) * layout.width);\n        if (xyDir && xyDir === 'Y')\n            return Math.round((parseFloat(size) / 100) * layout.height);\n        // Default: Assume width (x/cx)\n        return Math.round((parseFloat(size) / 100) * layout.width);\n    }\n    // LAST: Default value\n    return 0;\n}\n/**\n * Basic UUID Generator Adapted\n * @link https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript#answer-2117523\n * @param {string} uuidFormat - UUID format\n * @returns {string} UUID\n */\nfunction getUuid(uuidFormat) {\n    return uuidFormat.replace(/[xy]/g, function (c) {\n        const r = (Math.random() * 16) | 0;\n        const v = c === 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n}\n/**\n * Replace special XML characters with HTML-encoded strings\n * @param {string} xml - XML string to encode\n * @returns {string} escaped XML\n */\nfunction encodeXmlEntities(xml) {\n    // NOTE: Dont use short-circuit eval here as value c/b \"0\" (zero) etc.!\n    if (typeof xml === 'undefined' || xml == null)\n        return '';\n    return xml.toString().replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&apos;');\n}\n/**\n * Convert inches into EMU\n * @param {number|string} inches - as string or number\n * @returns {number} EMU value\n */\nfunction inch2Emu(inches) {\n    // NOTE: Provide Caller Safety: Numbers may get conv<->conv during flight, so be kind and do some simple checks to ensure inches were passed\n    // Any value over 100 damn sure isnt inches, so lets assume its in EMU already, therefore, just return the same value\n    if (typeof inches === 'number' && inches > 100)\n        return inches;\n    if (typeof inches === 'string')\n        inches = Number(inches.replace(/in*/gi, ''));\n    return Math.round(EMU * inches);\n}\n/**\n * Convert `pt` into points (using `ONEPT`)\n * @param {number|string} pt\n * @returns {number} value in points (`ONEPT`)\n */\nfunction valToPts(pt) {\n    const points = Number(pt) || 0;\n    return isNaN(points) ? 0 : Math.round(points * ONEPT);\n}\n/**\n * Convert degrees (0..360) to PowerPoint `rot` value\n * @param {number} d degrees\n * @returns {number} calculated `rot` value\n */\nfunction convertRotationDegrees(d) {\n    d = d || 0;\n    return Math.round((d > 360 ? d - 360 : d) * 60000);\n}\n/**\n * Converts component value to hex value\n * @param {number} c - component color\n * @returns {string} hex string\n */\nfunction componentToHex(c) {\n    const hex = c.toString(16);\n    return hex.length === 1 ? '0' + hex : hex;\n}\n/**\n * Converts RGB colors from css selectors to Hex for Presentation colors\n * @param {number} r - red value\n * @param {number} g - green value\n * @param {number} b - blue value\n * @returns {string} XML string\n */\nfunction rgbToHex(r, g, b) {\n    return (componentToHex(r) + componentToHex(g) + componentToHex(b)).toUpperCase();\n}\n/**  TODO: FUTURE: TODO-4.0:\n * @date 2022-04-10\n * @tldr this s/b a private method with all current calls switched to `genXmlColorSelection()`\n * @desc lots of code calls this method\n * @example [gen-charts.tx] `strXml += '<a:solidFill>' + createColorElement(seriesColor, `<a:alpha val=\"${Math.round(opts.chartColorsOpacity * 1000)}\"/>`) + '</a:solidFill>'`\n * Thi sis wrong. We s/b calling `genXmlColorSelection()` instead as it returns `<a:solidfill>BLAH</a:solidFill>`!!\n */\n/**\n * Create either a `a:schemeClr` - (scheme color) or `a:srgbClr` (hexa representation).\n * @param {string|SCHEME_COLORS} colorStr - hexa representation (eg. \"FFFF00\") or a scheme color constant (eg. pptx.SchemeColor.ACCENT1)\n * @param {string} innerElements - additional elements that adjust the color and are enclosed by the color element\n * @returns {string} XML string\n */\nfunction createColorElement(colorStr, innerElements) {\n    let colorVal = (colorStr || '').replace('#', '');\n    if (!REGEX_HEX_COLOR.test(colorVal) &&\n        colorVal !== SchemeColor.background1 &&\n        colorVal !== SchemeColor.background2 &&\n        colorVal !== SchemeColor.text1 &&\n        colorVal !== SchemeColor.text2 &&\n        colorVal !== SchemeColor.accent1 &&\n        colorVal !== SchemeColor.accent2 &&\n        colorVal !== SchemeColor.accent3 &&\n        colorVal !== SchemeColor.accent4 &&\n        colorVal !== SchemeColor.accent5 &&\n        colorVal !== SchemeColor.accent6) {\n        console.warn(`\"${colorVal}\" is not a valid scheme color or hex RGB! \"${DEF_FONT_COLOR}\" used instead. Only provide 6-digit RGB or 'pptx.SchemeColor' values!`);\n        colorVal = DEF_FONT_COLOR;\n    }\n    const tagName = REGEX_HEX_COLOR.test(colorVal) ? 'srgbClr' : 'schemeClr';\n    const colorAttr = 'val=\"' + (REGEX_HEX_COLOR.test(colorVal) ? colorVal.toUpperCase() : colorVal) + '\"';\n    return innerElements ? `<a:${tagName} ${colorAttr}>${innerElements}</a:${tagName}>` : `<a:${tagName} ${colorAttr}/>`;\n}\n/**\n * Creates `a:glow` element\n * @param {TextGlowProps} options glow properties\n * @param {TextGlowProps} defaults defaults for unspecified properties in `opts`\n * @see http://officeopenxml.com/drwSp-effects.php\n * { size: 8, color: 'FFFFFF', opacity: 0.75 };\n */\nfunction createGlowElement(options, defaults) {\n    let strXml = '';\n    const opts = Object.assign(Object.assign({}, defaults), options);\n    const size = Math.round(opts.size * ONEPT);\n    const color = opts.color;\n    const opacity = Math.round(opts.opacity * 100000);\n    strXml += `<a:glow rad=\"${size}\">`;\n    strXml += createColorElement(color, `<a:alpha val=\"${opacity}\"/>`);\n    strXml += '</a:glow>';\n    return strXml;\n}\n/**\n * Create color selection\n * @param {Color | ShapeFillProps | ShapeLineProps} props fill props\n * @returns XML string\n */\nfunction genXmlColorSelection(props) {\n    let fillType = 'solid';\n    let colorVal = '';\n    let internalElements = '';\n    let outText = '';\n    if (props) {\n        if (typeof props === 'string')\n            colorVal = props;\n        else {\n            if (props.type)\n                fillType = props.type;\n            if (props.color)\n                colorVal = props.color;\n            if (props.alpha)\n                internalElements += `<a:alpha val=\"${Math.round((100 - props.alpha) * 1000)}\"/>`; // DEPRECATED: @deprecated v3.3.0\n            if (props.transparency)\n                internalElements += `<a:alpha val=\"${Math.round((100 - props.transparency) * 1000)}\"/>`;\n        }\n        switch (fillType) {\n            case 'solid':\n                outText += `<a:solidFill>${createColorElement(colorVal, internalElements)}</a:solidFill>`;\n                break;\n            default: // @note need a statement as having only \"break\" is removed by rollup, then tiggers \"no-default\" js-linter\n                outText += '';\n                break;\n        }\n    }\n    return outText;\n}\n/**\n * Get a new rel ID (rId) for charts, media, etc.\n * @param {PresSlide} target - the slide to use\n * @returns {number} count of all current rels plus 1 for the caller to use as its \"rId\"\n */\nfunction getNewRelId(target) {\n    return target._rels.length + target._relsChart.length + target._relsMedia.length + 1;\n}\n/**\n * Checks shadow options passed by user and performs corrections if needed.\n * @param {ShadowProps} ShadowProps - shadow options\n */\nfunction correctShadowOptions(ShadowProps) {\n    if (!ShadowProps || typeof ShadowProps !== 'object') {\n        // console.warn(\"`shadow` options must be an object. Ex: `{shadow: {type:'none'}}`\")\n        return;\n    }\n    // OPT: `type`\n    if (ShadowProps.type !== 'outer' && ShadowProps.type !== 'inner' && ShadowProps.type !== 'none') {\n        console.warn('Warning: shadow.type options are `outer`, `inner` or `none`.');\n        ShadowProps.type = 'outer';\n    }\n    // OPT: `angle`\n    if (ShadowProps.angle) {\n        // A: REALITY-CHECK\n        if (isNaN(Number(ShadowProps.angle)) || ShadowProps.angle < 0 || ShadowProps.angle > 359) {\n            console.warn('Warning: shadow.angle can only be 0-359');\n            ShadowProps.angle = 270;\n        }\n        // B: ROBUST: Cast any type of valid arg to int: '12', 12.3, etc. -> 12\n        ShadowProps.angle = Math.round(Number(ShadowProps.angle));\n    }\n    // OPT: `opacity`\n    if (ShadowProps.opacity) {\n        // A: REALITY-CHECK\n        if (isNaN(Number(ShadowProps.opacity)) || ShadowProps.opacity < 0 || ShadowProps.opacity > 1) {\n            console.warn('Warning: shadow.opacity can only be 0-1');\n            ShadowProps.opacity = 0.75;\n        }\n        // B: ROBUST: Cast any type of valid arg to int: '12', 12.3, etc. -> 12\n        ShadowProps.opacity = Number(ShadowProps.opacity);\n    }\n    // OPT: `color`\n    if (ShadowProps.color) {\n        // INCORRECT FORMAT\n        if (ShadowProps.color.startsWith('#')) {\n            console.warn('Warning: shadow.color should not include hash (#) character, , e.g. \"FF0000\"');\n            ShadowProps.color = ShadowProps.color.replace('#', '');\n        }\n    }\n    return ShadowProps;\n}\n\n/**\n * PptxGenJS: Table Generation\n */\n/**\n * Break cell text into lines based upon table column width (e.g.: Magic Happens Here(tm))\n * @param {TableCell} cell - table cell\n * @param {number} colWidth - table column width (inches)\n * @return {TableRow[]} - cell's text objects grouped into lines\n */\nfunction parseTextToLines(cell, colWidth, verbose) {\n    var _a, _b;\n    // FYI: CPL = Width / (font-size / font-constant)\n    // FYI: CHAR:2.3, colWidth:10, fontSize:12 => CPL=138, (actual chars per line in PPT)=145 [14.5 CPI]\n    // FYI: CHAR:2.3, colWidth:7 , fontSize:12 => CPL= 97, (actual chars per line in PPT)=100 [14.3 CPI]\n    // FYI: CHAR:2.3, colWidth:9 , fontSize:16 => CPL= 96, (actual chars per line in PPT)=84  [ 9.3 CPI]\n    const FOCO = 2.3 + (((_a = cell.options) === null || _a === void 0 ? void 0 : _a.autoPageCharWeight) ? cell.options.autoPageCharWeight : 0); // Character Constant\n    const CPL = Math.floor((colWidth / ONEPT) * EMU) / ((((_b = cell.options) === null || _b === void 0 ? void 0 : _b.fontSize) ? cell.options.fontSize : DEF_FONT_SIZE) / FOCO); // Chars-Per-Line\n    const parsedLines = [];\n    let inputCells = [];\n    const inputLines1 = [];\n    const inputLines2 = [];\n    /*\n        if (cell.options && cell.options.autoPageCharWeight) {\n            let CHR1 = 2.3 + (cell.options && cell.options.autoPageCharWeight ? cell.options.autoPageCharWeight : 0) // Character Constant\n            let CPL1 = ((colWidth / ONEPT) * EMU) / ((cell.options && cell.options.fontSize ? cell.options.fontSize : DEF_FONT_SIZE) / CHR1) // Chars-Per-Line\n            console.log(`cell.options.autoPageCharWeight: '${cell.options.autoPageCharWeight}' => CPL: ${CPL1}`)\n            let CHR2 = 2.3 + 0\n            let CPL2 = ((colWidth / ONEPT) * EMU) / ((cell.options && cell.options.fontSize ? cell.options.fontSize : DEF_FONT_SIZE) / CHR2) // Chars-Per-Line\n            console.log(`cell.options.autoPageCharWeight: '0' => CPL: ${CPL2}`)\n        }\n    */\n    /**\n     * EX INPUTS: `cell.text`\n     * - string....: \"Account Name Column\"\n     * - object....: { text:\"Account Name Column\" }\n     * - object[]..: [{ text:\"Account Name\", options:{ bold:true } }, { text:\" Column\" }]\n     * - object[]..: [{ text:\"Account Name\", options:{ breakLine:true } }, { text:\"Input\" }]\n     */\n    /**\n     * EX OUTPUTS:\n     * - string....: [{ text:\"Account Name Column\" }]\n     * - object....: [{ text:\"Account Name Column\" }]\n     * - object[]..: [{ text:\"Account Name\", options:{ breakLine:true } }, { text:\"Input\" }]\n     * - object[]..: [{ text:\"Account Name\", options:{ breakLine:true } }, { text:\"Input\" }]\n     */\n    // STEP 1: Ensure inputCells is an array of TableCells\n    if (cell.text && cell.text.toString().trim().length === 0) {\n        // Allow a single space/whitespace as cell text (user-requested feature)\n        inputCells.push({ _type: SLIDE_OBJECT_TYPES.tablecell, text: ' ' });\n    }\n    else if (typeof cell.text === 'number' || typeof cell.text === 'string') {\n        inputCells.push({ _type: SLIDE_OBJECT_TYPES.tablecell, text: (cell.text || '').toString().trim() });\n    }\n    else if (Array.isArray(cell.text)) {\n        inputCells = cell.text;\n    }\n    // STEP 2: Group table cells into lines based on \"\\n\" or `breakLine` prop\n    /**\n     * - EX: `[{ text:\"Input Output\" }, { text:\"Extra\" }]`                       == 1 line\n     * - EX: `[{ text:\"Input\" }, { text:\"Output\", options:{ breakLine:true } }]` == 1 line\n     * - EX: `[{ text:\"Input\\nOutput\" }]`                                        == 2 lines\n     * - EX: `[{ text:\"Input\", options:{ breakLine:true } }, { text:\"Output\" }]` == 2 lines\n     */\n    let newLine = [];\n    inputCells.forEach(cell => {\n        var _a;\n        // (this is always true, we just constructed them above, but we need to tell typescript b/c type is still string||Cell[])\n        if (typeof cell.text === 'string') {\n            if (cell.text.split('\\n').length > 1) {\n                cell.text.split('\\n').forEach(textLine => {\n                    newLine.push({\n                        _type: SLIDE_OBJECT_TYPES.tablecell,\n                        text: textLine,\n                        options: Object.assign(Object.assign({}, cell.options), { breakLine: true }),\n                    });\n                });\n            }\n            else {\n                newLine.push({\n                    _type: SLIDE_OBJECT_TYPES.tablecell,\n                    text: cell.text.trim(),\n                    options: cell.options,\n                });\n            }\n            if ((_a = cell.options) === null || _a === void 0 ? void 0 : _a.breakLine) {\n                inputLines1.push(newLine);\n                newLine = [];\n            }\n        }\n        // Flush buffer\n        if (newLine.length > 0) {\n            inputLines1.push(newLine);\n            newLine = [];\n        }\n    });\n    // STEP 3: Tokenize every text object into words (then it's really easy to assemble lines below without having to break text, add its `options`, etc.)\n    inputLines1.forEach(line => {\n        line.forEach(cell => {\n            const lineCells = [];\n            const cellTextStr = String(cell.text); // force convert to string (compiled JS is better with this than a cast)\n            const lineWords = cellTextStr.split(' ');\n            lineWords.forEach((word, idx) => {\n                const cellProps = Object.assign({}, cell.options);\n                // IMPORTANT: Handle `breakLine` prop - we cannot apply to each word - only apply to very last word!\n                if (cellProps === null || cellProps === void 0 ? void 0 : cellProps.breakLine)\n                    cellProps.breakLine = idx + 1 === lineWords.length;\n                lineCells.push({ _type: SLIDE_OBJECT_TYPES.tablecell, text: word + (idx + 1 < lineWords.length ? ' ' : ''), options: cellProps });\n            });\n            inputLines2.push(lineCells);\n        });\n    });\n    // STEP 4: Group cells/words into lines based upon space consumed by word letters\n    inputLines2.forEach(line => {\n        let lineCells = [];\n        let strCurrLine = '';\n        line.forEach(word => {\n            // A: create new line when horizontal space is exhausted\n            if (strCurrLine.length + word.text.length > CPL) {\n                // if (verbose) console.log(`STEP 4: New line added: (${strCurrLine.length} + ${word.text.length} > ${CPL})`);\n                parsedLines.push(lineCells);\n                lineCells = [];\n                strCurrLine = '';\n            }\n            // B: add current word to line cells\n            lineCells.push(word);\n            // C: add current word to `strCurrLine` which we use to keep track of line's char length\n            strCurrLine += word.text.toString();\n        });\n        // Flush buffer: Only create a line when there's text to avoid empty row\n        if (lineCells.length > 0)\n            parsedLines.push(lineCells);\n    });\n    // Done:\n    return parsedLines;\n}\n/**\n * Takes an array of table rows and breaks into an array of slides, which contain the calculated amount of table rows that fit on that slide\n * @param {TableCell[][]} tableRows - table rows\n * @param {TableToSlidesProps} tableProps - table2slides properties\n * @param {PresLayout} presLayout - presentation layout\n * @param {SlideLayout} masterSlide - master slide\n * @return {TableRowSlide[]} array of table rows\n */\nfunction getSlidesForTableRows(tableRows = [], tableProps = {}, presLayout, masterSlide) {\n    let arrInchMargins = DEF_SLIDE_MARGIN_IN;\n    let emuSlideTabW = EMU * 1;\n    let emuSlideTabH = EMU * 1;\n    let emuTabCurrH = 0;\n    let numCols = 0;\n    const tableRowSlides = [];\n    const tablePropX = getSmartParseNumber(tableProps.x, 'X', presLayout);\n    const tablePropY = getSmartParseNumber(tableProps.y, 'Y', presLayout);\n    const tablePropW = getSmartParseNumber(tableProps.w, 'X', presLayout);\n    const tablePropH = getSmartParseNumber(tableProps.h, 'Y', presLayout);\n    let tableCalcW = tablePropW;\n    function calcSlideTabH() {\n        let emuStartY = 0;\n        if (tableRowSlides.length === 0)\n            emuStartY = tablePropY || inch2Emu(arrInchMargins[0]);\n        if (tableRowSlides.length > 0)\n            emuStartY = inch2Emu(tableProps.autoPageSlideStartY || tableProps.newSlideStartY || arrInchMargins[0]);\n        emuSlideTabH = (tablePropH || presLayout.height) - emuStartY - inch2Emu(arrInchMargins[2]);\n        // console.log(`| startY .......................................... = ${(emuStartY / EMU).toFixed(1)}`)\n        // console.log(`| emuSlideTabH .................................... = ${(emuSlideTabH / EMU).toFixed(1)}`)\n        if (tableRowSlides.length > 1) {\n            // D: RULE: Use margins for starting point after the initial Slide, not `opt.y` (ISSUE #43, ISSUE #47, ISSUE #48)\n            if (typeof tableProps.autoPageSlideStartY === 'number') {\n                emuSlideTabH = (tablePropH || presLayout.height) - inch2Emu(tableProps.autoPageSlideStartY + arrInchMargins[2]);\n            }\n            else if (typeof tableProps.newSlideStartY === 'number') {\n                // @deprecated v3.3.0\n                emuSlideTabH = (tablePropH || presLayout.height) - inch2Emu(tableProps.newSlideStartY + arrInchMargins[2]);\n            }\n            else if (tablePropY) {\n                emuSlideTabH = (tablePropH || presLayout.height) - inch2Emu((tablePropY / EMU < arrInchMargins[0] ? tablePropY / EMU : arrInchMargins[0]) + arrInchMargins[2]);\n                // Use whichever is greater: area between margins or the table H provided (dont shrink usable area - the whole point of over-riding Y on paging is to *increase* usable space)\n                if (emuSlideTabH < tablePropH)\n                    emuSlideTabH = tablePropH;\n            }\n        }\n    }\n    if (tableProps.verbose) {\n        console.log('[[VERBOSE MODE]]');\n        console.log('|-- TABLE PROPS --------------------------------------------------------|');\n        console.log(`| presLayout.width ................................ = ${(presLayout.width / EMU).toFixed(1)}`);\n        console.log(`| presLayout.height ............................... = ${(presLayout.height / EMU).toFixed(1)}`);\n        console.log(`| tableProps.x .................................... = ${typeof tableProps.x === 'number' ? (tableProps.x / EMU).toFixed(1) : tableProps.x}`);\n        console.log(`| tableProps.y .................................... = ${typeof tableProps.y === 'number' ? (tableProps.y / EMU).toFixed(1) : tableProps.y}`);\n        console.log(`| tableProps.w .................................... = ${typeof tableProps.w === 'number' ? (tableProps.w / EMU).toFixed(1) : tableProps.w}`);\n        console.log(`| tableProps.h .................................... = ${typeof tableProps.h === 'number' ? (tableProps.h / EMU).toFixed(1) : tableProps.h}`);\n        console.log(`| tableProps.slideMargin .......................... = ${tableProps.slideMargin ? String(tableProps.slideMargin) : ''}`);\n        console.log(`| tableProps.margin ............................... = ${String(tableProps.margin)}`);\n        console.log(`| tableProps.colW ................................. = ${String(tableProps.colW)}`);\n        console.log(`| tableProps.autoPageSlideStartY .................. = ${tableProps.autoPageSlideStartY}`);\n        console.log(`| tableProps.autoPageCharWeight ................... = ${tableProps.autoPageCharWeight}`);\n        console.log('|-- CALCULATIONS -------------------------------------------------------|');\n        console.log(`| tablePropX ...................................... = ${tablePropX / EMU}`);\n        console.log(`| tablePropY ...................................... = ${tablePropY / EMU}`);\n        console.log(`| tablePropW ...................................... = ${tablePropW / EMU}`);\n        console.log(`| tablePropH ...................................... = ${tablePropH / EMU}`);\n        console.log(`| tableCalcW ...................................... = ${tableCalcW / EMU}`);\n    }\n    // STEP 1: Calculate margins\n    {\n        // Important: Use default size as zero cell margin is causing our tables to be too large and touch bottom of slide!\n        if (!tableProps.slideMargin && tableProps.slideMargin !== 0)\n            tableProps.slideMargin = DEF_SLIDE_MARGIN_IN[0];\n        if (masterSlide && typeof masterSlide._margin !== 'undefined') {\n            if (Array.isArray(masterSlide._margin))\n                arrInchMargins = masterSlide._margin;\n            else if (!isNaN(Number(masterSlide._margin))) {\n                arrInchMargins = [Number(masterSlide._margin), Number(masterSlide._margin), Number(masterSlide._margin), Number(masterSlide._margin)];\n            }\n        }\n        else if (tableProps.slideMargin || tableProps.slideMargin === 0) {\n            if (Array.isArray(tableProps.slideMargin))\n                arrInchMargins = tableProps.slideMargin;\n            else if (!isNaN(tableProps.slideMargin))\n                arrInchMargins = [tableProps.slideMargin, tableProps.slideMargin, tableProps.slideMargin, tableProps.slideMargin];\n        }\n        if (tableProps.verbose)\n            console.log(`| arrInchMargins .................................. = [${arrInchMargins.join(', ')}]`);\n    }\n    // STEP 2: Calculate number of columns\n    {\n        // NOTE: Cells may have a colspan, so merely taking the length of the [0] (or any other) row is not\n        // ....: sufficient to determine column count. Therefore, check each cell for a colspan and total cols as reqd\n        const firstRow = tableRows[0] || [];\n        firstRow.forEach(cell => {\n            if (!cell)\n                cell = { _type: SLIDE_OBJECT_TYPES.tablecell };\n            const cellOpts = cell.options || null;\n            numCols += Number((cellOpts === null || cellOpts === void 0 ? void 0 : cellOpts.colspan) ? cellOpts.colspan : 1);\n        });\n        if (tableProps.verbose)\n            console.log(`| numCols ......................................... = ${numCols}`);\n    }\n    // STEP 3: Calculate width using tableProps.colW if possible\n    if (!tablePropW && tableProps.colW) {\n        tableCalcW = Array.isArray(tableProps.colW) ? tableProps.colW.reduce((p, n) => p + n) * EMU : tableProps.colW * numCols || 0;\n        if (tableProps.verbose)\n            console.log(`| tableCalcW ...................................... = ${tableCalcW / EMU}`);\n    }\n    // STEP 4: Calculate usable width now that total usable space is known (`emuSlideTabW`)\n    {\n        emuSlideTabW = tableCalcW || inch2Emu((tablePropX ? tablePropX / EMU : arrInchMargins[1]) + arrInchMargins[3]);\n        if (tableProps.verbose)\n            console.log(`| emuSlideTabW .................................... = ${(emuSlideTabW / EMU).toFixed(1)}`);\n    }\n    // STEP 5: Calculate column widths if not provided (emuSlideTabW will be used below to determine lines-per-col)\n    if (!tableProps.colW || !Array.isArray(tableProps.colW)) {\n        if (tableProps.colW && !isNaN(Number(tableProps.colW))) {\n            const arrColW = [];\n            const firstRow = tableRows[0] || [];\n            firstRow.forEach(() => arrColW.push(tableProps.colW));\n            tableProps.colW = [];\n            arrColW.forEach(val => {\n                if (Array.isArray(tableProps.colW))\n                    tableProps.colW.push(val);\n            });\n        }\n        else {\n            // No column widths provided? Then distribute cols.\n            tableProps.colW = [];\n            for (let iCol = 0; iCol < numCols; iCol++) {\n                tableProps.colW.push(emuSlideTabW / EMU / numCols);\n            }\n        }\n    }\n    // STEP 6: **MAIN** Iterate over rows, add table content, create new slides as rows overflow\n    let newTableRowSlide = { rows: [] };\n    tableRows.forEach((row, iRow) => {\n        // A: Row variables\n        const rowCellLines = [];\n        let maxCellMarTopEmu = 0;\n        let maxCellMarBtmEmu = 0;\n        // B: Create new row in data model, calc `maxCellMar*`\n        let currTableRow = [];\n        row.forEach(cell => {\n            var _a, _b, _c, _d;\n            currTableRow.push({\n                _type: SLIDE_OBJECT_TYPES.tablecell,\n                text: [],\n                options: cell.options,\n            });\n            /** FUTURE: DEPRECATED:\n             * - Backwards-Compat: Oops! Discovered we were still using points for cell margin before v3.8.0 (UGH!)\n             * - We cant introduce a breaking change before v4.0, so...\n             */\n            if (cell.options.margin && cell.options.margin[0] >= 1) {\n                if (((_a = cell.options) === null || _a === void 0 ? void 0 : _a.margin) && cell.options.margin[0] && valToPts(cell.options.margin[0]) > maxCellMarTopEmu)\n                    maxCellMarTopEmu = valToPts(cell.options.margin[0]);\n                else if ((tableProps === null || tableProps === void 0 ? void 0 : tableProps.margin) && tableProps.margin[0] && valToPts(tableProps.margin[0]) > maxCellMarTopEmu)\n                    maxCellMarTopEmu = valToPts(tableProps.margin[0]);\n                if (((_b = cell.options) === null || _b === void 0 ? void 0 : _b.margin) && cell.options.margin[2] && valToPts(cell.options.margin[2]) > maxCellMarBtmEmu)\n                    maxCellMarBtmEmu = valToPts(cell.options.margin[2]);\n                else if ((tableProps === null || tableProps === void 0 ? void 0 : tableProps.margin) && tableProps.margin[2] && valToPts(tableProps.margin[2]) > maxCellMarBtmEmu)\n                    maxCellMarBtmEmu = valToPts(tableProps.margin[2]);\n            }\n            else {\n                if (((_c = cell.options) === null || _c === void 0 ? void 0 : _c.margin) && cell.options.margin[0] && inch2Emu(cell.options.margin[0]) > maxCellMarTopEmu)\n                    maxCellMarTopEmu = inch2Emu(cell.options.margin[0]);\n                else if ((tableProps === null || tableProps === void 0 ? void 0 : tableProps.margin) && tableProps.margin[0] && inch2Emu(tableProps.margin[0]) > maxCellMarTopEmu)\n                    maxCellMarTopEmu = inch2Emu(tableProps.margin[0]);\n                if (((_d = cell.options) === null || _d === void 0 ? void 0 : _d.margin) && cell.options.margin[2] && inch2Emu(cell.options.margin[2]) > maxCellMarBtmEmu)\n                    maxCellMarBtmEmu = inch2Emu(cell.options.margin[2]);\n                else if ((tableProps === null || tableProps === void 0 ? void 0 : tableProps.margin) && tableProps.margin[2] && inch2Emu(tableProps.margin[2]) > maxCellMarBtmEmu)\n                    maxCellMarBtmEmu = inch2Emu(tableProps.margin[2]);\n            }\n        });\n        // C: Calc usable vertical space/table height. Set default value first, adjust below when necessary.\n        calcSlideTabH();\n        emuTabCurrH += maxCellMarTopEmu + maxCellMarBtmEmu; // Start row height with margins\n        if (tableProps.verbose && iRow === 0)\n            console.log(`| SLIDE [${tableRowSlides.length}]: emuSlideTabH ...... = ${(emuSlideTabH / EMU).toFixed(1)} `);\n        // D: --==[[ BUILD DATA SET ]]==-- (iterate over cells: split text into lines[], set `lineHeight`)\n        row.forEach((cell, iCell) => {\n            var _a;\n            const newCell = {\n                _type: SLIDE_OBJECT_TYPES.tablecell,\n                _lines: null,\n                _lineHeight: inch2Emu(((((_a = cell.options) === null || _a === void 0 ? void 0 : _a.fontSize) ? cell.options.fontSize : tableProps.fontSize ? tableProps.fontSize : DEF_FONT_SIZE) *\n                    (LINEH_MODIFIER + (tableProps.autoPageLineWeight ? tableProps.autoPageLineWeight : 0))) /\n                    100),\n                text: [],\n                options: cell.options,\n            };\n            // E-1: Exempt cells with `rowspan` from increasing lineHeight (or we could create a new slide when unecessary!)\n            if (newCell.options.rowspan)\n                newCell._lineHeight = 0;\n            // E-2: The parseTextToLines method uses `autoPageCharWeight`, so inherit from table options\n            newCell.options.autoPageCharWeight = tableProps.autoPageCharWeight ? tableProps.autoPageCharWeight : null;\n            // E-3: **MAIN** Parse cell contents into lines based upon col width, font, etc\n            let totalColW = tableProps.colW[iCell];\n            if (cell.options.colspan && Array.isArray(tableProps.colW)) {\n                totalColW = tableProps.colW.filter((_cell, idx) => idx >= iCell && idx < idx + cell.options.colspan).reduce((prev, curr) => prev + curr);\n            }\n            // E-4: Create lines based upon available column width\n            newCell._lines = parseTextToLines(cell, totalColW);\n            // E-5: Add cell to array\n            rowCellLines.push(newCell);\n        });\n        /** E: --==[[ PAGE DATA SET ]]==--\n         * Add text one-line-a-time to this row's cells until: lines are exhausted OR table height limit is hit\n         *\n         * Design:\n         * - Building cells L-to-R/loop style wont work as one could be 100 lines and another 1 line\n         * - Therefore, build the whole row, one-line-at-a-time, across each table columns\n         * - Then, when the vertical size limit is hit is by any of the cells, make a new slide and continue adding any remaining lines\n         *\n         * Implementation:\n         * - `rowCellLines` is an array of cells, one for each column in the table, with each cell containing an array of lines\n         *\n         * Sample Data:\n         * - `rowCellLines` ..: [ TableCell, TableCell, TableCell ]\n         * - `TableCell` .....: { _type: 'tablecell', _lines: TableCell[], _lineHeight: 10 }\n         * - `_lines` ........: [ {_type: 'tablecell', text: 'cell-1,line-1', options: {…}}, {_type: 'tablecell', text: 'cell-1,line-2', options: {…}} }\n         * - `_lines` is TableCell[] (the 1-N words in the line)\n         * {\n         *    _lines: [{ text:'cell-1,line-1' }, { text:'cell-1,line-2' }],                                                     // TOTAL-CELL-HEIGHT = 2\n         *    _lines: [{ text:'cell-2,line-1' }, { text:'cell-2,line-2' }],                                                     // TOTAL-CELL-HEIGHT = 2\n         *    _lines: [{ text:'cell-3,line-1' }, { text:'cell-3,line-2' }, { text:'cell-3,line-3' }, { text:'cell-3,line-4' }], // TOTAL-CELL-HEIGHT = 4\n         * }\n         *\n         * Example: 2 rows, with the firstrow overflowing onto a new slide\n         * SLIDE 1:\n         *  |--------|--------|--------|--------|\n         *  | line-1 | line-1 | line-1 | line-1 |\n         *  |        |        | line-2 |        |\n         *  |        |        | line-3 |        |\n         *  |--------|--------|--------|--------|\n         *\n         * SLIDE 2:\n         *  |--------|--------|--------|--------|\n         *  |        |        | line-4 |        |\n         *  |--------|--------|--------|--------|\n         *  | line-1 | line-1 | line-1 | line-1 |\n         *  |--------|--------|--------|--------|\n         */\n        if (tableProps.verbose)\n            console.log(`\\n| SLIDE [${tableRowSlides.length}]: ROW [${iRow}]: START...`);\n        let currCellIdx = 0;\n        let emuLineMaxH = 0;\n        let isDone = false;\n        while (!isDone) {\n            const srcCell = rowCellLines[currCellIdx];\n            let tgtCell = currTableRow[currCellIdx]; // NOTE: may be redefined below (a new row may be created, thus changing this value)\n            // 1: calc emuLineMaxH\n            rowCellLines.forEach(cell => {\n                if (cell._lineHeight >= emuLineMaxH)\n                    emuLineMaxH = cell._lineHeight;\n            });\n            // 2: create a new slide if there is insufficient room for the current row\n            if (emuTabCurrH + emuLineMaxH > emuSlideTabH) {\n                if (tableProps.verbose) {\n                    console.log('\\n|-----------------------------------------------------------------------|');\n                    // prettier-ignore\n                    console.log(`|-- NEW SLIDE CREATED (currTabH+currLineH > maxH) => ${(emuTabCurrH / EMU).toFixed(2)} + ${(srcCell._lineHeight / EMU).toFixed(2)} > ${emuSlideTabH / EMU}`);\n                    console.log('|-----------------------------------------------------------------------|\\n\\n');\n                }\n                // A: add current row slide or it will be lost (only if it has rows and text)\n                if (currTableRow.length > 0 && currTableRow.map(cell => cell.text.length).reduce((p, n) => p + n) > 0)\n                    newTableRowSlide.rows.push(currTableRow);\n                // B: add current slide to Slides array\n                tableRowSlides.push(newTableRowSlide);\n                // C: reset working/curr slide to hold rows as they're created\n                const newRows = [];\n                newTableRowSlide = { rows: newRows };\n                // D: reset working/curr row\n                currTableRow = [];\n                row.forEach(cell => currTableRow.push({ _type: SLIDE_OBJECT_TYPES.tablecell, text: [], options: cell.options }));\n                // E: Calc usable vertical space/table height now as we may still be in the same row and code above (\"C: Calc usable vertical space/table height.\") calc may now be invalid\n                calcSlideTabH();\n                emuTabCurrH += maxCellMarTopEmu + maxCellMarBtmEmu; // Start row height with margins\n                if (tableProps.verbose)\n                    console.log(`| SLIDE [${tableRowSlides.length}]: emuSlideTabH ...... = ${(emuSlideTabH / EMU).toFixed(1)} `);\n                // F: reset current table height for this new Slide\n                emuTabCurrH = 0;\n                // G: handle repeat headers option /or/ Add new empty row to continue current lines into\n                if ((tableProps.addHeaderToEach || tableProps.autoPageRepeatHeader) && tableProps._arrObjTabHeadRows) {\n                    tableProps._arrObjTabHeadRows.forEach(row => {\n                        const newHeadRow = [];\n                        let maxLineHeight = 0;\n                        row.forEach(cell => {\n                            newHeadRow.push(cell);\n                            if (cell._lineHeight > maxLineHeight)\n                                maxLineHeight = cell._lineHeight;\n                        });\n                        newTableRowSlide.rows.push(newHeadRow);\n                        emuTabCurrH += maxLineHeight; // TODO: what about margins? dont we need to include cell margin in line height?\n                    });\n                }\n                // WIP: NEW: TEST THIS!!\n                tgtCell = currTableRow[currCellIdx];\n            }\n            // 3: set array of words that comprise this line\n            const currLine = srcCell._lines.shift();\n            // 4: create new line by adding all words from curr line (or add empty if there are no words to avoid \"needs repair\" issue triggered when cells have null content)\n            if (Array.isArray(tgtCell.text)) {\n                if (currLine)\n                    tgtCell.text = tgtCell.text.concat(currLine);\n                else if (tgtCell.text.length === 0)\n                    tgtCell.text = tgtCell.text.concat({ _type: SLIDE_OBJECT_TYPES.tablecell, text: '' });\n                // IMPORTANT: ^^^ add empty if there are no words to avoid \"needs repair\" issue triggered when cells have null content\n            }\n            // 5: increase table height by the curr line height (if we're on the last column)\n            if (currCellIdx === rowCellLines.length - 1)\n                emuTabCurrH += emuLineMaxH;\n            // 6: advance column/cell index (or circle back to first one to continue adding lines)\n            currCellIdx = currCellIdx < rowCellLines.length - 1 ? currCellIdx + 1 : 0;\n            // 7: WIP: done?\n            const brent = rowCellLines.map(cell => cell._lines.length).reduce((prev, next) => prev + next);\n            if (brent === 0)\n                isDone = true;\n        }\n        // F: Flush/capture row buffer before it resets at the top of this loop\n        if (currTableRow.length > 0)\n            newTableRowSlide.rows.push(currTableRow);\n        if (tableProps.verbose) {\n            console.log(`- SLIDE [${tableRowSlides.length}]: ROW [${iRow}]: ...COMPLETE ...... emuTabCurrH = ${(emuTabCurrH / EMU).toFixed(2)} ( emuSlideTabH = ${(emuSlideTabH / EMU).toFixed(2)} )`);\n        }\n    });\n    // STEP 7: Flush buffer / add final slide\n    tableRowSlides.push(newTableRowSlide);\n    if (tableProps.verbose) {\n        console.log('\\n|================================================|');\n        console.log(`| FINAL: tableRowSlides.length = ${tableRowSlides.length}`);\n        tableRowSlides.forEach(slide => console.log(slide));\n        console.log('|================================================|\\n\\n');\n    }\n    // LAST:\n    return tableRowSlides;\n}\n/**\n * Reproduces an HTML table as a PowerPoint table - including column widths, style, etc. - creates 1 or more slides as needed\n * @param {PptxGenJS} pptx - pptxgenjs instance\n * @param {string} tabEleId - HTMLElementID of the table\n * @param {ITableToSlidesOpts} options - array of options (e.g.: tabsize)\n * @param {SlideLayout} masterSlide - masterSlide\n */\nfunction genTableToSlides(pptx, tabEleId, options = {}, masterSlide) {\n    const opts = options || {};\n    opts.slideMargin = opts.slideMargin || opts.slideMargin === 0 ? opts.slideMargin : 0.5;\n    let emuSlideTabW = opts.w || pptx.presLayout.width;\n    const arrObjTabHeadRows = [];\n    const arrObjTabBodyRows = [];\n    const arrObjTabFootRows = [];\n    const arrColW = [];\n    const arrTabColW = [];\n    let arrInchMargins = [0.5, 0.5, 0.5, 0.5]; // TRBL-style\n    let intTabW = 0;\n    // REALITY-CHECK:\n    if (!document.getElementById(tabEleId))\n        throw new Error('tableToSlides: Table ID \"' + tabEleId + '\" does not exist!');\n    // STEP 1: Set margins\n    if (masterSlide === null || masterSlide === void 0 ? void 0 : masterSlide._margin) {\n        if (Array.isArray(masterSlide._margin))\n            arrInchMargins = masterSlide._margin;\n        else if (!isNaN(masterSlide._margin))\n            arrInchMargins = [masterSlide._margin, masterSlide._margin, masterSlide._margin, masterSlide._margin];\n        opts.slideMargin = arrInchMargins;\n    }\n    else if (opts === null || opts === void 0 ? void 0 : opts.slideMargin) {\n        if (Array.isArray(opts.slideMargin))\n            arrInchMargins = opts.slideMargin;\n        else if (!isNaN(opts.slideMargin))\n            arrInchMargins = [opts.slideMargin, opts.slideMargin, opts.slideMargin, opts.slideMargin];\n    }\n    emuSlideTabW = (opts.w ? inch2Emu(opts.w) : pptx.presLayout.width) - inch2Emu(arrInchMargins[1] + arrInchMargins[3]);\n    if (opts.verbose) {\n        console.log('[[VERBOSE MODE]]');\n        console.log('|-- `tableToSlides` ----------------------------------------------------|');\n        console.log(`| tableProps.h .................................... = ${opts.h}`);\n        console.log(`| tableProps.w .................................... = ${opts.w}`);\n        console.log(`| pptx.presLayout.width ........................... = ${(pptx.presLayout.width / EMU).toFixed(1)}`);\n        console.log(`| pptx.presLayout.height .......................... = ${(pptx.presLayout.height / EMU).toFixed(1)}`);\n        console.log(`| emuSlideTabW .................................... = ${(emuSlideTabW / EMU).toFixed(1)}`);\n    }\n    // STEP 2: Grab table col widths - just find the first availble row, either thead/tbody/tfoot, others may have colspans, who cares, we only need col widths from 1\n    let firstRowCells = document.querySelectorAll(`#${tabEleId} tr:first-child th`);\n    if (firstRowCells.length === 0)\n        firstRowCells = document.querySelectorAll(`#${tabEleId} tr:first-child td`);\n    firstRowCells.forEach((cellEle) => {\n        const cell = cellEle;\n        if (cell.getAttribute('colspan')) {\n            // Guesstimate (divide evenly) col widths\n            // NOTE: both j$query and vanilla selectors return {0} when table is not visible)\n            for (let idxc = 0; idxc < Number(cell.getAttribute('colspan')); idxc++) {\n                arrTabColW.push(Math.round(cell.offsetWidth / Number(cell.getAttribute('colspan'))));\n            }\n        }\n        else {\n            arrTabColW.push(cell.offsetWidth);\n        }\n    });\n    arrTabColW.forEach(colW => {\n        intTabW += colW;\n    });\n    // STEP 3: Calc/Set column widths by using same column width percent from HTML table\n    arrTabColW.forEach((colW, idxW) => {\n        const intCalcWidth = Number(((Number(emuSlideTabW) * ((colW / intTabW) * 100)) / 100 / EMU).toFixed(2));\n        let intMinWidth = 0;\n        const colSelectorMin = document.querySelector(`#${tabEleId} thead tr:first-child th:nth-child(${idxW + 1})`);\n        if (colSelectorMin)\n            intMinWidth = Number(colSelectorMin.getAttribute('data-pptx-min-width'));\n        const colSelectorSet = document.querySelector(`#${tabEleId} thead tr:first-child th:nth-child(${idxW + 1})`);\n        if (colSelectorSet)\n            intMinWidth = Number(colSelectorSet.getAttribute('data-pptx-width'));\n        arrColW.push((intMinWidth > intCalcWidth ? intMinWidth : intCalcWidth));\n    });\n    if (opts.verbose) {\n        console.log(`| arrColW ......................................... = [${arrColW.join(', ')}]`);\n    }\n    // STEP 4: Iterate over each table element and create data arrays (text and opts)\n    // NOTE: We create 3 arrays instead of one so we can loop over body then show header/footer rows on first and last page\n    const tableParts = ['thead', 'tbody', 'tfoot'];\n    tableParts.forEach(part => {\n        document.querySelectorAll(`#${tabEleId} ${part} tr`).forEach((row) => {\n            const htmlRow = row;\n            const arrObjTabCells = [];\n            Array.from(htmlRow.cells).forEach(cell => {\n                // A: Get RGB text/bkgd colors\n                const arrRGB1 = window.getComputedStyle(cell).getPropertyValue('color').replace(/\\s+/gi, '').replace('rgba(', '').replace('rgb(', '').replace(')', '').split(',');\n                let arrRGB2 = window\n                    .getComputedStyle(cell)\n                    .getPropertyValue('background-color')\n                    .replace(/\\s+/gi, '')\n                    .replace('rgba(', '')\n                    .replace('rgb(', '')\n                    .replace(')', '')\n                    .split(',');\n                if (\n                // NOTE: (ISSUE#57): Default for unstyled tables is black bkgd, so use white instead\n                window.getComputedStyle(cell).getPropertyValue('background-color') === 'rgba(0, 0, 0, 0)' ||\n                    window.getComputedStyle(cell).getPropertyValue('transparent')) {\n                    arrRGB2 = ['255', '255', '255'];\n                }\n                // B: Create option object\n                const cellOpts = {\n                    align: null,\n                    bold: !!(window.getComputedStyle(cell).getPropertyValue('font-weight') === 'bold' ||\n                        Number(window.getComputedStyle(cell).getPropertyValue('font-weight')) >= 500),\n                    border: null,\n                    color: rgbToHex(Number(arrRGB1[0]), Number(arrRGB1[1]), Number(arrRGB1[2])),\n                    fill: { color: rgbToHex(Number(arrRGB2[0]), Number(arrRGB2[1]), Number(arrRGB2[2])) },\n                    fontFace: (window.getComputedStyle(cell).getPropertyValue('font-family') || '').split(',')[0].replace(/\"/g, '').replace('inherit', '').replace('initial', '') ||\n                        null,\n                    fontSize: Number(window.getComputedStyle(cell).getPropertyValue('font-size').replace(/[a-z]/gi, '')),\n                    margin: null,\n                    colspan: Number(cell.getAttribute('colspan')) || null,\n                    rowspan: Number(cell.getAttribute('rowspan')) || null,\n                    valign: null,\n                };\n                if (['left', 'center', 'right', 'start', 'end'].includes(window.getComputedStyle(cell).getPropertyValue('text-align'))) {\n                    const align = window.getComputedStyle(cell).getPropertyValue('text-align').replace('start', 'left').replace('end', 'right');\n                    cellOpts.align = align === 'center' ? 'center' : align === 'left' ? 'left' : align === 'right' ? 'right' : null;\n                }\n                if (['top', 'middle', 'bottom'].includes(window.getComputedStyle(cell).getPropertyValue('vertical-align'))) {\n                    const valign = window.getComputedStyle(cell).getPropertyValue('vertical-align');\n                    cellOpts.valign = valign === 'top' ? 'top' : valign === 'middle' ? 'middle' : valign === 'bottom' ? 'bottom' : null;\n                }\n                // C: Add padding [margin] (if any)\n                // NOTE: Margins translate: px->pt 1:1 (e.g.: a 20px padded cell looks the same in PPTX as 20pt Text Inset/Padding)\n                if (window.getComputedStyle(cell).getPropertyValue('padding-left')) {\n                    cellOpts.margin = [0, 0, 0, 0];\n                    const sidesPad = ['padding-top', 'padding-right', 'padding-bottom', 'padding-left'];\n                    sidesPad.forEach((val, idxs) => {\n                        cellOpts.margin[idxs] = Math.round(Number(window.getComputedStyle(cell).getPropertyValue(val).replace(/\\D/gi, '')));\n                    });\n                }\n                // D: Add border (if any)\n                if (window.getComputedStyle(cell).getPropertyValue('border-top-width') ||\n                    window.getComputedStyle(cell).getPropertyValue('border-right-width') ||\n                    window.getComputedStyle(cell).getPropertyValue('border-bottom-width') ||\n                    window.getComputedStyle(cell).getPropertyValue('border-left-width')) {\n                    cellOpts.border = [null, null, null, null];\n                    const sidesBor = ['top', 'right', 'bottom', 'left'];\n                    sidesBor.forEach((val, idxb) => {\n                        const intBorderW = Math.round(Number(window\n                            .getComputedStyle(cell)\n                            .getPropertyValue('border-' + val + '-width')\n                            .replace('px', '')));\n                        let arrRGB = [];\n                        arrRGB = window\n                            .getComputedStyle(cell)\n                            .getPropertyValue('border-' + val + '-color')\n                            .replace(/\\s+/gi, '')\n                            .replace('rgba(', '')\n                            .replace('rgb(', '')\n                            .replace(')', '')\n                            .split(',');\n                        const strBorderC = rgbToHex(Number(arrRGB[0]), Number(arrRGB[1]), Number(arrRGB[2]));\n                        cellOpts.border[idxb] = { pt: intBorderW, color: strBorderC };\n                    });\n                }\n                // LAST: Add cell\n                arrObjTabCells.push({\n                    _type: SLIDE_OBJECT_TYPES.tablecell,\n                    text: cell.innerText, // `innerText` returns <br> as \"\\n\", so linebreak etc. work later!\n                    options: cellOpts,\n                });\n            });\n            switch (part) {\n                case 'thead':\n                    arrObjTabHeadRows.push(arrObjTabCells);\n                    break;\n                case 'tbody':\n                    arrObjTabBodyRows.push(arrObjTabCells);\n                    break;\n                case 'tfoot':\n                    arrObjTabFootRows.push(arrObjTabCells);\n                    break;\n                default:\n                    console.log(`table parsing: unexpected table part: ${part}`);\n                    break;\n            }\n        });\n    });\n    // STEP 5: Break table into Slides as needed\n    // Pass head-rows as there is an option to add to each table and the parse func needs this data to fulfill that option\n    opts._arrObjTabHeadRows = arrObjTabHeadRows || null;\n    opts.colW = arrColW;\n    getSlidesForTableRows([...arrObjTabHeadRows, ...arrObjTabBodyRows, ...arrObjTabFootRows], opts, pptx.presLayout, masterSlide).forEach((slide, idxTr) => {\n        // A: Create new Slide\n        const newSlide = pptx.addSlide({ masterName: opts.masterSlideName || null });\n        // B: DESIGN: Reset `y` to startY or margin after first Slide (ISSUE#43, ISSUE#47, ISSUE#48)\n        if (idxTr === 0)\n            opts.y = opts.y || arrInchMargins[0];\n        if (idxTr > 0)\n            opts.y = opts.autoPageSlideStartY || opts.newSlideStartY || arrInchMargins[0];\n        if (opts.verbose)\n            console.log(`| opts.autoPageSlideStartY: ${opts.autoPageSlideStartY} / arrInchMargins[0]: ${arrInchMargins[0]} => opts.y = ${opts.y}`);\n        // C: Add table to Slide\n        newSlide.addTable(slide.rows, { x: opts.x || arrInchMargins[3], y: opts.y, w: Number(emuSlideTabW) / EMU, colW: arrColW, autoPage: false });\n        // D: Add any additional objects\n        if (opts.addImage) {\n            opts.addImage.options = opts.addImage.options || {};\n            if (!opts.addImage.image || (!opts.addImage.image.path && !opts.addImage.image.data)) {\n                console.warn('Warning: tableToSlides.addImage requires either `path` or `data`');\n            }\n            else {\n                newSlide.addImage({\n                    path: opts.addImage.image.path,\n                    data: opts.addImage.image.data,\n                    x: opts.addImage.options.x,\n                    y: opts.addImage.options.y,\n                    w: opts.addImage.options.w,\n                    h: opts.addImage.options.h,\n                });\n            }\n        }\n        if (opts.addShape)\n            newSlide.addShape(opts.addShape.shapeName, opts.addShape.options || {});\n        if (opts.addTable)\n            newSlide.addTable(opts.addTable.rows, opts.addTable.options || {});\n        if (opts.addText)\n            newSlide.addText(opts.addText.text, opts.addText.options || {});\n    });\n}\n\n/**\n * PptxGenJS: Slide Object Generators\n */\n/** counter for included charts (used for index in their filenames) */\nlet _chartCounter = 0;\n/**\n * Transforms a slide definition to a slide object that is then passed to the XML transformation process.\n * @param {SlideMasterProps} props - slide definition\n * @param {PresSlide|SlideLayout} target - empty slide object that should be updated by the passed definition\n */\nfunction createSlideMaster(props, target) {\n    // STEP 1: Add background if either the slide or layout has background props\n    // if (props.background || target.background) addBackgroundDefinition(props.background, target)\n    if (props.bkgd)\n        target.bkgd = props.bkgd; // DEPRECATED: (remove in v4.0.0)\n    // STEP 2: Add all Slide Master objects in the order they were given\n    if (props.objects && Array.isArray(props.objects) && props.objects.length > 0) {\n        props.objects.forEach((object, idx) => {\n            const key = Object.keys(object)[0];\n            const tgt = target;\n            if (MASTER_OBJECTS[key] && key === 'chart')\n                addChartDefinition(tgt, object[key].type, object[key].data, object[key].opts);\n            else if (MASTER_OBJECTS[key] && key === 'image')\n                addImageDefinition(tgt, object[key]);\n            else if (MASTER_OBJECTS[key] && key === 'line')\n                addShapeDefinition(tgt, SHAPE_TYPE.LINE, object[key]);\n            else if (MASTER_OBJECTS[key] && key === 'rect')\n                addShapeDefinition(tgt, SHAPE_TYPE.RECTANGLE, object[key]);\n            else if (MASTER_OBJECTS[key] && key === 'text')\n                addTextDefinition(tgt, [{ text: object[key].text }], object[key].options, false);\n            else if (MASTER_OBJECTS[key] && key === 'placeholder') {\n                // TODO: 20180820: Check for existing `name`?\n                object[key].options.placeholder = object[key].options.name;\n                delete object[key].options.name; // remap name for earier handling internally\n                object[key].options._placeholderType = object[key].options.type;\n                delete object[key].options.type; // remap name for earier handling internally\n                object[key].options._placeholderIdx = 100 + idx;\n                addTextDefinition(tgt, [{ text: object[key].text }], object[key].options, true);\n                // TODO: ISSUE#599 - only text is suported now (add more below)\n                // else if (object[key].image) addImageDefinition(tgt, object[key].image)\n                /* 20200120: So... image placeholders go into the \"slideLayoutN.xml\" file and addImage doesnt do this yet...\n                    <p:sp>\n                  <p:nvSpPr>\n                    <p:cNvPr id=\"7\" name=\"Picture Placeholder 6\">\n                      <a:extLst>\n                        <a:ext uri=\"{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}\">\n                          <a16:creationId xmlns:a16=\"http://schemas.microsoft.com/office/drawing/2014/main\" id=\"{CE1AE45D-8641-0F4F-BDB5-080E69CCB034}\"/>\n                        </a:ext>\n                      </a:extLst>\n                    </p:cNvPr>\n                    <p:cNvSpPr>\n                */\n            }\n        });\n    }\n    // STEP 3: Add Slide Numbers (NOTE: Do this last so numbers are not covered by objects!)\n    if (props.slideNumber && typeof props.slideNumber === 'object')\n        target._slideNumberProps = props.slideNumber;\n}\n/**\n * Generate the chart based on input data.\n * OOXML Chart Spec: ISO/IEC 29500-1:2016(E)\n *\n * @param {CHART_NAME | IChartMulti[]} `type` should belong to: 'column', 'pie'\n * @param {[]} `data` a JSON object with follow the following format\n * @param {IChartOptsLib} `opt` chart options\n * @param {PresSlide} `target` slide object that the chart will be added to\n * @return {object} chart object\n * {\n *    title: 'eSurvey chart',\n *    data: [\n *        {\n *            name: 'Income',\n *            labels: ['2005', '2006', '2007', '2008', '2009'],\n *            values: [23.5, 26.2, 30.1, 29.5, 24.6]\n *        },\n *        {\n *            name: 'Expense',\n *            labels: ['2005', '2006', '2007', '2008', '2009'],\n *            values: [18.1, 22.8, 23.9, 25.1, 25]\n *        }\n *    ]\n * }\n */\nfunction addChartDefinition(target, type, data, opt) {\n    var _a;\n    function correctGridLineOptions(glOpts) {\n        if (!glOpts || glOpts.style === 'none')\n            return;\n        if (glOpts.size !== undefined && (isNaN(Number(glOpts.size)) || glOpts.size <= 0)) {\n            console.warn('Warning: chart.gridLine.size must be greater than 0.');\n            delete glOpts.size; // delete prop to used defaults\n        }\n        if (glOpts.style && !['solid', 'dash', 'dot'].includes(glOpts.style)) {\n            console.warn('Warning: chart.gridLine.style options: `solid`, `dash`, `dot`.');\n            delete glOpts.style;\n        }\n        if (glOpts.cap && !['flat', 'square', 'round'].includes(glOpts.cap)) {\n            console.warn('Warning: chart.gridLine.cap options: `flat`, `square`, `round`.');\n            delete glOpts.cap;\n        }\n    }\n    const chartId = ++_chartCounter;\n    const resultObject = {\n        _type: null,\n        text: null,\n        options: null,\n        chartRid: null,\n    };\n    // DESIGN: `type` can an object (ex: `pptx.charts.DOUGHNUT`) or an array of chart objects\n    // EX: addChartDefinition([ { type:pptx.charts.BAR, data:{name:'', labels:[], values[]} }, {<etc>} ])\n    // Multi-Type Charts\n    let tmpOpt = null;\n    let tmpData = [];\n    if (Array.isArray(type)) {\n        // For multi-type charts there needs to be data for each type,\n        // as well as a single data source for non-series operations.\n        // The data is indexed below to keep the data in order when segmented\n        // into types.\n        type.forEach(obj => {\n            tmpData = tmpData.concat(obj.data);\n        });\n        tmpOpt = data || opt;\n    }\n    else {\n        tmpData = data;\n        tmpOpt = opt;\n    }\n    tmpData.forEach((item, i) => {\n        item._dataIndex = i;\n        // Converts the 'labels' array from string[] to string[][] (or the respective primitive type), if needed\n        if (item.labels !== undefined && !Array.isArray(item.labels[0])) {\n            item.labels = [item.labels];\n        }\n    });\n    const options = tmpOpt && typeof tmpOpt === 'object' ? tmpOpt : {};\n    // STEP 1: TODO: check for reqd fields, correct type, etc\n    // `type` exists in CHART_TYPE\n    // Array.isArray(data)\n    /*\n        if ( Array.isArray(rel.data) && rel.data.length > 0 && typeof rel.data[0] === 'object'\n            && rel.data[0].labels && Array.isArray(rel.data[0].labels)\n            && rel.data[0].values && Array.isArray(rel.data[0].values) ) {\n            obj = rel.data[0];\n        }\n        else {\n            console.warn(\"USAGE: addChart( 'pie', [ {name:'Sales', labels:['Jan','Feb'], values:[10,20]} ], {x:1, y:1} )\");\n            return;\n        }\n        */\n    // STEP 2: Set default options/decode user options\n    // A: Core\n    options._type = type;\n    options.x = typeof options.x !== 'undefined' && options.x != null && !isNaN(Number(options.x)) ? options.x : 1;\n    options.y = typeof options.y !== 'undefined' && options.y != null && !isNaN(Number(options.y)) ? options.y : 1;\n    options.w = options.w || '50%';\n    options.h = options.h || '50%';\n    options.objectName = options.objectName\n        ? encodeXmlEntities(options.objectName)\n        : `Chart ${target._slideObjects.filter(obj => obj._type === SLIDE_OBJECT_TYPES.chart).length}`;\n    // B: Options: misc\n    if (!['bar', 'col'].includes(options.barDir || ''))\n        options.barDir = 'col';\n    // barGrouping: \"21.2.3.17 ST_Grouping (Grouping)\"\n    // barGrouping must be handled before data label validation as it can affect valid label positioning\n    if (options._type === CHART_TYPE.AREA) {\n        if (!['stacked', 'standard', 'percentStacked'].includes(options.barGrouping || ''))\n            options.barGrouping = 'standard';\n    }\n    if (options._type === CHART_TYPE.BAR) {\n        if (!['clustered', 'stacked', 'percentStacked'].includes(options.barGrouping || ''))\n            options.barGrouping = 'clustered';\n    }\n    if (options._type === CHART_TYPE.BAR3D) {\n        if (!['clustered', 'stacked', 'standard', 'percentStacked'].includes(options.barGrouping || ''))\n            options.barGrouping = 'standard';\n    }\n    if ((_a = options.barGrouping) === null || _a === void 0 ? void 0 : _a.includes('tacked')) {\n        if (!options.barGapWidthPct)\n            options.barGapWidthPct = 50;\n    }\n    // Clean up and validate data label positions\n    // REFERENCE: https://docs.microsoft.com/en-us/openspecs/office_standards/ms-oi29500/e2b1697c-7adc-463d-9081-3daef72f656f?redirectedfrom=MSDN\n    if (options.dataLabelPosition) {\n        if (options._type === CHART_TYPE.AREA || options._type === CHART_TYPE.BAR3D || options._type === CHART_TYPE.DOUGHNUT || options._type === CHART_TYPE.RADAR) {\n            delete options.dataLabelPosition;\n        }\n        if (options._type === CHART_TYPE.PIE) {\n            if (!['bestFit', 'ctr', 'inEnd', 'outEnd'].includes(options.dataLabelPosition))\n                delete options.dataLabelPosition;\n        }\n        if (options._type === CHART_TYPE.BUBBLE || options._type === CHART_TYPE.BUBBLE3D || options._type === CHART_TYPE.LINE || options._type === CHART_TYPE.SCATTER) {\n            if (!['b', 'ctr', 'l', 'r', 't'].includes(options.dataLabelPosition))\n                delete options.dataLabelPosition;\n        }\n        if (options._type === CHART_TYPE.BAR) {\n            if (!['stacked', 'percentStacked'].includes(options.barGrouping || '')) {\n                if (!['ctr', 'inBase', 'inEnd'].includes(options.dataLabelPosition))\n                    delete options.dataLabelPosition;\n            }\n            if (!['clustered'].includes(options.barGrouping || '')) {\n                if (!['ctr', 'inBase', 'inEnd', 'outEnd'].includes(options.dataLabelPosition))\n                    delete options.dataLabelPosition;\n            }\n        }\n    }\n    options.dataLabelBkgrdColors = options.dataLabelBkgrdColors || !options.dataLabelBkgrdColors ? options.dataLabelBkgrdColors : false;\n    if (!['b', 'l', 'r', 't', 'tr'].includes(options.legendPos || ''))\n        options.legendPos = 'r';\n    // 3D bar: ST_Shape\n    if (!['cone', 'coneToMax', 'box', 'cylinder', 'pyramid', 'pyramidToMax'].includes(options.bar3DShape || ''))\n        options.bar3DShape = 'box';\n    // lineDataSymbol: http://www.datypic.com/sc/ooxml/a-val-32.html\n    // Spec has [plus,star,x] however neither PPT2013 nor PPT-Online support them\n    if (!['circle', 'dash', 'diamond', 'dot', 'none', 'square', 'triangle'].includes(options.lineDataSymbol || ''))\n        options.lineDataSymbol = 'circle';\n    if (!['gap', 'span'].includes(options.displayBlanksAs || ''))\n        options.displayBlanksAs = 'span';\n    if (!['standard', 'marker', 'filled'].includes(options.radarStyle || ''))\n        options.radarStyle = 'standard';\n    options.lineDataSymbolSize = options.lineDataSymbolSize && !isNaN(options.lineDataSymbolSize) ? options.lineDataSymbolSize : 6;\n    options.lineDataSymbolLineSize = options.lineDataSymbolLineSize && !isNaN(options.lineDataSymbolLineSize) ? valToPts(options.lineDataSymbolLineSize) : valToPts(0.75);\n    // `layout` allows the override of PPT defaults to maximize space\n    if (options.layout) {\n        ['x', 'y', 'w', 'h'].forEach(key => {\n            const val = options.layout[key];\n            if (isNaN(Number(val)) || val < 0 || val > 1) {\n                console.warn('Warning: chart.layout.' + key + ' can only be 0-1');\n                delete options.layout[key]; // remove invalid value so that default will be used\n            }\n        });\n    }\n    // Set gridline defaults\n    options.catGridLine = options.catGridLine || (options._type === CHART_TYPE.SCATTER ? { color: 'D9D9D9', size: 1 } : { style: 'none' });\n    options.valGridLine = options.valGridLine || (options._type === CHART_TYPE.SCATTER ? { color: 'D9D9D9', size: 1 } : {});\n    options.serGridLine = options.serGridLine || (options._type === CHART_TYPE.SCATTER ? { color: 'D9D9D9', size: 1 } : { style: 'none' });\n    correctGridLineOptions(options.catGridLine);\n    correctGridLineOptions(options.valGridLine);\n    correctGridLineOptions(options.serGridLine);\n    correctShadowOptions(options.shadow);\n    // C: Options: plotArea\n    options.showDataTable = options.showDataTable || !options.showDataTable ? options.showDataTable : false;\n    options.showDataTableHorzBorder = options.showDataTableHorzBorder || !options.showDataTableHorzBorder ? options.showDataTableHorzBorder : true;\n    options.showDataTableVertBorder = options.showDataTableVertBorder || !options.showDataTableVertBorder ? options.showDataTableVertBorder : true;\n    options.showDataTableOutline = options.showDataTableOutline || !options.showDataTableOutline ? options.showDataTableOutline : true;\n    options.showDataTableKeys = options.showDataTableKeys || !options.showDataTableKeys ? options.showDataTableKeys : true;\n    options.showLabel = options.showLabel || !options.showLabel ? options.showLabel : false;\n    options.showLegend = options.showLegend || !options.showLegend ? options.showLegend : false;\n    options.showPercent = options.showPercent || !options.showPercent ? options.showPercent : true;\n    options.showTitle = options.showTitle || !options.showTitle ? options.showTitle : false;\n    options.showValue = options.showValue || !options.showValue ? options.showValue : false;\n    options.showLeaderLines = options.showLeaderLines || !options.showLeaderLines ? options.showLeaderLines : false;\n    options.catAxisLineShow = typeof options.catAxisLineShow !== 'undefined' ? options.catAxisLineShow : true;\n    options.valAxisLineShow = typeof options.valAxisLineShow !== 'undefined' ? options.valAxisLineShow : true;\n    options.serAxisLineShow = typeof options.serAxisLineShow !== 'undefined' ? options.serAxisLineShow : true;\n    options.v3DRotX = !isNaN(options.v3DRotX) && options.v3DRotX >= -90 && options.v3DRotX <= 90 ? options.v3DRotX : 30;\n    options.v3DRotY = !isNaN(options.v3DRotY) && options.v3DRotY >= 0 && options.v3DRotY <= 360 ? options.v3DRotY : 30;\n    options.v3DRAngAx = options.v3DRAngAx || !options.v3DRAngAx ? options.v3DRAngAx : true;\n    options.v3DPerspective = !isNaN(options.v3DPerspective) && options.v3DPerspective >= 0 && options.v3DPerspective <= 240 ? options.v3DPerspective : 30;\n    // D: Options: chart\n    options.barGapWidthPct = !isNaN(options.barGapWidthPct) && options.barGapWidthPct >= 0 && options.barGapWidthPct <= 1000 ? options.barGapWidthPct : 150;\n    options.barGapDepthPct = !isNaN(options.barGapDepthPct) && options.barGapDepthPct >= 0 && options.barGapDepthPct <= 1000 ? options.barGapDepthPct : 150;\n    options.chartColors = Array.isArray(options.chartColors)\n        ? options.chartColors\n        : options._type === CHART_TYPE.PIE || options._type === CHART_TYPE.DOUGHNUT\n            ? PIECHART_COLORS\n            : BARCHART_COLORS;\n    options.chartColorsOpacity = options.chartColorsOpacity && !isNaN(options.chartColorsOpacity) ? options.chartColorsOpacity : null;\n    // DEPRECATED: v3.11.0 - use `plotArea.border` vvv\n    options.border = options.border && typeof options.border === 'object' ? options.border : null;\n    if (options.border && (!options.border.pt || isNaN(options.border.pt)))\n        options.border.pt = DEF_CHART_BORDER.pt;\n    if (options.border && (!options.border.color || typeof options.border.color !== 'string'))\n        options.border.color = DEF_CHART_BORDER.color;\n    // DEPRECATED: (remove above in v4.0) ^^^\n    options.plotArea = options.plotArea || {};\n    options.plotArea.border = options.plotArea.border && typeof options.plotArea.border === 'object' ? options.plotArea.border : null;\n    if (options.plotArea.border && (!options.plotArea.border.pt || isNaN(options.plotArea.border.pt)))\n        options.plotArea.border.pt = DEF_CHART_BORDER.pt;\n    if (options.plotArea.border && (!options.plotArea.border.color || typeof options.plotArea.border.color !== 'string')) {\n        options.plotArea.border.color = DEF_CHART_BORDER.color;\n    }\n    if (options.border)\n        options.plotArea.border = options.border; // @deprecated [[remove in v4.0]]\n    options.plotArea.fill = options.plotArea.fill || { color: null, transparency: null };\n    if (options.fill)\n        options.plotArea.fill.color = options.fill; // @deprecated [[remove in v4.0]]\n    //\n    options.chartArea = options.chartArea || {};\n    options.chartArea.border = options.chartArea.border && typeof options.chartArea.border === 'object' ? options.chartArea.border : null;\n    if (options.chartArea.border) {\n        options.chartArea.border = {\n            color: options.chartArea.border.color || DEF_CHART_BORDER.color,\n            pt: options.chartArea.border.pt || DEF_CHART_BORDER.pt,\n        };\n    }\n    options.chartArea.roundedCorners = typeof options.chartArea.roundedCorners === 'boolean' ? options.chartArea.roundedCorners : true;\n    //\n    options.dataBorder = options.dataBorder && typeof options.dataBorder === 'object' ? options.dataBorder : null;\n    if (options.dataBorder && (!options.dataBorder.pt || isNaN(options.dataBorder.pt)))\n        options.dataBorder.pt = 0.75;\n    if (options.dataBorder && options.dataBorder.color) {\n        const isHexColor = typeof options.dataBorder.color === 'string' && options.dataBorder.color.length === 6 && /^[0-9A-Fa-f]{6}$/.test(options.dataBorder.color);\n        const isSchemeColor = Object.values(SCHEME_COLOR_NAMES).includes(options.dataBorder.color);\n        if (!isHexColor && !isSchemeColor) {\n            options.dataBorder.color = 'F9F9F9'; // Fallback if neither hex nor scheme color\n        }\n    }\n    //\n    if (!options.dataLabelFormatCode && options._type === CHART_TYPE.SCATTER)\n        options.dataLabelFormatCode = 'General';\n    if (!options.dataLabelFormatCode && (options._type === CHART_TYPE.PIE || options._type === CHART_TYPE.DOUGHNUT)) {\n        options.dataLabelFormatCode = options.showPercent ? '0%' : 'General';\n    }\n    options.dataLabelFormatCode = options.dataLabelFormatCode && typeof options.dataLabelFormatCode === 'string' ? options.dataLabelFormatCode : '#,##0';\n    //\n    // Set default format for Scatter chart labels to custom string if not defined\n    if (!options.dataLabelFormatScatter && options._type === CHART_TYPE.SCATTER)\n        options.dataLabelFormatScatter = 'custom';\n    //\n    options.lineSize = typeof options.lineSize === 'number' ? options.lineSize : 2;\n    options.valAxisMajorUnit = typeof options.valAxisMajorUnit === 'number' ? options.valAxisMajorUnit : null;\n    if (options._type === CHART_TYPE.AREA || options._type === CHART_TYPE.BAR || options._type === CHART_TYPE.BAR3D || options._type === CHART_TYPE.LINE) {\n        options.catAxisMultiLevelLabels = !!options.catAxisMultiLevelLabels;\n    }\n    else {\n        delete options.catAxisMultiLevelLabels;\n    }\n    // STEP 4: Set props\n    resultObject._type = 'chart';\n    resultObject.options = options;\n    resultObject.chartRid = getNewRelId(target);\n    // STEP 5: Add this chart to this Slide Rels (rId/rels count spans all slides! Count all images to get next rId)\n    target._relsChart.push({\n        rId: getNewRelId(target),\n        data: tmpData,\n        opts: options,\n        type: options._type,\n        globalId: chartId,\n        fileName: `chart${chartId}.xml`,\n        Target: `/ppt/charts/chart${chartId}.xml`,\n    });\n    target._slideObjects.push(resultObject);\n    return resultObject;\n}\n/**\n * Adds an image object to a slide definition.\n * This method can be called with only two args (opt, target) - this is supposed to be the only way in future.\n * @param {ImageProps} `opt` - object containing `path`/`data`, `x`, `y`, etc.\n * @param {PresSlide} `target` - slide that the image should be added to (if not specified as the 2nd arg)\n * @note: Remote images (eg: \"http://whatev.com/blah\"/from web and/or remote server arent supported yet - we'd need to create an <img>, load it, then send to canvas\n * @see: https://stackoverflow.com/questions/164181/how-to-fetch-a-remote-image-to-display-in-a-canvas)\n */\nfunction addImageDefinition(target, opt) {\n    const newObject = {\n        _type: null,\n        text: null,\n        options: null,\n        image: null,\n        imageRid: null,\n        hyperlink: null,\n    };\n    // FIRST: Set vars for this image (object param replaces positional args in 1.1.0)\n    const intPosX = opt.x || 0;\n    const intPosY = opt.y || 0;\n    const intWidth = opt.w || 0;\n    const intHeight = opt.h || 0;\n    const sizing = opt.sizing || null;\n    const objHyperlink = opt.hyperlink || '';\n    const strImageData = opt.data || '';\n    const strImagePath = opt.path || '';\n    let imageRelId = getNewRelId(target);\n    const objectName = opt.objectName ? encodeXmlEntities(opt.objectName) : `Image ${target._slideObjects.filter(obj => obj._type === SLIDE_OBJECT_TYPES.image).length}`;\n    // REALITY-CHECK:\n    if (!strImagePath && !strImageData) {\n        console.error('ERROR: addImage() requires either \\'data\\' or \\'path\\' parameter!');\n        return null;\n    }\n    else if (strImagePath && typeof strImagePath !== 'string') {\n        console.error(`ERROR: addImage() 'path' should be a string, ex: {path:'/img/sample.png'} - you sent ${String(strImagePath)}`);\n        return null;\n    }\n    else if (strImageData && typeof strImageData !== 'string') {\n        console.error(`ERROR: addImage() 'data' should be a string, ex: {data:'image/png;base64,NMP[...]'} - you sent ${String(strImageData)}`);\n        return null;\n    }\n    else if (strImageData && typeof strImageData === 'string' && !strImageData.toLowerCase().includes('base64,')) {\n        console.error('ERROR: Image `data` value lacks a base64 header! Ex: \\'image/png;base64,NMP[...]\\')');\n        return null;\n    }\n    // STEP 1: Set extension\n    // NOTE: Split to address URLs with params (eg: `path/brent.jpg?someParam=true`)\n    let strImgExtn = (strImagePath\n        .substring(strImagePath.lastIndexOf('/') + 1)\n        .split('?')[0]\n        .split('.')\n        .pop()\n        .split('#')[0] || 'png').toLowerCase();\n    // However, pre-encoded images can be whatever mime-type they want (and good for them!)\n    if (strImageData && /image\\/(\\w+);/.exec(strImageData) && /image\\/(\\w+);/.exec(strImageData).length > 0) {\n        strImgExtn = /image\\/(\\w+);/.exec(strImageData)[1];\n    }\n    else if (strImageData === null || strImageData === void 0 ? void 0 : strImageData.toLowerCase().includes('image/svg+xml')) {\n        strImgExtn = 'svg';\n    }\n    // STEP 2: Set type/path\n    newObject._type = SLIDE_OBJECT_TYPES.image;\n    newObject.image = strImagePath || 'preencoded.png';\n    // STEP 3: Set image properties & options\n    // FIXME: Measure actual image when no intWidth/intHeight params passed\n    // ....: This is an async process: we need to make getSizeFromImage use callback, then set H/W...\n    // if ( !intWidth || !intHeight ) { var imgObj = getSizeFromImage(strImagePath);\n    newObject.options = {\n        x: intPosX || 0,\n        y: intPosY || 0,\n        w: intWidth || 1,\n        h: intHeight || 1,\n        altText: opt.altText || '',\n        rounding: typeof opt.rounding === 'boolean' ? opt.rounding : false,\n        sizing,\n        placeholder: opt.placeholder,\n        rotate: opt.rotate || 0,\n        flipV: opt.flipV || false,\n        flipH: opt.flipH || false,\n        transparency: opt.transparency || 0,\n        objectName,\n        shadow: correctShadowOptions(opt.shadow),\n    };\n    // STEP 4: Add this image to this Slide Rels (rId/rels count spans all slides! Count all images to get next rId)\n    if (strImgExtn === 'svg') {\n        // SVG files consume *TWO* rId's: (a png version and the svg image)\n        // <Relationship Id=\"rId3\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/image\" Target=\"../media/image1.png\"/>\n        // <Relationship Id=\"rId4\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/image\" Target=\"../media/image2.svg\"/>\n        target._relsMedia.push({\n            path: strImagePath || strImageData + 'png',\n            type: 'image/png',\n            extn: 'png',\n            data: strImageData || '',\n            rId: imageRelId,\n            Target: `../media/image-${target._slideNum}-${target._relsMedia.length + 1}.png`,\n            isSvgPng: true,\n            svgSize: { w: getSmartParseNumber(newObject.options.w, 'X', target._presLayout), h: getSmartParseNumber(newObject.options.h, 'Y', target._presLayout) },\n        });\n        newObject.imageRid = imageRelId;\n        target._relsMedia.push({\n            path: strImagePath || strImageData,\n            type: 'image/svg+xml',\n            extn: strImgExtn,\n            data: strImageData || '',\n            rId: imageRelId + 1,\n            Target: `../media/image-${target._slideNum}-${target._relsMedia.length + 1}.${strImgExtn}`,\n        });\n        newObject.imageRid = imageRelId + 1;\n    }\n    else {\n        // PERF: Duplicate media should reuse existing `Target` value and not create an additional copy\n        const dupeItem = target._relsMedia.filter(item => item.path && item.path === strImagePath && item.type === 'image/' + strImgExtn && !item.isDuplicate)[0];\n        target._relsMedia.push({\n            path: strImagePath || 'preencoded.' + strImgExtn,\n            type: 'image/' + strImgExtn,\n            extn: strImgExtn,\n            data: strImageData || '',\n            rId: imageRelId,\n            isDuplicate: !!(dupeItem === null || dupeItem === void 0 ? void 0 : dupeItem.Target),\n            Target: (dupeItem === null || dupeItem === void 0 ? void 0 : dupeItem.Target) ? dupeItem.Target : `../media/image-${target._slideNum}-${target._relsMedia.length + 1}.${strImgExtn}`,\n        });\n        newObject.imageRid = imageRelId;\n    }\n    // STEP 5: Hyperlink support\n    if (typeof objHyperlink === 'object') {\n        if (!objHyperlink.url && !objHyperlink.slide)\n            throw new Error('ERROR: `hyperlink` option requires either: `url` or `slide`');\n        else {\n            imageRelId++;\n            target._rels.push({\n                type: SLIDE_OBJECT_TYPES.hyperlink,\n                data: objHyperlink.slide ? 'slide' : 'dummy',\n                rId: imageRelId,\n                Target: objHyperlink.url || objHyperlink.slide.toString(),\n            });\n            objHyperlink._rId = imageRelId;\n            newObject.hyperlink = objHyperlink;\n        }\n    }\n    // STEP 6: Add object to slide\n    target._slideObjects.push(newObject);\n}\n/**\n * Adds a media object to a slide definition.\n * @param {PresSlide} `target` - slide object that the media will be added to\n * @param {MediaProps} `opt` - media options\n */\nfunction addMediaDefinition(target, opt) {\n    const intPosX = opt.x || 0;\n    const intPosY = opt.y || 0;\n    const intSizeX = opt.w || 2;\n    const intSizeY = opt.h || 2;\n    const strData = opt.data || '';\n    const strLink = opt.link || '';\n    const strPath = opt.path || '';\n    const strType = opt.type || 'audio';\n    let strExtn = '';\n    const strCover = opt.cover || IMG_PLAYBTN;\n    const objectName = opt.objectName ? encodeXmlEntities(opt.objectName) : `Media ${target._slideObjects.filter(obj => obj._type === SLIDE_OBJECT_TYPES.media).length}`;\n    const slideData = { _type: SLIDE_OBJECT_TYPES.media };\n    // STEP 1: REALITY-CHECK\n    if (!strPath && !strData && strType !== 'online') {\n        throw new Error('addMedia() error: either `data` or `path` are required!');\n    }\n    else if (strData && !strData.toLowerCase().includes('base64,')) {\n        throw new Error('addMedia() error: `data` value lacks a base64 header! Ex: \\'video/mpeg;base64,NMP[...]\\')');\n    }\n    else if (!strCover.toLowerCase().includes('base64,')) {\n        throw new Error('addMedia() error: `cover` value lacks a base64 header! Ex: \\'data:image/png;base64,iV[...]\\')');\n    }\n    // Online Video: requires `link`\n    if (strType === 'online' && !strLink) {\n        throw new Error('addMedia() error: online videos require `link` value');\n    }\n    // FIXME: 20190707\n    // strType = strData ? strData.split(';')[0].split('/')[0] : strType\n    strExtn = opt.extn || (strData ? strData.split(';')[0].split('/')[1] : strPath.split('.').pop()) || 'mp3';\n    // STEP 2: Set type, media\n    slideData.mtype = strType;\n    slideData.media = strPath || 'preencoded.mov';\n    slideData.options = {};\n    // STEP 3: Set media properties & options\n    slideData.options.x = intPosX;\n    slideData.options.y = intPosY;\n    slideData.options.w = intSizeX;\n    slideData.options.h = intSizeY;\n    slideData.options.objectName = objectName;\n    // STEP 4: Add this media to this Slide Rels (rId/rels count spans all slides! Count all media to get next rId)\n    /**\n     * NOTE:\n     * - rId starts at 2 (hence the intRels+1 below) as slideLayout.xml is rId=1!\n     *\n     * NOTE:\n     * - Audio/Video files consume *TWO* rId's:\n     * <Relationship Id=\"rId2\" Target=\"../media/media1.mov\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/video\"/>\n     * <Relationship Id=\"rId3\" Target=\"../media/media1.mov\" Type=\"http://schemas.microsoft.com/office/2007/relationships/media\"/>\n     */\n    if (strType === 'online') {\n        const relId1 = getNewRelId(target);\n        // A: Add video\n        target._relsMedia.push({\n            path: strPath || 'preencoded' + strExtn,\n            data: 'dummy',\n            type: 'online',\n            extn: strExtn,\n            rId: relId1,\n            Target: strLink,\n        });\n        slideData.mediaRid = relId1;\n        // B: Add cover (preview/overlay) image\n        target._relsMedia.push({\n            path: 'preencoded.png',\n            data: strCover,\n            type: 'image/png',\n            extn: 'png',\n            rId: getNewRelId(target),\n            Target: `../media/image-${target._slideNum}-${target._relsMedia.length + 1}.png`,\n        });\n    }\n    else {\n        // PERF: Duplicate media should reuse existing `Target` value and not create an additional copy\n        const dupeItem = target._relsMedia.filter(item => item.path && item.path === strPath && item.type === strType + '/' + strExtn && !item.isDuplicate)[0];\n        // A: \"relationships/video\"\n        const relId1 = getNewRelId(target);\n        target._relsMedia.push({\n            path: strPath || 'preencoded' + strExtn,\n            type: strType + '/' + strExtn,\n            extn: strExtn,\n            data: strData || '',\n            rId: relId1,\n            isDuplicate: !!(dupeItem === null || dupeItem === void 0 ? void 0 : dupeItem.Target),\n            Target: (dupeItem === null || dupeItem === void 0 ? void 0 : dupeItem.Target) ? dupeItem.Target : `../media/media-${target._slideNum}-${target._relsMedia.length + 1}.${strExtn}`,\n        });\n        slideData.mediaRid = relId1;\n        // B: \"relationships/media\"\n        target._relsMedia.push({\n            path: strPath || 'preencoded' + strExtn,\n            type: strType + '/' + strExtn,\n            extn: strExtn,\n            data: strData || '',\n            rId: getNewRelId(target),\n            isDuplicate: !!(dupeItem === null || dupeItem === void 0 ? void 0 : dupeItem.Target),\n            Target: (dupeItem === null || dupeItem === void 0 ? void 0 : dupeItem.Target) ? dupeItem.Target : `../media/media-${target._slideNum}-${target._relsMedia.length + 0}.${strExtn}`,\n        });\n        // C: Add cover (preview/overlay) image\n        target._relsMedia.push({\n            path: 'preencoded.png',\n            type: 'image/png',\n            extn: 'png',\n            data: strCover,\n            rId: getNewRelId(target),\n            Target: `../media/image-${target._slideNum}-${target._relsMedia.length + 1}.png`,\n        });\n    }\n    // LAST\n    target._slideObjects.push(slideData);\n}\n/**\n * Adds Notes to a slide.\n * @param {PresSlide} `target` slide object\n * @param {string} `notes`\n * @since 2.3.0\n */\nfunction addNotesDefinition(target, notes) {\n    target._slideObjects.push({\n        _type: SLIDE_OBJECT_TYPES.notes,\n        text: [{ text: notes }],\n    });\n}\n/**\n * Adds a shape object to a slide definition.\n * @param {PresSlide} target slide object that the shape should be added to\n * @param {SHAPE_NAME} shapeName shape name\n * @param {ShapeProps} opts shape options\n */\nfunction addShapeDefinition(target, shapeName, opts) {\n    const options = typeof opts === 'object' ? opts : {};\n    options.line = options.line || { type: 'none' };\n    const newObject = {\n        _type: SLIDE_OBJECT_TYPES.text,\n        shape: shapeName || SHAPE_TYPE.RECTANGLE,\n        options,\n        text: null,\n    };\n    // Reality check\n    if (!shapeName)\n        throw new Error('Missing/Invalid shape parameter! Example: `addShape(pptxgen.shapes.LINE, {x:1, y:1, w:1, h:1});`');\n    // 1: ShapeLineProps defaults\n    const newLineOpts = {\n        type: options.line.type || 'solid',\n        color: options.line.color || DEF_SHAPE_LINE_COLOR,\n        transparency: options.line.transparency || 0,\n        width: options.line.width || 1,\n        dashType: options.line.dashType || 'solid',\n        beginArrowType: options.line.beginArrowType || null,\n        endArrowType: options.line.endArrowType || null,\n    };\n    if (typeof options.line === 'object' && options.line.type !== 'none')\n        options.line = newLineOpts;\n    // 2: Set options defaults\n    options.x = options.x || (options.x === 0 ? 0 : 1);\n    options.y = options.y || (options.y === 0 ? 0 : 1);\n    options.w = options.w || (options.w === 0 ? 0 : 1);\n    options.h = options.h || (options.h === 0 ? 0 : 1);\n    options.objectName = options.objectName\n        ? encodeXmlEntities(options.objectName)\n        : `Shape ${target._slideObjects.filter(obj => obj._type === SLIDE_OBJECT_TYPES.text).length}`;\n    // 3: Handle line (lots of deprecated opts)\n    if (typeof options.line === 'string') {\n        const tmpOpts = newLineOpts;\n        tmpOpts.color = String(options.line); // @deprecated `options.line` string (was line color)\n        options.line = tmpOpts;\n    }\n    if (typeof options.lineSize === 'number')\n        options.line.width = options.lineSize; // @deprecated (part of `ShapeLineProps` now)\n    if (typeof options.lineDash === 'string')\n        options.line.dashType = options.lineDash; // @deprecated (part of `ShapeLineProps` now)\n    if (typeof options.lineHead === 'string')\n        options.line.beginArrowType = options.lineHead; // @deprecated (part of `ShapeLineProps` now)\n    if (typeof options.lineTail === 'string')\n        options.line.endArrowType = options.lineTail; // @deprecated (part of `ShapeLineProps` now)\n    // 4: Create hyperlink rels\n    createHyperlinkRels(target, newObject);\n    // LAST: Add object to slide\n    target._slideObjects.push(newObject);\n}\n/**\n * Adds a table object to a slide definition.\n * @param {PresSlide} target - slide object that the table should be added to\n * @param {TableRow[]} tableRows - table data\n * @param {TableProps} options - table options\n * @param {SlideLayout} slideLayout - Slide layout\n * @param {PresLayout} presLayout - Presentation layout\n * @param {Function} addSlide - method\n * @param {Function} getSlide - method\n */\nfunction addTableDefinition(target, tableRows, options, slideLayout, presLayout, addSlide, getSlide) {\n    const slides = [target]; // Create array of Slides as more may be added by auto-paging\n    const opt = options && typeof options === 'object' ? options : {};\n    opt.objectName = opt.objectName ? encodeXmlEntities(opt.objectName) : `Table ${target._slideObjects.filter(obj => obj._type === SLIDE_OBJECT_TYPES.table).length}`;\n    // STEP 1: REALITY-CHECK\n    {\n        // A: check for empty\n        if (tableRows === null || tableRows.length === 0 || !Array.isArray(tableRows)) {\n            throw new Error('addTable: Array expected! EX: \\'slide.addTable( [rows], {options} );\\' (https://gitbrent.github.io/PptxGenJS/docs/api-tables.html)');\n        }\n        // B: check for non-well-formatted array (ex: rows=['a','b'] instead of [['a','b']])\n        if (!tableRows[0] || !Array.isArray(tableRows[0])) {\n            throw new Error('addTable: \\'rows\\' should be an array of cells! EX: \\'slide.addTable( [ [\\'A\\'], [\\'B\\'], {text:\\'C\\',options:{align:\\'center\\'}} ] );\\' (https://gitbrent.github.io/PptxGenJS/docs/api-tables.html)');\n        }\n        // TODO: FUTURE: This is wacky and wont function right (shows .w value when there is none from demo.js?!) 20191219\n        /*\n        if (opt.w && opt.colW) {\n            console.warn('addTable: please use either `colW` or `w` - not both (table will use `colW` and ignore `w`)')\n            console.log(`${opt.w} ${opt.colW}`)\n        }\n        */\n    }\n    // STEP 2: Transform `tableRows` into well-formatted TableCell's\n    // tableRows can be object or plain text array: `[{text:'cell 1'}, {text:'cell 2', options:{color:'ff0000'}}]` | `[\"cell 1\", \"cell 2\"]`\n    const arrRows = [];\n    tableRows.forEach(row => {\n        const newRow = [];\n        if (Array.isArray(row)) {\n            row.forEach((cell) => {\n                // A:\n                const newCell = {\n                    _type: SLIDE_OBJECT_TYPES.tablecell,\n                    text: '',\n                    options: typeof cell === 'object' && cell.options ? cell.options : {},\n                };\n                // B:\n                if (typeof cell === 'string' || typeof cell === 'number')\n                    newCell.text = cell.toString();\n                else if (cell.text) {\n                    // Cell can contain complex text type, or string, or number\n                    if (typeof cell.text === 'string' || typeof cell.text === 'number')\n                        newCell.text = cell.text.toString();\n                    else if (cell.text)\n                        newCell.text = cell.text;\n                    // Capture options\n                    if (cell.options && typeof cell.options === 'object')\n                        newCell.options = cell.options;\n                }\n                // C: Set cell borders\n                newCell.options.border = newCell.options.border || opt.border || [{ type: 'none' }, { type: 'none' }, { type: 'none' }, { type: 'none' }];\n                const cellBorder = newCell.options.border;\n                // CASE 1: border interface is: BorderOptions | [BorderOptions, BorderOptions, BorderOptions, BorderOptions]\n                if (!Array.isArray(cellBorder) && typeof cellBorder === 'object')\n                    newCell.options.border = [cellBorder, cellBorder, cellBorder, cellBorder];\n                // Handle: [null, null, {type:'solid'}, null]\n                if (!newCell.options.border[0])\n                    newCell.options.border[0] = { type: 'none' };\n                if (!newCell.options.border[1])\n                    newCell.options.border[1] = { type: 'none' };\n                if (!newCell.options.border[2])\n                    newCell.options.border[2] = { type: 'none' };\n                if (!newCell.options.border[3])\n                    newCell.options.border[3] = { type: 'none' };\n                // set complete BorderOptions for all sides\n                const arrSides = [0, 1, 2, 3];\n                arrSides.forEach(idx => {\n                    newCell.options.border[idx] = {\n                        type: newCell.options.border[idx].type || DEF_CELL_BORDER.type,\n                        color: newCell.options.border[idx].color || DEF_CELL_BORDER.color,\n                        pt: typeof newCell.options.border[idx].pt === 'number' ? newCell.options.border[idx].pt : DEF_CELL_BORDER.pt,\n                    };\n                });\n                // LAST:\n                newRow.push(newCell);\n            });\n        }\n        else {\n            console.log('addTable: tableRows has a bad row. A row should be an array of cells. You provided:');\n            console.log(row);\n        }\n        arrRows.push(newRow);\n    });\n    // STEP 3: Set options\n    opt.x = getSmartParseNumber(opt.x || (opt.x === 0 ? 0 : EMU / 2), 'X', presLayout);\n    opt.y = getSmartParseNumber(opt.y || (opt.y === 0 ? 0 : EMU / 2), 'Y', presLayout);\n    if (opt.h)\n        opt.h = getSmartParseNumber(opt.h, 'Y', presLayout); // NOTE: Dont set default `h` - leaving it null triggers auto-rowH in `makeXMLSlide()`\n    opt.fontSize = opt.fontSize || DEF_FONT_SIZE;\n    opt.margin = opt.margin === 0 || opt.margin ? opt.margin : DEF_CELL_MARGIN_IN;\n    if (typeof opt.margin === 'number')\n        opt.margin = [Number(opt.margin), Number(opt.margin), Number(opt.margin), Number(opt.margin)];\n    // NOTE: dont add default color on tables with hyperlinks! (it causes any textObj's with hyperlinks to have subsequent words to be black)\n    if (JSON.stringify({ arrRows: arrRows }).indexOf('hyperlink') === -1) {\n        if (!opt.color)\n            opt.color = opt.color || DEF_FONT_COLOR; // Set default color if needed (table option > inherit from Slide > default to black)\n    }\n    if (typeof opt.border === 'string') {\n        console.warn('addTable `border` option must be an object. Ex: `{border: {type:\\'none\\'}}`');\n        opt.border = null;\n    }\n    else if (Array.isArray(opt.border)) {\n        [0, 1, 2, 3].forEach(idx => {\n            opt.border[idx] = opt.border[idx]\n                ? { type: opt.border[idx].type || DEF_CELL_BORDER.type, color: opt.border[idx].color || DEF_CELL_BORDER.color, pt: opt.border[idx].pt || DEF_CELL_BORDER.pt }\n                : { type: 'none' };\n        });\n    }\n    opt.autoPage = typeof opt.autoPage === 'boolean' ? opt.autoPage : false;\n    opt.autoPageRepeatHeader = typeof opt.autoPageRepeatHeader === 'boolean' ? opt.autoPageRepeatHeader : false;\n    opt.autoPageHeaderRows = typeof opt.autoPageHeaderRows !== 'undefined' && !isNaN(Number(opt.autoPageHeaderRows)) ? Number(opt.autoPageHeaderRows) : 1;\n    opt.autoPageLineWeight = typeof opt.autoPageLineWeight !== 'undefined' && !isNaN(Number(opt.autoPageLineWeight)) ? Number(opt.autoPageLineWeight) : 0;\n    if (opt.autoPageLineWeight) {\n        if (opt.autoPageLineWeight > 1)\n            opt.autoPageLineWeight = 1;\n        else if (opt.autoPageLineWeight < -1)\n            opt.autoPageLineWeight = -1;\n    }\n    // autoPage ^^^\n    // Set/Calc table width\n    // Get slide margins - start with default values, then adjust if master or slide margins exist\n    let arrTableMargin = DEF_SLIDE_MARGIN_IN;\n    // Case 1: Master margins\n    if (slideLayout && typeof slideLayout._margin !== 'undefined') {\n        if (Array.isArray(slideLayout._margin))\n            arrTableMargin = slideLayout._margin;\n        else if (!isNaN(Number(slideLayout._margin))) {\n            arrTableMargin = [Number(slideLayout._margin), Number(slideLayout._margin), Number(slideLayout._margin), Number(slideLayout._margin)];\n        }\n    }\n    // Case 2: Table margins\n    /* FIXME: add `_margin` option to slide options\n        else if ( addNewSlide._margin ) {\n            if ( Array.isArray(addNewSlide._margin) ) arrTableMargin = addNewSlide._margin;\n            else if ( !isNaN(Number(addNewSlide._margin)) ) arrTableMargin = [Number(addNewSlide._margin), Number(addNewSlide._margin), Number(addNewSlide._margin), Number(addNewSlide._margin)];\n        }\n    */\n    /**\n     * Calc table width depending upon what data we have - several scenarios exist (including bad data, eg: colW doesnt match col count)\n     * The API does not require a `w` value, but XML generation does, hence, code to calc a width below using colW value(s)\n     */\n    if (opt.colW) {\n        const firstRowColCnt = arrRows[0].reduce((totalLen, c) => {\n            var _a;\n            if (((_a = c === null || c === void 0 ? void 0 : c.options) === null || _a === void 0 ? void 0 : _a.colspan) && typeof c.options.colspan === 'number') {\n                totalLen += c.options.colspan;\n            }\n            else {\n                totalLen += 1;\n            }\n            return totalLen;\n        }, 0);\n        if (typeof opt.colW === 'string' || typeof opt.colW === 'number') {\n            // Ex: `colW = 3` or `colW = '3'`\n            opt.w = Math.floor(Number(opt.colW) * firstRowColCnt);\n            opt.colW = null; // IMPORTANT: Unset `colW` so table is created using `opt.w`, which will evenly divide cols\n        }\n        else if (opt.colW && Array.isArray(opt.colW) && opt.colW.length === 1 && firstRowColCnt > 1) {\n            // Ex: `colW=[3]` but with >1 cols (same as above, user is saying \"use this width for all\")\n            opt.w = Math.floor(Number(opt.colW) * firstRowColCnt);\n            opt.colW = null; // IMPORTANT: Unset `colW` so table is created using `opt.w`, which will evenly divide cols\n        }\n        else if (opt.colW && Array.isArray(opt.colW) && opt.colW.length !== firstRowColCnt) {\n            // Err: Mismatched colW and cols count\n            console.warn('addTable: mismatch: (colW.length != data.length) Therefore, defaulting to evenly distributed col widths.');\n            opt.colW = null;\n        }\n    }\n    else if (opt.w) {\n        opt.w = getSmartParseNumber(opt.w, 'X', presLayout);\n    }\n    else {\n        opt.w = Math.floor(presLayout._sizeW / EMU - arrTableMargin[1] - arrTableMargin[3]);\n    }\n    // STEP 4: Convert units to EMU now (we use different logic in makeSlide->table - smartCalc is not used)\n    if (opt.x && opt.x < 20)\n        opt.x = inch2Emu(opt.x);\n    if (opt.y && opt.y < 20)\n        opt.y = inch2Emu(opt.y);\n    if (opt.w && typeof opt.w === 'number' && opt.w < 20)\n        opt.w = inch2Emu(opt.w);\n    if (opt.h && typeof opt.h === 'number' && opt.h < 20)\n        opt.h = inch2Emu(opt.h);\n    // STEP 5: Loop over cells: transform each to ITableCell; check to see whether to unset `autoPage` while here\n    arrRows.forEach(row => {\n        row.forEach((cell, idy) => {\n            // A: Transform cell data if needed\n            /* Table rows can be an object or plain text - transform into object when needed\n                // EX:\n                var arrTabRows1 = [\n                    [ { text:'A1\\nA2', options:{rowspan:2, fill:'99FFCC'} } ]\n                    ,[ 'B2', 'C2', 'D2', 'E2' ]\n                ]\n            */\n            if (typeof cell === 'number' || typeof cell === 'string') {\n                // Grab table formatting `opts` to use here so text style/format inherits as it should\n                row[idy] = { _type: SLIDE_OBJECT_TYPES.tablecell, text: String(row[idy]), options: opt };\n            }\n            else if (typeof cell === 'object') {\n                // ARG0: `text`\n                if (typeof cell.text === 'number')\n                    row[idy].text = row[idy].text.toString();\n                else if (typeof cell.text === 'undefined' || cell.text === null)\n                    row[idy].text = '';\n                // ARG1: `options`: ensure options exists\n                row[idy].options = cell.options || {};\n                // Set type to tabelcell\n                row[idy]._type = SLIDE_OBJECT_TYPES.tablecell;\n            }\n            // B: Check for fine-grained formatting, disable auto-page when found\n            // Since genXmlTextBody already checks for text array ( text:[{},..{}] ) we're done!\n            // Text in individual cells will be formatted as they are added by calls to genXmlTextBody within table builder\n            // if (cell.text && Array.isArray(cell.text)) opt.autoPage = false\n            // TODO: FIXME: WIP: 20210807: We cant do this anymore\n        });\n    });\n    // If autoPage = true, we need to return references to newly created slides if any\n    const newAutoPagedSlides = [];\n    // STEP 6: Auto-Paging: (via {options} and used internally)\n    // (used internally by `tableToSlides()` to not engage recursion - we've already paged the table data, just add this one)\n    if (opt && !opt.autoPage) {\n        // Create hyperlink rels (IMPORTANT: Wait until table has been shredded across Slides or all rels will end-up on Slide 1!)\n        createHyperlinkRels(target, arrRows);\n        // Add slideObjects (NOTE: Use `extend` to avoid mutation)\n        target._slideObjects.push({\n            _type: SLIDE_OBJECT_TYPES.table,\n            arrTabRows: arrRows,\n            options: Object.assign({}, opt),\n        });\n    }\n    else {\n        if (opt.autoPageRepeatHeader)\n            opt._arrObjTabHeadRows = arrRows.filter((_row, idx) => idx < opt.autoPageHeaderRows);\n        // Loop over rows and create 1-N tables as needed (ISSUE#21)\n        getSlidesForTableRows(arrRows, opt, presLayout, slideLayout).forEach((slide, idx) => {\n            // A: Create new Slide when needed, otherwise, use existing (NOTE: More than 1 table can be on a Slide, so we will go up AND down the Slide chain)\n            if (!getSlide(target._slideNum + idx))\n                slides.push(addSlide({ masterName: (slideLayout === null || slideLayout === void 0 ? void 0 : slideLayout._name) || null }));\n            // B: Reset opt.y to `option`/`margin` after first Slide (ISSUE#43, ISSUE#47, ISSUE#48)\n            if (idx > 0)\n                opt.y = inch2Emu(opt.autoPageSlideStartY || opt.newSlideStartY || arrTableMargin[0]);\n            // C: Add this table to new Slide\n            {\n                const newSlide = getSlide(target._slideNum + idx);\n                opt.autoPage = false;\n                // Create hyperlink rels (IMPORTANT: Wait until table has been shredded across Slides or all rels will end-up on Slide 1!)\n                createHyperlinkRels(newSlide, slide.rows);\n                // Add rows to new slide\n                newSlide.addTable(slide.rows, Object.assign({}, opt));\n                // Add reference to the new slide so it can be returned, but don't add the first one because the user already has a reference to that one.\n                if (idx > 0)\n                    newAutoPagedSlides.push(newSlide);\n            }\n        });\n    }\n    return newAutoPagedSlides;\n}\n/**\n * Adds a text object to a slide definition.\n * @param {PresSlide} target - slide object that the text should be added to\n * @param {string|TextProps[]} text text string or object\n * @param {TextPropsOptions} opts text options\n * @param {boolean} isPlaceholder whether this a placeholder object\n * @since: 1.0.0\n */\nfunction addTextDefinition(target, text, opts, isPlaceholder) {\n    const newObject = {\n        _type: isPlaceholder ? SLIDE_OBJECT_TYPES.placeholder : SLIDE_OBJECT_TYPES.text,\n        shape: (opts === null || opts === void 0 ? void 0 : opts.shape) || SHAPE_TYPE.RECTANGLE,\n        text: !text || text.length === 0 ? [{ text: '', options: null }] : text,\n        options: opts || {},\n    };\n    function cleanOpts(itemOpts) {\n        // STEP 1: Set some options\n        {\n            // A.1: Color (placeholders should inherit their colors or override them, so don't default them)\n            if (!itemOpts.placeholder) {\n                itemOpts.color = itemOpts.color || newObject.options.color || target.color || DEF_FONT_COLOR;\n            }\n            // A.2: Placeholder should inherit their bullets or override them, so don't default them\n            if (itemOpts.placeholder || isPlaceholder) {\n                itemOpts.bullet = itemOpts.bullet || false;\n            }\n            // A.3: Text targeting a placeholder need to inherit the placeholders options (eg: margin, valign, etc.) (Issue #640)\n            if (itemOpts.placeholder && target._slideLayout && target._slideLayout._slideObjects) {\n                const placeHold = target._slideLayout._slideObjects.filter(item => item._type === 'placeholder' && item.options && item.options.placeholder && item.options.placeholder === itemOpts.placeholder)[0];\n                if (placeHold === null || placeHold === void 0 ? void 0 : placeHold.options)\n                    itemOpts = Object.assign(Object.assign({}, itemOpts), placeHold.options);\n            }\n            // A.4: Other options\n            itemOpts.objectName = itemOpts.objectName\n                ? encodeXmlEntities(itemOpts.objectName)\n                : `Text ${target._slideObjects.filter(obj => obj._type === SLIDE_OBJECT_TYPES.text).length}`;\n            // B:\n            if (itemOpts.shape === SHAPE_TYPE.LINE) {\n                // ShapeLineProps defaults\n                const newLineOpts = {\n                    type: itemOpts.line.type || 'solid',\n                    color: itemOpts.line.color || DEF_SHAPE_LINE_COLOR,\n                    transparency: itemOpts.line.transparency || 0,\n                    width: itemOpts.line.width || 1,\n                    dashType: itemOpts.line.dashType || 'solid',\n                    beginArrowType: itemOpts.line.beginArrowType || null,\n                    endArrowType: itemOpts.line.endArrowType || null,\n                };\n                if (typeof itemOpts.line === 'object')\n                    itemOpts.line = newLineOpts;\n                // 3: Handle line (lots of deprecated opts)\n                if (typeof itemOpts.line === 'string') {\n                    const tmpOpts = newLineOpts;\n                    if (typeof itemOpts.line === 'string')\n                        tmpOpts.color = itemOpts.line; // @deprecated [remove in v4.0]\n                    // tmpOpts.color = itemOpts.line!.toString() // @deprecated `itemOpts.line`:[string] (was line color)\n                    itemOpts.line = tmpOpts;\n                }\n                if (typeof itemOpts.lineSize === 'number')\n                    itemOpts.line.width = itemOpts.lineSize; // @deprecated (part of `ShapeLineProps` now)\n                if (typeof itemOpts.lineDash === 'string')\n                    itemOpts.line.dashType = itemOpts.lineDash; // @deprecated (part of `ShapeLineProps` now)\n                if (typeof itemOpts.lineHead === 'string')\n                    itemOpts.line.beginArrowType = itemOpts.lineHead; // @deprecated (part of `ShapeLineProps` now)\n                if (typeof itemOpts.lineTail === 'string')\n                    itemOpts.line.endArrowType = itemOpts.lineTail; // @deprecated (part of `ShapeLineProps` now)\n            }\n            // C: Line opts\n            itemOpts.line = itemOpts.line || {};\n            itemOpts.lineSpacing = itemOpts.lineSpacing && !isNaN(itemOpts.lineSpacing) ? itemOpts.lineSpacing : null;\n            itemOpts.lineSpacingMultiple = itemOpts.lineSpacingMultiple && !isNaN(itemOpts.lineSpacingMultiple) ? itemOpts.lineSpacingMultiple : null;\n            // D: Transform text options to bodyProperties as thats how we build XML\n            itemOpts._bodyProp = itemOpts._bodyProp || {};\n            itemOpts._bodyProp.autoFit = itemOpts.autoFit || false; // DEPRECATED: (3.3.0) If true, shape will collapse to text size (Fit To shape)\n            itemOpts._bodyProp.anchor = !itemOpts.placeholder ? TEXT_VALIGN.ctr : null; // VALS: [t,ctr,b]\n            itemOpts._bodyProp.vert = itemOpts.vert || null; // VALS: [eaVert,horz,mongolianVert,vert,vert270,wordArtVert,wordArtVertRtl]\n            itemOpts._bodyProp.wrap = typeof itemOpts.wrap === 'boolean' ? itemOpts.wrap : true;\n            // E: Inset\n            // @deprecated 3.10.0 (`inset` - use `margin`)\n            if ((itemOpts.inset && !isNaN(Number(itemOpts.inset))) || itemOpts.inset === 0) {\n                itemOpts._bodyProp.lIns = inch2Emu(itemOpts.inset);\n                itemOpts._bodyProp.rIns = inch2Emu(itemOpts.inset);\n                itemOpts._bodyProp.tIns = inch2Emu(itemOpts.inset);\n                itemOpts._bodyProp.bIns = inch2Emu(itemOpts.inset);\n            }\n            // F: Transform @deprecated props\n            if (typeof itemOpts.underline === 'boolean' && itemOpts.underline === true)\n                itemOpts.underline = { style: 'sng' };\n        }\n        // STEP 2: Transform `align`/`valign` to XML values, store in _bodyProp for XML gen\n        {\n            if ((itemOpts.align || '').toLowerCase().indexOf('c') === 0)\n                itemOpts._bodyProp.align = TEXT_HALIGN.center;\n            else if ((itemOpts.align || '').toLowerCase().indexOf('l') === 0)\n                itemOpts._bodyProp.align = TEXT_HALIGN.left;\n            else if ((itemOpts.align || '').toLowerCase().indexOf('r') === 0)\n                itemOpts._bodyProp.align = TEXT_HALIGN.right;\n            else if ((itemOpts.align || '').toLowerCase().indexOf('j') === 0)\n                itemOpts._bodyProp.align = TEXT_HALIGN.justify;\n            if ((itemOpts.valign || '').toLowerCase().indexOf('b') === 0)\n                itemOpts._bodyProp.anchor = TEXT_VALIGN.b;\n            else if ((itemOpts.valign || '').toLowerCase().indexOf('m') === 0)\n                itemOpts._bodyProp.anchor = TEXT_VALIGN.ctr;\n            else if ((itemOpts.valign || '').toLowerCase().indexOf('t') === 0)\n                itemOpts._bodyProp.anchor = TEXT_VALIGN.t;\n        }\n        // STEP 3: ROBUST: Set rational values for some shadow props if needed\n        correctShadowOptions(itemOpts.shadow);\n        return itemOpts;\n    }\n    // STEP 1: Create/Clean object options\n    newObject.options = cleanOpts(newObject.options);\n    // STEP 2: Create/Clean text options\n    newObject.text.forEach(item => (item.options = cleanOpts(item.options || {})));\n    // STEP 3: Create hyperlinks\n    createHyperlinkRels(target, newObject.text || '');\n    // LAST: Add object to Slide\n    target._slideObjects.push(newObject);\n}\n/**\n * Adds placeholder objects to slide\n * @param {PresSlide} slide - slide object containing layouts\n */\nfunction addPlaceholdersToSlideLayouts(slide) {\n    // Add all placeholders on this Slide that dont already exist\n    (slide._slideLayout._slideObjects || []).forEach(slideLayoutObj => {\n        if (slideLayoutObj._type === SLIDE_OBJECT_TYPES.placeholder) {\n            // A: Search for this placeholder on Slide before we add\n            // NOTE: Check to ensure a placeholder does not already exist on the Slide\n            // They are created when they have been populated with text (ex: `slide.addText('Hi', { placeholder:'title' });`)\n            if (slide._slideObjects.filter(slideObj => slideObj.options && slideObj.options.placeholder === slideLayoutObj.options.placeholder).length === 0) {\n                addTextDefinition(slide, [{ text: '' }], slideLayoutObj.options, false);\n            }\n        }\n    });\n}\n/* -------------------------------------------------------------------------------- */\n/**\n * Adds a background image or color to a slide definition.\n * @param {BackgroundProps} props - color string or an object with image definition\n * @param {PresSlide} target - slide object that the background is set to\n */\nfunction addBackgroundDefinition(props, target) {\n    var _a;\n    // A: @deprecated\n    if (target.bkgd) {\n        if (!target.background)\n            target.background = {};\n        if (typeof target.bkgd === 'string')\n            target.background.color = target.bkgd;\n        else {\n            if (target.bkgd.data)\n                target.background.data = target.bkgd.data;\n            if (target.bkgd.path)\n                target.background.path = target.bkgd.path;\n            if (target.bkgd.src)\n                target.background.path = target.bkgd.src; // @deprecated (drop in 4.x)\n        }\n    }\n    if ((_a = target.background) === null || _a === void 0 ? void 0 : _a.fill)\n        target.background.color = target.background.fill;\n    // B: Handle media\n    if (props && (props.path || props.data)) {\n        // Allow the use of only the data key (`path` isnt reqd)\n        props.path = props.path || 'preencoded.png';\n        let strImgExtn = (props.path.split('.').pop() || 'png').split('?')[0]; // Handle \"blah.jpg?width=540\" etc.\n        if (strImgExtn === 'jpg')\n            strImgExtn = 'jpeg'; // base64-encoded jpg's come out as \"data:image/jpeg;base64,/9j/[...]\", so correct exttnesion to avoid content warnings at PPT startup\n        target._relsMedia = target._relsMedia || [];\n        const intRels = target._relsMedia.length + 1;\n        // NOTE: `Target` cannot have spaces (eg:\"Slide 1-image-1.jpg\") or a \"presentation is corrupt\" warning comes up\n        target._relsMedia.push({\n            path: props.path,\n            type: SLIDE_OBJECT_TYPES.image,\n            extn: strImgExtn,\n            data: props.data || null,\n            rId: intRels,\n            Target: `../media/${(target._name || '').replace(/\\s+/gi, '-')}-image-${target._relsMedia.length + 1}.${strImgExtn}`,\n        });\n        target._bkgdImgRid = intRels;\n    }\n}\n/**\n * Parses text/text-objects from `addText()` and `addTable()` methods; creates 'hyperlink'-type Slide Rels for each hyperlink found\n * @param {PresSlide} target - slide object that any hyperlinks will be be added to\n * @param {number | string | TextProps | TextProps[] | ITableCell[][]} text - text to parse\n */\nfunction createHyperlinkRels(target, text, options) {\n    let textObjs = [];\n    // Only text objects can have hyperlinks, bail when text param is plain text\n    if (typeof text === 'string' || typeof text === 'number')\n        return;\n    // IMPORTANT: \"else if\" Array.isArray must come before typeof===object! Otherwise, code will exhaust recursion!\n    else if (Array.isArray(text))\n        textObjs = text;\n    else if (typeof text === 'object')\n        textObjs = [text];\n    textObjs.forEach((text, idx) => {\n        // IMPORTANT: `options` are lost due to recursion/copy!\n        if (options && options[idx] && options[idx].hyperlink)\n            text.options = Object.assign(Object.assign({}, text.options), options[idx]);\n        // NOTE: `text` can be an array of other `text` objects (table cell word-level formatting), continue parsing using recursion\n        if (Array.isArray(text)) {\n            const cellOpts = [];\n            text.forEach((tablecell) => {\n                if (tablecell.options && !tablecell.text.options) {\n                    cellOpts.push(tablecell.options);\n                }\n            });\n            createHyperlinkRels(target, text, cellOpts);\n        }\n        else if (Array.isArray(text.text)) {\n            createHyperlinkRels(target, text.text, options && options[idx] ? [options[idx]] : undefined);\n        }\n        else if (text && typeof text === 'object' && text.options && text.options.hyperlink && !text.options.hyperlink._rId) {\n            if (typeof text.options.hyperlink !== 'object') {\n                console.log('ERROR: text `hyperlink` option should be an object. Ex: `hyperlink: {url:\\'https://github.com\\'}` ');\n            }\n            else if (!text.options.hyperlink.url && !text.options.hyperlink.slide) {\n                console.log('ERROR: \\'hyperlink requires either: `url` or `slide`\\'');\n            }\n            else {\n                const relId = getNewRelId(target);\n                target._rels.push({\n                    type: SLIDE_OBJECT_TYPES.hyperlink,\n                    data: text.options.hyperlink.slide ? 'slide' : 'dummy',\n                    rId: relId,\n                    Target: encodeXmlEntities(text.options.hyperlink.url) || text.options.hyperlink.slide.toString(),\n                });\n                text.options.hyperlink._rId = relId;\n            }\n        }\n        else if (text && typeof text === 'object' && text.options && text.options.hyperlink && text.options.hyperlink._rId) {\n            // NOTE: auto-paging will create new slides, but skip above as _rId exists, BUT this is a new slide, so add rels!\n            if (target._rels.filter(rel => rel.rId === text.options.hyperlink._rId).length === 0) {\n                target._rels.push({\n                    type: SLIDE_OBJECT_TYPES.hyperlink,\n                    data: text.options.hyperlink.slide ? 'slide' : 'dummy',\n                    rId: text.options.hyperlink._rId,\n                    Target: encodeXmlEntities(text.options.hyperlink.url) || text.options.hyperlink.slide.toString(),\n                });\n            }\n        }\n    });\n}\n\n/**\n * PptxGenJS: Slide Class\n */\nclass Slide {\n    constructor(params) {\n        var _a;\n        this.addSlide = params.addSlide;\n        this.getSlide = params.getSlide;\n        this._name = `Slide ${params.slideNumber}`;\n        this._presLayout = params.presLayout;\n        this._rId = params.slideRId;\n        this._rels = [];\n        this._relsChart = [];\n        this._relsMedia = [];\n        this._setSlideNum = params.setSlideNum;\n        this._slideId = params.slideId;\n        this._slideLayout = params.slideLayout || null;\n        this._slideNum = params.slideNumber;\n        this._slideObjects = [];\n        /** NOTE: Slide Numbers: In order for Slide Numbers to function they need to be in all 3 files: master/layout/slide\n         * `defineSlideMaster` and `addNewSlide.slideNumber` will add {slideNumber} to `this.masterSlide` and `this.slideLayouts`\n         * so, lastly, add to the Slide now.\n         */\n        this._slideNumberProps = ((_a = this._slideLayout) === null || _a === void 0 ? void 0 : _a._slideNumberProps) ? this._slideLayout._slideNumberProps : null;\n    }\n    set bkgd(value) {\n        this._bkgd = value;\n        if (!this._background || !this._background.color) {\n            if (!this._background)\n                this._background = {};\n            if (typeof value === 'string')\n                this._background.color = value;\n        }\n    }\n    get bkgd() {\n        return this._bkgd;\n    }\n    set background(props) {\n        this._background = props;\n        // Add background (image data/path must be captured before `exportPresentation()` is called)\n        if (props)\n            addBackgroundDefinition(props, this);\n    }\n    get background() {\n        return this._background;\n    }\n    set color(value) {\n        this._color = value;\n    }\n    get color() {\n        return this._color;\n    }\n    set hidden(value) {\n        this._hidden = value;\n    }\n    get hidden() {\n        return this._hidden;\n    }\n    /**\n     * @type {SlideNumberProps}\n     */\n    set slideNumber(value) {\n        // NOTE: Slide Numbers: In order for Slide Numbers to function they need to be in all 3 files: master/layout/slide\n        this._slideNumberProps = value;\n        this._setSlideNum(value);\n    }\n    get slideNumber() {\n        return this._slideNumberProps;\n    }\n    get newAutoPagedSlides() {\n        return this._newAutoPagedSlides;\n    }\n    /**\n     * Add chart to Slide\n     * @param {CHART_NAME|IChartMulti[]} type - chart type\n     * @param {object[]} data - data object\n     * @param {IChartOpts} options - chart options\n     * @return {Slide} this Slide\n     */\n    addChart(type, data, options) {\n        // FUTURE: TODO-VERSION-4: Remove first arg - only take data and opts, with \"type\" required on opts\n        // Set `_type` on IChartOptsLib as its what is used as object is passed around\n        const optionsWithType = options || {};\n        optionsWithType._type = type;\n        addChartDefinition(this, type, data, options);\n        return this;\n    }\n    /**\n     * Add image to Slide\n     * @param {ImageProps} options - image options\n     * @return {Slide} this Slide\n     */\n    addImage(options) {\n        addImageDefinition(this, options);\n        return this;\n    }\n    /**\n     * Add media (audio/video) to Slide\n     * @param {MediaProps} options - media options\n     * @return {Slide} this Slide\n     */\n    addMedia(options) {\n        addMediaDefinition(this, options);\n        return this;\n    }\n    /**\n     * Add speaker notes to Slide\n     * @docs https://gitbrent.github.io/PptxGenJS/docs/speaker-notes.html\n     * @param {string} notes - notes to add to slide\n     * @return {Slide} this Slide\n     */\n    addNotes(notes) {\n        addNotesDefinition(this, notes);\n        return this;\n    }\n    /**\n     * Add shape to Slide\n     * @param {SHAPE_NAME} shapeName - shape name\n     * @param {ShapeProps} options - shape options\n     * @return {Slide} this Slide\n     */\n    addShape(shapeName, options) {\n        // NOTE: As of v3.1.0, <script> users are passing the old shape object from the shapes file (orig to the project)\n        // But React/TypeScript users are passing the shapeName from an enum, which is a simple string, so lets cast\n        // <script./> => `pptx.shapes.RECTANGLE` [string] \"rect\" ... shapeName['name'] = 'rect'\n        // TypeScript => `pptxgen.shapes.RECTANGLE` [string] \"rect\" ... shapeName = 'rect'\n        // let shapeNameDecode = typeof shapeName === 'object' && shapeName['name'] ? shapeName['name'] : shapeName\n        addShapeDefinition(this, shapeName, options);\n        return this;\n    }\n    /**\n     * Add table to Slide\n     * @param {TableRow[]} tableRows - table rows\n     * @param {TableProps} options - table options\n     * @return {Slide} this Slide\n     */\n    addTable(tableRows, options) {\n        // FUTURE: we pass `this` - we dont need to pass layouts - they can be read from this!\n        this._newAutoPagedSlides = addTableDefinition(this, tableRows, options, this._slideLayout, this._presLayout, this.addSlide, this.getSlide);\n        return this;\n    }\n    /**\n     * Add text to Slide\n     * @param {string|TextProps[]} text - text string or complex object\n     * @param {TextPropsOptions} options - text options\n     * @return {Slide} this Slide\n     */\n    addText(text, options) {\n        const textParam = typeof text === 'string' || typeof text === 'number' ? [{ text, options }] : text;\n        addTextDefinition(this, textParam, options, false);\n        return this;\n    }\n}\n\n/**\n * PptxGenJS: Chart Generation\n */\n/**\n * Based on passed data, creates Excel Worksheet that is used as a data source for a chart.\n * @param {ISlideRelChart} chartObject - chart object\n * @param {JSZip} zip - file that the resulting XLSX should be added to\n * @return {Promise} promise of generating the XLSX file\n */\nfunction createExcelWorksheet(chartObject, zip) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const data = chartObject.data;\n        return yield new Promise((resolve, reject) => {\n            var _a, _b;\n            const zipExcel = new (jszip__WEBPACK_IMPORTED_MODULE_0___default())();\n            const intBubbleCols = (data.length - 1) * 2 + 1; // 1 for \"X-Values\", then 2 for every Y-Axis\n            const IS_MULTI_CAT_AXES = ((_b = (_a = data[0]) === null || _a === void 0 ? void 0 : _a.labels) === null || _b === void 0 ? void 0 : _b.length) > 1;\n            // A: Add folders\n            zipExcel.folder('_rels');\n            zipExcel.folder('docProps');\n            zipExcel.folder('xl/_rels');\n            zipExcel.folder('xl/tables');\n            zipExcel.folder('xl/theme');\n            zipExcel.folder('xl/worksheets');\n            zipExcel.folder('xl/worksheets/_rels');\n            // B: Add core contents\n            {\n                zipExcel.file('[Content_Types].xml', '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><Types xmlns=\"http://schemas.openxmlformats.org/package/2006/content-types\">' +\n                    '  <Default Extension=\"rels\" ContentType=\"application/vnd.openxmlformats-package.relationships+xml\"/>' +\n                    '  <Default Extension=\"xml\" ContentType=\"application/xml\"/>' +\n                    '  <Override PartName=\"/xl/workbook.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\"/>' +\n                    '  <Override PartName=\"/xl/worksheets/sheet1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\"/>' +\n                    '  <Override PartName=\"/xl/theme/theme1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.theme+xml\"/>' +\n                    '  <Override PartName=\"/xl/styles.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml\"/>' +\n                    '  <Override PartName=\"/xl/sharedStrings.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml\"/>' +\n                    '  <Override PartName=\"/xl/tables/table1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml\"/>' +\n                    '  <Override PartName=\"/docProps/core.xml\" ContentType=\"application/vnd.openxmlformats-package.core-properties+xml\"/>' +\n                    '  <Override PartName=\"/docProps/app.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.extended-properties+xml\"/>' +\n                    '</Types>\\n');\n                zipExcel.file('_rels/.rels', '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">' +\n                    '<Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties\" Target=\"docProps/core.xml\"/>' +\n                    '<Relationship Id=\"rId2\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties\" Target=\"docProps/app.xml\"/>' +\n                    '<Relationship Id=\"rId3\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument\" Target=\"xl/workbook.xml\"/>' +\n                    '</Relationships>\\n');\n                zipExcel.file('docProps/app.xml', '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><Properties xmlns=\"http://schemas.openxmlformats.org/officeDocument/2006/extended-properties\" xmlns:vt=\"http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes\">' +\n                    '<Application>Microsoft Macintosh Excel</Application>' +\n                    '<DocSecurity>0</DocSecurity>' +\n                    '<ScaleCrop>false</ScaleCrop>' +\n                    '<HeadingPairs><vt:vector size=\"2\" baseType=\"variant\"><vt:variant><vt:lpstr>Worksheets</vt:lpstr></vt:variant><vt:variant><vt:i4>1</vt:i4></vt:variant></vt:vector></HeadingPairs>' +\n                    '<TitlesOfParts><vt:vector size=\"1\" baseType=\"lpstr\"><vt:lpstr>Sheet1</vt:lpstr></vt:vector></TitlesOfParts>' +\n                    '<Company></Company><LinksUpToDate>false</LinksUpToDate><SharedDoc>false</SharedDoc><HyperlinksChanged>false</HyperlinksChanged><AppVersion>16.0300</AppVersion>' +\n                    '</Properties>\\n');\n                zipExcel.file('docProps/core.xml', '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><cp:coreProperties xmlns:cp=\"http://schemas.openxmlformats.org/package/2006/metadata/core-properties\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:dcterms=\"http://purl.org/dc/terms/\" xmlns:dcmitype=\"http://purl.org/dc/dcmitype/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">' +\n                    '<dc:creator>PptxGenJS</dc:creator>' +\n                    '<cp:lastModifiedBy>PptxGenJS</cp:lastModifiedBy>' +\n                    '<dcterms:created xsi:type=\"dcterms:W3CDTF\">' +\n                    new Date().toISOString() +\n                    '</dcterms:created>' +\n                    '<dcterms:modified xsi:type=\"dcterms:W3CDTF\">' +\n                    new Date().toISOString() +\n                    '</dcterms:modified>' +\n                    '</cp:coreProperties>');\n                zipExcel.file('xl/_rels/workbook.xml.rels', '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' +\n                    '<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">' +\n                    '<Relationship Id=\"rId3\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles\" Target=\"styles.xml\"/>' +\n                    '<Relationship Id=\"rId2\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme\" Target=\"theme/theme1.xml\"/>' +\n                    '<Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet\" Target=\"worksheets/sheet1.xml\"/>' +\n                    '<Relationship Id=\"rId4\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings\" Target=\"sharedStrings.xml\"/>' +\n                    '</Relationships>');\n                zipExcel.file('xl/styles.xml', '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><styleSheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"><numFmts count=\"1\"><numFmt numFmtId=\"0\" formatCode=\"General\"/></numFmts><fonts count=\"4\"><font><sz val=\"9\"/><color indexed=\"8\"/><name val=\"Geneva\"/></font><font><sz val=\"9\"/><color indexed=\"8\"/><name val=\"Geneva\"/></font><font><sz val=\"10\"/><color indexed=\"8\"/><name val=\"Geneva\"/></font><font><sz val=\"18\"/><color indexed=\"8\"/>' +\n                    '<name val=\"Arial\"/></font></fonts><fills count=\"2\"><fill><patternFill patternType=\"none\"/></fill><fill><patternFill patternType=\"gray125\"/></fill></fills><borders count=\"1\"><border><left/><right/><top/><bottom/><diagonal/></border></borders><dxfs count=\"0\"/><tableStyles count=\"0\"/><colors><indexedColors><rgbColor rgb=\"ff000000\"/><rgbColor rgb=\"ffffffff\"/><rgbColor rgb=\"ffff0000\"/><rgbColor rgb=\"ff00ff00\"/><rgbColor rgb=\"ff0000ff\"/>' +\n                    '<rgbColor rgb=\"ffffff00\"/><rgbColor rgb=\"ffff00ff\"/><rgbColor rgb=\"ff00ffff\"/><rgbColor rgb=\"ff000000\"/><rgbColor rgb=\"ffffffff\"/><rgbColor rgb=\"ff878787\"/><rgbColor rgb=\"fff9f9f9\"/></indexedColors></colors></styleSheet>\\n');\n                zipExcel.file('xl/theme/theme1.xml', '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><a:theme xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" name=\"Office Theme\"><a:themeElements><a:clrScheme name=\"Office\"><a:dk1><a:sysClr val=\"windowText\" lastClr=\"000000\"/></a:dk1><a:lt1><a:sysClr val=\"window\" lastClr=\"FFFFFF\"/></a:lt1><a:dk2><a:srgbClr val=\"44546A\"/></a:dk2><a:lt2><a:srgbClr val=\"E7E6E6\"/></a:lt2><a:accent1><a:srgbClr val=\"4472C4\"/></a:accent1><a:accent2><a:srgbClr val=\"ED7D31\"/></a:accent2><a:accent3><a:srgbClr val=\"A5A5A5\"/></a:accent3><a:accent4><a:srgbClr val=\"FFC000\"/></a:accent4><a:accent5><a:srgbClr val=\"5B9BD5\"/></a:accent5><a:accent6><a:srgbClr val=\"70AD47\"/></a:accent6><a:hlink><a:srgbClr val=\"0563C1\"/></a:hlink><a:folHlink><a:srgbClr val=\"954F72\"/></a:folHlink></a:clrScheme><a:fontScheme name=\"Office\"><a:majorFont><a:latin typeface=\"Calibri Light\" panose=\"020F0302020204030204\"/><a:ea typeface=\"\"/><a:cs typeface=\"\"/><a:font script=\"Jpan\" typeface=\"Yu Gothic Light\"/><a:font script=\"Hang\" typeface=\"맑은 고딕\"/><a:font script=\"Hans\" typeface=\"DengXian Light\"/><a:font script=\"Hant\" typeface=\"新細明體\"/><a:font script=\"Arab\" typeface=\"Times New Roman\"/><a:font script=\"Hebr\" typeface=\"Times New Roman\"/><a:font script=\"Thai\" typeface=\"Tahoma\"/><a:font script=\"Ethi\" typeface=\"Nyala\"/><a:font script=\"Beng\" typeface=\"Vrinda\"/><a:font script=\"Gujr\" typeface=\"Shruti\"/><a:font script=\"Khmr\" typeface=\"MoolBoran\"/><a:font script=\"Knda\" typeface=\"Tunga\"/><a:font script=\"Guru\" typeface=\"Raavi\"/><a:font script=\"Cans\" typeface=\"Euphemia\"/><a:font script=\"Cher\" typeface=\"Plantagenet Cherokee\"/><a:font script=\"Yiii\" typeface=\"Microsoft Yi Baiti\"/><a:font script=\"Tibt\" typeface=\"Microsoft Himalaya\"/><a:font script=\"Thaa\" typeface=\"MV Boli\"/><a:font script=\"Deva\" typeface=\"Mangal\"/><a:font script=\"Telu\" typeface=\"Gautami\"/><a:font script=\"Taml\" typeface=\"Latha\"/><a:font script=\"Syrc\" typeface=\"Estrangelo Edessa\"/><a:font script=\"Orya\" typeface=\"Kalinga\"/><a:font script=\"Mlym\" typeface=\"Kartika\"/><a:font script=\"Laoo\" typeface=\"DokChampa\"/><a:font script=\"Sinh\" typeface=\"Iskoola Pota\"/><a:font script=\"Mong\" typeface=\"Mongolian Baiti\"/><a:font script=\"Viet\" typeface=\"Times New Roman\"/><a:font script=\"Uigh\" typeface=\"Microsoft Uighur\"/><a:font script=\"Geor\" typeface=\"Sylfaen\"/></a:majorFont><a:minorFont><a:latin typeface=\"Calibri\" panose=\"020F0502020204030204\"/><a:ea typeface=\"\"/><a:cs typeface=\"\"/><a:font script=\"Jpan\" typeface=\"Yu Gothic\"/><a:font script=\"Hang\" typeface=\"맑은 고딕\"/><a:font script=\"Hans\" typeface=\"DengXian\"/><a:font script=\"Hant\" typeface=\"新細明體\"/><a:font script=\"Arab\" typeface=\"Arial\"/><a:font script=\"Hebr\" typeface=\"Arial\"/><a:font script=\"Thai\" typeface=\"Tahoma\"/><a:font script=\"Ethi\" typeface=\"Nyala\"/><a:font script=\"Beng\" typeface=\"Vrinda\"/><a:font script=\"Gujr\" typeface=\"Shruti\"/><a:font script=\"Khmr\" typeface=\"DaunPenh\"/><a:font script=\"Knda\" typeface=\"Tunga\"/><a:font script=\"Guru\" typeface=\"Raavi\"/><a:font script=\"Cans\" typeface=\"Euphemia\"/><a:font script=\"Cher\" typeface=\"Plantagenet Cherokee\"/><a:font script=\"Yiii\" typeface=\"Microsoft Yi Baiti\"/><a:font script=\"Tibt\" typeface=\"Microsoft Himalaya\"/><a:font script=\"Thaa\" typeface=\"MV Boli\"/><a:font script=\"Deva\" typeface=\"Mangal\"/><a:font script=\"Telu\" typeface=\"Gautami\"/><a:font script=\"Taml\" typeface=\"Latha\"/><a:font script=\"Syrc\" typeface=\"Estrangelo Edessa\"/><a:font script=\"Orya\" typeface=\"Kalinga\"/><a:font script=\"Mlym\" typeface=\"Kartika\"/><a:font script=\"Laoo\" typeface=\"DokChampa\"/><a:font script=\"Sinh\" typeface=\"Iskoola Pota\"/><a:font script=\"Mong\" typeface=\"Mongolian Baiti\"/><a:font script=\"Viet\" typeface=\"Arial\"/><a:font script=\"Uigh\" typeface=\"Microsoft Uighur\"/><a:font script=\"Geor\" typeface=\"Sylfaen\"/></a:minorFont></a:fontScheme><a:fmtScheme name=\"Office\"><a:fillStyleLst><a:solidFill><a:schemeClr val=\"phClr\"/></a:solidFill><a:gradFill rotWithShape=\"1\"><a:gsLst><a:gs pos=\"0\"><a:schemeClr val=\"phClr\"><a:lumMod val=\"110000\"/><a:satMod val=\"105000\"/><a:tint val=\"67000\"/></a:schemeClr></a:gs><a:gs pos=\"50000\"><a:schemeClr val=\"phClr\"><a:lumMod val=\"105000\"/><a:satMod val=\"103000\"/><a:tint val=\"73000\"/></a:schemeClr></a:gs><a:gs pos=\"100000\"><a:schemeClr val=\"phClr\"><a:lumMod val=\"105000\"/><a:satMod val=\"109000\"/><a:tint val=\"81000\"/></a:schemeClr></a:gs></a:gsLst><a:lin ang=\"5400000\" scaled=\"0\"/></a:gradFill><a:gradFill rotWithShape=\"1\"><a:gsLst><a:gs pos=\"0\"><a:schemeClr val=\"phClr\"><a:satMod val=\"103000\"/><a:lumMod val=\"102000\"/><a:tint val=\"94000\"/></a:schemeClr></a:gs><a:gs pos=\"50000\"><a:schemeClr val=\"phClr\"><a:satMod val=\"110000\"/><a:lumMod val=\"100000\"/><a:shade val=\"100000\"/></a:schemeClr></a:gs><a:gs pos=\"100000\"><a:schemeClr val=\"phClr\"><a:lumMod val=\"99000\"/><a:satMod val=\"120000\"/><a:shade val=\"78000\"/></a:schemeClr></a:gs></a:gsLst><a:lin ang=\"5400000\" scaled=\"0\"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w=\"6350\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"><a:solidFill><a:schemeClr val=\"phClr\"/></a:solidFill><a:prstDash val=\"solid\"/><a:miter lim=\"800000\"/></a:ln><a:ln w=\"12700\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"><a:solidFill><a:schemeClr val=\"phClr\"/></a:solidFill><a:prstDash val=\"solid\"/><a:miter lim=\"800000\"/></a:ln><a:ln w=\"19050\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"><a:solidFill><a:schemeClr val=\"phClr\"/></a:solidFill><a:prstDash val=\"solid\"/><a:miter lim=\"800000\"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad=\"57150\" dist=\"19050\" dir=\"5400000\" algn=\"ctr\" rotWithShape=\"0\"><a:srgbClr val=\"000000\"><a:alpha val=\"63000\"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val=\"phClr\"/></a:solidFill><a:solidFill><a:schemeClr val=\"phClr\"><a:tint val=\"95000\"/><a:satMod val=\"170000\"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape=\"1\"><a:gsLst><a:gs pos=\"0\"><a:schemeClr val=\"phClr\"><a:tint val=\"93000\"/><a:satMod val=\"150000\"/><a:shade val=\"98000\"/><a:lumMod val=\"102000\"/></a:schemeClr></a:gs><a:gs pos=\"50000\"><a:schemeClr val=\"phClr\"><a:tint val=\"98000\"/><a:satMod val=\"130000\"/><a:shade val=\"90000\"/><a:lumMod val=\"103000\"/></a:schemeClr></a:gs><a:gs pos=\"100000\"><a:schemeClr val=\"phClr\"><a:shade val=\"63000\"/><a:satMod val=\"120000\"/></a:schemeClr></a:gs></a:gsLst><a:lin ang=\"5400000\" scaled=\"0\"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri=\"{05A4C25C-085E-4340-85A3-A5531E510DB2}\"><thm15:themeFamily xmlns:thm15=\"http://schemas.microsoft.com/office/thememl/2012/main\" name=\"Office Theme\" id=\"{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}\" vid=\"{4A3C46E8-61CC-4603-A589-7422A47A8E4A}\"/></a:ext></a:extLst></a:theme>');\n                zipExcel.file('xl/workbook.xml', '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' +\n                    '<workbook xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x15\" xmlns:x15=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/main\">' +\n                    '<fileVersion appName=\"xl\" lastEdited=\"7\" lowestEdited=\"6\" rupBuild=\"10507\"/>' +\n                    '<workbookPr/>' +\n                    '<bookViews><workbookView xWindow=\"0\" yWindow=\"500\" windowWidth=\"20960\" windowHeight=\"15960\"/></bookViews>' +\n                    '<sheets><sheet name=\"Sheet1\" sheetId=\"1\" r:id=\"rId1\"/></sheets>' +\n                    '<calcPr calcId=\"0\" concurrentCalc=\"0\"/>' +\n                    '</workbook>\\n');\n                zipExcel.file('xl/worksheets/_rels/sheet1.xml.rels', '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' +\n                    '<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">' +\n                    '<Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/table\" Target=\"../tables/table1.xml\"/>' +\n                    '</Relationships>\\n');\n            }\n            // sharedStrings.xml\n            {\n                // A: Start XML\n                let strSharedStrings = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>';\n                if (chartObject.opts._type === CHART_TYPE.BUBBLE || chartObject.opts._type === CHART_TYPE.BUBBLE3D) {\n                    strSharedStrings += `<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"${intBubbleCols}\" uniqueCount=\"${intBubbleCols}\">`;\n                }\n                else if (chartObject.opts._type === CHART_TYPE.SCATTER) {\n                    strSharedStrings += `<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"${data.length}\" uniqueCount=\"${data.length}\">`;\n                }\n                else if (IS_MULTI_CAT_AXES) {\n                    let totCount = data.length;\n                    data[0].labels.forEach(arrLabel => (totCount += arrLabel.filter(label => label && label !== '').length));\n                    strSharedStrings += `<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"${totCount}\" uniqueCount=\"${totCount}\">`;\n                    strSharedStrings += '<si><t/></si>';\n                }\n                else {\n                    // series names + all labels of one series + number of label groups (data.labels.length) of one series (i.e. how many times the blank string is used)\n                    const totCount = data.length + data[0].labels.length * data[0].labels[0].length + data[0].labels.length;\n                    // series names + labels of one series + blank string (same for all label groups)\n                    const unqCount = data.length + data[0].labels.length * data[0].labels[0].length + 1;\n                    // start `sst`\n                    strSharedStrings += `<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"${totCount}\" uniqueCount=\"${unqCount}\">`;\n                    // B: Add 'blank' for A1, B1, ..., of every label group inside data[n].labels\n                    strSharedStrings += '<si><t xml:space=\"preserve\"></t></si>';\n                }\n                // C: Add `name`/Series\n                if (chartObject.opts._type === CHART_TYPE.BUBBLE || chartObject.opts._type === CHART_TYPE.BUBBLE3D) {\n                    data.forEach((objData, idx) => {\n                        if (idx === 0)\n                            strSharedStrings += '<si><t>X-Axis</t></si>';\n                        else {\n                            strSharedStrings += `<si><t>${encodeXmlEntities(objData.name || `Y-Axis${idx}`)}</t></si>`;\n                            strSharedStrings += `<si><t>${encodeXmlEntities(`Size${idx}`)}</t></si>`;\n                        }\n                    });\n                }\n                else {\n                    data.forEach(objData => {\n                        strSharedStrings += `<si><t>${encodeXmlEntities((objData.name || ' ').replace('X-Axis', 'X-Values'))}</t></si>`;\n                    });\n                }\n                // D: Add `labels`/Categories\n                if (chartObject.opts._type !== CHART_TYPE.BUBBLE && chartObject.opts._type !== CHART_TYPE.BUBBLE3D && chartObject.opts._type !== CHART_TYPE.SCATTER) {\n                    // Use forEach backwards & check for '' to support multi-cat axes\n                    data[0].labels\n                        .slice()\n                        .reverse()\n                        .forEach(labelsGroup => {\n                        labelsGroup\n                            .filter(label => label && label !== '')\n                            .forEach(label => {\n                            strSharedStrings += `<si><t>${encodeXmlEntities(label)}</t></si>`;\n                        });\n                    });\n                }\n                // DONE:\n                strSharedStrings += '</sst>\\n';\n                zipExcel.file('xl/sharedStrings.xml', strSharedStrings);\n            }\n            // tables/table1.xml\n            {\n                let strTableXml = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>';\n                if (chartObject.opts._type === CHART_TYPE.BUBBLE || chartObject.opts._type === CHART_TYPE.BUBBLE3D) {\n                    strTableXml += `<table xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" id=\"1\" name=\"Table1\" displayName=\"Table1\" ref=\"A1:${getExcelColName(intBubbleCols)}${intBubbleCols}\" totalsRowShown=\"0\">`;\n                    strTableXml += `<tableColumns count=\"${intBubbleCols}\">`;\n                    let idxColLtr = 1;\n                    data.forEach((obj, idx) => {\n                        if (idx === 0) {\n                            strTableXml += `<tableColumn id=\"${idx + 1}\" name=\"X-Values\"/>`;\n                        }\n                        else {\n                            strTableXml += `<tableColumn id=\"${idx + idxColLtr}\" name=\"${obj.name}\"/>`;\n                            idxColLtr++;\n                            strTableXml += `<tableColumn id=\"${idx + idxColLtr}\" name=\"Size${idx}\"/>`;\n                        }\n                    });\n                }\n                else if (chartObject.opts._type === CHART_TYPE.SCATTER) {\n                    strTableXml += `<table xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" id=\"1\" name=\"Table1\" displayName=\"Table1\" ref=\"A1:${getExcelColName(data.length)}${data[0].values.length + 1}\" totalsRowShown=\"0\">`;\n                    strTableXml += `<tableColumns count=\"${data.length}\">`;\n                    data.forEach((_obj, idx) => {\n                        strTableXml += `<tableColumn id=\"${idx + 1}\" name=\"${idx === 0 ? 'X-Values' : 'Y-Value '}${idx}\"/>`;\n                    });\n                }\n                else {\n                    strTableXml += `<table xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" id=\"1\" name=\"Table1\" displayName=\"Table1\" ref=\"A1:${getExcelColName(data.length + data[0].labels.length)}${data[0].labels[0].length + 1}'\" totalsRowShown=\"0\">`;\n                    strTableXml += `<tableColumns count=\"${data.length + data[0].labels.length}\">`;\n                    data[0].labels.forEach((_labelsGroup, idx) => {\n                        strTableXml += `<tableColumn id=\"${idx + 1}\" name=\"Column${idx + 1}\"/>`;\n                    });\n                    data.forEach((obj, idx) => {\n                        strTableXml += `<tableColumn id=\"${idx + data[0].labels.length + 1}\" name=\"${encodeXmlEntities(obj.name)}\"/>`;\n                    });\n                }\n                strTableXml += '</tableColumns>';\n                strTableXml += '<tableStyleInfo showFirstColumn=\"0\" showLastColumn=\"0\" showRowStripes=\"1\" showColumnStripes=\"0\"/>';\n                strTableXml += '</table>';\n                zipExcel.file('xl/tables/table1.xml', strTableXml);\n            }\n            // worksheets/sheet1.xml\n            {\n                let strSheetXml = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>';\n                strSheetXml +=\n                    '<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x14ac\" xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\">';\n                if (chartObject.opts._type === CHART_TYPE.BUBBLE || chartObject.opts._type === CHART_TYPE.BUBBLE3D) {\n                    strSheetXml += `<dimension ref=\"A1:${getExcelColName(intBubbleCols)}${data[0].values.length + 1}\"/>`;\n                }\n                else if (chartObject.opts._type === CHART_TYPE.SCATTER) {\n                    strSheetXml += `<dimension ref=\"A1:${getExcelColName(data.length)}${data[0].values.length + 1}\"/>`;\n                }\n                else {\n                    strSheetXml += `<dimension ref=\"A1:${getExcelColName(data.length + 1)}${data[0].values.length + 1}\"/>`;\n                }\n                strSheetXml += '<sheetViews><sheetView tabSelected=\"1\" workbookViewId=\"0\"><selection activeCell=\"B1\" sqref=\"B1\"/></sheetView></sheetViews>';\n                strSheetXml += '<sheetFormatPr baseColWidth=\"10\" defaultRowHeight=\"16\"/>';\n                if (chartObject.opts._type === CHART_TYPE.BUBBLE || chartObject.opts._type === CHART_TYPE.BUBBLE3D) {\n                    // UNUSED: strSheetXml += `<cols><col min=\"1\" max=\"${data.length}\" width=\"11\" customWidth=\"1\" /></cols>`\n                    /* EX: INPUT: `data`\n                    [\n                        { name:'X-Axis'  , values:[10,11,12,13,14,15,16,17,18,19,20] },\n                        { name:'Y-Axis 1', values:[ 1, 6, 7, 8, 9], sizes:[ 4, 5, 6, 7, 8] },\n                        { name:'Y-Axis 2', values:[33,32,42,53,63], sizes:[11,12,13,14,15] }\n                    ];\n                    */\n                    /* EX: OUTPUT: bubbleChart Worksheet:\n                        -|----A-----|------B-----|------C-----|------D-----|------E-----|\n                        1| X-Values | Y-Values 1 | Y-Sizes 1  | Y-Values 2 | Y-Sizes 2  |\n                        2|    11    |     22     |      4     |     33     |      8     |\n                        -|----------|------------|------------|------------|------------|\n                    */\n                    strSheetXml += '<sheetData>';\n                    // A: Create header row first (NOTE: Start at index=1 as headers cols start with 'B')\n                    strSheetXml += `<row r=\"1\" spans=\"1:${intBubbleCols}\">`;\n                    strSheetXml += '<c r=\"A1\" t=\"s\"><v>0</v></c>';\n                    for (let idx = 1; idx < intBubbleCols; idx++) {\n                        strSheetXml += `<c r=\"${getExcelColName(idx + 1)}1\" t=\"s\"><v>${idx}</v></c>`; // NOTE: add `t=\"s\"` for label cols!\n                    }\n                    strSheetXml += '</row>';\n                    // B: Add row for each X-Axis value (Y-Axis* value is optional)\n                    data[0].values.forEach((val, idx) => {\n                        // Leading col is reserved for the 'X-Axis' value, so hard-code it, then loop over col values\n                        strSheetXml += `<row r=\"${idx + 2}\" spans=\"1:${intBubbleCols}\">`;\n                        strSheetXml += `<c r=\"A${idx + 2}\"><v>${val}</v></c>`;\n                        // Add Y-Axis 1->N (idy=0 = Xaxis)\n                        let idxColLtr = 2;\n                        for (let idy = 1; idy < data.length; idy++) {\n                            // y-value\n                            strSheetXml += `<c r=\"${getExcelColName(idxColLtr)}${idx + 2}\"><v>${data[idy].values[idx] || ''}</v></c>`;\n                            idxColLtr++;\n                            // y-size\n                            strSheetXml += `<c r=\"${getExcelColName(idxColLtr)}${idx + 2}\"><v>${data[idy].sizes[idx] || ''}</v></c>`;\n                            idxColLtr++;\n                        }\n                        strSheetXml += '</row>';\n                    });\n                }\n                else if (chartObject.opts._type === CHART_TYPE.SCATTER) {\n                    /* UNUSED:\n                        strSheetXml += '<cols>'\n                        strSheetXml += '<col min=\"1\" max=\"' + data.length + '\" width=\"11\" customWidth=\"1\" />'\n                        //data.forEach((obj,idx)=>{ strSheetXml += '<col min=\"'+(idx+1)+'\" max=\"'+(idx+1)+'\" width=\"11\" customWidth=\"1\" />' });\n                        strSheetXml += '</cols>'\n                    */\n                    /* EX: INPUT: `data`\n                        [\n                            { name:'X-AxisA', values:[ 1, 2, 3, 4, 5] },\n                            { name:'Y-AxisB', values:[ 2,22,42,52,62] },\n                            { name:'Y-AxisC', values:[ 3,33,43,53,63] }\n                        ];\n                    */\n                    /* EX: OUTPUT: sheet1.xml:\n                        -|----A----|----B----|----C----|\n                        1| X-AxisA | Y-AxisB | Y-AxisC |\n                        2|    1    |    2    |    3    |\n                        -|---------|---------|---------|\n                    */\n                    strSheetXml += '<sheetData>';\n                    // A: Create header row first (every `name` row provided)\n                    strSheetXml += `<row r=\"1\" spans=\"1:${data.length}\">`;\n                    for (let idx = 0; idx < data.length; idx++) {\n                        strSheetXml += `<c r=\"${getExcelColName(idx + 1)}1\" t=\"s\"><v>${idx}</v></c>`; // NOTE: add `t=\"s\"` for label cols!\n                    }\n                    strSheetXml += '</row>';\n                    // B: Add row for each X-Axis value (Y-Axis* value is optional)\n                    data[0].values.forEach((val, idx) => {\n                        // Leading col is reserved for the 'X-Axis' value, so hard-code it, then loop over col values\n                        strSheetXml += `<row r=\"${idx + 2}\" spans=\"1:${data.length}\">`;\n                        strSheetXml += `<c r=\"A${idx + 2}\"><v>${val}</v></c>`;\n                        // Add Y-Axis 1->N\n                        for (let idy = 1; idy < data.length; idy++) {\n                            strSheetXml += `<c r=\"${getExcelColName(idy + 1)}${idx + 2}\"><v>${data[idy].values[idx] || data[idy].values[idx] === 0 ? data[idy].values[idx] : ''}</v></c>`;\n                        }\n                        strSheetXml += '</row>';\n                    });\n                }\n                else {\n                    // strSheetXml += '<cols><col min=\"1\" max=\"1\" width=\"11\" customWidth=\"1\" /></cols>'\n                    strSheetXml += '<sheetData>';\n                    /* EX: INPUT: `data`\n                        [\n                            { name:'Red', labels:['Jan..May-17'], values:[11,13,14,15,16] },\n                            { name:'Amb', labels:['Jan..May-17'], values:[22, 6, 7, 8, 9] },\n                            { name:'Grn', labels:['Jan..May-17'], values:[33,32,42,53,63] }\n                        ];\n                    */\n                    /* EX: OUTPUT: lineChart Worksheet:\n                        -|---A---|--B--|--C--|--D--|\n                        1|       | Red | Amb | Grn |\n                        2|Jan-17 |   11|   22|   33|\n                        3|Feb-17 |   55|   43|   70|\n                        4|Mar-17 |   56|  143|   99|\n                        5|Apr-17 |   65|    3|  120|\n                        6|May-17 |   75|   93|  170|\n                        -|-------|-----|-----|-----|\n                    */\n                    if (!IS_MULTI_CAT_AXES) {\n                        // A: Create header row first\n                        strSheetXml += `<row r=\"1\" spans=\"1:${data.length + data[0].labels.length}\">`;\n                        data[0].labels.forEach((_labelsGroup, idx) => {\n                            strSheetXml += `<c r=\"${getExcelColName(idx + 1)}1\" t=\"s\"><v>0</v></c>`;\n                        });\n                        for (let idx = 0; idx < data.length; idx++) {\n                            strSheetXml += `<c r=\"${getExcelColName(idx + 1 + data[0].labels.length)}1\" t=\"s\"><v>${idx + 1}</v></c>`; // NOTE: use `t=\"s\"` for label cols!\n                        }\n                        strSheetXml += '</row>';\n                        // B: Add data row(s) for each category\n                        data[0].labels[0].forEach((_cat, idx) => {\n                            strSheetXml += `<row r=\"${idx + 2}\" spans=\"1:${data.length + data[0].labels.length}\">`;\n                            // Leading cols are reserved for the label groups\n                            for (let idx2 = data[0].labels.length - 1; idx2 >= 0; idx2--) {\n                                strSheetXml += `<c r=\"${getExcelColName(data[0].labels.length - idx2)}${idx + 2}\" t=\"s\">`;\n                                strSheetXml += `<v>${data.length + idx + 1}</v>`;\n                                strSheetXml += '</c>';\n                            }\n                            for (let idy = 0; idy < data.length; idy++) {\n                                strSheetXml += `<c r=\"${getExcelColName(data[0].labels.length + idy + 1)}${idx + 2}\"><v>${data[idy].values[idx] || ''}</v></c>`;\n                            }\n                            strSheetXml += '</row>';\n                        });\n                    }\n                    else {\n                        // A: create header row\n                        strSheetXml += `<row r=\"1\" spans=\"1:${data.length + data[0].labels.length}\">`;\n                        for (let idx = 0; idx < data[0].labels.length; idx++) {\n                            strSheetXml += `<c r=\"${getExcelColName(idx + 1)}1\" t=\"s\"><v>0</v></c>`;\n                        }\n                        for (let idx = data[0].labels.length - 1; idx < data.length + data[0].labels.length - 1; idx++) {\n                            strSheetXml += `<c r=\"${getExcelColName(idx + data[0].labels.length)}1\" t=\"s\"><v>${idx}</v></c>`; // NOTE: use `t=\"s\"` for label cols!\n                        }\n                        strSheetXml += '</row>';\n                        // FIXME: 20220524 (v3.11.0)\n                        /**\n                         * @example INPUT\n                         * const LABELS = [\n                         *   [\"Gear\", \"Berg\", \"Motr\", \"Swch\", \"Plug\", \"Cord\", \"Pump\", \"Leak\", \"Seal\"],\n                         *   [\"Mech\", \"\", \"\", \"Elec\", \"\", \"\", \"Hydr\", \"\", \"\"],\n                         * ];\n                         * const arrDataRegions = [\n                         *   { name: \"West\", labels: LABELS, values: [11, 8, 3, 0, 11, 3, 0, 0, 0] },\n                         *   { name: \"Ctrl\", labels: LABELS, values: [0, 11, 6, 19, 12, 5, 0, 0, 0] },\n                         *   { name: \"East\", labels: LABELS, values: [0, 3, 2, 0, 0, 0, 4, 3, 1] },\n                         * ];\n                         */\n                        /**\n                         * @example OUTPUT EXCEL SHEET\n                         * |/|---A--|---B--|---C--|---D--|---E--|\n                         * |1|      |      | West | Ctrl | East |\n                         * |2| Mech | Gear |  ##  |  ##  |  ##  |\n                         * |3|      | Brng |  ##  |  ##  |  ##  |\n                         * |4|      | Motr |  ##  |  ##  |  ##  |\n                         * |5| Elec | Swch |  ##  |  ##  |  ##  |\n                         * |6|      | Plug |  ##  |  ##  |  ##  |\n                         * |7|      | Cord |  ##  |  ##  |  ##  |\n                         * |8| Hydr | Pump |  ##  |  ##  |  ##  |\n                         * |9|      | Leak |  ##  |  ##  |  ##  |\n                         *|10|      | Seal |  ##  |  ##  |  ##  |\n                         */\n                        /**\n                         * @example OUTPUT EXCEL SHEET XML\n                         * <row r=\"1\" spans=\"1:5\">\n                         *   <c r=\"A1\" t=\"s\"><v>0</v></c>\n                         *   <c r=\"B1\" t=\"s\"><v>0</v></c>\n                         *   <c r=\"C1\" t=\"s\"><v>1</v></c>\n                         *   <c r=\"D1\" t=\"s\"><v>2</v></c>\n                         *   <c r=\"E1\" t=\"s\"><v>3</v></c>\n                         * </row>\n                         * <row r=\"2\" spans=\"1:5\">\n                         *   <c r=\"A2\" t=\"s\"><v>4</v></c>\n                         *   <c r=\"B2\" t=\"s\"><v>7</v></c>\n                         *   <c r=\"C2\"      ><v>###</v></c>\n                         * </row>\n                         * <row r=\"3\" spans=\"1:5\">\n                         *   <c r=\"A3\" />\n                         *   <c r=\"B3\" t=\"s\"><v>8</v></c>\n                         *   <c r=\"C3\"      ><v>###</v></c>\n                         * </row>\n                         */\n                        /**\n                         * @example SHARED-STRINGS\n                         * 1=West, 2=Ctrl, 3=East, 4=Mech, 5=Elec, 6=Mydr, 7=Gear, 8=Brng, [...], 15=Seal\n                         */\n                        // B: Add data row(s) for each category\n                        /**\n                         * const LABELS = [\n                         *   [\"Gear\", \"Berg\", \"Motr\", \"Swch\", \"Plug\", \"Cord\", \"Pump\", \"Leak\", \"Seal\"],\n                         *   [\"Mech\",     \"\",     \"\", \"Elec\",     \"\",     \"\", \"Hydr\",     \"\",     \"\"],\n                         *   [\"2010\",     \"\",     \"\",     \"\",     \"\",     \"\",     \"\",     \"\",     \"\"],\n                         * ];\n                         */\n                        const TOT_SER = data.length;\n                        const TOT_CAT = data[0].labels[0].length;\n                        const TOT_LVL = data[0].labels.length;\n                        // Iterate across labels/cats as these are the <row>'s\n                        for (let idx = 0; idx < TOT_CAT; idx++) {\n                            // A: start row\n                            strSheetXml += `<row r=\"${idx + 2}\" spans=\"1:${TOT_SER + TOT_LVL}\">`;\n                            // WIP: FIXME:\n                            // B: add a col for each label/cat\n                            let totLabels = TOT_SER;\n                            const revLabelGroups = data[0].labels.slice().reverse();\n                            revLabelGroups.forEach((labelsGroup, idy) => {\n                                /**\n                                 * const LABELS_REVERSED = [\n                                 *   [\"Mech\",     \"\",     \"\", \"Elec\",     \"\",     \"\", \"Hydr\",     \"\",     \"\"],\n                                 *   [\"Gear\", \"Berg\", \"Motr\", \"Swch\", \"Plug\", \"Cord\", \"Pump\", \"Leak\", \"Seal\"],\n                                 * ];\n                                 */\n                                const colLabel = labelsGroup[idx];\n                                if (colLabel) {\n                                    const totGrpLbls = idy === 0 ? 1 : revLabelGroups[idy - 1].filter(label => label && label !== '').length; // get unique label so we can add to get proper shared-string #\n                                    totLabels += totGrpLbls;\n                                    strSheetXml += `<c r=\"${getExcelColName(idx + 1 + idy)}${idx + 2}\" t=\"s\"><v>${totLabels}</v></c>`;\n                                }\n                            });\n                            // WIP: FIXME:\n                            // C: add a col for each data value\n                            for (let idy = 0; idy < TOT_SER; idy++) {\n                                strSheetXml += `<c r=\"${getExcelColName(TOT_LVL + idy + 1)}${idx + 2}\"><v>${data[idy].values[idx] || 0}</v></c>`;\n                            }\n                            // D: Done\n                            strSheetXml += '</row>';\n                        }\n                        // console.log(strSheetXml) // WIP: CHECK:\n                        // console.log(`---CHECK ABOVE---------------------`)\n                    }\n                }\n                strSheetXml += '</sheetData>';\n                /* FIXME: support multi-level\n                if (IS_MULTI_CAT_AXES) {\n                    strSheetXml += '<mergeCells count=\"3\">'\n                    strSheetXml += ' <mergeCell ref=\"A2:A4\"/>'\n                    strSheetXml += ' <mergeCell ref=\"A10:A12\"/>'\n                    strSheetXml += ' <mergeCell ref=\"A5:A9\"/>'\n                    strSheetXml += '</mergeCells>'\n                }\n                */\n                strSheetXml += '<pageMargins left=\"0.7\" right=\"0.7\" top=\"0.75\" bottom=\"0.75\" header=\"0.3\" footer=\"0.3\"/>';\n                // Link the `table1.xml` file to define an actual Table in Excel\n                // NOTE: This only works with scatter charts - all others give a \"cannot find linked file\" error\n                // ....: Since we dont need the table anyway (chart data can be edited/range selected, etc.), just dont use this\n                // ....: Leaving this so nobody foolishly attempts to add this in the future\n                // strSheetXml += '<tableParts count=\"1\"><tablePart r:id=\"rId1\"/></tableParts>'\n                strSheetXml += '</worksheet>\\n';\n                zipExcel.file('xl/worksheets/sheet1.xml', strSheetXml);\n            }\n            // C: Add XLSX to PPTX export\n            zipExcel\n                .generateAsync({ type: 'base64' })\n                .then(content => {\n                // 1: Create the embedded Excel worksheet with labels and data\n                zip.file(`ppt/embeddings/Microsoft_Excel_Worksheet${chartObject.globalId}.xlsx`, content, { base64: true });\n                // 2: Create the chart.xml and rel files\n                zip.file('ppt/charts/_rels/' + chartObject.fileName + '.rels', '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' +\n                    '<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">' +\n                    `<Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/package\" Target=\"../embeddings/Microsoft_Excel_Worksheet${chartObject.globalId}.xlsx\"/>` +\n                    '</Relationships>');\n                zip.file(`ppt/charts/${chartObject.fileName}`, makeXmlCharts(chartObject));\n                // 3: Done\n                resolve('');\n            })\n                .catch(strErr => {\n                reject(strErr);\n            });\n        });\n    });\n}\n/**\n * Main entry point method for create charts\n * @see: http://www.datypic.com/sc/ooxml/s-dml-chart.xsd.html\n * @param {ISlideRelChart} rel - chart object\n * @return {string} XML\n */\nfunction makeXmlCharts(rel) {\n    var _a, _b, _c, _d;\n    let strXml = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>';\n    let usesSecondaryValAxis = false;\n    // STEP 1: Create chart\n    {\n        // CHARTSPACE: BEGIN vvv\n        strXml +=\n            '<c:chartSpace xmlns:c=\"http://schemas.openxmlformats.org/drawingml/2006/chart\" xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\">';\n        strXml += '<c:date1904 val=\"0\"/>'; // ppt defaults to 1904 dates, excel to 1900\n        strXml += `<c:roundedCorners val=\"${rel.opts.chartArea.roundedCorners ? '1' : '0'}\"/>`;\n        strXml += '<c:chart>';\n        // OPTION: Title\n        if (rel.opts.showTitle) {\n            strXml += genXmlTitle({\n                title: rel.opts.title || 'Chart Title',\n                color: rel.opts.titleColor,\n                fontFace: rel.opts.titleFontFace,\n                fontSize: rel.opts.titleFontSize || DEF_FONT_TITLE_SIZE,\n                titleAlign: rel.opts.titleAlign,\n                titleBold: rel.opts.titleBold,\n                titlePos: rel.opts.titlePos,\n                titleRotate: rel.opts.titleRotate,\n            }, rel.opts.x, rel.opts.y);\n            strXml += '<c:autoTitleDeleted val=\"0\"/>';\n        }\n        else {\n            // NOTE: Add autoTitleDeleted tag in else to prevent default creation of chart title even when showTitle is set to false\n            strXml += '<c:autoTitleDeleted val=\"1\"/>';\n        }\n        /** Add 3D view tag\n         * @see: https://c-rex.net/projects/samples/ooxml/e1/Part4/OOXML_P4_DOCX_perspective_topic_ID0E6BUQB.html\n         */\n        if (rel.opts._type === CHART_TYPE.BAR3D) {\n            strXml += `<c:view3D><c:rotX val=\"${rel.opts.v3DRotX}\"/><c:rotY val=\"${rel.opts.v3DRotY}\"/><c:rAngAx val=\"${!rel.opts.v3DRAngAx ? 0 : 1}\"/><c:perspective val=\"${rel.opts.v3DPerspective}\"/></c:view3D>`;\n        }\n        strXml += '<c:plotArea>';\n        // IMPORTANT: Dont specify layout to enable auto-fit: PPT does a great job maximizing space with all 4 TRBL locations\n        if (rel.opts.layout) {\n            strXml += '<c:layout>';\n            strXml += ' <c:manualLayout>';\n            strXml += '  <c:layoutTarget val=\"inner\" />';\n            strXml += '  <c:xMode val=\"edge\" />';\n            strXml += '  <c:yMode val=\"edge\" />';\n            strXml += '  <c:x val=\"' + (rel.opts.layout.x || 0) + '\" />';\n            strXml += '  <c:y val=\"' + (rel.opts.layout.y || 0) + '\" />';\n            strXml += '  <c:w val=\"' + (rel.opts.layout.w || 1) + '\" />';\n            strXml += '  <c:h val=\"' + (rel.opts.layout.h || 1) + '\" />';\n            strXml += ' </c:manualLayout>';\n            strXml += '</c:layout>';\n        }\n        else {\n            strXml += '<c:layout/>';\n        }\n    }\n    // A: Create Chart XML -----------------------------------------------------------\n    if (Array.isArray(rel.opts._type)) {\n        rel.opts._type.forEach(type => {\n            // TODO: FIXME: theres `options` on chart rels??\n            const options = Object.assign(Object.assign({}, rel.opts), type.options);\n            // let options: IChartOptsLib = { type: type.type, }\n            const valAxisId = options.secondaryValAxis ? AXIS_ID_VALUE_SECONDARY : AXIS_ID_VALUE_PRIMARY;\n            const catAxisId = options.secondaryCatAxis ? AXIS_ID_CATEGORY_SECONDARY : AXIS_ID_CATEGORY_PRIMARY;\n            usesSecondaryValAxis = usesSecondaryValAxis || options.secondaryValAxis;\n            strXml += makeChartType(type.type, type.data, options, valAxisId, catAxisId);\n        });\n    }\n    else {\n        strXml += makeChartType(rel.opts._type, rel.data, rel.opts, AXIS_ID_VALUE_PRIMARY, AXIS_ID_CATEGORY_PRIMARY);\n    }\n    // B: Axes -----------------------------------------------------------\n    if (rel.opts._type !== CHART_TYPE.PIE && rel.opts._type !== CHART_TYPE.DOUGHNUT) {\n        // Param check\n        if (rel.opts.valAxes && rel.opts.valAxes.length > 1 && !usesSecondaryValAxis) {\n            throw new Error('Secondary axis must be used by one of the multiple charts');\n        }\n        if (rel.opts.catAxes) {\n            if (!rel.opts.valAxes || rel.opts.valAxes.length !== rel.opts.catAxes.length) {\n                throw new Error('There must be the same number of value and category axes.');\n            }\n            strXml += makeCatAxis(Object.assign(Object.assign({}, rel.opts), rel.opts.catAxes[0]), AXIS_ID_CATEGORY_PRIMARY, AXIS_ID_VALUE_PRIMARY);\n        }\n        else {\n            strXml += makeCatAxis(rel.opts, AXIS_ID_CATEGORY_PRIMARY, AXIS_ID_VALUE_PRIMARY);\n        }\n        if (rel.opts.valAxes) {\n            strXml += makeValAxis(Object.assign(Object.assign({}, rel.opts), rel.opts.valAxes[0]), AXIS_ID_VALUE_PRIMARY);\n            if (rel.opts.valAxes[1]) {\n                strXml += makeValAxis(Object.assign(Object.assign({}, rel.opts), rel.opts.valAxes[1]), AXIS_ID_VALUE_SECONDARY);\n            }\n        }\n        else {\n            strXml += makeValAxis(rel.opts, AXIS_ID_VALUE_PRIMARY);\n            // Add series axis for 3D bar\n            if (rel.opts._type === CHART_TYPE.BAR3D) {\n                strXml += makeSerAxis(rel.opts, AXIS_ID_SERIES_PRIMARY, AXIS_ID_VALUE_PRIMARY);\n            }\n        }\n        // Combo Charts: Add secondary axes after all vals\n        if (((_a = rel.opts) === null || _a === void 0 ? void 0 : _a.catAxes) && ((_b = rel.opts) === null || _b === void 0 ? void 0 : _b.catAxes[1])) {\n            strXml += makeCatAxis(Object.assign(Object.assign({}, rel.opts), rel.opts.catAxes[1]), AXIS_ID_CATEGORY_SECONDARY, AXIS_ID_VALUE_SECONDARY);\n        }\n    }\n    // C: Chart Properties and plotArea Options: Border, Data Table, Fill, Legend\n    {\n        // NOTE: DataTable goes between '</c:valAx>' and '<c:spPr>'\n        if (rel.opts.showDataTable) {\n            strXml += '<c:dTable>';\n            strXml += `  <c:showHorzBorder val=\"${!rel.opts.showDataTableHorzBorder ? 0 : 1}\"/>`;\n            strXml += `  <c:showVertBorder val=\"${!rel.opts.showDataTableVertBorder ? 0 : 1}\"/>`;\n            strXml += `  <c:showOutline    val=\"${!rel.opts.showDataTableOutline ? 0 : 1}\"/>`;\n            strXml += `  <c:showKeys       val=\"${!rel.opts.showDataTableKeys ? 0 : 1}\"/>`;\n            strXml += '  <c:spPr>';\n            strXml += '    <a:noFill/>';\n            strXml += '    <a:ln w=\"9525\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"><a:solidFill><a:schemeClr val=\"tx1\"><a:lumMod val=\"15000\"/><a:lumOff val=\"85000\"/></a:schemeClr></a:solidFill><a:round/></a:ln>';\n            strXml += '    <a:effectLst/>';\n            strXml += '  </c:spPr>';\n            strXml += '  <c:txPr>';\n            strXml += '   <a:bodyPr rot=\"0\" spcFirstLastPara=\"1\" vertOverflow=\"ellipsis\" vert=\"horz\" wrap=\"square\" anchor=\"ctr\" anchorCtr=\"1\"/>';\n            strXml += '   <a:lstStyle/>';\n            strXml += '   <a:p>';\n            strXml += '     <a:pPr rtl=\"0\">';\n            strXml += `       <a:defRPr sz=\"${Math.round((rel.opts.dataTableFontSize || DEF_FONT_SIZE) * 100)}\" b=\"0\" i=\"0\" u=\"none\" strike=\"noStrike\" kern=\"1200\" baseline=\"0\">`;\n            strXml += '         <a:solidFill><a:schemeClr val=\"tx1\"><a:lumMod val=\"65000\"/><a:lumOff val=\"35000\"/></a:schemeClr></a:solidFill>';\n            strXml += '         <a:latin typeface=\"+mn-lt\"/>';\n            strXml += '         <a:ea typeface=\"+mn-ea\"/>';\n            strXml += '         <a:cs typeface=\"+mn-cs\"/>';\n            strXml += '       </a:defRPr>';\n            strXml += '     </a:pPr>';\n            strXml += '    <a:endParaRPr lang=\"en-US\"/>';\n            strXml += '   </a:p>';\n            strXml += ' </c:txPr>';\n            strXml += '</c:dTable>';\n        }\n        strXml += '  <c:spPr>';\n        // OPTION: Fill\n        strXml += ((_c = rel.opts.plotArea.fill) === null || _c === void 0 ? void 0 : _c.color) ? genXmlColorSelection(rel.opts.plotArea.fill) : '<a:noFill/>';\n        // OPTION: Border\n        strXml += rel.opts.plotArea.border\n            ? `<a:ln w=\"${valToPts(rel.opts.plotArea.border.pt)}\" cap=\"flat\">${genXmlColorSelection(rel.opts.plotArea.border.color)}</a:ln>`\n            : '<a:ln><a:noFill/></a:ln>';\n        // Close shapeProp/plotArea before Legend\n        strXml += '    <a:effectLst/>';\n        strXml += '  </c:spPr>';\n        strXml += '</c:plotArea>';\n        // OPTION: Legend\n        // IMPORTANT: Dont specify layout to enable auto-fit: PPT does a great job maximizing space with all 4 TRBL locations\n        if (rel.opts.showLegend) {\n            strXml += '<c:legend>';\n            strXml += '<c:legendPos val=\"' + rel.opts.legendPos + '\"/>';\n            // strXml += '<c:layout/>'\n            strXml += '<c:overlay val=\"0\"/>';\n            if (rel.opts.legendFontFace || rel.opts.legendFontSize || rel.opts.legendColor) {\n                strXml += '<c:txPr>';\n                strXml += '  <a:bodyPr/>';\n                strXml += '  <a:lstStyle/>';\n                strXml += '  <a:p>';\n                strXml += '    <a:pPr>';\n                strXml += rel.opts.legendFontSize ? `<a:defRPr sz=\"${Math.round(Number(rel.opts.legendFontSize) * 100)}\">` : '<a:defRPr>';\n                if (rel.opts.legendColor)\n                    strXml += genXmlColorSelection(rel.opts.legendColor);\n                if (rel.opts.legendFontFace)\n                    strXml += '<a:latin typeface=\"' + rel.opts.legendFontFace + '\"/>';\n                if (rel.opts.legendFontFace)\n                    strXml += '<a:cs    typeface=\"' + rel.opts.legendFontFace + '\"/>';\n                strXml += '      </a:defRPr>';\n                strXml += '    </a:pPr>';\n                strXml += '    <a:endParaRPr lang=\"en-US\"/>';\n                strXml += '  </a:p>';\n                strXml += '</c:txPr>';\n            }\n            strXml += '</c:legend>';\n        }\n    }\n    strXml += '  <c:plotVisOnly val=\"1\"/>';\n    strXml += '  <c:dispBlanksAs val=\"' + rel.opts.displayBlanksAs + '\"/>';\n    if (rel.opts._type === CHART_TYPE.SCATTER)\n        strXml += '<c:showDLblsOverMax val=\"1\"/>';\n    strXml += '</c:chart>';\n    // D: CHARTSPACE SHAPE PROPS\n    strXml += '<c:spPr>';\n    strXml += ((_d = rel.opts.chartArea.fill) === null || _d === void 0 ? void 0 : _d.color) ? genXmlColorSelection(rel.opts.chartArea.fill) : '<a:noFill/>';\n    strXml += rel.opts.chartArea.border\n        ? `<a:ln w=\"${valToPts(rel.opts.chartArea.border.pt)}\" cap=\"flat\">${genXmlColorSelection(rel.opts.chartArea.border.color)}</a:ln>`\n        : '<a:ln><a:noFill/></a:ln>';\n    strXml += '  <a:effectLst/>';\n    strXml += '</c:spPr>';\n    // E: DATA (Add relID)\n    strXml += '<c:externalData r:id=\"rId1\"><c:autoUpdate val=\"0\"/></c:externalData>';\n    // LAST: chartSpace end\n    strXml += '</c:chartSpace>';\n    return strXml;\n}\n/**\n * Create XML string for any given chart type\n * @param {CHART_NAME} chartType chart type name\n * @param {IOptsChartData[]} data chart data\n * @param {IChartOptsLib} opts chart options\n * @param {string} valAxisId chart val axis id\n * @param {string} catAxisId chart cat axis id\n * @param {boolean} isMultiTypeChart is this a mutli-type chart?\n * @example 'bubble' returns <c:bubbleChart></c>\n * @example '<c:lineChart>'\n * @return {string} XML chart\n */\nfunction makeChartType(chartType, data, opts, valAxisId, catAxisId, isMultiTypeChart) {\n    // NOTE: \"Chart Range\" (as shown in \"select Chart Area dialog\") is calculated.\n    // ....: Ensure each X/Y Axis/Col has same row height (esp. applicable to XY Scatter where X can often be larger than Y's)\n    let colorIndex = -1; // Maintain the color index by region\n    let idxColLtr = 1;\n    let optsChartData = null;\n    let strXml = '';\n    switch (chartType) {\n        case CHART_TYPE.AREA:\n        case CHART_TYPE.BAR:\n        case CHART_TYPE.BAR3D:\n        case CHART_TYPE.LINE:\n        case CHART_TYPE.RADAR:\n            // 1: Start Chart\n            strXml += `<c:${chartType}Chart>`;\n            if (chartType === CHART_TYPE.AREA && opts.barGrouping === 'stacked') {\n                strXml += '<c:grouping val=\"' + opts.barGrouping + '\"/>';\n            }\n            if (chartType === CHART_TYPE.BAR || chartType === CHART_TYPE.BAR3D) {\n                strXml += '<c:barDir val=\"' + opts.barDir + '\"/>';\n                strXml += '<c:grouping val=\"' + (opts.barGrouping || 'clustered') + '\"/>';\n            }\n            if (chartType === CHART_TYPE.RADAR) {\n                strXml += '<c:radarStyle val=\"' + opts.radarStyle + '\"/>';\n            }\n            strXml += '<c:varyColors val=\"0\"/>';\n            // 2: \"Series\" block for every data row\n            /* EX1:\n                data: [\n                 {\n                   name: 'Region 1',\n                   labels: [['April', 'May', 'June', 'July']],\n                   values: [17, 26, 53, 96]\n                 },\n                 {\n                   name: 'Region 2',\n                   labels: [['April', 'May', 'June', 'July']],\n                   values: [55, 43, 70, 58]\n                 }\n                ]\n            */\n            /* EX2:\n                data: [\n                 {\n                   name: 'Region 1',\n                   labels: [\n                       ['April', 'May', 'June', 'April', 'May', 'June'],\n                       ['2020',     '',     '', '2021',     '',     '']\n                   ],\n                   values: [17, 26, 53, 96, 40, 33]\n                 },\n                 {\n                   name: 'Region 2',\n                   labels: [\n                       ['April', 'May', 'June', 'April', 'May', 'June'],\n                       ['2020',     '',     '', '2021',     '',     '']\n                   ],\n                   values: [55, 43, 70, 58, 78, 63]\n                 }\n                ]\n             */\n            data.forEach(obj => {\n                var _a;\n                colorIndex++;\n                strXml += '<c:ser>';\n                strXml += `  <c:idx val=\"${obj._dataIndex}\"/><c:order val=\"${obj._dataIndex}\"/>`;\n                strXml += '  <c:tx>';\n                strXml += '    <c:strRef>';\n                strXml += '      <c:f>Sheet1!$' + getExcelColName(obj._dataIndex + obj.labels.length + 1) + '$1</c:f>';\n                strXml += '      <c:strCache><c:ptCount val=\"1\"/><c:pt idx=\"0\"><c:v>' + encodeXmlEntities(obj.name) + '</c:v></c:pt></c:strCache>';\n                strXml += '    </c:strRef>';\n                strXml += '  </c:tx>';\n                // Fill and Border\n                // TODO: CURRENT: Pull#727\n                // TODO: let seriesColor = obj.color ? obj.color : opts.chartColors ? opts.chartColors[colorIndex % opts.chartColors.length] : null\n                const seriesColor = opts.chartColors ? opts.chartColors[colorIndex % opts.chartColors.length] : null;\n                strXml += '  <c:spPr>';\n                if (seriesColor === 'transparent') {\n                    strXml += '<a:noFill/>';\n                }\n                else if (opts.chartColorsOpacity) {\n                    strXml += '<a:solidFill>' + createColorElement(seriesColor, `<a:alpha val=\"${Math.round(opts.chartColorsOpacity * 1000)}\"/>`) + '</a:solidFill>';\n                }\n                else {\n                    strXml += '<a:solidFill>' + createColorElement(seriesColor) + '</a:solidFill>';\n                }\n                if (chartType === CHART_TYPE.LINE || chartType === CHART_TYPE.RADAR) {\n                    if (opts.lineSize === 0) {\n                        strXml += '<a:ln><a:noFill/></a:ln>';\n                    }\n                    else {\n                        strXml += `<a:ln w=\"${valToPts(opts.lineSize)}\" cap=\"${createLineCap(opts.lineCap)}\"><a:solidFill>${createColorElement(seriesColor)}</a:solidFill>`;\n                        strXml += '<a:prstDash val=\"' + (opts.lineDash || 'solid') + '\"/><a:round/></a:ln>';\n                    }\n                }\n                else if (opts.dataBorder) {\n                    strXml += `<a:ln w=\"${valToPts(opts.dataBorder.pt)}\" cap=\"${createLineCap(opts.lineCap)}\"><a:solidFill>${createColorElement(opts.dataBorder.color)}</a:solidFill><a:prstDash val=\"solid\"/><a:round/></a:ln>`;\n                }\n                strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);\n                strXml += '  </c:spPr>';\n                strXml += '  <c:invertIfNegative val=\"0\"/>';\n                // Data Labels per series\n                // NOTE: [20190117] Adding these to RADAR chart causes unrecoverable corruption!\n                if (chartType !== CHART_TYPE.RADAR) {\n                    strXml += '<c:dLbls>';\n                    strXml += `<c:numFmt formatCode=\"${encodeXmlEntities(opts.dataLabelFormatCode) || 'General'}\" sourceLinked=\"0\"/>`;\n                    if (opts.dataLabelBkgrdColors)\n                        strXml += `<c:spPr><a:solidFill>${createColorElement(seriesColor)}</a:solidFill></c:spPr>`;\n                    strXml += '<c:txPr><a:bodyPr/><a:lstStyle/><a:p><a:pPr>';\n                    strXml += `<a:defRPr b=\"${opts.dataLabelFontBold ? 1 : 0}\" i=\"${opts.dataLabelFontItalic ? 1 : 0}\" strike=\"noStrike\" sz=\"${Math.round((opts.dataLabelFontSize || DEF_FONT_SIZE) * 100)}\" u=\"none\">`;\n                    strXml += `<a:solidFill>${createColorElement(opts.dataLabelColor || DEF_FONT_COLOR)}</a:solidFill>`;\n                    strXml += `<a:latin typeface=\"${opts.dataLabelFontFace || 'Arial'}\"/>`;\n                    strXml += '</a:defRPr></a:pPr></a:p></c:txPr>';\n                    if (opts.dataLabelPosition)\n                        strXml += `<c:dLblPos val=\"${opts.dataLabelPosition}\"/>`;\n                    strXml += '<c:showLegendKey val=\"0\"/>';\n                    strXml += `<c:showVal val=\"${opts.showValue ? '1' : '0'}\"/>`;\n                    strXml += `<c:showCatName val=\"0\"/><c:showSerName val=\"${opts.showSerName ? '1' : '0'}\"/><c:showPercent val=\"0\"/><c:showBubbleSize val=\"0\"/>`;\n                    strXml += `<c:showLeaderLines val=\"${opts.showLeaderLines ? '1' : '0'}\"/>`;\n                    strXml += '</c:dLbls>';\n                }\n                // 'c:marker' tag: `lineDataSymbol`\n                if (chartType === CHART_TYPE.LINE || chartType === CHART_TYPE.RADAR) {\n                    strXml += '<c:marker>';\n                    strXml += '  <c:symbol val=\"' + opts.lineDataSymbol + '\"/>';\n                    if (opts.lineDataSymbolSize)\n                        strXml += `<c:size val=\"${opts.lineDataSymbolSize}\"/>`; // Defaults to \"auto\" otherwise (but this is usually too small, so there is a default)\n                    strXml += '  <c:spPr>';\n                    strXml += `    <a:solidFill>${createColorElement(opts.chartColors[obj._dataIndex + 1 > opts.chartColors.length ? Math.floor(Math.random() * opts.chartColors.length) : obj._dataIndex])}</a:solidFill>`;\n                    strXml += `    <a:ln w=\"${opts.lineDataSymbolLineSize}\" cap=\"flat\"><a:solidFill>${createColorElement(opts.lineDataSymbolLineColor || seriesColor)}</a:solidFill><a:prstDash val=\"solid\"/><a:round/></a:ln>`;\n                    strXml += '    <a:effectLst/>';\n                    strXml += '  </c:spPr>';\n                    strXml += '</c:marker>';\n                }\n                // Allow users with a single data set to pass their own array of colors (check for this using != ours)\n                // Color chart bars various colors when >1 color\n                // NOTE: `<c:dPt>` created with various colors will change PPT legend by design so each dataPt/color is an legend item!\n                if ((chartType === CHART_TYPE.BAR || chartType === CHART_TYPE.BAR3D) &&\n                    data.length === 1 &&\n                    ((opts.chartColors && opts.chartColors !== BARCHART_COLORS && opts.chartColors.length > 1) || ((_a = opts.invertedColors) === null || _a === void 0 ? void 0 : _a.length))) {\n                    // Series Data Point colors\n                    obj.values.forEach((value, index) => {\n                        const arrColors = value < 0 ? opts.invertedColors || opts.chartColors || BARCHART_COLORS : opts.chartColors || [];\n                        strXml += '  <c:dPt>';\n                        strXml += `    <c:idx val=\"${index}\"/>`;\n                        strXml += '      <c:invertIfNegative val=\"0\"/>';\n                        strXml += '    <c:bubble3D val=\"0\"/>';\n                        strXml += '    <c:spPr>';\n                        if (opts.lineSize === 0) {\n                            strXml += '<a:ln><a:noFill/></a:ln>';\n                        }\n                        else if (chartType === CHART_TYPE.BAR) {\n                            strXml += '<a:solidFill>';\n                            strXml += '  <a:srgbClr val=\"' + arrColors[index % arrColors.length] + '\"/>';\n                            strXml += '</a:solidFill>';\n                        }\n                        else {\n                            strXml += '<a:ln>';\n                            strXml += '  <a:solidFill>';\n                            strXml += '   <a:srgbClr val=\"' + arrColors[index % arrColors.length] + '\"/>';\n                            strXml += '  </a:solidFill>';\n                            strXml += '</a:ln>';\n                        }\n                        strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);\n                        strXml += '    </c:spPr>';\n                        strXml += '  </c:dPt>';\n                    });\n                }\n                // 2: \"Categories\"\n                {\n                    strXml += '<c:cat>';\n                    if (opts.catLabelFormatCode) {\n                        // Use 'numRef' as catLabelFormatCode implies that we are expecting numbers here\n                        strXml += '  <c:numRef>';\n                        strXml += `    <c:f>Sheet1!$A$2:$A$${obj.labels[0].length + 1}</c:f>`;\n                        strXml += '    <c:numCache>';\n                        strXml += '      <c:formatCode>' + (opts.catLabelFormatCode || 'General') + '</c:formatCode>';\n                        strXml += `      <c:ptCount val=\"${obj.labels[0].length}\"/>`;\n                        obj.labels[0].forEach((label, idx) => (strXml += `<c:pt idx=\"${idx}\"><c:v>${encodeXmlEntities(label)}</c:v></c:pt>`));\n                        strXml += '    </c:numCache>';\n                        strXml += '  </c:numRef>';\n                    }\n                    else {\n                        strXml += '  <c:multiLvlStrRef>';\n                        strXml += `    <c:f>Sheet1!$A$2:$${getExcelColName(obj.labels.length)}$${obj.labels[0].length + 1}</c:f>`;\n                        strXml += '    <c:multiLvlStrCache>';\n                        strXml += `      <c:ptCount val=\"${obj.labels[0].length}\"/>`;\n                        obj.labels.forEach(labelsGroup => {\n                            strXml += '<c:lvl>';\n                            labelsGroup.forEach((label, idx) => (strXml += `<c:pt idx=\"${idx}\"><c:v>${encodeXmlEntities(label)}</c:v></c:pt>`));\n                            strXml += '</c:lvl>';\n                        });\n                        strXml += '    </c:multiLvlStrCache>';\n                        strXml += '  </c:multiLvlStrRef>';\n                    }\n                    strXml += '</c:cat>';\n                }\n                // 3: \"Values\"\n                {\n                    strXml += '<c:val>';\n                    strXml += '  <c:numRef>';\n                    strXml += `<c:f>Sheet1!$${getExcelColName(obj._dataIndex + obj.labels.length + 1)}$2:$${getExcelColName(obj._dataIndex + obj.labels.length + 1)}$${obj.labels[0].length + 1}</c:f>`;\n                    strXml += '    <c:numCache>';\n                    strXml += '      <c:formatCode>' + (opts.valLabelFormatCode || opts.dataTableFormatCode || 'General') + '</c:formatCode>';\n                    strXml += `      <c:ptCount val=\"${obj.labels[0].length}\"/>`;\n                    obj.values.forEach((value, idx) => (strXml += `<c:pt idx=\"${idx}\"><c:v>${value || value === 0 ? value : ''}</c:v></c:pt>`));\n                    strXml += '    </c:numCache>';\n                    strXml += '  </c:numRef>';\n                    strXml += '</c:val>';\n                }\n                // Option: `smooth`\n                if (chartType === CHART_TYPE.LINE)\n                    strXml += '<c:smooth val=\"' + (opts.lineSmooth ? '1' : '0') + '\"/>';\n                // 4: Close \"SERIES\"\n                strXml += '</c:ser>';\n            });\n            // 3: \"Data Labels\"\n            {\n                strXml += '  <c:dLbls>';\n                strXml += `    <c:numFmt formatCode=\"${encodeXmlEntities(opts.dataLabelFormatCode) || 'General'}\" sourceLinked=\"0\"/>`;\n                strXml += '    <c:txPr>';\n                strXml += '      <a:bodyPr/>';\n                strXml += '      <a:lstStyle/>';\n                strXml += '      <a:p><a:pPr>';\n                strXml += `        <a:defRPr b=\"${opts.dataLabelFontBold ? 1 : 0}\" i=\"${opts.dataLabelFontItalic ? 1 : 0}\" strike=\"noStrike\" sz=\"${Math.round((opts.dataLabelFontSize || DEF_FONT_SIZE) * 100)}\" u=\"none\">`;\n                strXml += '          <a:solidFill>' + createColorElement(opts.dataLabelColor || DEF_FONT_COLOR) + '</a:solidFill>';\n                strXml += '          <a:latin typeface=\"' + (opts.dataLabelFontFace || 'Arial') + '\"/>';\n                strXml += '        </a:defRPr>';\n                strXml += '      </a:pPr></a:p>';\n                strXml += '    </c:txPr>';\n                if (opts.dataLabelPosition)\n                    strXml += ' <c:dLblPos val=\"' + opts.dataLabelPosition + '\"/>';\n                strXml += '    <c:showLegendKey val=\"0\"/>';\n                strXml += '    <c:showVal val=\"' + (opts.showValue ? '1' : '0') + '\"/>';\n                strXml += '    <c:showCatName val=\"0\"/>';\n                strXml += '    <c:showSerName val=\"' + (opts.showSerName ? '1' : '0') + '\"/>';\n                strXml += '    <c:showPercent val=\"0\"/>';\n                strXml += '    <c:showBubbleSize val=\"0\"/>';\n                strXml += `    <c:showLeaderLines val=\"${opts.showLeaderLines ? '1' : '0'}\"/>`;\n                strXml += '  </c:dLbls>';\n            }\n            // 4: Add more chart options (gapWidth, line Marker, etc.)\n            if (chartType === CHART_TYPE.BAR) {\n                strXml += `  <c:gapWidth val=\"${opts.barGapWidthPct}\"/>`;\n                strXml += `  <c:overlap val=\"${(opts.barGrouping || '').includes('tacked') ? 100 : opts.barOverlapPct ? opts.barOverlapPct : 0}\"/>`;\n            }\n            else if (chartType === CHART_TYPE.BAR3D) {\n                strXml += `  <c:gapWidth val=\"${opts.barGapWidthPct}\"/>`;\n                strXml += `  <c:gapDepth val=\"${opts.barGapDepthPct}\"/>`;\n                strXml += '  <c:shape val=\"' + opts.bar3DShape + '\"/>';\n            }\n            else if (chartType === CHART_TYPE.LINE) {\n                strXml += '  <c:marker val=\"1\"/>';\n            }\n            // 5: Add axisId (NOTE: order matters! (category comes first))\n            strXml += `<c:axId val=\"${catAxisId}\"/><c:axId val=\"${valAxisId}\"/><c:axId val=\"${AXIS_ID_SERIES_PRIMARY}\"/>`;\n            // 6: Close Chart tag\n            strXml += `</c:${chartType}Chart>`;\n            // end switch\n            break;\n        case CHART_TYPE.SCATTER:\n            /*\n                `data` = [\n                    { name:'X-Axis',    values:[1,2,3,4,5,6,7,8,9,10,11,12] },\n                    { name:'Y-Value 1', values:[13, 20, 21, 25] },\n                    { name:'Y-Value 2', values:[ 1,  2,  5,  9] }\n                ];\n            */\n            // 1: Start Chart\n            strXml += '<c:' + chartType + 'Chart>';\n            strXml += '<c:scatterStyle val=\"lineMarker\"/>';\n            strXml += '<c:varyColors val=\"0\"/>';\n            // 2: Series: (One for each Y-Axis)\n            colorIndex = -1;\n            data.filter((_obj, idx) => idx > 0).forEach((obj, idx) => {\n                colorIndex++;\n                strXml += '<c:ser>';\n                strXml += `  <c:idx val=\"${idx}\"/>`;\n                strXml += `  <c:order val=\"${idx}\"/>`;\n                strXml += '  <c:tx>';\n                strXml += '    <c:strRef>';\n                strXml += `      <c:f>Sheet1!$${getExcelColName(idx + 2)}$1</c:f>`;\n                strXml += '      <c:strCache><c:ptCount val=\"1\"/><c:pt idx=\"0\"><c:v>' + encodeXmlEntities(obj.name) + '</c:v></c:pt></c:strCache>';\n                strXml += '    </c:strRef>';\n                strXml += '  </c:tx>';\n                // 'c:spPr': Fill, Border, Line, LineStyle (dash, etc.), Shadow\n                strXml += '  <c:spPr>';\n                {\n                    const tmpSerColor = opts.chartColors[colorIndex % opts.chartColors.length];\n                    if (tmpSerColor === 'transparent') {\n                        strXml += '<a:noFill/>';\n                    }\n                    else if (opts.chartColorsOpacity) {\n                        strXml += '<a:solidFill>' + createColorElement(tmpSerColor, '<a:alpha val=\"' + Math.round(opts.chartColorsOpacity * 1000).toString() + '\"/>') + '</a:solidFill>';\n                    }\n                    else {\n                        strXml += '<a:solidFill>' + createColorElement(tmpSerColor) + '</a:solidFill>';\n                    }\n                    if (opts.lineSize === 0) {\n                        strXml += '<a:ln><a:noFill/></a:ln>';\n                    }\n                    else {\n                        strXml += `<a:ln w=\"${valToPts(opts.lineSize)}\" cap=\"${createLineCap(opts.lineCap)}\"><a:solidFill>${createColorElement(tmpSerColor)}</a:solidFill>`;\n                        strXml += `<a:prstDash val=\"${opts.lineDash || 'solid'}\"/><a:round/></a:ln>`;\n                    }\n                    // Shadow\n                    strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);\n                }\n                strXml += '  </c:spPr>';\n                // 'c:marker' tag: `lineDataSymbol`\n                {\n                    strXml += '<c:marker>';\n                    strXml += '  <c:symbol val=\"' + opts.lineDataSymbol + '\"/>';\n                    if (opts.lineDataSymbolSize) {\n                        // Defaults to \"auto\" otherwise (but this is usually too small, so there is a default)\n                        strXml += `<c:size val=\"${opts.lineDataSymbolSize}\"/>`;\n                    }\n                    strXml += '<c:spPr>';\n                    strXml += `<a:solidFill>${createColorElement(opts.chartColors[idx + 1 > opts.chartColors.length ? Math.floor(Math.random() * opts.chartColors.length) : idx])}</a:solidFill>`;\n                    strXml += `<a:ln w=\"${opts.lineDataSymbolLineSize}\" cap=\"flat\"><a:solidFill>${createColorElement(opts.lineDataSymbolLineColor || opts.chartColors[colorIndex % opts.chartColors.length])}</a:solidFill><a:prstDash val=\"solid\"/><a:round/></a:ln>`;\n                    strXml += '<a:effectLst/>';\n                    strXml += '</c:spPr>';\n                    strXml += '</c:marker>';\n                }\n                // Option: scatter data point labels\n                if (opts.showLabel) {\n                    const chartUuid = getUuid('-xxxx-xxxx-xxxx-xxxxxxxxxxxx');\n                    if (obj.labels[0] && (opts.dataLabelFormatScatter === 'custom' || opts.dataLabelFormatScatter === 'customXY')) {\n                        strXml += '<c:dLbls>';\n                        obj.labels[0].forEach((label, idx) => {\n                            if (opts.dataLabelFormatScatter === 'custom' || opts.dataLabelFormatScatter === 'customXY') {\n                                strXml += '  <c:dLbl>';\n                                strXml += `    <c:idx val=\"${idx}\"/>`;\n                                strXml += '    <c:tx>';\n                                strXml += '      <c:rich>';\n                                strXml += '            <a:bodyPr>';\n                                strXml += '                <a:spAutoFit/>';\n                                strXml += '            </a:bodyPr>';\n                                strXml += '            <a:lstStyle/>';\n                                strXml += '            <a:p>';\n                                strXml += '                <a:pPr>';\n                                strXml += '                    <a:defRPr/>';\n                                strXml += '                </a:pPr>';\n                                strXml += '              <a:r>';\n                                strXml += '                    <a:rPr lang=\"' + (opts.lang || 'en-US') + '\" dirty=\"0\"/>';\n                                strXml += '                    <a:t>' + encodeXmlEntities(label) + '</a:t>';\n                                strXml += '              </a:r>';\n                                // Apply XY values at end of custom label\n                                // Do not apply the values if the label was empty or just spaces\n                                // This allows for selective labelling where required\n                                if (opts.dataLabelFormatScatter === 'customXY' && !/^ *$/.test(label)) {\n                                    strXml += '              <a:r>';\n                                    strXml += '                  <a:rPr lang=\"' + (opts.lang || 'en-US') + '\" baseline=\"0\" dirty=\"0\"/>';\n                                    strXml += '                  <a:t> (</a:t>';\n                                    strXml += '              </a:r>';\n                                    strXml += '              <a:fld id=\"{' + getUuid('xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx') + '}\" type=\"XVALUE\">';\n                                    strXml += '                  <a:rPr lang=\"' + (opts.lang || 'en-US') + '\" baseline=\"0\"/>';\n                                    strXml += '                  <a:pPr>';\n                                    strXml += '                      <a:defRPr/>';\n                                    strXml += '                  </a:pPr>';\n                                    strXml += '                  <a:t>[' + encodeXmlEntities(obj.name) + '</a:t>';\n                                    strXml += '              </a:fld>';\n                                    strXml += '              <a:r>';\n                                    strXml += '                  <a:rPr lang=\"' + (opts.lang || 'en-US') + '\" baseline=\"0\" dirty=\"0\"/>';\n                                    strXml += '                  <a:t>, </a:t>';\n                                    strXml += '              </a:r>';\n                                    strXml += '              <a:fld id=\"{' + getUuid('xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx') + '}\" type=\"YVALUE\">';\n                                    strXml += '                  <a:rPr lang=\"' + (opts.lang || 'en-US') + '\" baseline=\"0\"/>';\n                                    strXml += '                  <a:pPr>';\n                                    strXml += '                      <a:defRPr/>';\n                                    strXml += '                  </a:pPr>';\n                                    strXml += '                  <a:t>[' + encodeXmlEntities(obj.name) + ']</a:t>';\n                                    strXml += '              </a:fld>';\n                                    strXml += '              <a:r>';\n                                    strXml += '                  <a:rPr lang=\"' + (opts.lang || 'en-US') + '\" baseline=\"0\" dirty=\"0\"/>';\n                                    strXml += '                  <a:t>)</a:t>';\n                                    strXml += '              </a:r>';\n                                    strXml += '              <a:endParaRPr lang=\"' + (opts.lang || 'en-US') + '\" dirty=\"0\"/>';\n                                }\n                                strXml += '            </a:p>';\n                                strXml += '      </c:rich>';\n                                strXml += '    </c:tx>';\n                                strXml += '    <c:spPr>';\n                                strXml += '        <a:noFill/>';\n                                strXml += '        <a:ln>';\n                                strXml += '            <a:noFill/>';\n                                strXml += '        </a:ln>';\n                                strXml += '        <a:effectLst/>';\n                                strXml += '    </c:spPr>';\n                                if (opts.dataLabelPosition)\n                                    strXml += ' <c:dLblPos val=\"' + opts.dataLabelPosition + '\"/>';\n                                strXml += '    <c:showLegendKey val=\"0\"/>';\n                                strXml += '    <c:showVal val=\"0\"/>';\n                                strXml += '    <c:showCatName val=\"0\"/>';\n                                strXml += '    <c:showSerName val=\"0\"/>';\n                                strXml += '    <c:showPercent val=\"0\"/>';\n                                strXml += '    <c:showBubbleSize val=\"0\"/>';\n                                strXml += '       <c:showLeaderLines val=\"1\"/>';\n                                strXml += '    <c:extLst>';\n                                strXml += '      <c:ext uri=\"{CE6537A1-D6FC-4f65-9D91-7224C49458BB}\" xmlns:c15=\"http://schemas.microsoft.com/office/drawing/2012/chart\"/>';\n                                strXml += '      <c:ext uri=\"{C3380CC4-5D6E-409C-BE32-E72D297353CC}\" xmlns:c16=\"http://schemas.microsoft.com/office/drawing/2014/chart\">';\n                                strXml += `            <c16:uniqueId val=\"{${'00000000'.substring(0, 8 - (idx + 1).toString().length).toString()}${idx + 1}${chartUuid}}\"/>`;\n                                strXml += '      </c:ext>';\n                                strXml += '        </c:extLst>';\n                                strXml += '</c:dLbl>';\n                            }\n                        });\n                        strXml += '</c:dLbls>';\n                    }\n                    if (opts.dataLabelFormatScatter === 'XY') {\n                        strXml += '<c:dLbls>';\n                        strXml += '    <c:spPr>';\n                        strXml += '        <a:noFill/>';\n                        strXml += '        <a:ln>';\n                        strXml += '            <a:noFill/>';\n                        strXml += '        </a:ln>';\n                        strXml += '          <a:effectLst/>';\n                        strXml += '    </c:spPr>';\n                        strXml += '    <c:txPr>';\n                        strXml += '        <a:bodyPr>';\n                        strXml += '            <a:spAutoFit/>';\n                        strXml += '        </a:bodyPr>';\n                        strXml += '        <a:lstStyle/>';\n                        strXml += '        <a:p>';\n                        strXml += '            <a:pPr>';\n                        strXml += '                <a:defRPr/>';\n                        strXml += '            </a:pPr>';\n                        strXml += '            <a:endParaRPr lang=\"en-US\"/>';\n                        strXml += '        </a:p>';\n                        strXml += '    </c:txPr>';\n                        if (opts.dataLabelPosition)\n                            strXml += ' <c:dLblPos val=\"' + opts.dataLabelPosition + '\"/>';\n                        strXml += '    <c:showLegendKey val=\"0\"/>';\n                        strXml += ` <c:showVal val=\"${opts.showLabel ? '1' : '0'}\"/>`;\n                        strXml += ` <c:showCatName val=\"${opts.showLabel ? '1' : '0'}\"/>`;\n                        strXml += ` <c:showSerName val=\"${opts.showSerName ? '1' : '0'}\"/>`;\n                        strXml += '    <c:showPercent val=\"0\"/>';\n                        strXml += '    <c:showBubbleSize val=\"0\"/>';\n                        strXml += '    <c:extLst>';\n                        strXml += '        <c:ext uri=\"{CE6537A1-D6FC-4f65-9D91-7224C49458BB}\" xmlns:c15=\"http://schemas.microsoft.com/office/drawing/2012/chart\">';\n                        strXml += '            <c15:showLeaderLines val=\"1\"/>';\n                        strXml += '        </c:ext>';\n                        strXml += '    </c:extLst>';\n                        strXml += '</c:dLbls>';\n                    }\n                }\n                // Color bar chart bars various colors\n                // Allow users with a single data set to pass their own array of colors (check for this using != ours)\n                if (data.length === 1 && opts.chartColors !== BARCHART_COLORS) {\n                    // Series Data Point colors\n                    obj.values.forEach((value, index) => {\n                        const arrColors = value < 0 ? opts.invertedColors || opts.chartColors || BARCHART_COLORS : opts.chartColors || [];\n                        strXml += '  <c:dPt>';\n                        strXml += `    <c:idx val=\"${index}\"/>`;\n                        strXml += '      <c:invertIfNegative val=\"0\"/>';\n                        strXml += '    <c:bubble3D val=\"0\"/>';\n                        strXml += '    <c:spPr>';\n                        if (opts.lineSize === 0) {\n                            strXml += '<a:ln><a:noFill/></a:ln>';\n                        }\n                        else {\n                            strXml += '<a:solidFill>';\n                            strXml += ' <a:srgbClr val=\"' + arrColors[index % arrColors.length] + '\"/>';\n                            strXml += '</a:solidFill>';\n                        }\n                        strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);\n                        strXml += '    </c:spPr>';\n                        strXml += '  </c:dPt>';\n                    });\n                }\n                // 3: \"Values\": Scatter Chart has 2: `xVal` and `yVal`\n                {\n                    // X-Axis is always the same\n                    strXml += '<c:xVal>';\n                    strXml += '  <c:numRef>';\n                    strXml += `    <c:f>Sheet1!$A$2:$A$${data[0].values.length + 1}</c:f>`;\n                    strXml += '    <c:numCache>';\n                    strXml += '      <c:formatCode>General</c:formatCode>';\n                    strXml += `      <c:ptCount val=\"${data[0].values.length}\"/>`;\n                    data[0].values.forEach((value, idx) => {\n                        strXml += `<c:pt idx=\"${idx}\"><c:v>${value || value === 0 ? value : ''}</c:v></c:pt>`;\n                    });\n                    strXml += '    </c:numCache>';\n                    strXml += '  </c:numRef>';\n                    strXml += '</c:xVal>';\n                    // Y-Axis vals are this object's `values`\n                    strXml += '<c:yVal>';\n                    strXml += '  <c:numRef>';\n                    strXml += `    <c:f>Sheet1!$${getExcelColName(idx + 2)}$2:$${getExcelColName(idx + 2)}$${data[0].values.length + 1}</c:f>`;\n                    strXml += '    <c:numCache>';\n                    strXml += '      <c:formatCode>General</c:formatCode>';\n                    // NOTE: Use pt count and iterate over data[0] (X-Axis) as user can have more values than data (eg: timeline where only first few months are populated)\n                    strXml += `      <c:ptCount val=\"${data[0].values.length}\"/>`;\n                    data[0].values.forEach((_value, idx) => {\n                        strXml += `<c:pt idx=\"${idx}\"><c:v>${obj.values[idx] || obj.values[idx] === 0 ? obj.values[idx] : ''}</c:v></c:pt>`;\n                    });\n                    strXml += '    </c:numCache>';\n                    strXml += '  </c:numRef>';\n                    strXml += '</c:yVal>';\n                }\n                // Option: `smooth`\n                strXml += '<c:smooth val=\"' + (opts.lineSmooth ? '1' : '0') + '\"/>';\n                // 4: Close \"SERIES\"\n                strXml += '</c:ser>';\n            });\n            // 3: Data Labels\n            {\n                strXml += '  <c:dLbls>';\n                strXml += `    <c:numFmt formatCode=\"${encodeXmlEntities(opts.dataLabelFormatCode) || 'General'}\" sourceLinked=\"0\"/>`;\n                strXml += '    <c:txPr>';\n                strXml += '      <a:bodyPr/>';\n                strXml += '      <a:lstStyle/>';\n                strXml += '      <a:p><a:pPr>';\n                strXml += `        <a:defRPr b=\"${opts.dataLabelFontBold ? '1' : '0'}\" i=\"${opts.dataLabelFontItalic ? '1' : '0'}\" strike=\"noStrike\" sz=\"${Math.round((opts.dataLabelFontSize || DEF_FONT_SIZE) * 100)}\" u=\"none\">`;\n                strXml += '          <a:solidFill>' + createColorElement(opts.dataLabelColor || DEF_FONT_COLOR) + '</a:solidFill>';\n                strXml += '          <a:latin typeface=\"' + (opts.dataLabelFontFace || 'Arial') + '\"/>';\n                strXml += '        </a:defRPr>';\n                strXml += '      </a:pPr></a:p>';\n                strXml += '    </c:txPr>';\n                if (opts.dataLabelPosition)\n                    strXml += ' <c:dLblPos val=\"' + opts.dataLabelPosition + '\"/>';\n                strXml += '    <c:showLegendKey val=\"0\"/>';\n                strXml += '    <c:showVal val=\"' + (opts.showValue ? '1' : '0') + '\"/>';\n                strXml += '    <c:showCatName val=\"0\"/>';\n                strXml += '    <c:showSerName val=\"' + (opts.showSerName ? '1' : '0') + '\"/>';\n                strXml += '    <c:showPercent val=\"0\"/>';\n                strXml += '    <c:showBubbleSize val=\"0\"/>';\n                strXml += '  </c:dLbls>';\n            }\n            // 4: Add axis Id (NOTE: order matters! - category comes first)\n            strXml += `<c:axId val=\"${catAxisId}\"/><c:axId val=\"${valAxisId}\"/>`;\n            // 5: Close Chart tag\n            strXml += '</c:' + chartType + 'Chart>';\n            // end switch\n            break;\n        case CHART_TYPE.BUBBLE:\n        case CHART_TYPE.BUBBLE3D:\n            /*\n                `data` = [\n                    { name:'X-Axis',     values:[1,2,3,4,5,6,7,8,9,10,11,12] },\n                    { name:'Y-Values 1', values:[13, 20, 21, 25], sizes:[10, 5, 20, 15] },\n                    { name:'Y-Values 2', values:[ 1,  2,  5,  9], sizes:[ 5, 3,  9,  3] }\n                ];\n            */\n            // 1: Start Chart\n            strXml += '<c:bubbleChart>';\n            strXml += '<c:varyColors val=\"0\"/>';\n            // 2: Series: (One for each Y-Axis)\n            colorIndex = -1;\n            data.filter((_obj, idx) => idx > 0).forEach((obj, idx) => {\n                colorIndex++;\n                strXml += '<c:ser>';\n                strXml += `  <c:idx val=\"${idx}\"/>`;\n                strXml += `  <c:order val=\"${idx}\"/>`;\n                // A: `<c:tx>`\n                strXml += '  <c:tx>';\n                strXml += '    <c:strRef>';\n                strXml += '      <c:f>Sheet1!$' + getExcelColName(idxColLtr + 1) + '$1</c:f>';\n                strXml += '      <c:strCache><c:ptCount val=\"1\"/><c:pt idx=\"0\"><c:v>' + encodeXmlEntities(obj.name) + '</c:v></c:pt></c:strCache>';\n                strXml += '    </c:strRef>';\n                strXml += '  </c:tx>';\n                // B: '<c:spPr>': Fill, Border, Line, LineStyle (dash, etc.), Shadow\n                {\n                    strXml += '<c:spPr>';\n                    const tmpSerColor = opts.chartColors[colorIndex % opts.chartColors.length];\n                    if (tmpSerColor === 'transparent') {\n                        strXml += '<a:noFill/>';\n                    }\n                    else if (opts.chartColorsOpacity) {\n                        strXml += `<a:solidFill>${createColorElement(tmpSerColor, '<a:alpha val=\"' + Math.round(opts.chartColorsOpacity * 1000).toString() + '\"/>')}</a:solidFill>`;\n                    }\n                    else {\n                        strXml += '<a:solidFill>' + createColorElement(tmpSerColor) + '</a:solidFill>';\n                    }\n                    if (opts.lineSize === 0) {\n                        strXml += '<a:ln><a:noFill/></a:ln>';\n                    }\n                    else if (opts.dataBorder) {\n                        strXml += `<a:ln w=\"${valToPts(opts.dataBorder.pt)}\" cap=\"flat\"><a:solidFill>${createColorElement(opts.dataBorder.color)}</a:solidFill><a:prstDash val=\"solid\"/><a:round/></a:ln>`;\n                    }\n                    else {\n                        strXml += `<a:ln w=\"${valToPts(opts.lineSize)}\" cap=\"flat\"><a:solidFill>${createColorElement(tmpSerColor)}</a:solidFill>`;\n                        strXml += `<a:prstDash val=\"${opts.lineDash || 'solid'}\"/><a:round/></a:ln>`;\n                    }\n                    // Shadow\n                    strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);\n                    strXml += '</c:spPr>';\n                }\n                // C: '<c:dLbls>' \"Data Labels\"\n                // Let it be defaulted for now\n                // D: '<c:xVal>'/'<c:yVal>' \"Values\": Scatter Chart has 2: `xVal` and `yVal`\n                {\n                    // X-Axis is always the same\n                    strXml += '<c:xVal>';\n                    strXml += '  <c:numRef>';\n                    strXml += `    <c:f>Sheet1!$A$2:$A$${data[0].values.length + 1}</c:f>`;\n                    strXml += '    <c:numCache>';\n                    strXml += '      <c:formatCode>General</c:formatCode>';\n                    strXml += `      <c:ptCount val=\"${data[0].values.length}\"/>`;\n                    data[0].values.forEach((value, idx) => {\n                        strXml += `<c:pt idx=\"${idx}\"><c:v>${value || value === 0 ? value : ''}</c:v></c:pt>`;\n                    });\n                    strXml += '    </c:numCache>';\n                    strXml += '  </c:numRef>';\n                    strXml += '</c:xVal>';\n                    // Y-Axis vals are this object's `values`\n                    strXml += '<c:yVal>';\n                    strXml += '  <c:numRef>';\n                    strXml += `<c:f>Sheet1!$${getExcelColName(idxColLtr + 1)}$2:$${getExcelColName(idxColLtr + 1)}$${data[0].values.length + 1}</c:f>`;\n                    idxColLtr++;\n                    strXml += '    <c:numCache>';\n                    strXml += '      <c:formatCode>General</c:formatCode>';\n                    // NOTE: Use pt count and iterate over data[0] (X-Axis) as user can have more values than data (eg: timeline where only first few months are populated)\n                    strXml += `      <c:ptCount val=\"${data[0].values.length}\"/>`;\n                    data[0].values.forEach((_value, idx) => {\n                        strXml += `<c:pt idx=\"${idx}\"><c:v>${obj.values[idx] || obj.values[idx] === 0 ? obj.values[idx] : ''}</c:v></c:pt>`;\n                    });\n                    strXml += '    </c:numCache>';\n                    strXml += '  </c:numRef>';\n                    strXml += '</c:yVal>';\n                }\n                // E: '<c:bubbleSize>'\n                strXml += '  <c:bubbleSize>';\n                strXml += '    <c:numRef>';\n                strXml += `<c:f>Sheet1!$${getExcelColName(idxColLtr + 1)}$2:$${getExcelColName(idxColLtr + 1)}$${obj.sizes.length + 1}</c:f>`;\n                idxColLtr++;\n                strXml += '      <c:numCache>';\n                strXml += '        <c:formatCode>General</c:formatCode>';\n                strXml += `           <c:ptCount val=\"${obj.sizes.length}\"/>`;\n                obj.sizes.forEach((value, idx) => {\n                    strXml += `<c:pt idx=\"${idx}\"><c:v>${value || ''}</c:v></c:pt>`;\n                });\n                strXml += '      </c:numCache>';\n                strXml += '    </c:numRef>';\n                strXml += '  </c:bubbleSize>';\n                strXml += '  <c:bubble3D val=\"' + (chartType === CHART_TYPE.BUBBLE3D ? '1' : '0') + '\"/>';\n                // F: Close \"SERIES\"\n                strXml += '</c:ser>';\n            });\n            // 3: Data Labels\n            {\n                strXml += '<c:dLbls>';\n                strXml += `<c:numFmt formatCode=\"${encodeXmlEntities(opts.dataLabelFormatCode) || 'General'}\" sourceLinked=\"0\"/>`;\n                strXml += '<c:txPr><a:bodyPr/><a:lstStyle/><a:p><a:pPr>';\n                strXml += `<a:defRPr b=\"${opts.dataLabelFontBold ? 1 : 0}\" i=\"${opts.dataLabelFontItalic ? 1 : 0}\" strike=\"noStrike\" sz=\"${Math.round(Math.round(opts.dataLabelFontSize || DEF_FONT_SIZE) * 100)}\" u=\"none\">`;\n                strXml += `<a:solidFill>${createColorElement(opts.dataLabelColor || DEF_FONT_COLOR)}</a:solidFill>`;\n                strXml += `<a:latin typeface=\"${opts.dataLabelFontFace || 'Arial'}\"/>`;\n                strXml += '</a:defRPr></a:pPr></a:p></c:txPr>';\n                if (opts.dataLabelPosition)\n                    strXml += `<c:dLblPos val=\"${opts.dataLabelPosition}\"/>`;\n                strXml += '<c:showLegendKey val=\"0\"/>';\n                strXml += `<c:showVal val=\"${opts.showValue ? '1' : '0'}\"/>`;\n                strXml += `<c:showCatName val=\"0\"/><c:showSerName val=\"${opts.showSerName ? '1' : '0'}\"/><c:showPercent val=\"0\"/><c:showBubbleSize val=\"0\"/>`;\n                strXml += '<c:extLst>';\n                strXml += '  <c:ext uri=\"{CE6537A1-D6FC-4f65-9D91-7224C49458BB}\" xmlns:c15=\"http://schemas.microsoft.com/office/drawing/2012/chart\">';\n                strXml += '    <c15:showLeaderLines val=\"' + (opts.showLeaderLines ? '1' : '0') + '\"/>';\n                strXml += '  </c:ext>';\n                strXml += '</c:extLst>';\n                strXml += '</c:dLbls>';\n            }\n            // 4: Bubble options\n            // strXml += '  <c:bubbleScale val=\"100\"/>';\n            // strXml += '  <c:showNegBubbles val=\"0\"/>';\n            // Commented out to let it default to PPT until we create options\n            // 5: AxisId (NOTE: order matters! (category comes first))\n            strXml += `<c:axId val=\"${catAxisId}\"/><c:axId val=\"${valAxisId}\"/>`;\n            // 6: Close Chart tag\n            strXml += '</c:bubbleChart>';\n            // end switch\n            break;\n        case CHART_TYPE.DOUGHNUT:\n        case CHART_TYPE.PIE:\n            // Use the same let name so code blocks from barChart are interchangeable\n            optsChartData = data[0];\n            /* EX:\n                data: [\n                 {\n                   name: 'Project Status',\n                   labels: ['Red', 'Amber', 'Green', 'Unknown'],\n                   values: [10, 20, 38, 2]\n                 }\n                ]\n            */\n            // 1: Start Chart\n            strXml += '<c:' + chartType + 'Chart>';\n            strXml += '  <c:varyColors val=\"1\"/>';\n            strXml += '<c:ser>';\n            strXml += '  <c:idx val=\"0\"/>';\n            strXml += '  <c:order val=\"0\"/>';\n            strXml += '  <c:tx>';\n            strXml += '    <c:strRef>';\n            strXml += '      <c:f>Sheet1!$B$1</c:f>';\n            strXml += '      <c:strCache>';\n            strXml += '        <c:ptCount val=\"1\"/>';\n            strXml += '        <c:pt idx=\"0\"><c:v>' + encodeXmlEntities(optsChartData.name) + '</c:v></c:pt>';\n            strXml += '      </c:strCache>';\n            strXml += '    </c:strRef>';\n            strXml += '  </c:tx>';\n            strXml += '  <c:spPr>';\n            strXml += '    <a:solidFill><a:schemeClr val=\"accent1\"/></a:solidFill>';\n            strXml += '    <a:ln w=\"9525\" cap=\"flat\"><a:solidFill><a:srgbClr val=\"F9F9F9\"/></a:solidFill><a:prstDash val=\"solid\"/><a:round/></a:ln>';\n            if (opts.dataNoEffects) {\n                strXml += '<a:effectLst/>';\n            }\n            else {\n                strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);\n            }\n            strXml += '  </c:spPr>';\n            // strXml += '<c:explosion val=\"0\"/>'\n            // 2: \"Data Point\" block for every data row\n            optsChartData.labels[0].forEach((_label, idx) => {\n                strXml += '<c:dPt>';\n                strXml += ` <c:idx val=\"${idx}\"/>`;\n                strXml += ' <c:bubble3D val=\"0\"/>';\n                strXml += ' <c:spPr>';\n                strXml += `<a:solidFill>${createColorElement(opts.chartColors[idx + 1 > opts.chartColors.length ? Math.floor(Math.random() * opts.chartColors.length) : idx])}</a:solidFill>`;\n                if (opts.dataBorder) {\n                    strXml += `<a:ln w=\"${valToPts(opts.dataBorder.pt)}\" cap=\"flat\"><a:solidFill>${createColorElement(opts.dataBorder.color)}</a:solidFill><a:prstDash val=\"solid\"/><a:round/></a:ln>`;\n                }\n                strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);\n                strXml += '  </c:spPr>';\n                strXml += '</c:dPt>';\n            });\n            // 3: \"Data Label\" block for every data Label\n            strXml += '<c:dLbls>';\n            optsChartData.labels[0].forEach((_label, idx) => {\n                strXml += '<c:dLbl>';\n                strXml += ` <c:idx val=\"${idx}\"/>`;\n                strXml += `  <c:numFmt formatCode=\"${encodeXmlEntities(opts.dataLabelFormatCode) || 'General'}\" sourceLinked=\"0\"/>`;\n                strXml += '  <c:spPr/><c:txPr>';\n                strXml += '   <a:bodyPr/><a:lstStyle/>';\n                strXml += '   <a:p><a:pPr>';\n                strXml += `   <a:defRPr sz=\"${Math.round((opts.dataLabelFontSize || DEF_FONT_SIZE) * 100)}\" b=\"${opts.dataLabelFontBold ? 1 : 0}\" i=\"${opts.dataLabelFontItalic ? 1 : 0}\" u=\"none\" strike=\"noStrike\">`;\n                strXml += '    <a:solidFill>' + createColorElement(opts.dataLabelColor || DEF_FONT_COLOR) + '</a:solidFill>';\n                strXml += `    <a:latin typeface=\"${opts.dataLabelFontFace || 'Arial'}\"/>`;\n                strXml += '   </a:defRPr>';\n                strXml += '      </a:pPr></a:p>';\n                strXml += '    </c:txPr>';\n                if (chartType === CHART_TYPE.PIE && opts.dataLabelPosition)\n                    strXml += `<c:dLblPos val=\"${opts.dataLabelPosition}\"/>`;\n                strXml += '    <c:showLegendKey val=\"0\"/>';\n                strXml += '    <c:showVal val=\"' + (opts.showValue ? '1' : '0') + '\"/>';\n                strXml += '    <c:showCatName val=\"' + (opts.showLabel ? '1' : '0') + '\"/>';\n                strXml += '    <c:showSerName val=\"' + (opts.showSerName ? '1' : '0') + '\"/>';\n                strXml += '    <c:showPercent val=\"' + (opts.showPercent ? '1' : '0') + '\"/>';\n                strXml += '    <c:showBubbleSize val=\"0\"/>';\n                strXml += '  </c:dLbl>';\n            });\n            strXml += ` <c:numFmt formatCode=\"${encodeXmlEntities(opts.dataLabelFormatCode) || 'General'}\" sourceLinked=\"0\"/>`;\n            strXml += '    <c:txPr>';\n            strXml += '      <a:bodyPr/>';\n            strXml += '      <a:lstStyle/>';\n            strXml += '      <a:p>';\n            strXml += '        <a:pPr>';\n            strXml += `          <a:defRPr sz=\"1800\" b=\"${opts.dataLabelFontBold ? '1' : '0'}\" i=\"${opts.dataLabelFontItalic ? '1' : '0'}\" u=\"none\" strike=\"noStrike\">`;\n            strXml += '            <a:solidFill><a:srgbClr val=\"000000\"/></a:solidFill><a:latin typeface=\"Arial\"/>';\n            strXml += '          </a:defRPr>';\n            strXml += '        </a:pPr>';\n            strXml += '      </a:p>';\n            strXml += '    </c:txPr>';\n            strXml += chartType === CHART_TYPE.PIE ? '<c:dLblPos val=\"ctr\"/>' : '';\n            strXml += '    <c:showLegendKey val=\"0\"/>';\n            strXml += '    <c:showVal val=\"0\"/>';\n            strXml += '    <c:showCatName val=\"1\"/>';\n            strXml += '    <c:showSerName val=\"0\"/>';\n            strXml += '    <c:showPercent val=\"1\"/>';\n            strXml += '    <c:showBubbleSize val=\"0\"/>';\n            strXml += ` <c:showLeaderLines val=\"${opts.showLeaderLines ? '1' : '0'}\"/>`;\n            strXml += '</c:dLbls>';\n            // 2: \"Categories\"\n            strXml += '<c:cat>';\n            strXml += '  <c:strRef>';\n            strXml += `    <c:f>Sheet1!$A$2:$A$${optsChartData.labels[0].length + 1}</c:f>`;\n            strXml += '    <c:strCache>';\n            strXml += `         <c:ptCount val=\"${optsChartData.labels[0].length}\"/>`;\n            optsChartData.labels[0].forEach((label, idx) => {\n                strXml += `<c:pt idx=\"${idx}\"><c:v>${encodeXmlEntities(label)}</c:v></c:pt>`;\n            });\n            strXml += '    </c:strCache>';\n            strXml += '  </c:strRef>';\n            strXml += '</c:cat>';\n            // 3: Create vals\n            strXml += '  <c:val>';\n            strXml += '    <c:numRef>';\n            strXml += `      <c:f>Sheet1!$B$2:$B$${optsChartData.labels[0].length + 1}</c:f>`;\n            strXml += '      <c:numCache>';\n            strXml += `           <c:ptCount val=\"${optsChartData.labels[0].length}\"/>`;\n            optsChartData.values.forEach((value, idx) => {\n                strXml += `<c:pt idx=\"${idx}\"><c:v>${value || value === 0 ? value : ''}</c:v></c:pt>`;\n            });\n            strXml += '      </c:numCache>';\n            strXml += '    </c:numRef>';\n            strXml += '  </c:val>';\n            // 4: Close \"SERIES\"\n            strXml += '  </c:ser>';\n            strXml += `  <c:firstSliceAng val=\"${opts.firstSliceAng ? Math.round(opts.firstSliceAng) : 0}\"/>`;\n            if (chartType === CHART_TYPE.DOUGHNUT)\n                strXml += `<c:holeSize val=\"${typeof opts.holeSize === 'number' ? opts.holeSize : '50'}\"/>`;\n            strXml += '</c:' + chartType + 'Chart>';\n            // Done with Doughnut/Pie\n            break;\n        default:\n            strXml += '';\n            break;\n    }\n    return strXml;\n}\n/**\n * Create Category axis\n * @param {IChartOptsLib} opts - chart options\n * @param {string} axisId - value\n * @param {string} valAxisId - value\n * @return {string} XML\n */\nfunction makeCatAxis(opts, axisId, valAxisId) {\n    let strXml = '';\n    // Build cat axis tag\n    // NOTE: Scatter and Bubble chart need two Val axises as they display numbers on x axis\n    if (opts._type === CHART_TYPE.SCATTER || opts._type === CHART_TYPE.BUBBLE || opts._type === CHART_TYPE.BUBBLE3D) {\n        strXml += '<c:valAx>';\n    }\n    else {\n        strXml += '<c:' + (opts.catLabelFormatCode ? 'dateAx' : 'catAx') + '>';\n    }\n    strXml += '  <c:axId val=\"' + axisId + '\"/>';\n    strXml += '  <c:scaling>';\n    strXml += '<c:orientation val=\"' + (opts.catAxisOrientation || (opts.barDir === 'col' ? 'minMax' : 'minMax')) + '\"/>';\n    if (opts.catAxisMaxVal || opts.catAxisMaxVal === 0)\n        strXml += `<c:max val=\"${opts.catAxisMaxVal}\"/>`;\n    if (opts.catAxisMinVal || opts.catAxisMinVal === 0)\n        strXml += `<c:min val=\"${opts.catAxisMinVal}\"/>`;\n    strXml += '</c:scaling>';\n    strXml += '  <c:delete val=\"' + (opts.catAxisHidden ? '1' : '0') + '\"/>';\n    strXml += '  <c:axPos val=\"' + (opts.barDir === 'col' ? 'b' : 'l') + '\"/>';\n    strXml += opts.catGridLine.style !== 'none' ? createGridLineElement(opts.catGridLine) : '';\n    // '<c:title>' comes between '</c:majorGridlines>' and '<c:numFmt>'\n    if (opts.showCatAxisTitle) {\n        strXml += genXmlTitle({\n            color: opts.catAxisTitleColor,\n            fontFace: opts.catAxisTitleFontFace,\n            fontSize: opts.catAxisTitleFontSize,\n            titleRotate: opts.catAxisTitleRotate,\n            title: opts.catAxisTitle || 'Axis Title',\n        });\n    }\n    // NOTE: Adding Val Axis Formatting if scatter or bubble charts\n    if (opts._type === CHART_TYPE.SCATTER || opts._type === CHART_TYPE.BUBBLE || opts._type === CHART_TYPE.BUBBLE3D) {\n        strXml += '  <c:numFmt formatCode=\"' + (opts.valAxisLabelFormatCode ? encodeXmlEntities(opts.valAxisLabelFormatCode) : 'General') + '\" sourceLinked=\"1\"/>';\n    }\n    else {\n        strXml += '  <c:numFmt formatCode=\"' + (encodeXmlEntities(opts.catLabelFormatCode) || 'General') + '\" sourceLinked=\"1\"/>';\n    }\n    if (opts._type === CHART_TYPE.SCATTER) {\n        strXml += '  <c:majorTickMark val=\"none\"/>';\n        strXml += '  <c:minorTickMark val=\"none\"/>';\n        strXml += '  <c:tickLblPos val=\"nextTo\"/>';\n    }\n    else {\n        strXml += '  <c:majorTickMark val=\"' + (opts.catAxisMajorTickMark || 'out') + '\"/>';\n        strXml += '  <c:minorTickMark val=\"' + (opts.catAxisMinorTickMark || 'none') + '\"/>';\n        strXml += '  <c:tickLblPos val=\"' + (opts.catAxisLabelPos || (opts.barDir === 'col' ? 'low' : 'nextTo')) + '\"/>';\n    }\n    strXml += '  <c:spPr>';\n    strXml += `    <a:ln w=\"${opts.catAxisLineSize ? valToPts(opts.catAxisLineSize) : ONEPT}\" cap=\"flat\">`;\n    strXml += !opts.catAxisLineShow ? '<a:noFill/>' : '<a:solidFill>' + createColorElement(opts.catAxisLineColor || DEF_CHART_GRIDLINE.color) + '</a:solidFill>';\n    strXml += '      <a:prstDash val=\"' + (opts.catAxisLineStyle || 'solid') + '\"/>';\n    strXml += '      <a:round/>';\n    strXml += '    </a:ln>';\n    strXml += '  </c:spPr>';\n    strXml += '  <c:txPr>';\n    if (opts.catAxisLabelRotate) {\n        strXml += `<a:bodyPr rot=\"${convertRotationDegrees(opts.catAxisLabelRotate)}\"/>`;\n    }\n    else {\n        // NOTE: don't specify \"`rot=0\" - that way the object will be auto behavior\n        strXml += '<a:bodyPr/>';\n    }\n    strXml += '    <a:lstStyle/>';\n    strXml += '    <a:p>';\n    strXml += '    <a:pPr>';\n    strXml += `      <a:defRPr sz=\"${Math.round((opts.catAxisLabelFontSize || DEF_FONT_SIZE) * 100)}\" b=\"${opts.catAxisLabelFontBold ? 1 : 0}\" i=\"${opts.catAxisLabelFontItalic ? 1 : 0}\" u=\"none\" strike=\"noStrike\">`;\n    strXml += '      <a:solidFill>' + createColorElement(opts.catAxisLabelColor || DEF_FONT_COLOR) + '</a:solidFill>';\n    strXml += '      <a:latin typeface=\"' + (opts.catAxisLabelFontFace || 'Arial') + '\"/>';\n    strXml += '   </a:defRPr>';\n    strXml += '  </a:pPr>';\n    strXml += '  <a:endParaRPr lang=\"' + (opts.lang || 'en-US') + '\"/>';\n    strXml += '  </a:p>';\n    strXml += ' </c:txPr>';\n    strXml += ' <c:crossAx val=\"' + valAxisId + '\"/>';\n    strXml += ` <c:${typeof opts.valAxisCrossesAt === 'number' ? 'crossesAt' : 'crosses'} val=\"${opts.valAxisCrossesAt || 'autoZero'}\"/>`;\n    strXml += ' <c:auto val=\"1\"/>';\n    strXml += ' <c:lblAlgn val=\"ctr\"/>';\n    strXml += ` <c:noMultiLvlLbl val=\"${opts.catAxisMultiLevelLabels ? 0 : 1}\"/>`;\n    if (opts.catAxisLabelFrequency)\n        strXml += ' <c:tickLblSkip val=\"' + opts.catAxisLabelFrequency + '\"/>';\n    // Issue#149: PPT will auto-adjust these as needed after calcing the date bounds, so we only include them when specified by user\n    // Allow major and minor units to be set for double value axis charts\n    if (opts.catLabelFormatCode || opts._type === CHART_TYPE.SCATTER || opts._type === CHART_TYPE.BUBBLE || opts._type === CHART_TYPE.BUBBLE3D) {\n        if (opts.catLabelFormatCode) {\n            ['catAxisBaseTimeUnit', 'catAxisMajorTimeUnit', 'catAxisMinorTimeUnit'].forEach(opt => {\n                // Validate input as poorly chosen/garbage options will cause chart corruption and it wont render at all!\n                if (opts[opt] && (typeof opts[opt] !== 'string' || !['days', 'months', 'years'].includes(opts[opt].toLowerCase()))) {\n                    console.warn(`\"${opt}\" must be one of: 'days','months','years' !`);\n                    opts[opt] = null;\n                }\n            });\n            if (opts.catAxisBaseTimeUnit)\n                strXml += '<c:baseTimeUnit val=\"' + opts.catAxisBaseTimeUnit.toLowerCase() + '\"/>';\n            if (opts.catAxisMajorTimeUnit)\n                strXml += '<c:majorTimeUnit val=\"' + opts.catAxisMajorTimeUnit.toLowerCase() + '\"/>';\n            if (opts.catAxisMinorTimeUnit)\n                strXml += '<c:minorTimeUnit val=\"' + opts.catAxisMinorTimeUnit.toLowerCase() + '\"/>';\n        }\n        if (opts.catAxisMajorUnit)\n            strXml += `<c:majorUnit val=\"${opts.catAxisMajorUnit}\"/>`;\n        if (opts.catAxisMinorUnit)\n            strXml += `<c:minorUnit val=\"${opts.catAxisMinorUnit}\"/>`;\n    }\n    // Close cat axis tag\n    // NOTE: Added closing tag of val or cat axis based on chart type\n    if (opts._type === CHART_TYPE.SCATTER || opts._type === CHART_TYPE.BUBBLE || opts._type === CHART_TYPE.BUBBLE3D) {\n        strXml += '</c:valAx>';\n    }\n    else {\n        strXml += '</c:' + (opts.catLabelFormatCode ? 'dateAx' : 'catAx') + '>';\n    }\n    return strXml;\n}\n/**\n * Create Value Axis (Used by `bar3D`)\n * @param {IChartOptsLib} opts - chart options\n * @param {string} valAxisId - value\n * @return {string} XML\n */\nfunction makeValAxis(opts, valAxisId) {\n    let axisPos = valAxisId === AXIS_ID_VALUE_PRIMARY ? (opts.barDir === 'col' ? 'l' : 'b') : opts.barDir !== 'col' ? 'r' : 't';\n    if (valAxisId === AXIS_ID_VALUE_SECONDARY)\n        axisPos = 'r'; // default behavior for PPT is showing 2nd val axis on right (primary axis on left)\n    const crossAxId = valAxisId === AXIS_ID_VALUE_PRIMARY ? AXIS_ID_CATEGORY_PRIMARY : AXIS_ID_CATEGORY_SECONDARY;\n    let strXml = '';\n    strXml += '<c:valAx>';\n    strXml += '  <c:axId val=\"' + valAxisId + '\"/>';\n    strXml += '  <c:scaling>';\n    if (opts.valAxisLogScaleBase)\n        strXml += `<c:logBase val=\"${opts.valAxisLogScaleBase}\"/>`;\n    strXml += '<c:orientation val=\"' + (opts.valAxisOrientation || (opts.barDir === 'col' ? 'minMax' : 'minMax')) + '\"/>';\n    if (opts.valAxisMaxVal || opts.valAxisMaxVal === 0)\n        strXml += `<c:max val=\"${opts.valAxisMaxVal}\"/>`;\n    if (opts.valAxisMinVal || opts.valAxisMinVal === 0)\n        strXml += `<c:min val=\"${opts.valAxisMinVal}\"/>`;\n    strXml += '  </c:scaling>';\n    strXml += `  <c:delete val=\"${opts.valAxisHidden ? 1 : 0}\"/>`;\n    strXml += '  <c:axPos val=\"' + axisPos + '\"/>';\n    if (opts.valGridLine.style !== 'none')\n        strXml += createGridLineElement(opts.valGridLine);\n    // '<c:title>' comes between '</c:majorGridlines>' and '<c:numFmt>'\n    if (opts.showValAxisTitle) {\n        strXml += genXmlTitle({\n            color: opts.valAxisTitleColor,\n            fontFace: opts.valAxisTitleFontFace,\n            fontSize: opts.valAxisTitleFontSize,\n            titleRotate: opts.valAxisTitleRotate,\n            title: opts.valAxisTitle || 'Axis Title',\n        });\n    }\n    strXml += `<c:numFmt formatCode=\"${opts.valAxisLabelFormatCode ? encodeXmlEntities(opts.valAxisLabelFormatCode) : 'General'}\" sourceLinked=\"0\"/>`;\n    if (opts._type === CHART_TYPE.SCATTER) {\n        strXml += '  <c:majorTickMark val=\"none\"/>';\n        strXml += '  <c:minorTickMark val=\"none\"/>';\n        strXml += '  <c:tickLblPos val=\"nextTo\"/>';\n    }\n    else {\n        strXml += ' <c:majorTickMark val=\"' + (opts.valAxisMajorTickMark || 'out') + '\"/>';\n        strXml += ' <c:minorTickMark val=\"' + (opts.valAxisMinorTickMark || 'none') + '\"/>';\n        strXml += ' <c:tickLblPos val=\"' + (opts.valAxisLabelPos || (opts.barDir === 'col' ? 'nextTo' : 'low')) + '\"/>';\n    }\n    strXml += ' <c:spPr>';\n    strXml += `   <a:ln w=\"${opts.valAxisLineSize ? valToPts(opts.valAxisLineSize) : ONEPT}\" cap=\"flat\">`;\n    strXml += !opts.valAxisLineShow ? '<a:noFill/>' : '<a:solidFill>' + createColorElement(opts.valAxisLineColor || DEF_CHART_GRIDLINE.color) + '</a:solidFill>';\n    strXml += '     <a:prstDash val=\"' + (opts.valAxisLineStyle || 'solid') + '\"/>';\n    strXml += '     <a:round/>';\n    strXml += '   </a:ln>';\n    strXml += ' </c:spPr>';\n    strXml += ' <c:txPr>';\n    strXml += `  <a:bodyPr${opts.valAxisLabelRotate ? (' rot=\"' + convertRotationDegrees(opts.valAxisLabelRotate).toString() + '\"') : ''}/>`; // don't specify rot 0 so we get the auto behavior\n    strXml += '  <a:lstStyle/>';\n    strXml += '  <a:p>';\n    strXml += '    <a:pPr>';\n    strXml += `      <a:defRPr sz=\"${Math.round((opts.valAxisLabelFontSize || DEF_FONT_SIZE) * 100)}\" b=\"${opts.valAxisLabelFontBold ? 1 : 0}\" i=\"${opts.valAxisLabelFontItalic ? 1 : 0}\" u=\"none\" strike=\"noStrike\">`;\n    strXml += '        <a:solidFill>' + createColorElement(opts.valAxisLabelColor || DEF_FONT_COLOR) + '</a:solidFill>';\n    strXml += '        <a:latin typeface=\"' + (opts.valAxisLabelFontFace || 'Arial') + '\"/>';\n    strXml += '      </a:defRPr>';\n    strXml += '    </a:pPr>';\n    strXml += '  <a:endParaRPr lang=\"' + (opts.lang || 'en-US') + '\"/>';\n    strXml += '  </a:p>';\n    strXml += ' </c:txPr>';\n    strXml += ' <c:crossAx val=\"' + crossAxId + '\"/>';\n    if (typeof opts.catAxisCrossesAt === 'number') {\n        strXml += ` <c:crossesAt val=\"${opts.catAxisCrossesAt}\"/>`;\n    }\n    else if (typeof opts.catAxisCrossesAt === 'string') {\n        strXml += ' <c:crosses val=\"' + opts.catAxisCrossesAt + '\"/>';\n    }\n    else {\n        const isRight = axisPos === 'r' || axisPos === 't';\n        const crosses = isRight ? 'max' : 'autoZero';\n        strXml += ' <c:crosses val=\"' + crosses + '\"/>';\n    }\n    strXml +=\n        ' <c:crossBetween val=\"' +\n            (opts._type === CHART_TYPE.SCATTER || (!!(Array.isArray(opts._type) && opts._type.filter(type => type.type === CHART_TYPE.AREA).length > 0)) ? 'midCat' : 'between') +\n            '\"/>';\n    if (opts.valAxisMajorUnit)\n        strXml += ` <c:majorUnit val=\"${opts.valAxisMajorUnit}\"/>`;\n    if (opts.valAxisDisplayUnit) {\n        strXml += `<c:dispUnits><c:builtInUnit val=\"${opts.valAxisDisplayUnit}\"/>${opts.valAxisDisplayUnitLabel ? '<c:dispUnitsLbl/>' : ''}</c:dispUnits>`;\n    }\n    strXml += '</c:valAx>';\n    return strXml;\n}\n/**\n * Create Series Axis (Used by `bar3D`)\n * @param {IChartOptsLib} opts - chart options\n * @param {string} axisId - axis ID\n * @param {string} valAxisId - value\n * @return {string} XML\n */\nfunction makeSerAxis(opts, axisId, valAxisId) {\n    let strXml = '';\n    // Build ser axis tag\n    strXml += '<c:serAx>';\n    strXml += '  <c:axId val=\"' + axisId + '\"/>';\n    strXml += '  <c:scaling><c:orientation val=\"' + (opts.serAxisOrientation || (opts.barDir === 'col' ? 'minMax' : 'minMax')) + '\"/></c:scaling>';\n    strXml += '  <c:delete val=\"' + (opts.serAxisHidden ? '1' : '0') + '\"/>';\n    strXml += '  <c:axPos val=\"' + (opts.barDir === 'col' ? 'b' : 'l') + '\"/>';\n    strXml += opts.serGridLine.style !== 'none' ? createGridLineElement(opts.serGridLine) : '';\n    // '<c:title>' comes between '</c:majorGridlines>' and '<c:numFmt>'\n    if (opts.showSerAxisTitle) {\n        strXml += genXmlTitle({\n            color: opts.serAxisTitleColor,\n            fontFace: opts.serAxisTitleFontFace,\n            fontSize: opts.serAxisTitleFontSize,\n            titleRotate: opts.serAxisTitleRotate,\n            title: opts.serAxisTitle || 'Axis Title',\n        });\n    }\n    strXml += `  <c:numFmt formatCode=\"${encodeXmlEntities(opts.serLabelFormatCode) || 'General'}\" sourceLinked=\"0\"/>`;\n    strXml += '  <c:majorTickMark val=\"out\"/>';\n    strXml += '  <c:minorTickMark val=\"none\"/>';\n    strXml += `  <c:tickLblPos val=\"${opts.serAxisLabelPos || opts.barDir === 'col' ? 'low' : 'nextTo'}\"/>`;\n    strXml += '  <c:spPr>';\n    strXml += '    <a:ln w=\"12700\" cap=\"flat\">';\n    strXml += !opts.serAxisLineShow ? '<a:noFill/>' : `<a:solidFill>${createColorElement(opts.serAxisLineColor || DEF_CHART_GRIDLINE.color)}</a:solidFill>`;\n    strXml += '      <a:prstDash val=\"solid\"/>';\n    strXml += '      <a:round/>';\n    strXml += '    </a:ln>';\n    strXml += '  </c:spPr>';\n    strXml += '  <c:txPr>';\n    strXml += '    <a:bodyPr/>'; // don't specify rot 0 so we get the auto behavior\n    strXml += '    <a:lstStyle/>';\n    strXml += '    <a:p>';\n    strXml += '    <a:pPr>';\n    strXml += `    <a:defRPr sz=\"${Math.round((opts.serAxisLabelFontSize || DEF_FONT_SIZE) * 100)}\" b=\"${opts.serAxisLabelFontBold ? '1' : '0'}\" i=\"${opts.serAxisLabelFontItalic ? '1' : '0'}\" u=\"none\" strike=\"noStrike\">`;\n    strXml += `      <a:solidFill>${createColorElement(opts.serAxisLabelColor || DEF_FONT_COLOR)}</a:solidFill>`;\n    strXml += `      <a:latin typeface=\"${opts.serAxisLabelFontFace || 'Arial'}\"/>`;\n    strXml += '   </a:defRPr>';\n    strXml += '  </a:pPr>';\n    strXml += '  <a:endParaRPr lang=\"' + (opts.lang || 'en-US') + '\"/>';\n    strXml += '  </a:p>';\n    strXml += ' </c:txPr>';\n    strXml += ' <c:crossAx val=\"' + valAxisId + '\"/>';\n    strXml += ' <c:crosses val=\"autoZero\"/>';\n    if (opts.serAxisLabelFrequency)\n        strXml += ' <c:tickLblSkip val=\"' + opts.serAxisLabelFrequency + '\"/>';\n    // Issue#149: PPT will auto-adjust these as needed after calcing the date bounds, so we only include them when specified by user\n    if (opts.serLabelFormatCode) {\n        ['serAxisBaseTimeUnit', 'serAxisMajorTimeUnit', 'serAxisMinorTimeUnit'].forEach(opt => {\n            // Validate input as poorly chosen/garbage options will cause chart corruption and it wont render at all!\n            if (opts[opt] && (typeof opts[opt] !== 'string' || !['days', 'months', 'years'].includes(opt.toLowerCase()))) {\n                console.warn(`\"${opt}\" must be one of: 'days','months','years' !`);\n                opts[opt] = null;\n            }\n        });\n        if (opts.serAxisBaseTimeUnit)\n            strXml += ` <c:baseTimeUnit  val=\"${opts.serAxisBaseTimeUnit.toLowerCase()}\"/>`;\n        if (opts.serAxisMajorTimeUnit)\n            strXml += ` <c:majorTimeUnit val=\"${opts.serAxisMajorTimeUnit.toLowerCase()}\"/>`;\n        if (opts.serAxisMinorTimeUnit)\n            strXml += ` <c:minorTimeUnit val=\"${opts.serAxisMinorTimeUnit.toLowerCase()}\"/>`;\n        if (opts.serAxisMajorUnit)\n            strXml += ` <c:majorUnit val=\"${opts.serAxisMajorUnit}\"/>`;\n        if (opts.serAxisMinorUnit)\n            strXml += ` <c:minorUnit val=\"${opts.serAxisMinorUnit}\"/>`;\n    }\n    // Close ser axis tag\n    strXml += '</c:serAx>';\n    return strXml;\n}\n/**\n * Create char title elements\n * @param {IChartPropsTitle} opts - options\n * @return {string} XML `<c:title>`\n */\nfunction genXmlTitle(opts, chartX, chartY) {\n    const align = opts.titleAlign === 'left' || opts.titleAlign === 'right' ? `<a:pPr algn=\"${opts.titleAlign.substring(0, 1)}\">` : '<a:pPr>';\n    const rotate = opts.titleRotate ? `<a:bodyPr rot=\"${convertRotationDegrees(opts.titleRotate)}\"/>` : '<a:bodyPr/>'; // don't specify rotation to get default (ex. vertical for cat axis)\n    const sizeAttr = opts.fontSize ? `sz=\"${Math.round(opts.fontSize * 100)}\"` : ''; // only set the font size if specified.  Powerpoint will handle the default size\n    const titleBold = opts.titleBold ? 1 : 0;\n    let layout = '<c:layout/>';\n    if (opts.titlePos && typeof opts.titlePos.x === 'number' && typeof opts.titlePos.y === 'number') {\n        // NOTE: manualLayout x/y vals are *relative to entire slide*\n        const totalX = opts.titlePos.x + chartX;\n        const totalY = opts.titlePos.y + chartY;\n        let valX = totalX === 0 ? 0 : (totalX * (totalX / 5)) / 10;\n        if (valX >= 1)\n            valX = valX / 10;\n        if (valX >= 0.1)\n            valX = valX / 10;\n        let valY = totalY === 0 ? 0 : (totalY * (totalY / 5)) / 10;\n        if (valY >= 1)\n            valY = valY / 10;\n        if (valY >= 0.1)\n            valY = valY / 10;\n        layout = `<c:layout><c:manualLayout><c:xMode val=\"edge\"/><c:yMode val=\"edge\"/><c:x val=\"${valX}\"/><c:y val=\"${valY}\"/></c:manualLayout></c:layout>`;\n    }\n    return `<c:title>\n      <c:tx>\n        <c:rich>\n          ${rotate}\n          <a:lstStyle/>\n          <a:p>\n            ${align}\n            <a:defRPr ${sizeAttr} b=\"${titleBold}\" i=\"0\" u=\"none\" strike=\"noStrike\">\n              <a:solidFill>${createColorElement(opts.color || DEF_FONT_COLOR)}</a:solidFill>\n              <a:latin typeface=\"${opts.fontFace || 'Arial'}\"/>\n            </a:defRPr>\n          </a:pPr>\n          <a:r>\n            <a:rPr ${sizeAttr} b=\"${titleBold}\" i=\"0\" u=\"none\" strike=\"noStrike\">\n              <a:solidFill>${createColorElement(opts.color || DEF_FONT_COLOR)}</a:solidFill>\n              <a:latin typeface=\"${opts.fontFace || 'Arial'}\"/>\n            </a:rPr>\n            <a:t>${encodeXmlEntities(opts.title) || ''}</a:t>\n          </a:r>\n        </a:p>\n        </c:rich>\n      </c:tx>\n      ${layout}\n      <c:overlay val=\"0\"/>\n    </c:title>`;\n}\n/**\n * Calc and return excel column name for a given column length\n * @param colIndex column index\n * @return column name\n * @example 1 returns 'A'\n * @example 27 returns 'AA'\n */\nfunction getExcelColName(colIndex) {\n    let colStr = '';\n    const colIdx = colIndex - 1; // Subtract 1 so `LETTERS[columnIndex]` returns \"A\" etc\n    if (colIdx <= 25) {\n        // A-Z\n        colStr = LETTERS[colIdx];\n    }\n    else {\n        // AA-ZZ (ZZ = index 702)\n        colStr = `${LETTERS[Math.floor(colIdx / LETTERS.length - 1)]}${LETTERS[colIdx % LETTERS.length]}`;\n    }\n    return colStr;\n}\n/**\n * Creates `a:innerShdw` or `a:outerShdw` depending on pass options `opts`.\n * @param {Object} opts optional shadow properties\n * @param {Object} defaults defaults for unspecified properties in `opts`\n * @see http://officeopenxml.com/drwSp-effects.php\n * @example { type: 'outer', blur: 3, offset: (23000 / 12700), angle: 90, color: '000000', opacity: 0.35, rotateWithShape: true };\n * @return {string} XML\n */\nfunction createShadowElement(options, defaults) {\n    if (!options) {\n        return '<a:effectLst/>';\n    }\n    else if (typeof options !== 'object') {\n        console.warn('`shadow` options must be an object. Ex: `{shadow: {type:\\'none\\'}}`');\n        return '<a:effectLst/>';\n    }\n    let strXml = '<a:effectLst>';\n    const opts = Object.assign(Object.assign({}, defaults), options);\n    const type = opts.type || 'outer';\n    const blur = valToPts(opts.blur);\n    const offset = valToPts(opts.offset);\n    const angle = Math.round(opts.angle * 60000);\n    const color = opts.color;\n    const opacity = Math.round(opts.opacity * 100000);\n    const rotShape = opts.rotateWithShape ? 1 : 0;\n    strXml += `<a:${type}Shdw sx=\"100000\" sy=\"100000\" kx=\"0\" ky=\"0\"  algn=\"bl\" blurRad=\"${blur}\" rotWithShape=\"${rotShape}\" dist=\"${offset}\" dir=\"${angle}\">`;\n    strXml += `<a:srgbClr val=\"${color}\">`;\n    strXml += `<a:alpha val=\"${opacity}\"/></a:srgbClr>`;\n    strXml += `</a:${type}Shdw>`;\n    strXml += '</a:effectLst>';\n    return strXml;\n}\n/**\n * Create Grid Line Element\n * @param {OptsChartGridLine} glOpts {size, color, style}\n * @return {string} XML\n */\nfunction createGridLineElement(glOpts) {\n    let strXml = '<c:majorGridlines>';\n    strXml += ' <c:spPr>';\n    strXml += `  <a:ln w=\"${valToPts(glOpts.size || DEF_CHART_GRIDLINE.size)}\" cap=\"${createLineCap(glOpts.cap || DEF_CHART_GRIDLINE.cap)}\">`;\n    strXml += '  <a:solidFill><a:srgbClr val=\"' + (glOpts.color || DEF_CHART_GRIDLINE.color) + '\"/></a:solidFill>'; // should accept scheme colors as implemented in [Pull #135]\n    strXml += '   <a:prstDash val=\"' + (glOpts.style || DEF_CHART_GRIDLINE.style) + '\"/><a:round/>';\n    strXml += '  </a:ln>';\n    strXml += ' </c:spPr>';\n    strXml += '</c:majorGridlines>';\n    return strXml;\n}\nfunction createLineCap(lineCap) {\n    if (!lineCap || lineCap === 'flat') {\n        return 'flat';\n    }\n    else if (lineCap === 'square') {\n        return 'sq';\n    }\n    else if (lineCap === 'round') {\n        return 'rnd';\n    }\n    else {\n        const neverLineCap = lineCap;\n        throw new Error(`Invalid chart line cap: ${neverLineCap}`);\n    }\n}\n\n/**\n * PptxGenJS: Media Methods\n */\n/**\n * Encode Image/Audio/Video into base64\n * @param {PresSlide | SlideLayout} layout - slide layout\n * @return {Promise} promise\n */\nfunction encodeSlideMediaRels(layout) {\n    var _a, _b;\n    // STEP 1: Detect real Node runtime once\n    const isNode = typeof process !== 'undefined' && !!((_a = process.versions) === null || _a === void 0 ? void 0 : _a.node) && ((_b = process.release) === null || _b === void 0 ? void 0 : _b.name) === 'node';\n    // These will be filled only when we’re in Node\n    let fs;\n    let https;\n    // STEP 2: Lazy-load Node built-ins if needed\n    const loadNodeDeps = isNode\n        ? () => __awaiter(this, void 0, void 0, function* () {\n            ({ default: fs } = yield Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! node:fs */ \"node:fs\", 23)));\n            ({ default: https } = yield Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! node:https */ \"node:https\", 23)));\n        })\n        : () => __awaiter(this, void 0, void 0, function* () { });\n    // Immediately start it when we know we’re in Node\n    if (isNode)\n        loadNodeDeps();\n    // STEP 3: Prepare promises list\n    const imageProms = [];\n    // A: Capture all audio/image/video candidates for encoding (filtering online/pre-encoded)\n    const candidateRels = layout._relsMedia.filter(rel => rel.type !== 'online' && !rel.data && (!rel.path || (rel.path && !rel.path.includes('preencoded'))));\n    // B: PERF: Mark dupes (same `path`) to avoid loading the same media over-and-over!\n    const unqPaths = [];\n    candidateRels.forEach(rel => {\n        if (!unqPaths.includes(rel.path)) {\n            rel.isDuplicate = false;\n            unqPaths.push(rel.path);\n        }\n        else {\n            rel.isDuplicate = true;\n        }\n    });\n    // STEP 4: Read/Encode each unique media item\n    candidateRels\n        .filter(rel => !rel.isDuplicate)\n        .forEach(rel => {\n        imageProms.push((() => __awaiter(this, void 0, void 0, function* () {\n            if (!https)\n                yield loadNodeDeps();\n            // ────────────  NODE LOCAL FILE  ────────────\n            if (isNode && fs && rel.path.indexOf('http') !== 0) {\n                try {\n                    const bitmap = fs.readFileSync(rel.path);\n                    rel.data = Buffer.from(bitmap).toString('base64');\n                    candidateRels\n                        .filter(dupe => dupe.isDuplicate && dupe.path === rel.path)\n                        .forEach(dupe => (dupe.data = rel.data));\n                    return 'done';\n                }\n                catch (ex) {\n                    rel.data = IMG_BROKEN;\n                    candidateRels\n                        .filter(dupe => dupe.isDuplicate && dupe.path === rel.path)\n                        .forEach(dupe => (dupe.data = rel.data));\n                    throw new Error(`ERROR: Unable to read media: \"${rel.path}\"\\n${String(ex)}`);\n                }\n            }\n            // ────────────  NODE HTTP(S)  ────────────\n            if (isNode && https && rel.path.startsWith('http')) {\n                return yield new Promise((resolve, reject) => {\n                    https.get(rel.path, res => {\n                        let raw = '';\n                        res.setEncoding('binary'); // IMPORTANT: Only binary encoding works\n                        res.on('data', chunk => (raw += chunk));\n                        res.on('end', () => {\n                            rel.data = Buffer.from(raw, 'binary').toString('base64');\n                            candidateRels\n                                .filter(dupe => dupe.isDuplicate && dupe.path === rel.path)\n                                .forEach(dupe => (dupe.data = rel.data));\n                            resolve('done');\n                        });\n                        res.on('error', () => {\n                            rel.data = IMG_BROKEN;\n                            candidateRels\n                                .filter(dupe => dupe.isDuplicate && dupe.path === rel.path)\n                                .forEach(dupe => (dupe.data = rel.data));\n                            reject(new Error(`ERROR! Unable to load image (https.get): ${rel.path}`));\n                        });\n                    });\n                });\n            }\n            // ────────────  BROWSER  ────────────\n            return yield new Promise((resolve, reject) => {\n                // A: build request\n                const xhr = new XMLHttpRequest();\n                xhr.onload = () => {\n                    const reader = new FileReader();\n                    reader.onloadend = () => {\n                        rel.data = reader.result;\n                        candidateRels\n                            .filter(dupe => dupe.isDuplicate && dupe.path === rel.path)\n                            .forEach(dupe => (dupe.data = rel.data));\n                        if (!rel.isSvgPng) {\n                            resolve('done');\n                        }\n                        else {\n                            createSvgPngPreview(rel)\n                                .then(() => resolve('done'))\n                                .catch(reject);\n                        }\n                    };\n                    reader.readAsDataURL(xhr.response);\n                };\n                xhr.onerror = () => {\n                    rel.data = IMG_BROKEN;\n                    candidateRels\n                        .filter(dupe => dupe.isDuplicate && dupe.path === rel.path)\n                        .forEach(dupe => (dupe.data = rel.data));\n                    reject(new Error(`ERROR! Unable to load image (xhr.onerror): ${rel.path}`));\n                };\n                // B: execute request\n                xhr.open('GET', rel.path);\n                xhr.responseType = 'blob';\n                xhr.send();\n            });\n        }))());\n    });\n    // STEP 5: SVG-PNG previews\n    // ......: \"SVG:\" base64 data still requires a png to be generated\n    // ......: (`isSvgPng` flag this as the preview image, not the SVG itself)\n    layout._relsMedia\n        .filter(rel => rel.isSvgPng && rel.data)\n        .forEach(rel => {\n        (() => __awaiter(this, void 0, void 0, function* () {\n            if (isNode && !fs)\n                yield loadNodeDeps();\n            if (isNode && fs) {\n                // console.log('Sorry, SVG is not supported in Node (more info: https://github.com/gitbrent/PptxGenJS/issues/401)')\n                rel.data = IMG_BROKEN;\n                imageProms.push(Promise.resolve('done'));\n            }\n            else {\n                imageProms.push(createSvgPngPreview(rel));\n            }\n        }))();\n    });\n    return imageProms;\n}\n/**\n * Create SVG preview image\n * @param {ISlideRelMedia} rel - slide rel\n * @return {Promise} promise\n */\nfunction createSvgPngPreview(rel) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield new Promise((resolve, reject) => {\n            // A: Create\n            const image = new Image();\n            // B: Set onload event\n            image.onload = () => {\n                // First: Check for any errors: This is the best method (try/catch wont work, etc.)\n                if (image.width + image.height === 0) {\n                    image.onerror('h/w=0');\n                }\n                let canvas = document.createElement('CANVAS');\n                const ctx = canvas.getContext('2d');\n                canvas.width = image.width;\n                canvas.height = image.height;\n                ctx.drawImage(image, 0, 0);\n                // Users running on local machine will get the following error:\n                // \"SecurityError: Failed to execute 'toDataURL' on 'HTMLCanvasElement': Tainted canvases may not be exported.\"\n                // when the canvas.toDataURL call executes below.\n                try {\n                    rel.data = canvas.toDataURL(rel.type);\n                    resolve('done');\n                }\n                catch (ex) {\n                    image.onerror(ex.toString());\n                }\n                canvas = null;\n            };\n            image.onerror = () => {\n                rel.data = IMG_BROKEN;\n                reject(new Error(`ERROR! Unable to load image (image.onerror): ${rel.path}`));\n            };\n            // C: Load image\n            image.src = typeof rel.data === 'string' ? rel.data : IMG_BROKEN;\n        });\n    });\n}\n/**\n * FIXME: TODO: currently unused\n * TODO: Should return a Promise\n */\n/*\nfunction getSizeFromImage (inImgUrl: string): { width: number, height: number } {\n    const sizeOf = typeof require !== 'undefined' ? require('sizeof') : null // NodeJS\n\n    if (sizeOf) {\n        try {\n            const dimensions = sizeOf(inImgUrl)\n            return { width: dimensions.width, height: dimensions.height }\n        } catch (ex) {\n            console.error('ERROR: sizeOf: Unable to load image: ' + inImgUrl)\n            return { width: 0, height: 0 }\n        }\n    } else if (Image && typeof Image === 'function') {\n        // A: Create\n        const image = new Image()\n\n        // B: Set onload event\n        image.onload = () => {\n            // FIRST: Check for any errors: This is the best method (try/catch wont work, etc.)\n            if (image.width + image.height === 0) {\n                return { width: 0, height: 0 }\n            }\n            const obj = { width: image.width, height: image.height }\n            return obj\n        }\n        image.onerror = () => {\n            console.error(`ERROR: image.onload: Unable to load image: ${inImgUrl}`)\n        }\n\n        // C: Load image\n        image.src = inImgUrl\n    }\n}\n*/\n\n/**\n * PptxGenJS: XML Generation\n */\nconst ImageSizingXml = {\n    cover: function (imgSize, boxDim) {\n        const imgRatio = imgSize.h / imgSize.w;\n        const boxRatio = boxDim.h / boxDim.w;\n        const isBoxBased = boxRatio > imgRatio;\n        const width = isBoxBased ? boxDim.h / imgRatio : boxDim.w;\n        const height = isBoxBased ? boxDim.h : boxDim.w * imgRatio;\n        const hzPerc = Math.round(1e5 * 0.5 * (1 - boxDim.w / width));\n        const vzPerc = Math.round(1e5 * 0.5 * (1 - boxDim.h / height));\n        return `<a:srcRect l=\"${hzPerc}\" r=\"${hzPerc}\" t=\"${vzPerc}\" b=\"${vzPerc}\"/><a:stretch/>`;\n    },\n    contain: function (imgSize, boxDim) {\n        const imgRatio = imgSize.h / imgSize.w;\n        const boxRatio = boxDim.h / boxDim.w;\n        const widthBased = boxRatio > imgRatio;\n        const width = widthBased ? boxDim.w : boxDim.h / imgRatio;\n        const height = widthBased ? boxDim.w * imgRatio : boxDim.h;\n        const hzPerc = Math.round(1e5 * 0.5 * (1 - boxDim.w / width));\n        const vzPerc = Math.round(1e5 * 0.5 * (1 - boxDim.h / height));\n        return `<a:srcRect l=\"${hzPerc}\" r=\"${hzPerc}\" t=\"${vzPerc}\" b=\"${vzPerc}\"/><a:stretch/>`;\n    },\n    crop: function (imgSize, boxDim) {\n        const l = boxDim.x;\n        const r = imgSize.w - (boxDim.x + boxDim.w);\n        const t = boxDim.y;\n        const b = imgSize.h - (boxDim.y + boxDim.h);\n        const lPerc = Math.round(1e5 * (l / imgSize.w));\n        const rPerc = Math.round(1e5 * (r / imgSize.w));\n        const tPerc = Math.round(1e5 * (t / imgSize.h));\n        const bPerc = Math.round(1e5 * (b / imgSize.h));\n        return `<a:srcRect l=\"${lPerc}\" r=\"${rPerc}\" t=\"${tPerc}\" b=\"${bPerc}\"/><a:stretch/>`;\n    },\n};\n/**\n * Transforms a slide or slideLayout to resulting XML string - Creates `ppt/slide*.xml`\n * @param {PresSlide|SlideLayout} slideObject - slide object created within createSlideObject\n * @return {string} XML string with <p:cSld> as the root\n */\nfunction slideObjectToXml(slide) {\n    var _a;\n    let strSlideXml = slide._name ? '<p:cSld name=\"' + slide._name + '\">' : '<p:cSld>';\n    let intTableNum = 1;\n    // STEP 1: Add background color/image (ensure only a single `<p:bg>` tag is created, ex: when master-baskground has both `color` and `path`)\n    if (slide._bkgdImgRid) {\n        strSlideXml += `<p:bg><p:bgPr><a:blipFill dpi=\"0\" rotWithShape=\"1\"><a:blip r:embed=\"rId${slide._bkgdImgRid}\"><a:lum/></a:blip><a:srcRect/><a:stretch><a:fillRect/></a:stretch></a:blipFill><a:effectLst/></p:bgPr></p:bg>`;\n    }\n    else if ((_a = slide.background) === null || _a === void 0 ? void 0 : _a.color) {\n        strSlideXml += `<p:bg><p:bgPr>${genXmlColorSelection(slide.background)}</p:bgPr></p:bg>`;\n    }\n    else if (!slide.bkgd && slide._name && slide._name === DEF_PRES_LAYOUT_NAME) {\n        // NOTE: Default [white] background is needed on slideMaster1.xml to avoid gray background in Keynote (and Finder previews)\n        strSlideXml += '<p:bg><p:bgRef idx=\"1001\"><a:schemeClr val=\"bg1\"/></p:bgRef></p:bg>';\n    }\n    // STEP 2: Continue slide by starting spTree node\n    strSlideXml += '<p:spTree>';\n    strSlideXml += '<p:nvGrpSpPr><p:cNvPr id=\"1\" name=\"\"/><p:cNvGrpSpPr/><p:nvPr/></p:nvGrpSpPr>';\n    strSlideXml += '<p:grpSpPr><a:xfrm><a:off x=\"0\" y=\"0\"/><a:ext cx=\"0\" cy=\"0\"/>';\n    strSlideXml += '<a:chOff x=\"0\" y=\"0\"/><a:chExt cx=\"0\" cy=\"0\"/></a:xfrm></p:grpSpPr>';\n    // STEP 3: Loop over all Slide.data objects and add them to this slide\n    slide._slideObjects.forEach((slideItemObj, idx) => {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        let x = 0;\n        let y = 0;\n        let cx = getSmartParseNumber('75%', 'X', slide._presLayout);\n        let cy = 0;\n        let placeholderObj;\n        let locationAttr = '';\n        let arrTabRows = null;\n        let objTabOpts = null;\n        let intColCnt = 0;\n        let intColW = 0;\n        let cellOpts = null;\n        let strXml = null;\n        const sizing = (_a = slideItemObj.options) === null || _a === void 0 ? void 0 : _a.sizing;\n        const rounding = (_b = slideItemObj.options) === null || _b === void 0 ? void 0 : _b.rounding;\n        if (slide._slideLayout !== undefined &&\n            slide._slideLayout._slideObjects !== undefined &&\n            slideItemObj.options &&\n            slideItemObj.options.placeholder) {\n            placeholderObj = slide._slideLayout._slideObjects.filter((object) => object.options.placeholder === slideItemObj.options.placeholder)[0];\n        }\n        // A: Set option vars\n        slideItemObj.options = slideItemObj.options || {};\n        if (typeof slideItemObj.options.x !== 'undefined')\n            x = getSmartParseNumber(slideItemObj.options.x, 'X', slide._presLayout);\n        if (typeof slideItemObj.options.y !== 'undefined')\n            y = getSmartParseNumber(slideItemObj.options.y, 'Y', slide._presLayout);\n        if (typeof slideItemObj.options.w !== 'undefined')\n            cx = getSmartParseNumber(slideItemObj.options.w, 'X', slide._presLayout);\n        if (typeof slideItemObj.options.h !== 'undefined')\n            cy = getSmartParseNumber(slideItemObj.options.h, 'Y', slide._presLayout);\n        // Set w/h now that smart parse is done\n        let imgWidth = cx;\n        let imgHeight = cy;\n        // If using a placeholder then inherit it's position\n        if (placeholderObj) {\n            if (placeholderObj.options.x || placeholderObj.options.x === 0)\n                x = getSmartParseNumber(placeholderObj.options.x, 'X', slide._presLayout);\n            if (placeholderObj.options.y || placeholderObj.options.y === 0)\n                y = getSmartParseNumber(placeholderObj.options.y, 'Y', slide._presLayout);\n            if (placeholderObj.options.w || placeholderObj.options.w === 0)\n                cx = getSmartParseNumber(placeholderObj.options.w, 'X', slide._presLayout);\n            if (placeholderObj.options.h || placeholderObj.options.h === 0)\n                cy = getSmartParseNumber(placeholderObj.options.h, 'Y', slide._presLayout);\n        }\n        //\n        if (slideItemObj.options.flipH)\n            locationAttr += ' flipH=\"1\"';\n        if (slideItemObj.options.flipV)\n            locationAttr += ' flipV=\"1\"';\n        if (slideItemObj.options.rotate)\n            locationAttr += ` rot=\"${convertRotationDegrees(slideItemObj.options.rotate)}\"`;\n        // B: Add OBJECT to the current Slide\n        switch (slideItemObj._type) {\n            case SLIDE_OBJECT_TYPES.table:\n                arrTabRows = slideItemObj.arrTabRows;\n                objTabOpts = slideItemObj.options;\n                intColCnt = 0;\n                intColW = 0;\n                // Calc number of columns\n                // NOTE: Cells may have a colspan, so merely taking the length of the [0] (or any other) row is not\n                // ....: sufficient to determine column count. Therefore, check each cell for a colspan and total cols as reqd\n                arrTabRows[0].forEach(cell => {\n                    cellOpts = cell.options || null;\n                    intColCnt += (cellOpts === null || cellOpts === void 0 ? void 0 : cellOpts.colspan) ? Number(cellOpts.colspan) : 1;\n                });\n                // STEP 1: Start Table XML\n                // NOTE: Non-numeric cNvPr id values will trigger \"presentation needs repair\" type warning in MS-PPT-2013\n                strXml = `<p:graphicFrame><p:nvGraphicFramePr><p:cNvPr id=\"${intTableNum * slide._slideNum + 1}\" name=\"${slideItemObj.options.objectName}\"/>`;\n                strXml +=\n                    '<p:cNvGraphicFramePr><a:graphicFrameLocks noGrp=\"1\"/></p:cNvGraphicFramePr>' +\n                        '  <p:nvPr><p:extLst><p:ext uri=\"{D42A27DB-BD31-4B8C-83A1-F6EECF244321}\"><p14:modId xmlns:p14=\"http://schemas.microsoft.com/office/powerpoint/2010/main\" val=\"1579011935\"/></p:ext></p:extLst></p:nvPr>' +\n                        '</p:nvGraphicFramePr>';\n                strXml += `<p:xfrm><a:off x=\"${x || (x === 0 ? 0 : EMU)}\" y=\"${y || (y === 0 ? 0 : EMU)}\"/><a:ext cx=\"${cx || (cx === 0 ? 0 : EMU)}\" cy=\"${cy || EMU}\"/></p:xfrm>`;\n                strXml += '<a:graphic><a:graphicData uri=\"http://schemas.openxmlformats.org/drawingml/2006/table\"><a:tbl><a:tblPr/>';\n                // + '        <a:tblPr bandRow=\"1\"/>';\n                // TODO: Support banded rows, first/last row, etc.\n                // NOTE: Banding, etc. only shows when using a table style! (or set alt row color if banding)\n                // <a:tblPr firstCol=\"0\" firstRow=\"0\" lastCol=\"0\" lastRow=\"0\" bandCol=\"0\" bandRow=\"1\">\n                // STEP 2: Set column widths\n                // Evenly distribute cols/rows across size provided when applicable (calc them if only overall dimensions were provided)\n                // A: Col widths provided?\n                // B: Table Width provided without colW? Then distribute cols\n                if (Array.isArray(objTabOpts.colW)) {\n                    strXml += '<a:tblGrid>';\n                    for (let col = 0; col < intColCnt; col++) {\n                        let w = inch2Emu(objTabOpts.colW[col]);\n                        if (w == null || isNaN(w)) {\n                            w = (typeof slideItemObj.options.w === 'number' ? slideItemObj.options.w : 1) / intColCnt;\n                        }\n                        strXml += `<a:gridCol w=\"${Math.round(w)}\"/>`;\n                    }\n                    strXml += '</a:tblGrid>';\n                }\n                else {\n                    intColW = objTabOpts.colW ? objTabOpts.colW : EMU;\n                    if (slideItemObj.options.w && !objTabOpts.colW)\n                        intColW = Math.round((typeof slideItemObj.options.w === 'number' ? slideItemObj.options.w : 1) / intColCnt);\n                    strXml += '<a:tblGrid>';\n                    for (let colw = 0; colw < intColCnt; colw++) {\n                        strXml += `<a:gridCol w=\"${intColW}\"/>`;\n                    }\n                    strXml += '</a:tblGrid>';\n                }\n                // STEP 3: Build our row arrays into an actual grid to match the XML we will be building next (ISSUE #36)\n                // Note row arrays can arrive \"lopsided\" as in row1:[1,2,3] row2:[3] when first two cols rowspan!,\n                // so a simple loop below in XML building wont suffice to build table correctly.\n                // We have to build an actual grid now\n                /*\n                    EX: (A0:rowspan=3, B1:rowspan=2, C1:colspan=2)\n\n                    /------|------|------|------\\\n                    |  A0  |  B0  |  C0  |  D0  |\n                    |      |  B1  |  C1  |      |\n                    |      |      |  C2  |  D2  |\n                    \\------|------|------|------/\n                */\n                // A: add _hmerge cell for colspan. should reserve rowspan\n                arrTabRows.forEach(cells => {\n                    var _a, _b;\n                    for (let cIdx = 0; cIdx < cells.length;) {\n                        const cell = cells[cIdx];\n                        const colspan = (_a = cell.options) === null || _a === void 0 ? void 0 : _a.colspan;\n                        const rowspan = (_b = cell.options) === null || _b === void 0 ? void 0 : _b.rowspan;\n                        if (colspan && colspan > 1) {\n                            const vMergeCells = new Array(colspan - 1).fill(undefined).map(() => {\n                                return { _type: SLIDE_OBJECT_TYPES.tablecell, options: { rowspan }, _hmerge: true };\n                            });\n                            cells.splice(cIdx + 1, 0, ...vMergeCells);\n                            cIdx += colspan;\n                        }\n                        else {\n                            cIdx += 1;\n                        }\n                    }\n                });\n                // B: add _vmerge cell for rowspan. should reserve colspan/_hmerge\n                arrTabRows.forEach((cells, rIdx) => {\n                    const nextRow = arrTabRows[rIdx + 1];\n                    if (!nextRow)\n                        return;\n                    cells.forEach((cell, cIdx) => {\n                        var _a, _b;\n                        const rowspan = cell._rowContinue || ((_a = cell.options) === null || _a === void 0 ? void 0 : _a.rowspan);\n                        const colspan = (_b = cell.options) === null || _b === void 0 ? void 0 : _b.colspan;\n                        const _hmerge = cell._hmerge;\n                        if (rowspan && rowspan > 1) {\n                            const hMergeCell = { _type: SLIDE_OBJECT_TYPES.tablecell, options: { colspan }, _rowContinue: rowspan - 1, _vmerge: true, _hmerge };\n                            nextRow.splice(cIdx, 0, hMergeCell);\n                        }\n                    });\n                });\n                // STEP 4: Build table rows/cells\n                arrTabRows.forEach((cells, rIdx) => {\n                    // A: Table Height provided without rowH? Then distribute rows\n                    let intRowH = 0; // IMPORTANT: Default must be zero for auto-sizing to work\n                    if (Array.isArray(objTabOpts.rowH) && objTabOpts.rowH[rIdx])\n                        intRowH = inch2Emu(Number(objTabOpts.rowH[rIdx]));\n                    else if (objTabOpts.rowH && !isNaN(Number(objTabOpts.rowH)))\n                        intRowH = inch2Emu(Number(objTabOpts.rowH));\n                    else if (slideItemObj.options.cy || slideItemObj.options.h) {\n                        intRowH = Math.round((slideItemObj.options.h ? inch2Emu(slideItemObj.options.h) : typeof slideItemObj.options.cy === 'number' ? slideItemObj.options.cy : 1) /\n                            arrTabRows.length);\n                    }\n                    // B: Start row\n                    strXml += `<a:tr h=\"${intRowH}\">`;\n                    // C: Loop over each CELL\n                    cells.forEach(cellObj => {\n                        var _a, _b, _c, _d, _e;\n                        const cell = cellObj;\n                        const cellSpanAttrs = {\n                            rowSpan: ((_a = cell.options) === null || _a === void 0 ? void 0 : _a.rowspan) > 1 ? cell.options.rowspan : undefined,\n                            gridSpan: ((_b = cell.options) === null || _b === void 0 ? void 0 : _b.colspan) > 1 ? cell.options.colspan : undefined,\n                            vMerge: cell._vmerge ? 1 : undefined,\n                            hMerge: cell._hmerge ? 1 : undefined,\n                        };\n                        let cellSpanAttrStr = Object.keys(cellSpanAttrs)\n                            .map(k => [k, cellSpanAttrs[k]])\n                            .filter(([, v]) => !!v)\n                            .map(([k, v]) => `${String(k)}=\"${String(v)}\"`)\n                            .join(' ');\n                        if (cellSpanAttrStr)\n                            cellSpanAttrStr = ' ' + cellSpanAttrStr;\n                        // 1: COLSPAN/ROWSPAN: Add dummy cells for any active colspan/rowspan\n                        if (cell._hmerge || cell._vmerge) {\n                            strXml += `<a:tc${cellSpanAttrStr}><a:tcPr/></a:tc>`;\n                            return;\n                        }\n                        // 2: OPTIONS: Build/set cell options\n                        const cellOpts = cell.options || {};\n                        cell.options = cellOpts;\n                        ['align', 'bold', 'border', 'color', 'fill', 'fontFace', 'fontSize', 'margin', 'textDirection', 'underline', 'valign'].forEach(name => {\n                            if (objTabOpts[name] && !cellOpts[name] && cellOpts[name] !== 0)\n                                cellOpts[name] = objTabOpts[name];\n                        });\n                        const cellValign = cellOpts.valign\n                            ? ` anchor=\"${cellOpts.valign.replace(/^c$/i, 'ctr').replace(/^m$/i, 'ctr').replace('center', 'ctr').replace('middle', 'ctr').replace('top', 't').replace('btm', 'b').replace('bottom', 'b')}\"`\n                            : '';\n                        const cellTextDir = (cellOpts.textDirection && cellOpts.textDirection !== 'horz') ? ` vert=\"${cellOpts.textDirection}\"` : '';\n                        let fillColor = ((_d = (_c = cell._optImp) === null || _c === void 0 ? void 0 : _c.fill) === null || _d === void 0 ? void 0 : _d.color)\n                            ? cell._optImp.fill.color\n                            : ((_e = cell._optImp) === null || _e === void 0 ? void 0 : _e.fill) && typeof cell._optImp.fill === 'string'\n                                ? cell._optImp.fill\n                                : '';\n                        fillColor = fillColor || cellOpts.fill ? cellOpts.fill : '';\n                        const cellFill = fillColor ? genXmlColorSelection(fillColor) : '';\n                        let cellMargin = cellOpts.margin === 0 || cellOpts.margin ? cellOpts.margin : DEF_CELL_MARGIN_IN;\n                        if (!Array.isArray(cellMargin) && typeof cellMargin === 'number')\n                            cellMargin = [cellMargin, cellMargin, cellMargin, cellMargin];\n                        /** FUTURE: DEPRECATED:\n                         * - Backwards-Compat: Oops! Discovered we were still using points for cell margin before v3.8.0 (UGH!)\n                         * - We cant introduce a breaking change before v4.0, so...\n                         */\n                        let cellMarginXml = '';\n                        if (cellMargin[0] >= 1) {\n                            cellMarginXml = ` marL=\"${valToPts(cellMargin[3])}\" marR=\"${valToPts(cellMargin[1])}\" marT=\"${valToPts(cellMargin[0])}\" marB=\"${valToPts(cellMargin[2])}\"`;\n                        }\n                        else {\n                            cellMarginXml = ` marL=\"${inch2Emu(cellMargin[3])}\" marR=\"${inch2Emu(cellMargin[1])}\" marT=\"${inch2Emu(cellMargin[0])}\" marB=\"${inch2Emu(cellMargin[2])}\"`;\n                        }\n                        // FUTURE: Cell NOWRAP property (textwrap: add to a:tcPr (horzOverflow=\"overflow\" or whatever options exist)\n                        // 4: Set CELL content and properties ==================================\n                        strXml += `<a:tc${cellSpanAttrStr}>${genXmlTextBody(cell)}<a:tcPr${cellMarginXml}${cellValign}${cellTextDir}>`;\n                        // strXml += `<a:tc${cellColspan}${cellRowspan}>${genXmlTextBody(cell)}<a:tcPr${cellMarginXml}${cellValign}${cellTextDir}>`\n                        // FIXME: 20200525: ^^^\n                        // <a:tcPr marL=\"38100\" marR=\"38100\" marT=\"38100\" marB=\"38100\" vert=\"vert270\">\n                        // 5: Borders: Add any borders\n                        if (cellOpts.border && Array.isArray(cellOpts.border)) {\n                            // NOTE: *** IMPORTANT! *** LRTB order matters! (Reorder a line below to watch the borders go wonky in MS-PPT-2013!!)\n                            [\n                                { idx: 3, name: 'lnL' },\n                                { idx: 1, name: 'lnR' },\n                                { idx: 0, name: 'lnT' },\n                                { idx: 2, name: 'lnB' },\n                            ].forEach(obj => {\n                                if (cellOpts.border[obj.idx].type !== 'none') {\n                                    strXml += `<a:${obj.name} w=\"${valToPts(cellOpts.border[obj.idx].pt)}\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\">`;\n                                    strXml += `<a:solidFill>${createColorElement(cellOpts.border[obj.idx].color)}</a:solidFill>`;\n                                    strXml += `<a:prstDash val=\"${cellOpts.border[obj.idx].type === 'dash' ? 'sysDash' : 'solid'}\"/><a:round/><a:headEnd type=\"none\" w=\"med\" len=\"med\"/><a:tailEnd type=\"none\" w=\"med\" len=\"med\"/>`;\n                                    strXml += `</a:${obj.name}>`;\n                                }\n                                else {\n                                    strXml += `<a:${obj.name} w=\"0\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"><a:noFill/></a:${obj.name}>`;\n                                }\n                            });\n                        }\n                        // 6: Close cell Properties & Cell\n                        strXml += cellFill;\n                        strXml += '  </a:tcPr>';\n                        strXml += ' </a:tc>';\n                    });\n                    // D: Complete row\n                    strXml += '</a:tr>';\n                });\n                // STEP 5: Complete table\n                strXml += '      </a:tbl>';\n                strXml += '    </a:graphicData>';\n                strXml += '  </a:graphic>';\n                strXml += '</p:graphicFrame>';\n                // STEP 6: Set table XML\n                strSlideXml += strXml;\n                // LAST: Increment counter\n                intTableNum++;\n                break;\n            case SLIDE_OBJECT_TYPES.text:\n            case SLIDE_OBJECT_TYPES.placeholder:\n                // Lines can have zero cy, but text should not\n                if (!slideItemObj.options.line && cy === 0)\n                    cy = EMU * 0.3;\n                // Margin/Padding/Inset for textboxes\n                if (!slideItemObj.options._bodyProp)\n                    slideItemObj.options._bodyProp = {};\n                if (slideItemObj.options.margin && Array.isArray(slideItemObj.options.margin)) {\n                    slideItemObj.options._bodyProp.lIns = valToPts(slideItemObj.options.margin[0] || 0);\n                    slideItemObj.options._bodyProp.rIns = valToPts(slideItemObj.options.margin[1] || 0);\n                    slideItemObj.options._bodyProp.bIns = valToPts(slideItemObj.options.margin[2] || 0);\n                    slideItemObj.options._bodyProp.tIns = valToPts(slideItemObj.options.margin[3] || 0);\n                }\n                else if (typeof slideItemObj.options.margin === 'number') {\n                    slideItemObj.options._bodyProp.lIns = valToPts(slideItemObj.options.margin);\n                    slideItemObj.options._bodyProp.rIns = valToPts(slideItemObj.options.margin);\n                    slideItemObj.options._bodyProp.bIns = valToPts(slideItemObj.options.margin);\n                    slideItemObj.options._bodyProp.tIns = valToPts(slideItemObj.options.margin);\n                }\n                // A: Start SHAPE =======================================================\n                strSlideXml += '<p:sp>';\n                // B: The addition of the \"txBox\" attribute is the sole determiner of if an object is a shape or textbox\n                strSlideXml += `<p:nvSpPr><p:cNvPr id=\"${idx + 2}\" name=\"${slideItemObj.options.objectName}\">`;\n                // <Hyperlink>\n                if ((_c = slideItemObj.options.hyperlink) === null || _c === void 0 ? void 0 : _c.url) {\n                    strSlideXml += `<a:hlinkClick r:id=\"rId${slideItemObj.options.hyperlink._rId}\" tooltip=\"${slideItemObj.options.hyperlink.tooltip ? encodeXmlEntities(slideItemObj.options.hyperlink.tooltip) : ''}\"/>`;\n                }\n                if ((_d = slideItemObj.options.hyperlink) === null || _d === void 0 ? void 0 : _d.slide) {\n                    strSlideXml += `<a:hlinkClick r:id=\"rId${slideItemObj.options.hyperlink._rId}\" tooltip=\"${slideItemObj.options.hyperlink.tooltip ? encodeXmlEntities(slideItemObj.options.hyperlink.tooltip) : ''}\" action=\"ppaction://hlinksldjump\"/>`;\n                }\n                // </Hyperlink>\n                strSlideXml += '</p:cNvPr>';\n                strSlideXml += '<p:cNvSpPr' + (((_e = slideItemObj.options) === null || _e === void 0 ? void 0 : _e.isTextBox) ? ' txBox=\"1\"/>' : '/>');\n                strSlideXml += `<p:nvPr>${slideItemObj._type === 'placeholder' ? genXmlPlaceholder(slideItemObj) : genXmlPlaceholder(placeholderObj)}</p:nvPr>`;\n                strSlideXml += '</p:nvSpPr><p:spPr>';\n                strSlideXml += `<a:xfrm${locationAttr}>`;\n                strSlideXml += `<a:off x=\"${x}\" y=\"${y}\"/>`;\n                strSlideXml += `<a:ext cx=\"${cx}\" cy=\"${cy}\"/></a:xfrm>`;\n                if (slideItemObj.shape === 'custGeom') {\n                    strSlideXml += '<a:custGeom><a:avLst />';\n                    strSlideXml += '<a:gdLst>';\n                    strSlideXml += '</a:gdLst>';\n                    strSlideXml += '<a:ahLst />';\n                    strSlideXml += '<a:cxnLst>';\n                    strSlideXml += '</a:cxnLst>';\n                    strSlideXml += '<a:rect l=\"l\" t=\"t\" r=\"r\" b=\"b\" />';\n                    strSlideXml += '<a:pathLst>';\n                    strSlideXml += `<a:path w=\"${cx}\" h=\"${cy}\">`;\n                    (_f = slideItemObj.options.points) === null || _f === void 0 ? void 0 : _f.forEach((point, i) => {\n                        if ('curve' in point) {\n                            switch (point.curve.type) {\n                                case 'arc':\n                                    strSlideXml += `<a:arcTo hR=\"${getSmartParseNumber(point.curve.hR, 'Y', slide._presLayout)}\" wR=\"${getSmartParseNumber(point.curve.wR, 'X', slide._presLayout)}\" stAng=\"${convertRotationDegrees(point.curve.stAng)}\" swAng=\"${convertRotationDegrees(point.curve.swAng)}\" />`;\n                                    break;\n                                case 'cubic':\n                                    strSlideXml += `<a:cubicBezTo>\n\t\t\t\t\t\t\t\t\t<a:pt x=\"${getSmartParseNumber(point.curve.x1, 'X', slide._presLayout)}\" y=\"${getSmartParseNumber(point.curve.y1, 'Y', slide._presLayout)}\" />\n\t\t\t\t\t\t\t\t\t<a:pt x=\"${getSmartParseNumber(point.curve.x2, 'X', slide._presLayout)}\" y=\"${getSmartParseNumber(point.curve.y2, 'Y', slide._presLayout)}\" />\n\t\t\t\t\t\t\t\t\t<a:pt x=\"${getSmartParseNumber(point.x, 'X', slide._presLayout)}\" y=\"${getSmartParseNumber(point.y, 'Y', slide._presLayout)}\" />\n\t\t\t\t\t\t\t\t\t</a:cubicBezTo>`;\n                                    break;\n                                case 'quadratic':\n                                    strSlideXml += `<a:quadBezTo>\n\t\t\t\t\t\t\t\t\t<a:pt x=\"${getSmartParseNumber(point.curve.x1, 'X', slide._presLayout)}\" y=\"${getSmartParseNumber(point.curve.y1, 'Y', slide._presLayout)}\" />\n\t\t\t\t\t\t\t\t\t<a:pt x=\"${getSmartParseNumber(point.x, 'X', slide._presLayout)}\" y=\"${getSmartParseNumber(point.y, 'Y', slide._presLayout)}\" />\n\t\t\t\t\t\t\t\t\t</a:quadBezTo>`;\n                                    break;\n                            }\n                        }\n                        else if ('close' in point) {\n                            strSlideXml += '<a:close />';\n                        }\n                        else if (point.moveTo || i === 0) {\n                            strSlideXml += `<a:moveTo><a:pt x=\"${getSmartParseNumber(point.x, 'X', slide._presLayout)}\" y=\"${getSmartParseNumber(point.y, 'Y', slide._presLayout)}\" /></a:moveTo>`;\n                        }\n                        else {\n                            strSlideXml += `<a:lnTo><a:pt x=\"${getSmartParseNumber(point.x, 'X', slide._presLayout)}\" y=\"${getSmartParseNumber(point.y, 'Y', slide._presLayout)}\" /></a:lnTo>`;\n                        }\n                    });\n                    strSlideXml += '</a:path>';\n                    strSlideXml += '</a:pathLst>';\n                    strSlideXml += '</a:custGeom>';\n                }\n                else {\n                    strSlideXml += '<a:prstGeom prst=\"' + slideItemObj.shape + '\"><a:avLst>';\n                    if (slideItemObj.options.rectRadius) {\n                        strSlideXml += `<a:gd name=\"adj\" fmla=\"val ${Math.round((slideItemObj.options.rectRadius * EMU * 100000) / Math.min(cx, cy))}\"/>`;\n                    }\n                    else if (slideItemObj.options.angleRange) {\n                        for (let i = 0; i < 2; i++) {\n                            const angle = slideItemObj.options.angleRange[i];\n                            strSlideXml += `<a:gd name=\"adj${i + 1}\" fmla=\"val ${convertRotationDegrees(angle)}\" />`;\n                        }\n                        if (slideItemObj.options.arcThicknessRatio) {\n                            strSlideXml += `<a:gd name=\"adj3\" fmla=\"val ${Math.round(slideItemObj.options.arcThicknessRatio * 50000)}\" />`;\n                        }\n                    }\n                    strSlideXml += '</a:avLst></a:prstGeom>';\n                }\n                // Option: FILL\n                strSlideXml += slideItemObj.options.fill ? genXmlColorSelection(slideItemObj.options.fill) : '<a:noFill/>';\n                // shape Type: LINE: line color\n                if (slideItemObj.options.line) {\n                    strSlideXml += slideItemObj.options.line.width ? `<a:ln w=\"${valToPts(slideItemObj.options.line.width)}\">` : '<a:ln>';\n                    if (slideItemObj.options.line.color)\n                        strSlideXml += genXmlColorSelection(slideItemObj.options.line);\n                    if (slideItemObj.options.line.dashType)\n                        strSlideXml += `<a:prstDash val=\"${slideItemObj.options.line.dashType}\"/>`;\n                    if (slideItemObj.options.line.beginArrowType)\n                        strSlideXml += `<a:headEnd type=\"${slideItemObj.options.line.beginArrowType}\"/>`;\n                    if (slideItemObj.options.line.endArrowType)\n                        strSlideXml += `<a:tailEnd type=\"${slideItemObj.options.line.endArrowType}\"/>`;\n                    // FUTURE: `endArrowSize` < a: headEnd type = \"arrow\" w = \"lg\" len = \"lg\" /> 'sm' | 'med' | 'lg'(values are 1 - 9, making a 3x3 grid of w / len possibilities)\n                    strSlideXml += '</a:ln>';\n                }\n                // EFFECTS > SHADOW: REF: @see http://officeopenxml.com/drwSp-effects.php\n                if (slideItemObj.options.shadow && slideItemObj.options.shadow.type !== 'none') {\n                    slideItemObj.options.shadow.type = slideItemObj.options.shadow.type || 'outer';\n                    slideItemObj.options.shadow.blur = valToPts(slideItemObj.options.shadow.blur || 8);\n                    slideItemObj.options.shadow.offset = valToPts(slideItemObj.options.shadow.offset || 4);\n                    slideItemObj.options.shadow.angle = Math.round((slideItemObj.options.shadow.angle || 270) * 60000);\n                    slideItemObj.options.shadow.opacity = Math.round((slideItemObj.options.shadow.opacity || 0.75) * 100000);\n                    slideItemObj.options.shadow.color = slideItemObj.options.shadow.color || DEF_TEXT_SHADOW.color;\n                    strSlideXml += '<a:effectLst>';\n                    strSlideXml += ` <a:${slideItemObj.options.shadow.type}Shdw ${slideItemObj.options.shadow.type === 'outer' ? 'sx=\"100000\" sy=\"100000\" kx=\"0\" ky=\"0\" algn=\"bl\" rotWithShape=\"0\"' : ''} blurRad=\"${slideItemObj.options.shadow.blur}\" dist=\"${slideItemObj.options.shadow.offset}\" dir=\"${slideItemObj.options.shadow.angle}\">`;\n                    strSlideXml += ` <a:srgbClr val=\"${slideItemObj.options.shadow.color}\">`;\n                    strSlideXml += ` <a:alpha val=\"${slideItemObj.options.shadow.opacity}\"/></a:srgbClr>`;\n                    strSlideXml += ' </a:outerShdw>';\n                    strSlideXml += '</a:effectLst>';\n                }\n                /* TODO: FUTURE: Text wrapping (copied from MS-PPTX export)\n                    // Commented out b/c i'm not even sure this works - current code produces text that wraps in shapes and textboxes, so...\n                    if ( slideItemObj.options.textWrap ) {\n                        strSlideXml += '<a:extLst>'\n                                    + '<a:ext uri=\"{C572A759-6A51-4108-AA02-DFA0A04FC94B}\">'\n                                    + '<ma14:wrappingTextBoxFlag xmlns:ma14=\"http://schemas.microsoft.com/office/mac/drawingml/2011/main\" val=\"1\"/>'\n                                    + '</a:ext>'\n                                    + '</a:extLst>';\n                    }\n                */\n                // B: Close shape Properties\n                strSlideXml += '</p:spPr>';\n                // C: Add formatted text (text body \"bodyPr\")\n                strSlideXml += genXmlTextBody(slideItemObj);\n                // LAST: Close SHAPE =======================================================\n                strSlideXml += '</p:sp>';\n                break;\n            case SLIDE_OBJECT_TYPES.image:\n                strSlideXml += '<p:pic>';\n                strSlideXml += '  <p:nvPicPr>';\n                strSlideXml += `<p:cNvPr id=\"${idx + 2}\" name=\"${slideItemObj.options.objectName}\" descr=\"${encodeXmlEntities(slideItemObj.options.altText || slideItemObj.image)}\">`;\n                if ((_g = slideItemObj.hyperlink) === null || _g === void 0 ? void 0 : _g.url) {\n                    strSlideXml += `<a:hlinkClick r:id=\"rId${slideItemObj.hyperlink._rId}\" tooltip=\"${slideItemObj.hyperlink.tooltip ? encodeXmlEntities(slideItemObj.hyperlink.tooltip) : ''}\"/>`;\n                }\n                if ((_h = slideItemObj.hyperlink) === null || _h === void 0 ? void 0 : _h.slide) {\n                    strSlideXml += `<a:hlinkClick r:id=\"rId${slideItemObj.hyperlink._rId}\" tooltip=\"${slideItemObj.hyperlink.tooltip ? encodeXmlEntities(slideItemObj.hyperlink.tooltip) : ''}\" action=\"ppaction://hlinksldjump\"/>`;\n                }\n                strSlideXml += '    </p:cNvPr>';\n                strSlideXml += '    <p:cNvPicPr><a:picLocks noChangeAspect=\"1\"/></p:cNvPicPr>';\n                strSlideXml += '    <p:nvPr>' + genXmlPlaceholder(placeholderObj) + '</p:nvPr>';\n                strSlideXml += '  </p:nvPicPr>';\n                strSlideXml += '<p:blipFill>';\n                // NOTE: This works for both cases: either `path` or `data` contains the SVG\n                if ((slide._relsMedia || []).filter(rel => rel.rId === slideItemObj.imageRid)[0] &&\n                    (slide._relsMedia || []).filter(rel => rel.rId === slideItemObj.imageRid)[0].extn === 'svg') {\n                    strSlideXml += `<a:blip r:embed=\"rId${slideItemObj.imageRid - 1}\">`;\n                    strSlideXml += slideItemObj.options.transparency ? ` <a:alphaModFix amt=\"${Math.round((100 - slideItemObj.options.transparency) * 1000)}\"/>` : '';\n                    strSlideXml += ' <a:extLst>';\n                    strSlideXml += '  <a:ext uri=\"{96DAC541-7B7A-43D3-8B79-37D633B846F1}\">';\n                    strSlideXml += `   <asvg:svgBlip xmlns:asvg=\"http://schemas.microsoft.com/office/drawing/2016/SVG/main\" r:embed=\"rId${slideItemObj.imageRid}\"/>`;\n                    strSlideXml += '  </a:ext>';\n                    strSlideXml += ' </a:extLst>';\n                    strSlideXml += '</a:blip>';\n                }\n                else {\n                    strSlideXml += `<a:blip r:embed=\"rId${slideItemObj.imageRid}\">`;\n                    strSlideXml += slideItemObj.options.transparency ? `<a:alphaModFix amt=\"${Math.round((100 - slideItemObj.options.transparency) * 1000)}\"/>` : '';\n                    strSlideXml += '</a:blip>';\n                }\n                if (sizing === null || sizing === void 0 ? void 0 : sizing.type) {\n                    const boxW = sizing.w ? getSmartParseNumber(sizing.w, 'X', slide._presLayout) : cx;\n                    const boxH = sizing.h ? getSmartParseNumber(sizing.h, 'Y', slide._presLayout) : cy;\n                    const boxX = getSmartParseNumber(sizing.x || 0, 'X', slide._presLayout);\n                    const boxY = getSmartParseNumber(sizing.y || 0, 'Y', slide._presLayout);\n                    strSlideXml += ImageSizingXml[sizing.type]({ w: imgWidth, h: imgHeight }, { w: boxW, h: boxH, x: boxX, y: boxY });\n                    imgWidth = boxW;\n                    imgHeight = boxH;\n                }\n                else {\n                    strSlideXml += '  <a:stretch><a:fillRect/></a:stretch>';\n                }\n                strSlideXml += '</p:blipFill>';\n                strSlideXml += '<p:spPr>';\n                strSlideXml += ' <a:xfrm' + locationAttr + '>';\n                strSlideXml += `  <a:off x=\"${x}\" y=\"${y}\"/>`;\n                strSlideXml += `  <a:ext cx=\"${imgWidth}\" cy=\"${imgHeight}\"/>`;\n                strSlideXml += ' </a:xfrm>';\n                strSlideXml += ` <a:prstGeom prst=\"${rounding ? 'ellipse' : 'rect'}\"><a:avLst/></a:prstGeom>`;\n                // EFFECTS > SHADOW: REF: @see http://officeopenxml.com/drwSp-effects.php\n                if (slideItemObj.options.shadow && slideItemObj.options.shadow.type !== 'none') {\n                    slideItemObj.options.shadow.type = slideItemObj.options.shadow.type || 'outer';\n                    slideItemObj.options.shadow.blur = valToPts(slideItemObj.options.shadow.blur || 8);\n                    slideItemObj.options.shadow.offset = valToPts(slideItemObj.options.shadow.offset || 4);\n                    slideItemObj.options.shadow.angle = Math.round((slideItemObj.options.shadow.angle || 270) * 60000);\n                    slideItemObj.options.shadow.opacity = Math.round((slideItemObj.options.shadow.opacity || 0.75) * 100000);\n                    slideItemObj.options.shadow.color = slideItemObj.options.shadow.color || DEF_TEXT_SHADOW.color;\n                    strSlideXml += '<a:effectLst>';\n                    strSlideXml += `<a:${slideItemObj.options.shadow.type}Shdw ${slideItemObj.options.shadow.type === 'outer' ? 'sx=\"100000\" sy=\"100000\" kx=\"0\" ky=\"0\" algn=\"bl\" rotWithShape=\"0\"' : ''} blurRad=\"${slideItemObj.options.shadow.blur}\" dist=\"${slideItemObj.options.shadow.offset}\" dir=\"${slideItemObj.options.shadow.angle}\">`;\n                    strSlideXml += `<a:srgbClr val=\"${slideItemObj.options.shadow.color}\">`;\n                    strSlideXml += `<a:alpha val=\"${slideItemObj.options.shadow.opacity}\"/></a:srgbClr>`;\n                    strSlideXml += `</a:${slideItemObj.options.shadow.type}Shdw>`;\n                    strSlideXml += '</a:effectLst>';\n                }\n                strSlideXml += '</p:spPr>';\n                strSlideXml += '</p:pic>';\n                break;\n            case SLIDE_OBJECT_TYPES.media:\n                if (slideItemObj.mtype === 'online') {\n                    strSlideXml += '<p:pic>';\n                    strSlideXml += ' <p:nvPicPr>';\n                    // IMPORTANT: <p:cNvPr id=\"\" value is critical - if its not the same number as preview image `rId`, PowerPoint throws error!\n                    strSlideXml += `<p:cNvPr id=\"${slideItemObj.mediaRid + 2}\" name=\"${slideItemObj.options.objectName}\"/>`;\n                    strSlideXml += ' <p:cNvPicPr/>';\n                    strSlideXml += ' <p:nvPr>';\n                    strSlideXml += `  <a:videoFile r:link=\"rId${slideItemObj.mediaRid}\"/>`;\n                    strSlideXml += ' </p:nvPr>';\n                    strSlideXml += ' </p:nvPicPr>';\n                    // NOTE: `blip` is diferent than videos; also there's no preview \"p:extLst\" above but exists in videos\n                    strSlideXml += ` <p:blipFill><a:blip r:embed=\"rId${slideItemObj.mediaRid + 1}\"/><a:stretch><a:fillRect/></a:stretch></p:blipFill>`; // NOTE: Preview image is required!\n                    strSlideXml += ' <p:spPr>';\n                    strSlideXml += `  <a:xfrm${locationAttr}><a:off x=\"${x}\" y=\"${y}\"/><a:ext cx=\"${cx}\" cy=\"${cy}\"/></a:xfrm>`;\n                    strSlideXml += '  <a:prstGeom prst=\"rect\"><a:avLst/></a:prstGeom>';\n                    strSlideXml += ' </p:spPr>';\n                    strSlideXml += '</p:pic>';\n                }\n                else {\n                    strSlideXml += '<p:pic>';\n                    strSlideXml += ' <p:nvPicPr>';\n                    // IMPORTANT: <p:cNvPr id=\"\" value is critical - if not the same number as preiew image rId, PowerPoint throws error!\n                    strSlideXml += `<p:cNvPr id=\"${slideItemObj.mediaRid + 2}\" name=\"${slideItemObj.options.objectName}\"><a:hlinkClick r:id=\"\" action=\"ppaction://media\"/></p:cNvPr>`;\n                    strSlideXml += ' <p:cNvPicPr><a:picLocks noChangeAspect=\"1\"/></p:cNvPicPr>';\n                    strSlideXml += ' <p:nvPr>';\n                    strSlideXml += `  <a:videoFile r:link=\"rId${slideItemObj.mediaRid}\"/>`;\n                    strSlideXml += '  <p:extLst>';\n                    strSlideXml += '   <p:ext uri=\"{DAA4B4D4-6D71-4841-9C94-3DE7FCFB9230}\">';\n                    strSlideXml += `    <p14:media xmlns:p14=\"http://schemas.microsoft.com/office/powerpoint/2010/main\" r:embed=\"rId${slideItemObj.mediaRid + 1}\"/>`;\n                    strSlideXml += '   </p:ext>';\n                    strSlideXml += '  </p:extLst>';\n                    strSlideXml += ' </p:nvPr>';\n                    strSlideXml += ' </p:nvPicPr>';\n                    strSlideXml += ` <p:blipFill><a:blip r:embed=\"rId${slideItemObj.mediaRid + 2}\"/><a:stretch><a:fillRect/></a:stretch></p:blipFill>`; // NOTE: Preview image is required!\n                    strSlideXml += ' <p:spPr>';\n                    strSlideXml += `  <a:xfrm${locationAttr}><a:off x=\"${x}\" y=\"${y}\"/><a:ext cx=\"${cx}\" cy=\"${cy}\"/></a:xfrm>`;\n                    strSlideXml += '  <a:prstGeom prst=\"rect\"><a:avLst/></a:prstGeom>';\n                    strSlideXml += ' </p:spPr>';\n                    strSlideXml += '</p:pic>';\n                }\n                break;\n            case SLIDE_OBJECT_TYPES.chart:\n                strSlideXml += '<p:graphicFrame>';\n                strSlideXml += ' <p:nvGraphicFramePr>';\n                strSlideXml += `   <p:cNvPr id=\"${idx + 2}\" name=\"${slideItemObj.options.objectName}\" descr=\"${encodeXmlEntities(slideItemObj.options.altText || '')}\"/>`;\n                strSlideXml += '   <p:cNvGraphicFramePr/>';\n                strSlideXml += `   <p:nvPr>${genXmlPlaceholder(placeholderObj)}</p:nvPr>`;\n                strSlideXml += ' </p:nvGraphicFramePr>';\n                strSlideXml += ` <p:xfrm><a:off x=\"${x}\" y=\"${y}\"/><a:ext cx=\"${cx}\" cy=\"${cy}\"/></p:xfrm>`;\n                strSlideXml += ' <a:graphic xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\">';\n                strSlideXml += '  <a:graphicData uri=\"http://schemas.openxmlformats.org/drawingml/2006/chart\">';\n                strSlideXml += `   <c:chart r:id=\"rId${slideItemObj.chartRid}\" xmlns:c=\"http://schemas.openxmlformats.org/drawingml/2006/chart\"/>`;\n                strSlideXml += '  </a:graphicData>';\n                strSlideXml += ' </a:graphic>';\n                strSlideXml += '</p:graphicFrame>';\n                break;\n            default:\n                strSlideXml += '';\n                break;\n        }\n    });\n    // STEP 4: Add slide numbers (if any) last\n    if (slide._slideNumberProps) {\n        // Set some defaults (done here b/c SlideNumber canbe added to masters or slides and has numerous entry points)\n        if (!slide._slideNumberProps.align)\n            slide._slideNumberProps.align = 'left';\n        strSlideXml += '<p:sp>';\n        strSlideXml += ' <p:nvSpPr>';\n        strSlideXml += '  <p:cNvPr id=\"25\" name=\"Slide Number Placeholder 0\"/><p:cNvSpPr><a:spLocks noGrp=\"1\"/></p:cNvSpPr>';\n        strSlideXml += '  <p:nvPr><p:ph type=\"sldNum\" sz=\"quarter\" idx=\"4294967295\"/></p:nvPr>';\n        strSlideXml += ' </p:nvSpPr>';\n        strSlideXml += ' <p:spPr>';\n        strSlideXml += '<a:xfrm>' +\n            `<a:off x=\"${getSmartParseNumber(slide._slideNumberProps.x, 'X', slide._presLayout)}\" y=\"${getSmartParseNumber(slide._slideNumberProps.y, 'Y', slide._presLayout)}\"/>` +\n            `<a:ext cx=\"${slide._slideNumberProps.w ? getSmartParseNumber(slide._slideNumberProps.w, 'X', slide._presLayout) : '800000'}\" cy=\"${slide._slideNumberProps.h ? getSmartParseNumber(slide._slideNumberProps.h, 'Y', slide._presLayout) : '300000'}\"/>` +\n            '</a:xfrm>' +\n            ' <a:prstGeom prst=\"rect\"><a:avLst/></a:prstGeom>' +\n            ' <a:extLst><a:ext uri=\"{C572A759-6A51-4108-AA02-DFA0A04FC94B}\"><ma14:wrappingTextBoxFlag val=\"0\" xmlns:ma14=\"http://schemas.microsoft.com/office/mac/drawingml/2011/main\"/></a:ext></a:extLst>' +\n            '</p:spPr>';\n        strSlideXml += '<p:txBody>';\n        strSlideXml += '<a:bodyPr';\n        if (slide._slideNumberProps.margin && Array.isArray(slide._slideNumberProps.margin)) {\n            strSlideXml += ` lIns=\"${valToPts(slide._slideNumberProps.margin[3] || 0)}\"`;\n            strSlideXml += ` tIns=\"${valToPts(slide._slideNumberProps.margin[0] || 0)}\"`;\n            strSlideXml += ` rIns=\"${valToPts(slide._slideNumberProps.margin[1] || 0)}\"`;\n            strSlideXml += ` bIns=\"${valToPts(slide._slideNumberProps.margin[2] || 0)}\"`;\n        }\n        else if (typeof slide._slideNumberProps.margin === 'number') {\n            strSlideXml += ` lIns=\"${valToPts(slide._slideNumberProps.margin || 0)}\"`;\n            strSlideXml += ` tIns=\"${valToPts(slide._slideNumberProps.margin || 0)}\"`;\n            strSlideXml += ` rIns=\"${valToPts(slide._slideNumberProps.margin || 0)}\"`;\n            strSlideXml += ` bIns=\"${valToPts(slide._slideNumberProps.margin || 0)}\"`;\n        }\n        if (slide._slideNumberProps.valign) {\n            strSlideXml += ` anchor=\"${slide._slideNumberProps.valign.replace('top', 't').replace('middle', 'ctr').replace('bottom', 'b')}\"`;\n        }\n        strSlideXml += '/>';\n        strSlideXml += '  <a:lstStyle><a:lvl1pPr>';\n        if (slide._slideNumberProps.fontFace || slide._slideNumberProps.fontSize || slide._slideNumberProps.color) {\n            strSlideXml += `<a:defRPr sz=\"${Math.round((slide._slideNumberProps.fontSize || 12) * 100)}\">`;\n            if (slide._slideNumberProps.color)\n                strSlideXml += genXmlColorSelection(slide._slideNumberProps.color);\n            if (slide._slideNumberProps.fontFace) {\n                strSlideXml += `<a:latin typeface=\"${slide._slideNumberProps.fontFace}\"/><a:ea typeface=\"${slide._slideNumberProps.fontFace}\"/><a:cs typeface=\"${slide._slideNumberProps.fontFace}\"/>`;\n            }\n            strSlideXml += '</a:defRPr>';\n        }\n        strSlideXml += '</a:lvl1pPr></a:lstStyle>';\n        strSlideXml += '<a:p>';\n        if (slide._slideNumberProps.align.startsWith('l'))\n            strSlideXml += '<a:pPr algn=\"l\"/>';\n        else if (slide._slideNumberProps.align.startsWith('c'))\n            strSlideXml += '<a:pPr algn=\"ctr\"/>';\n        else if (slide._slideNumberProps.align.startsWith('r'))\n            strSlideXml += '<a:pPr algn=\"r\"/>';\n        else\n            strSlideXml += '<a:pPr algn=\"l\"/>';\n        strSlideXml += `<a:fld id=\"${SLDNUMFLDID}\" type=\"slidenum\"><a:rPr b=\"${slide._slideNumberProps.bold ? 1 : 0}\" lang=\"en-US\"/>`;\n        strSlideXml += `<a:t>${slide._slideNum}</a:t></a:fld><a:endParaRPr lang=\"en-US\"/></a:p>`;\n        strSlideXml += '</p:txBody></p:sp>';\n    }\n    // STEP 5: Close spTree and finalize slide XML\n    strSlideXml += '</p:spTree>';\n    strSlideXml += '</p:cSld>';\n    // LAST: Return\n    return strSlideXml;\n}\n/**\n * Transforms slide relations to XML string.\n * Extra relations that are not dynamic can be passed using the 2nd arg (e.g. theme relation in master file).\n * These relations use rId series that starts with 1-increased maximum of rIds used for dynamic relations.\n * @param {PresSlide | SlideLayout} slide - slide object whose relations are being transformed\n * @param {{ target: string; type: string }[]} defaultRels - array of default relations\n * @return {string} XML\n */\nfunction slideObjectRelationsToXml(slide, defaultRels) {\n    let lastRid = 0; // stores maximum rId used for dynamic relations\n    let strXml = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' + CRLF + '<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">';\n    // STEP 1: Add all rels for this Slide\n    slide._rels.forEach((rel) => {\n        lastRid = Math.max(lastRid, rel.rId);\n        if (rel.type.toLowerCase().includes('hyperlink')) {\n            if (rel.data === 'slide') {\n                strXml += `<Relationship Id=\"rId${rel.rId}\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide\" Target=\"slide${rel.Target}.xml\"/>`;\n            }\n            else {\n                strXml += `<Relationship Id=\"rId${rel.rId}\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink\" Target=\"${rel.Target}\" TargetMode=\"External\"/>`;\n            }\n        }\n        else if (rel.type.toLowerCase().includes('notesSlide')) {\n            strXml += `<Relationship Id=\"rId${rel.rId}\" Target=\"${rel.Target}\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesSlide\"/>`;\n        }\n    });\n    (slide._relsChart || []).forEach((rel) => {\n        lastRid = Math.max(lastRid, rel.rId);\n        strXml += `<Relationship Id=\"rId${rel.rId}\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart\" Target=\"${rel.Target}\"/>`;\n    });\n    (slide._relsMedia || []).forEach((rel) => {\n        const relRid = rel.rId.toString();\n        lastRid = Math.max(lastRid, rel.rId);\n        if (rel.type.toLowerCase().includes('image')) {\n            strXml += '<Relationship Id=\"rId' + relRid + '\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/image\" Target=\"' + rel.Target + '\"/>';\n        }\n        else if (rel.type.toLowerCase().includes('audio')) {\n            // As media has *TWO* rel entries per item, check for first one, if found add second rel with alt style\n            if (strXml.includes(' Target=\"' + rel.Target + '\"')) {\n                strXml += '<Relationship Id=\"rId' + relRid + '\" Type=\"http://schemas.microsoft.com/office/2007/relationships/media\" Target=\"' + rel.Target + '\"/>';\n            }\n            else {\n                strXml += '<Relationship Id=\"rId' + relRid + '\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/audio\" Target=\"' + rel.Target + '\"/>';\n            }\n        }\n        else if (rel.type.toLowerCase().includes('video')) {\n            // As media has *TWO* rel entries per item, check for first one, if found add second rel with alt style\n            if (strXml.includes(' Target=\"' + rel.Target + '\"')) {\n                strXml += '<Relationship Id=\"rId' + relRid + '\" Type=\"http://schemas.microsoft.com/office/2007/relationships/media\" Target=\"' + rel.Target + '\"/>';\n            }\n            else {\n                strXml += '<Relationship Id=\"rId' + relRid + '\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/video\" Target=\"' + rel.Target + '\"/>';\n            }\n        }\n        else if (rel.type.toLowerCase().includes('online')) {\n            // As media has *TWO* rel entries per item, check for first one, if found add second rel with alt style\n            if (strXml.includes(' Target=\"' + rel.Target + '\"')) {\n                strXml += '<Relationship Id=\"rId' + relRid + '\" Type=\"http://schemas.microsoft.com/office/2007/relationships/image\" Target=\"' + rel.Target + '\"/>';\n            }\n            else {\n                strXml += '<Relationship Id=\"rId' + relRid + '\" Target=\"' + rel.Target + '\" TargetMode=\"External\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/video\"/>';\n            }\n        }\n    });\n    // STEP 2: Add default rels\n    defaultRels.forEach((rel, idx) => {\n        strXml += `<Relationship Id=\"rId${lastRid + idx + 1}\" Type=\"${rel.type}\" Target=\"${rel.target}\"/>`;\n    });\n    strXml += '</Relationships>';\n    return strXml;\n}\n/**\n * Generate XML Paragraph Properties\n * @param {ISlideObject|TextProps} textObj - text object\n * @param {boolean} isDefault - array of default relations\n * @return {string} XML\n */\nfunction genXmlParagraphProperties(textObj, isDefault) {\n    var _a, _b;\n    let strXmlBullet = '';\n    let strXmlLnSpc = '';\n    let strXmlParaSpc = '';\n    let strXmlTabStops = '';\n    const tag = isDefault ? 'a:lvl1pPr' : 'a:pPr';\n    let bulletMarL = valToPts(DEF_BULLET_MARGIN);\n    let paragraphPropXml = `<${tag}${textObj.options.rtlMode ? ' rtl=\"1\" ' : ''}`;\n    // A: Build paragraphProperties\n    {\n        // OPTION: align\n        if (textObj.options.align) {\n            switch (textObj.options.align) {\n                case 'left':\n                    paragraphPropXml += ' algn=\"l\"';\n                    break;\n                case 'right':\n                    paragraphPropXml += ' algn=\"r\"';\n                    break;\n                case 'center':\n                    paragraphPropXml += ' algn=\"ctr\"';\n                    break;\n                case 'justify':\n                    paragraphPropXml += ' algn=\"just\"';\n                    break;\n                default:\n                    paragraphPropXml += '';\n                    break;\n            }\n        }\n        if (textObj.options.lineSpacing) {\n            strXmlLnSpc = `<a:lnSpc><a:spcPts val=\"${Math.round(textObj.options.lineSpacing * 100)}\"/></a:lnSpc>`;\n        }\n        else if (textObj.options.lineSpacingMultiple) {\n            strXmlLnSpc = `<a:lnSpc><a:spcPct val=\"${Math.round(textObj.options.lineSpacingMultiple * 100000)}\"/></a:lnSpc>`;\n        }\n        // OPTION: indent\n        if (textObj.options.indentLevel && !isNaN(Number(textObj.options.indentLevel)) && textObj.options.indentLevel > 0) {\n            paragraphPropXml += ` lvl=\"${textObj.options.indentLevel}\"`;\n        }\n        // OPTION: Paragraph Spacing: Before/After\n        if (textObj.options.paraSpaceBefore && !isNaN(Number(textObj.options.paraSpaceBefore)) && textObj.options.paraSpaceBefore > 0) {\n            strXmlParaSpc += `<a:spcBef><a:spcPts val=\"${Math.round(textObj.options.paraSpaceBefore * 100)}\"/></a:spcBef>`;\n        }\n        if (textObj.options.paraSpaceAfter && !isNaN(Number(textObj.options.paraSpaceAfter)) && textObj.options.paraSpaceAfter > 0) {\n            strXmlParaSpc += `<a:spcAft><a:spcPts val=\"${Math.round(textObj.options.paraSpaceAfter * 100)}\"/></a:spcAft>`;\n        }\n        // OPTION: bullet\n        // NOTE: OOXML uses the unicode character set for Bullets\n        // EX: Unicode Character 'BULLET' (U+2022) ==> '<a:buChar char=\"&#x2022;\"/>'\n        if (typeof textObj.options.bullet === 'object') {\n            if ((_b = (_a = textObj === null || textObj === void 0 ? void 0 : textObj.options) === null || _a === void 0 ? void 0 : _a.bullet) === null || _b === void 0 ? void 0 : _b.indent)\n                bulletMarL = valToPts(textObj.options.bullet.indent);\n            if (textObj.options.bullet.type) {\n                if (textObj.options.bullet.type.toString().toLowerCase() === 'number') {\n                    paragraphPropXml += ` marL=\"${textObj.options.indentLevel && textObj.options.indentLevel > 0 ? bulletMarL + bulletMarL * textObj.options.indentLevel : bulletMarL}\" indent=\"-${bulletMarL}\"`;\n                    strXmlBullet = `<a:buSzPct val=\"100000\"/><a:buFont typeface=\"+mj-lt\"/><a:buAutoNum type=\"${textObj.options.bullet.style || 'arabicPeriod'}\" startAt=\"${textObj.options.bullet.numberStartAt || textObj.options.bullet.startAt || '1'}\"/>`;\n                }\n            }\n            else if (textObj.options.bullet.characterCode) {\n                let bulletCode = `&#x${textObj.options.bullet.characterCode};`;\n                // Check value for hex-ness (s/b 4 char hex)\n                if (!/^[0-9A-Fa-f]{4}$/.test(textObj.options.bullet.characterCode)) {\n                    console.warn('Warning: `bullet.characterCode should be a 4-digit unicode charatcer (ex: 22AB)`!');\n                    bulletCode = BULLET_TYPES.DEFAULT;\n                }\n                paragraphPropXml += ` marL=\"${textObj.options.indentLevel && textObj.options.indentLevel > 0 ? bulletMarL + bulletMarL * textObj.options.indentLevel : bulletMarL}\" indent=\"-${bulletMarL}\"`;\n                strXmlBullet = '<a:buSzPct val=\"100000\"/><a:buChar char=\"' + bulletCode + '\"/>';\n            }\n            else if (textObj.options.bullet.code) {\n                // @deprecated `bullet.code` v3.3.0\n                let bulletCode = `&#x${textObj.options.bullet.code};`;\n                // Check value for hex-ness (s/b 4 char hex)\n                if (!/^[0-9A-Fa-f]{4}$/.test(textObj.options.bullet.code)) {\n                    console.warn('Warning: `bullet.code should be a 4-digit hex code (ex: 22AB)`!');\n                    bulletCode = BULLET_TYPES.DEFAULT;\n                }\n                paragraphPropXml += ` marL=\"${textObj.options.indentLevel && textObj.options.indentLevel > 0 ? bulletMarL + bulletMarL * textObj.options.indentLevel : bulletMarL}\" indent=\"-${bulletMarL}\"`;\n                strXmlBullet = '<a:buSzPct val=\"100000\"/><a:buChar char=\"' + bulletCode + '\"/>';\n            }\n            else {\n                paragraphPropXml += ` marL=\"${textObj.options.indentLevel && textObj.options.indentLevel > 0 ? bulletMarL + bulletMarL * textObj.options.indentLevel : bulletMarL}\" indent=\"-${bulletMarL}\"`;\n                strXmlBullet = `<a:buSzPct val=\"100000\"/><a:buChar char=\"${BULLET_TYPES.DEFAULT}\"/>`;\n            }\n        }\n        else if (textObj.options.bullet) {\n            paragraphPropXml += ` marL=\"${textObj.options.indentLevel && textObj.options.indentLevel > 0 ? bulletMarL + bulletMarL * textObj.options.indentLevel : bulletMarL}\" indent=\"-${bulletMarL}\"`;\n            strXmlBullet = `<a:buSzPct val=\"100000\"/><a:buChar char=\"${BULLET_TYPES.DEFAULT}\"/>`;\n        }\n        else if (!textObj.options.bullet) {\n            // We only add this when the user explicitely asks for no bullet, otherwise, it can override the master defaults!\n            paragraphPropXml += ' indent=\"0\" marL=\"0\"'; // FIX: ISSUE#589 - specify zero indent and marL or default will be hanging paragraph\n            strXmlBullet = '<a:buNone/>';\n        }\n        // OPTION: tabStops\n        if (textObj.options.tabStops && Array.isArray(textObj.options.tabStops)) {\n            const tabStopsXml = textObj.options.tabStops.map(stop => `<a:tab pos=\"${inch2Emu(stop.position || 1)}\" algn=\"${stop.alignment || 'l'}\"/>`).join('');\n            strXmlTabStops = `<a:tabLst>${tabStopsXml}</a:tabLst>`;\n        }\n        // B: Close Paragraph-Properties\n        // IMPORTANT: strXmlLnSpc, strXmlParaSpc, and strXmlBullet require strict ordering - anything out of order is ignored. (PPT-Online, PPT for Mac)\n        paragraphPropXml += '>' + strXmlLnSpc + strXmlParaSpc + strXmlBullet + strXmlTabStops;\n        if (isDefault)\n            paragraphPropXml += genXmlTextRunProperties(textObj.options, true);\n        paragraphPropXml += '</' + tag + '>';\n    }\n    return paragraphPropXml;\n}\n/**\n * Generate XML Text Run Properties (`a:rPr`)\n * @param {ObjectOptions|TextPropsOptions} opts - text options\n * @param {boolean} isDefault - whether these are the default text run properties\n * @return {string} XML\n */\nfunction genXmlTextRunProperties(opts, isDefault) {\n    var _a;\n    let runProps = '';\n    const runPropsTag = isDefault ? 'a:defRPr' : 'a:rPr';\n    // BEGIN runProperties (ex: `<a:rPr lang=\"en-US\" sz=\"1600\" b=\"1\" dirty=\"0\">`)\n    runProps += '<' + runPropsTag + ' lang=\"' + (opts.lang ? opts.lang : 'en-US') + '\"' + (opts.lang ? ' altLang=\"en-US\"' : '');\n    runProps += opts.fontSize ? ` sz=\"${Math.round(opts.fontSize * 100)}\"` : ''; // NOTE: Use round so sizes like '7.5' wont cause corrupt presentations\n    runProps += (opts === null || opts === void 0 ? void 0 : opts.bold) ? ` b=\"${opts.bold ? '1' : '0'}\"` : '';\n    runProps += (opts === null || opts === void 0 ? void 0 : opts.italic) ? ` i=\"${opts.italic ? '1' : '0'}\"` : '';\n    runProps += (opts === null || opts === void 0 ? void 0 : opts.strike) ? ` strike=\"${typeof opts.strike === 'string' ? opts.strike : 'sngStrike'}\"` : '';\n    if (typeof opts.underline === 'object' && ((_a = opts.underline) === null || _a === void 0 ? void 0 : _a.style)) {\n        runProps += ` u=\"${opts.underline.style}\"`;\n    }\n    else if (typeof opts.underline === 'string') {\n        // DEPRECATED: opts.underline is an object as of v3.5.0\n        runProps += ` u=\"${String(opts.underline)}\"`;\n    }\n    else if (opts.hyperlink) {\n        runProps += ' u=\"sng\"';\n    }\n    if (opts.baseline) {\n        runProps += ` baseline=\"${Math.round(opts.baseline * 50)}\"`;\n    }\n    else if (opts.subscript) {\n        runProps += ' baseline=\"-40000\"';\n    }\n    else if (opts.superscript) {\n        runProps += ' baseline=\"30000\"';\n    }\n    runProps += opts.charSpacing ? ` spc=\"${Math.round(opts.charSpacing * 100)}\" kern=\"0\"` : ''; // IMPORTANT: Also disable kerning; otherwise text won't actually expand\n    runProps += ' dirty=\"0\">';\n    // Color / Font / Highlight / Outline are children of <a:rPr>, so add them now before closing the runProperties tag\n    if (opts.color || opts.fontFace || opts.outline || (typeof opts.underline === 'object' && opts.underline.color)) {\n        if (opts.outline && typeof opts.outline === 'object') {\n            runProps += `<a:ln w=\"${valToPts(opts.outline.size || 0.75)}\">${genXmlColorSelection(opts.outline.color || 'FFFFFF')}</a:ln>`;\n        }\n        if (opts.color)\n            runProps += genXmlColorSelection({ color: opts.color, transparency: opts.transparency });\n        if (opts.highlight)\n            runProps += `<a:highlight>${createColorElement(opts.highlight)}</a:highlight>`;\n        if (typeof opts.underline === 'object' && opts.underline.color)\n            runProps += `<a:uFill>${genXmlColorSelection(opts.underline.color)}</a:uFill>`;\n        if (opts.glow)\n            runProps += `<a:effectLst>${createGlowElement(opts.glow, DEF_TEXT_GLOW)}</a:effectLst>`;\n        if (opts.fontFace) {\n            // NOTE: 'cs' = Complex Script, 'ea' = East Asian (use \"-120\" instead of \"0\" - per Issue #174); ea must come first (Issue #174)\n            runProps += `<a:latin typeface=\"${opts.fontFace}\" pitchFamily=\"34\" charset=\"0\"/><a:ea typeface=\"${opts.fontFace}\" pitchFamily=\"34\" charset=\"-122\"/><a:cs typeface=\"${opts.fontFace}\" pitchFamily=\"34\" charset=\"-120\"/>`;\n        }\n    }\n    // Hyperlink support\n    if (opts.hyperlink) {\n        if (typeof opts.hyperlink !== 'object')\n            throw new Error('ERROR: text `hyperlink` option should be an object. Ex: `hyperlink:{url:\\'https://github.com\\'}` ');\n        else if (!opts.hyperlink.url && !opts.hyperlink.slide)\n            throw new Error('ERROR: \\'hyperlink requires either `url` or `slide`\\'');\n        else if (opts.hyperlink.url) {\n            // runProps += '<a:uFill>'+ genXmlColorSelection('0000FF') +'</a:uFill>'; // Breaks PPT2010! (Issue#74)\n            runProps += `<a:hlinkClick r:id=\"rId${opts.hyperlink._rId}\" invalidUrl=\"\" action=\"\" tgtFrame=\"\" tooltip=\"${opts.hyperlink.tooltip ? encodeXmlEntities(opts.hyperlink.tooltip) : ''}\" history=\"1\" highlightClick=\"0\" endSnd=\"0\"${opts.color ? '>' : '/>'}`;\n        }\n        else if (opts.hyperlink.slide) {\n            runProps += `<a:hlinkClick r:id=\"rId${opts.hyperlink._rId}\" action=\"ppaction://hlinksldjump\" tooltip=\"${opts.hyperlink.tooltip ? encodeXmlEntities(opts.hyperlink.tooltip) : ''}\"${opts.color ? '>' : '/>'}`;\n        }\n        if (opts.color) {\n            runProps += ' <a:extLst>';\n            runProps += '  <a:ext uri=\"{A12FA001-AC4F-418D-AE19-62706E023703}\">';\n            runProps += '   <ahyp:hlinkClr xmlns:ahyp=\"http://schemas.microsoft.com/office/drawing/2018/hyperlinkcolor\" val=\"tx\"/>';\n            runProps += '  </a:ext>';\n            runProps += ' </a:extLst>';\n            runProps += '</a:hlinkClick>';\n        }\n    }\n    // END runProperties\n    runProps += `</${runPropsTag}>`;\n    return runProps;\n}\n/**\n * Build textBody text runs [`<a:r></a:r>`] for paragraphs [`<a:p>`]\n * @param {TextProps} textObj - Text object\n * @return {string} XML string\n */\nfunction genXmlTextRun(textObj) {\n    // NOTE: Dont create full rPr runProps for empty [lineBreak] runs\n    // Why? The size of the lineBreak wont match (eg: below it will be 18px instead of the correct 36px)\n    // Do this:\n    /*\n        <a:p>\n            <a:pPr algn=\"r\"/>\n            <a:endParaRPr lang=\"en-US\" sz=\"3600\" dirty=\"0\"/>\n        </a:p>\n    */\n    // NOT this:\n    /*\n        <a:p>\n            <a:pPr algn=\"r\"/>\n            <a:r>\n                <a:rPr lang=\"en-US\" sz=\"3600\" dirty=\"0\">\n                    <a:solidFill>\n                        <a:schemeClr val=\"accent5\"/>\n                    </a:solidFill>\n                    <a:latin typeface=\"Times\" pitchFamily=\"34\" charset=\"0\"/>\n                    <a:ea typeface=\"Times\" pitchFamily=\"34\" charset=\"-122\"/>\n                    <a:cs typeface=\"Times\" pitchFamily=\"34\" charset=\"-120\"/>\n                </a:rPr>\n                <a:t></a:t>\n            </a:r>\n            <a:endParaRPr lang=\"en-US\" dirty=\"0\"/>\n        </a:p>\n    */\n    // Return paragraph with text run\n    return textObj.text ? `<a:r>${genXmlTextRunProperties(textObj.options, false)}<a:t>${encodeXmlEntities(textObj.text)}</a:t></a:r>` : '';\n}\n/**\n * Builds `<a:bodyPr></a:bodyPr>` tag for \"genXmlTextBody()\"\n * @param {ISlideObject | TableCell} slideObject - various options\n * @return {string} XML string\n */\nfunction genXmlBodyProperties(slideObject) {\n    let bodyProperties = '<a:bodyPr';\n    if (slideObject && slideObject._type === SLIDE_OBJECT_TYPES.text && slideObject.options._bodyProp) {\n        // PPT-2019 EX: <a:bodyPr wrap=\"square\" lIns=\"1270\" tIns=\"1270\" rIns=\"1270\" bIns=\"1270\" rtlCol=\"0\" anchor=\"ctr\"/>\n        // A: Enable or disable textwrapping none or square\n        bodyProperties += slideObject.options._bodyProp.wrap ? ' wrap=\"square\"' : ' wrap=\"none\"';\n        // B: Textbox margins [padding]\n        if (slideObject.options._bodyProp.lIns || slideObject.options._bodyProp.lIns === 0)\n            bodyProperties += ` lIns=\"${slideObject.options._bodyProp.lIns}\"`;\n        if (slideObject.options._bodyProp.tIns || slideObject.options._bodyProp.tIns === 0)\n            bodyProperties += ` tIns=\"${slideObject.options._bodyProp.tIns}\"`;\n        if (slideObject.options._bodyProp.rIns || slideObject.options._bodyProp.rIns === 0)\n            bodyProperties += ` rIns=\"${slideObject.options._bodyProp.rIns}\"`;\n        if (slideObject.options._bodyProp.bIns || slideObject.options._bodyProp.bIns === 0)\n            bodyProperties += ` bIns=\"${slideObject.options._bodyProp.bIns}\"`;\n        // C: Add rtl after margins\n        bodyProperties += ' rtlCol=\"0\"';\n        // D: Add anchorPoints\n        if (slideObject.options._bodyProp.anchor)\n            bodyProperties += ' anchor=\"' + slideObject.options._bodyProp.anchor + '\"'; // VALS: [t,ctr,b]\n        if (slideObject.options._bodyProp.vert)\n            bodyProperties += ' vert=\"' + slideObject.options._bodyProp.vert + '\"'; // VALS: [eaVert,horz,mongolianVert,vert,vert270,wordArtVert,wordArtVertRtl]\n        // E: Close <a:bodyPr element\n        bodyProperties += '>';\n        /**\n         * F: Text Fit/AutoFit/Shrink option\n         * @see: http://officeopenxml.com/drwSp-text-bodyPr-fit.php\n         * @see: http://www.datypic.com/sc/ooxml/g-a_EG_TextAutofit.html\n         */\n        if (slideObject.options.fit) {\n            // NOTE: Use of '<a:noAutofit/>' instead of '' causes issues in PPT-2013!\n            if (slideObject.options.fit === 'none')\n                bodyProperties += '';\n            // NOTE: Shrink does not work automatically - PowerPoint calculates the `fontScale` value dynamically upon resize\n            // else if (slideObject.options.fit === 'shrink') bodyProperties += '<a:normAutofit fontScale=\"85000\" lnSpcReduction=\"20000\"/>' // MS-PPT > Format shape > Text Options: \"Shrink text on overflow\"\n            else if (slideObject.options.fit === 'shrink')\n                bodyProperties += '<a:normAutofit/>';\n            else if (slideObject.options.fit === 'resize')\n                bodyProperties += '<a:spAutoFit/>';\n        }\n        //\n        // DEPRECATED: below (@deprecated v3.3.0)\n        if (slideObject.options.shrinkText)\n            bodyProperties += '<a:normAutofit/>'; // MS-PPT > Format shape > Text Options: \"Shrink text on overflow\"\n        /* DEPRECATED: below (@deprecated v3.3.0)\n         * MS-PPT > Format shape > Text Options: \"Resize shape to fit text\" [spAutoFit]\n         * NOTE: Use of '<a:noAutofit/>' in lieu of '' below causes issues in PPT-2013\n         */\n        bodyProperties += slideObject.options._bodyProp.autoFit ? '<a:spAutoFit/>' : '';\n        // LAST: Close _bodyProp\n        bodyProperties += '</a:bodyPr>';\n    }\n    else {\n        // DEFAULT:\n        bodyProperties += ' wrap=\"square\" rtlCol=\"0\">';\n        bodyProperties += '</a:bodyPr>';\n    }\n    // LAST: Return Close _bodyProp\n    return slideObject._type === SLIDE_OBJECT_TYPES.tablecell ? '<a:bodyPr/>' : bodyProperties;\n}\n/**\n * Generate the XML for text and its options (bold, bullet, etc) including text runs (word-level formatting)\n * @param {ISlideObject|TableCell} slideObj - slideObj or tableCell\n * @note PPT text lines [lines followed by line-breaks] are created using <p>-aragraph's\n * @note Bullets are a paragragh-level formatting device\n * @template\n *    <p:txBody>\n *        <a:bodyPr wrap=\"square\" rtlCol=\"0\">\n *            <a:spAutoFit/>\n *        </a:bodyPr>\n *        <a:lstStyle/>\n *        <a:p>\n *            <a:pPr algn=\"ctr\"/>\n *            <a:r>\n *                <a:rPr lang=\"en-US\" dirty=\"0\" err=\"1\"/>\n *                <a:t>textbox text</a:t>\n *            </a:r>\n *            <a:endParaRPr lang=\"en-US\" dirty=\"0\"/>\n *        </a:p>\n *    </p:txBody>\n * @returns XML containing the param object's text and formatting\n */\nfunction genXmlTextBody(slideObj) {\n    const opts = slideObj.options || {};\n    let tmpTextObjects = [];\n    const arrTextObjects = [];\n    // FIRST: Shapes without text, etc. may be sent here during build, but have no text to render so return an empty string\n    if (opts && slideObj._type !== SLIDE_OBJECT_TYPES.tablecell && (typeof slideObj.text === 'undefined' || slideObj.text === null))\n        return '';\n    // STEP 1: Start textBody\n    let strSlideXml = slideObj._type === SLIDE_OBJECT_TYPES.tablecell ? '<a:txBody>' : '<p:txBody>';\n    // STEP 2: Add bodyProperties\n    {\n        // A: 'bodyPr'\n        strSlideXml += genXmlBodyProperties(slideObj);\n        // B: 'lstStyle'\n        // NOTE: shape type 'LINE' has different text align needs (a lstStyle.lvl1pPr between bodyPr and p)\n        // FIXME: LINE horiz-align doesnt work (text is always to the left inside line) (FYI: the PPT code diff is substantial!)\n        if (opts.h === 0 && opts.line && opts.align)\n            strSlideXml += '<a:lstStyle><a:lvl1pPr algn=\"l\"/></a:lstStyle>';\n        else if (slideObj._type === 'placeholder')\n            strSlideXml += `<a:lstStyle>${genXmlParagraphProperties(slideObj, true)}</a:lstStyle>`;\n        else\n            strSlideXml += '<a:lstStyle/>';\n    }\n    /* STEP 3: Modify slideObj.text to array\n        CASES:\n        addText( 'string' ) // string\n        addText( 'line1\\n line2' ) // string with lineBreak\n        addText( {text:'word1'} ) // TextProps object\n        addText( ['barry','allen'] ) // array of strings\n        addText( [{text:'word1'}, {text:'word2'}] ) // TextProps object array\n        addText( [{text:'line1\\n line2'}, {text:'end word'}] ) // TextProps object array with lineBreak\n    */\n    if (typeof slideObj.text === 'string' || typeof slideObj.text === 'number') {\n        // Handle cases 1,2\n        tmpTextObjects.push({ text: slideObj.text.toString(), options: opts || {} });\n    }\n    else if (slideObj.text && !Array.isArray(slideObj.text) && typeof slideObj.text === 'object' && Object.keys(slideObj.text).includes('text')) {\n        // } else if (!Array.isArray(slideObj.text) && slideObj.text!.hasOwnProperty('text')) { // 20210706: replaced with below as ts compiler rejected it\n        // Handle case 3\n        tmpTextObjects.push({ text: slideObj.text || '', options: slideObj.options || {} });\n    }\n    else if (Array.isArray(slideObj.text)) {\n        // Handle cases 4,5,6\n        // NOTE: use cast as text is TextProps[]|TableCell[] and their `options` dont overlap (they share the same TextBaseProps though)\n        tmpTextObjects = slideObj.text.map(item => ({ text: item.text, options: item.options }));\n    }\n    // STEP 4: Iterate over text objects, set text/options, break into pieces if '\\n'/breakLine found\n    tmpTextObjects.forEach((itext, idx) => {\n        if (!itext.text)\n            itext.text = '';\n        // A: Set options\n        itext.options = itext.options || opts || {};\n        if (idx === 0 && itext.options && !itext.options.bullet && opts.bullet)\n            itext.options.bullet = opts.bullet;\n        // B: Cast to text-object and fix line-breaks (if needed)\n        if (typeof itext.text === 'string' || typeof itext.text === 'number') {\n            // 1: Convert \"\\n\" or any variation into CRLF\n            itext.text = itext.text.toString().replace(/\\r*\\n/g, CRLF);\n        }\n        // C: If text string has line-breaks, then create a separate text-object for each (much easier than dealing with split inside a loop below)\n        // NOTE: Filter for trailing lineBreak prevents the creation of an empty textObj as the last item\n        if (itext.text.includes(CRLF) && itext.text.match(/\\n$/g) === null) {\n            itext.text.split(CRLF).forEach(line => {\n                itext.options.breakLine = true;\n                arrTextObjects.push({ text: line, options: itext.options });\n            });\n        }\n        else {\n            arrTextObjects.push(itext);\n        }\n    });\n    // STEP 5: Group textObj into lines by checking for lineBreak, bullets, alignment change, etc.\n    const arrLines = [];\n    let arrTexts = [];\n    arrTextObjects.forEach((textObj, idx) => {\n        // A: Align or Bullet trigger new line\n        if (arrTexts.length > 0 && (textObj.options.align || opts.align)) {\n            // Only start a new paragraph when align *changes*\n            if (textObj.options.align !== arrTextObjects[idx - 1].options.align) {\n                arrLines.push(arrTexts);\n                arrTexts = [];\n            }\n        }\n        else if (arrTexts.length > 0 && textObj.options.bullet && arrTexts.length > 0) {\n            arrLines.push(arrTexts);\n            arrTexts = [];\n            textObj.options.breakLine = false; // For cases with both `bullet` and `brekaLine` - prevent double lineBreak\n        }\n        // B: Add this text to current line\n        arrTexts.push(textObj);\n        // C: BreakLine begins new line **after** adding current text\n        if (arrTexts.length > 0 && textObj.options.breakLine) {\n            // Avoid starting a para right as loop is exhausted\n            if (idx + 1 < arrTextObjects.length) {\n                arrLines.push(arrTexts);\n                arrTexts = [];\n            }\n        }\n        // D: Flush buffer\n        if (idx + 1 === arrTextObjects.length)\n            arrLines.push(arrTexts);\n    });\n    // STEP 6: Loop over each line and create paragraph props, text run, etc.\n    arrLines.forEach(line => {\n        var _a;\n        let reqsClosingFontSize = false;\n        // A: Start paragraph, add paraProps\n        strSlideXml += '<a:p>';\n        // NOTE: `rtlMode` is like other opts, its propagated up to each text:options, so just check the 1st one\n        let paragraphPropXml = `<a:pPr ${((_a = line[0].options) === null || _a === void 0 ? void 0 : _a.rtlMode) ? ' rtl=\"1\" ' : ''}`;\n        // B: Start paragraph, loop over lines and add text runs\n        line.forEach((textObj, idx) => {\n            // A: Set line index\n            textObj.options._lineIdx = idx;\n            // A.1: Add soft break if not the first run of the line.\n            if (idx > 0 && textObj.options.softBreakBefore) {\n                strSlideXml += '<a:br/>';\n            }\n            // B: Inherit pPr-type options from parent shape's `options`\n            textObj.options.align = textObj.options.align || opts.align;\n            textObj.options.lineSpacing = textObj.options.lineSpacing || opts.lineSpacing;\n            textObj.options.lineSpacingMultiple = textObj.options.lineSpacingMultiple || opts.lineSpacingMultiple;\n            textObj.options.indentLevel = textObj.options.indentLevel || opts.indentLevel;\n            textObj.options.paraSpaceBefore = textObj.options.paraSpaceBefore || opts.paraSpaceBefore;\n            textObj.options.paraSpaceAfter = textObj.options.paraSpaceAfter || opts.paraSpaceAfter;\n            paragraphPropXml = genXmlParagraphProperties(textObj, false);\n            strSlideXml += paragraphPropXml.replace('<a:pPr></a:pPr>', ''); // IMPORTANT: Empty \"pPr\" blocks will generate needs-repair/corrupt msg\n            // C: Inherit any main options (color, fontSize, etc.)\n            // NOTE: We only pass the text.options to genXmlTextRun (not the Slide.options),\n            // so the run building function cant just fallback to Slide.color, therefore, we need to do that here before passing options below.\n            // FILTER RULE: Hyperlinks should not inherit `color` from main options (let PPT default to local color, eg: blue on MacOS)\n            Object.entries(opts).filter(([key]) => !(textObj.options.hyperlink && key === 'color')).forEach(([key, val]) => {\n                // if (textObj.options.hyperlink && key === 'color') null\n                // NOTE: This loop will pick up unecessary keys (`x`, etc.), but it doesnt hurt anything\n                if (key !== 'bullet' && !textObj.options[key])\n                    textObj.options[key] = val;\n            });\n            // D: Add formatted textrun\n            strSlideXml += genXmlTextRun(textObj);\n            // E: Flag close fontSize for empty [lineBreak] elements\n            if ((!textObj.text && opts.fontSize) || textObj.options.fontSize) {\n                reqsClosingFontSize = true;\n                opts.fontSize = opts.fontSize || textObj.options.fontSize;\n            }\n        });\n        /* C: Append 'endParaRPr' (when needed) and close current open paragraph\n         * NOTE: (ISSUE#20, ISSUE#193): Add 'endParaRPr' with font/size props or PPT default (Arial/18pt en-us) is used making row \"too tall\"/not honoring options\n         */\n        if (slideObj._type === SLIDE_OBJECT_TYPES.tablecell && (opts.fontSize || opts.fontFace)) {\n            if (opts.fontFace) {\n                strSlideXml += `<a:endParaRPr lang=\"${opts.lang || 'en-US'}\"` + (opts.fontSize ? ` sz=\"${Math.round(opts.fontSize * 100)}\"` : '') + ' dirty=\"0\">';\n                strSlideXml += `<a:latin typeface=\"${opts.fontFace}\" charset=\"0\"/>`;\n                strSlideXml += `<a:ea typeface=\"${opts.fontFace}\" charset=\"0\"/>`;\n                strSlideXml += `<a:cs typeface=\"${opts.fontFace}\" charset=\"0\"/>`;\n                strSlideXml += '</a:endParaRPr>';\n            }\n            else {\n                strSlideXml += `<a:endParaRPr lang=\"${opts.lang || 'en-US'}\"` + (opts.fontSize ? ` sz=\"${Math.round(opts.fontSize * 100)}\"` : '') + ' dirty=\"0\"/>';\n            }\n        }\n        else if (reqsClosingFontSize) {\n            // Empty [lineBreak] lines should not contain runProp, however, they need to specify fontSize in `endParaRPr`\n            strSlideXml += `<a:endParaRPr lang=\"${opts.lang || 'en-US'}\"` + (opts.fontSize ? ` sz=\"${Math.round(opts.fontSize * 100)}\"` : '') + ' dirty=\"0\"/>';\n        }\n        else {\n            strSlideXml += `<a:endParaRPr lang=\"${opts.lang || 'en-US'}\" dirty=\"0\"/>`; // Added 20180101 to address PPT-2007 issues\n        }\n        // D: End paragraph\n        strSlideXml += '</a:p>';\n    });\n    // IMPORTANT: An empty txBody will cause \"needs repair\" error! Add <p> content if missing.\n    // [FIXED in v3.13.0]: This fixes issue with table auto-paging where some cells w/b empty on subsequent pages.\n    /*\n        <a:txBody>\n            <a:bodyPr/>\n            <a:lstStyle/>\n        </a:txBody>\n    */\n    if (strSlideXml.indexOf('<a:p>') === -1) {\n        strSlideXml += '<a:p><a:endParaRPr/></a:p>';\n    }\n    // STEP 7: Close the textBody\n    strSlideXml += slideObj._type === SLIDE_OBJECT_TYPES.tablecell ? '</a:txBody>' : '</p:txBody>';\n    // LAST: Return XML\n    return strSlideXml;\n}\n/**\n * Generate an XML Placeholder\n * @param {ISlideObject} placeholderObj\n * @returns XML\n */\nfunction genXmlPlaceholder(placeholderObj) {\n    var _a, _b;\n    if (!placeholderObj)\n        return '';\n    const placeholderIdx = ((_a = placeholderObj.options) === null || _a === void 0 ? void 0 : _a._placeholderIdx) ? placeholderObj.options._placeholderIdx : '';\n    const placeholderTyp = ((_b = placeholderObj.options) === null || _b === void 0 ? void 0 : _b._placeholderType) ? placeholderObj.options._placeholderType : '';\n    const placeholderType = placeholderTyp && PLACEHOLDER_TYPES[placeholderTyp] ? (PLACEHOLDER_TYPES[placeholderTyp]).toString() : '';\n    return `<p:ph\n\t\t${placeholderIdx ? ' idx=\"' + placeholderIdx.toString() + '\"' : ''}\n\t\t${placeholderType && PLACEHOLDER_TYPES[placeholderType] ? ` type=\"${placeholderType}\"` : ''}\n\t\t${placeholderObj.text && placeholderObj.text.length > 0 ? ' hasCustomPrompt=\"1\"' : ''}\n\t\t/>`;\n}\n// XML-GEN: First 6 functions create the base /ppt files\n/**\n * Generate XML ContentType\n * @param {PresSlide[]} slides - slides\n * @param {SlideLayout[]} slideLayouts - slide layouts\n * @param {PresSlide} masterSlide - master slide\n * @returns XML\n */\nfunction makeXmlContTypes(slides, slideLayouts, masterSlide) {\n    let strXml = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' + CRLF;\n    strXml += '<Types xmlns=\"http://schemas.openxmlformats.org/package/2006/content-types\">';\n    strXml += '<Default Extension=\"xml\" ContentType=\"application/xml\"/>';\n    strXml += '<Default Extension=\"rels\" ContentType=\"application/vnd.openxmlformats-package.relationships+xml\"/>';\n    strXml += '<Default Extension=\"jpeg\" ContentType=\"image/jpeg\"/>';\n    strXml += '<Default Extension=\"jpg\" ContentType=\"image/jpg\"/>';\n    strXml += '<Default Extension=\"svg\" ContentType=\"image/svg+xml\"/>';\n    // STEP 1: Add standard/any media types used in Presentation\n    strXml += '<Default Extension=\"png\" ContentType=\"image/png\"/>';\n    strXml += '<Default Extension=\"gif\" ContentType=\"image/gif\"/>';\n    strXml += '<Default Extension=\"m4v\" ContentType=\"video/mp4\"/>'; // NOTE: Hard-Code this extension as it wont be created in loop below (as extn !== type)\n    strXml += '<Default Extension=\"mp4\" ContentType=\"video/mp4\"/>'; // NOTE: Hard-Code this extension as it wont be created in loop below (as extn !== type)\n    slides.forEach(slide => {\n        (slide._relsMedia || []).forEach(rel => {\n            if (rel.type !== 'image' && rel.type !== 'online' && rel.type !== 'chart' && rel.extn !== 'm4v' && !strXml.includes(rel.type)) {\n                strXml += '<Default Extension=\"' + rel.extn + '\" ContentType=\"' + rel.type + '\"/>';\n            }\n        });\n    });\n    strXml += '<Default Extension=\"vml\" ContentType=\"application/vnd.openxmlformats-officedocument.vmlDrawing\"/>';\n    strXml += '<Default Extension=\"xlsx\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"/>';\n    // STEP 2: Add presentation and slide master(s)/slide(s)\n    strXml += '<Override PartName=\"/ppt/presentation.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml\"/>';\n    strXml += '<Override PartName=\"/ppt/notesMasters/notesMaster1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.presentationml.notesMaster+xml\"/>';\n    slides.forEach((slide, idx) => {\n        strXml += `<Override PartName=\"/ppt/slideMasters/slideMaster${idx + 1}.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.presentationml.slideMaster+xml\"/>`;\n        strXml += `<Override PartName=\"/ppt/slides/slide${idx + 1}.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.presentationml.slide+xml\"/>`;\n        // Add charts if any\n        slide._relsChart.forEach(rel => {\n            strXml += `<Override PartName=\"${rel.Target}\" ContentType=\"application/vnd.openxmlformats-officedocument.drawingml.chart+xml\"/>`;\n        });\n    });\n    // STEP 3: Core PPT\n    strXml += '<Override PartName=\"/ppt/presProps.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.presentationml.presProps+xml\"/>';\n    strXml += '<Override PartName=\"/ppt/viewProps.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.presentationml.viewProps+xml\"/>';\n    strXml += '<Override PartName=\"/ppt/theme/theme1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.theme+xml\"/>';\n    strXml += '<Override PartName=\"/ppt/tableStyles.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.presentationml.tableStyles+xml\"/>';\n    // STEP 4: Add Slide Layouts\n    slideLayouts.forEach((layout, idx) => {\n        strXml += `<Override PartName=\"/ppt/slideLayouts/slideLayout${idx + 1}.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml\"/>`;\n        (layout._relsChart || []).forEach(rel => {\n            strXml += ' <Override PartName=\"' + rel.Target + '\" ContentType=\"application/vnd.openxmlformats-officedocument.drawingml.chart+xml\"/>';\n        });\n    });\n    // STEP 5: Add notes slide(s)\n    slides.forEach((_slide, idx) => {\n        strXml += `<Override PartName=\"/ppt/notesSlides/notesSlide${idx + 1}.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.presentationml.notesSlide+xml\"/>`;\n    });\n    // STEP 6: Add rels\n    masterSlide._relsChart.forEach(rel => {\n        strXml += ' <Override PartName=\"' + rel.Target + '\" ContentType=\"application/vnd.openxmlformats-officedocument.drawingml.chart+xml\"/>';\n    });\n    masterSlide._relsMedia.forEach(rel => {\n        if (rel.type !== 'image' && rel.type !== 'online' && rel.type !== 'chart' && rel.extn !== 'm4v' && !strXml.includes(rel.type)) {\n            strXml += ' <Default Extension=\"' + rel.extn + '\" ContentType=\"' + rel.type + '\"/>';\n        }\n    });\n    // LAST: Finish XML (Resume core)\n    strXml += ' <Override PartName=\"/docProps/core.xml\" ContentType=\"application/vnd.openxmlformats-package.core-properties+xml\"/>';\n    strXml += ' <Override PartName=\"/docProps/app.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.extended-properties+xml\"/>';\n    strXml += '</Types>';\n    return strXml;\n}\n/**\n * Creates `_rels/.rels`\n * @returns XML\n */\nfunction makeXmlRootRels() {\n    return `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>${CRLF}<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">\n\t\t<Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties\" Target=\"docProps/app.xml\"/>\n\t\t<Relationship Id=\"rId2\" Type=\"http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties\" Target=\"docProps/core.xml\"/>\n\t\t<Relationship Id=\"rId3\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument\" Target=\"ppt/presentation.xml\"/>\n\t\t</Relationships>`;\n}\n/**\n * Creates `docProps/app.xml`\n * @param {PresSlide[]} slides - Presenation Slides\n * @param {string} company - \"Company\" metadata\n * @returns XML\n */\nfunction makeXmlApp(slides, company) {\n    return `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>${CRLF}<Properties xmlns=\"http://schemas.openxmlformats.org/officeDocument/2006/extended-properties\" xmlns:vt=\"http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes\">\n\t<TotalTime>0</TotalTime>\n\t<Words>0</Words>\n\t<Application>Microsoft Office PowerPoint</Application>\n\t<PresentationFormat>On-screen Show (16:9)</PresentationFormat>\n\t<Paragraphs>0</Paragraphs>\n\t<Slides>${slides.length}</Slides>\n\t<Notes>${slides.length}</Notes>\n\t<HiddenSlides>0</HiddenSlides>\n\t<MMClips>0</MMClips>\n\t<ScaleCrop>false</ScaleCrop>\n\t<HeadingPairs>\n\t\t<vt:vector size=\"6\" baseType=\"variant\">\n\t\t\t<vt:variant><vt:lpstr>Fonts Used</vt:lpstr></vt:variant>\n\t\t\t<vt:variant><vt:i4>2</vt:i4></vt:variant>\n\t\t\t<vt:variant><vt:lpstr>Theme</vt:lpstr></vt:variant>\n\t\t\t<vt:variant><vt:i4>1</vt:i4></vt:variant>\n\t\t\t<vt:variant><vt:lpstr>Slide Titles</vt:lpstr></vt:variant>\n\t\t\t<vt:variant><vt:i4>${slides.length}</vt:i4></vt:variant>\n\t\t</vt:vector>\n\t</HeadingPairs>\n\t<TitlesOfParts>\n\t\t<vt:vector size=\"${slides.length + 1 + 2}\" baseType=\"lpstr\">\n\t\t\t<vt:lpstr>Arial</vt:lpstr>\n\t\t\t<vt:lpstr>Calibri</vt:lpstr>\n\t\t\t<vt:lpstr>Office Theme</vt:lpstr>\n\t\t\t${slides.map((_slideObj, idx) => `<vt:lpstr>Slide ${idx + 1}</vt:lpstr>`).join('')}\n\t\t</vt:vector>\n\t</TitlesOfParts>\n\t<Company>${company}</Company>\n\t<LinksUpToDate>false</LinksUpToDate>\n\t<SharedDoc>false</SharedDoc>\n\t<HyperlinksChanged>false</HyperlinksChanged>\n\t<AppVersion>16.0000</AppVersion>\n\t</Properties>`;\n}\n/**\n * Creates `docProps/core.xml`\n * @param {string} title - metadata data\n * @param {string} subject - metadata data\n * @param {string} author - metadata value\n * @param {string} revision - metadata value\n * @returns XML\n */\nfunction makeXmlCore(title, subject, author, revision) {\n    return `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n\t<cp:coreProperties xmlns:cp=\"http://schemas.openxmlformats.org/package/2006/metadata/core-properties\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:dcterms=\"http://purl.org/dc/terms/\" xmlns:dcmitype=\"http://purl.org/dc/dcmitype/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n\t\t<dc:title>${encodeXmlEntities(title)}</dc:title>\n\t\t<dc:subject>${encodeXmlEntities(subject)}</dc:subject>\n\t\t<dc:creator>${encodeXmlEntities(author)}</dc:creator>\n\t\t<cp:lastModifiedBy>${encodeXmlEntities(author)}</cp:lastModifiedBy>\n\t\t<cp:revision>${revision}</cp:revision>\n\t\t<dcterms:created xsi:type=\"dcterms:W3CDTF\">${new Date().toISOString().replace(/\\.\\d\\d\\dZ/, 'Z')}</dcterms:created>\n\t\t<dcterms:modified xsi:type=\"dcterms:W3CDTF\">${new Date().toISOString().replace(/\\.\\d\\d\\dZ/, 'Z')}</dcterms:modified>\n\t</cp:coreProperties>`;\n}\n/**\n * Creates `ppt/_rels/presentation.xml.rels`\n * @param {PresSlide[]} slides - Presenation Slides\n * @returns XML\n */\nfunction makeXmlPresentationRels(slides) {\n    let intRelNum = 1;\n    let strXml = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' + CRLF;\n    strXml += '<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">';\n    strXml += '<Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideMaster\" Target=\"slideMasters/slideMaster1.xml\"/>';\n    for (let idx = 1; idx <= slides.length; idx++) {\n        strXml += `<Relationship Id=\"rId${++intRelNum}\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide\" Target=\"slides/slide${idx}.xml\"/>`;\n    }\n    intRelNum++;\n    strXml +=\n        `<Relationship Id=\"rId${intRelNum + 0}\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesMaster\" Target=\"notesMasters/notesMaster1.xml\"/>` +\n            `<Relationship Id=\"rId${intRelNum + 1}\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/presProps\" Target=\"presProps.xml\"/>` +\n            `<Relationship Id=\"rId${intRelNum + 2}\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/viewProps\" Target=\"viewProps.xml\"/>` +\n            `<Relationship Id=\"rId${intRelNum + 3}\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme\" Target=\"theme/theme1.xml\"/>` +\n            `<Relationship Id=\"rId${intRelNum + 4}\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/tableStyles\" Target=\"tableStyles.xml\"/>` +\n            '</Relationships>';\n    return strXml;\n}\n// XML-GEN: Functions that run 1-N times (once for each Slide)\n/**\n * Generates XML for the slide file (`ppt/slides/slide1.xml`)\n * @param {PresSlide} slide - the slide object to transform into XML\n * @return {string} XML\n */\nfunction makeXmlSlide(slide) {\n    return (`<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>${CRLF}` +\n        '<p:sld xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" ' +\n        'xmlns:p=\"http://schemas.openxmlformats.org/presentationml/2006/main\"' +\n        `${(slide === null || slide === void 0 ? void 0 : slide.hidden) ? ' show=\"0\"' : ''}>` +\n        `${slideObjectToXml(slide)}` +\n        '<p:clrMapOvr><a:masterClrMapping/></p:clrMapOvr></p:sld>');\n}\n/**\n * Get text content of Notes from Slide\n * @param {PresSlide} slide - the slide object to transform into XML\n * @return {string} notes text\n */\nfunction getNotesFromSlide(slide) {\n    let notesText = '';\n    slide._slideObjects.forEach(data => {\n        if (data._type === SLIDE_OBJECT_TYPES.notes)\n            notesText += (data === null || data === void 0 ? void 0 : data.text) && data.text[0] ? data.text[0].text : '';\n    });\n    return notesText.replace(/\\r*\\n/g, CRLF);\n}\n/**\n * Generate XML for Notes Master (notesMaster1.xml)\n * @returns {string} XML\n */\nfunction makeXmlNotesMaster() {\n    return `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>${CRLF}<p:notesMaster xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:p=\"http://schemas.openxmlformats.org/presentationml/2006/main\"><p:cSld><p:bg><p:bgRef idx=\"1001\"><a:schemeClr val=\"bg1\"/></p:bgRef></p:bg><p:spTree><p:nvGrpSpPr><p:cNvPr id=\"1\" name=\"\"/><p:cNvGrpSpPr/><p:nvPr/></p:nvGrpSpPr><p:grpSpPr><a:xfrm><a:off x=\"0\" y=\"0\"/><a:ext cx=\"0\" cy=\"0\"/><a:chOff x=\"0\" y=\"0\"/><a:chExt cx=\"0\" cy=\"0\"/></a:xfrm></p:grpSpPr><p:sp><p:nvSpPr><p:cNvPr id=\"2\" name=\"Header Placeholder 1\"/><p:cNvSpPr><a:spLocks noGrp=\"1\"/></p:cNvSpPr><p:nvPr><p:ph type=\"hdr\" sz=\"quarter\"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x=\"0\" y=\"0\"/><a:ext cx=\"2971800\" cy=\"458788\"/></a:xfrm><a:prstGeom prst=\"rect\"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert=\"horz\" lIns=\"91440\" tIns=\"45720\" rIns=\"91440\" bIns=\"45720\" rtlCol=\"0\"/><a:lstStyle><a:lvl1pPr algn=\"l\"><a:defRPr sz=\"1200\"/></a:lvl1pPr></a:lstStyle><a:p><a:endParaRPr lang=\"en-US\"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id=\"3\" name=\"Date Placeholder 2\"/><p:cNvSpPr><a:spLocks noGrp=\"1\"/></p:cNvSpPr><p:nvPr><p:ph type=\"dt\" idx=\"1\"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x=\"3884613\" y=\"0\"/><a:ext cx=\"2971800\" cy=\"458788\"/></a:xfrm><a:prstGeom prst=\"rect\"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert=\"horz\" lIns=\"91440\" tIns=\"45720\" rIns=\"91440\" bIns=\"45720\" rtlCol=\"0\"/><a:lstStyle><a:lvl1pPr algn=\"r\"><a:defRPr sz=\"1200\"/></a:lvl1pPr></a:lstStyle><a:p><a:fld id=\"{5282F153-3F37-0F45-9E97-73ACFA13230C}\" type=\"datetimeFigureOut\"><a:rPr lang=\"en-US\"/><a:t>7/23/19</a:t></a:fld><a:endParaRPr lang=\"en-US\"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id=\"4\" name=\"Slide Image Placeholder 3\"/><p:cNvSpPr><a:spLocks noGrp=\"1\" noRot=\"1\" noChangeAspect=\"1\"/></p:cNvSpPr><p:nvPr><p:ph type=\"sldImg\" idx=\"2\"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x=\"685800\" y=\"1143000\"/><a:ext cx=\"5486400\" cy=\"3086100\"/></a:xfrm><a:prstGeom prst=\"rect\"><a:avLst/></a:prstGeom><a:noFill/><a:ln w=\"12700\"><a:solidFill><a:prstClr val=\"black\"/></a:solidFill></a:ln></p:spPr><p:txBody><a:bodyPr vert=\"horz\" lIns=\"91440\" tIns=\"45720\" rIns=\"91440\" bIns=\"45720\" rtlCol=\"0\" anchor=\"ctr\"/><a:lstStyle/><a:p><a:endParaRPr lang=\"en-US\"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id=\"5\" name=\"Notes Placeholder 4\"/><p:cNvSpPr><a:spLocks noGrp=\"1\"/></p:cNvSpPr><p:nvPr><p:ph type=\"body\" sz=\"quarter\" idx=\"3\"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x=\"685800\" y=\"4400550\"/><a:ext cx=\"5486400\" cy=\"3600450\"/></a:xfrm><a:prstGeom prst=\"rect\"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert=\"horz\" lIns=\"91440\" tIns=\"45720\" rIns=\"91440\" bIns=\"45720\" rtlCol=\"0\"/><a:lstStyle/><a:p><a:pPr lvl=\"0\"/><a:r><a:rPr lang=\"en-US\"/><a:t>Click to edit Master text styles</a:t></a:r></a:p><a:p><a:pPr lvl=\"1\"/><a:r><a:rPr lang=\"en-US\"/><a:t>Second level</a:t></a:r></a:p><a:p><a:pPr lvl=\"2\"/><a:r><a:rPr lang=\"en-US\"/><a:t>Third level</a:t></a:r></a:p><a:p><a:pPr lvl=\"3\"/><a:r><a:rPr lang=\"en-US\"/><a:t>Fourth level</a:t></a:r></a:p><a:p><a:pPr lvl=\"4\"/><a:r><a:rPr lang=\"en-US\"/><a:t>Fifth level</a:t></a:r></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id=\"6\" name=\"Footer Placeholder 5\"/><p:cNvSpPr><a:spLocks noGrp=\"1\"/></p:cNvSpPr><p:nvPr><p:ph type=\"ftr\" sz=\"quarter\" idx=\"4\"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x=\"0\" y=\"8685213\"/><a:ext cx=\"2971800\" cy=\"458787\"/></a:xfrm><a:prstGeom prst=\"rect\"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert=\"horz\" lIns=\"91440\" tIns=\"45720\" rIns=\"91440\" bIns=\"45720\" rtlCol=\"0\" anchor=\"b\"/><a:lstStyle><a:lvl1pPr algn=\"l\"><a:defRPr sz=\"1200\"/></a:lvl1pPr></a:lstStyle><a:p><a:endParaRPr lang=\"en-US\"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id=\"7\" name=\"Slide Number Placeholder 6\"/><p:cNvSpPr><a:spLocks noGrp=\"1\"/></p:cNvSpPr><p:nvPr><p:ph type=\"sldNum\" sz=\"quarter\" idx=\"5\"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x=\"3884613\" y=\"8685213\"/><a:ext cx=\"2971800\" cy=\"458787\"/></a:xfrm><a:prstGeom prst=\"rect\"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert=\"horz\" lIns=\"91440\" tIns=\"45720\" rIns=\"91440\" bIns=\"45720\" rtlCol=\"0\" anchor=\"b\"/><a:lstStyle><a:lvl1pPr algn=\"r\"><a:defRPr sz=\"1200\"/></a:lvl1pPr></a:lstStyle><a:p><a:fld id=\"{CE5E9CC1-C706-0F49-92D6-E571CC5EEA8F}\" type=\"slidenum\"><a:rPr lang=\"en-US\"/><a:t>‹#›</a:t></a:fld><a:endParaRPr lang=\"en-US\"/></a:p></p:txBody></p:sp></p:spTree><p:extLst><p:ext uri=\"{BB962C8B-B14F-4D97-AF65-F5344CB8AC3E}\"><p14:creationId xmlns:p14=\"http://schemas.microsoft.com/office/powerpoint/2010/main\" val=\"1024086991\"/></p:ext></p:extLst></p:cSld><p:clrMap bg1=\"lt1\" tx1=\"dk1\" bg2=\"lt2\" tx2=\"dk2\" accent1=\"accent1\" accent2=\"accent2\" accent3=\"accent3\" accent4=\"accent4\" accent5=\"accent5\" accent6=\"accent6\" hlink=\"hlink\" folHlink=\"folHlink\"/><p:notesStyle><a:lvl1pPr marL=\"0\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1200\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl1pPr><a:lvl2pPr marL=\"457200\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1200\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl2pPr><a:lvl3pPr marL=\"914400\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1200\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl3pPr><a:lvl4pPr marL=\"1371600\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1200\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl4pPr><a:lvl5pPr marL=\"1828800\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1200\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl5pPr><a:lvl6pPr marL=\"2286000\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1200\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl6pPr><a:lvl7pPr marL=\"2743200\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1200\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl7pPr><a:lvl8pPr marL=\"3200400\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1200\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl8pPr><a:lvl9pPr marL=\"3657600\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1200\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl9pPr></p:notesStyle></p:notesMaster>`;\n}\n/**\n * Creates Notes Slide (`ppt/notesSlides/notesSlide1.xml`)\n * @param {PresSlide} slide - the slide object to transform into XML\n * @return {string} XML\n */\nfunction makeXmlNotesSlide(slide) {\n    return (`<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>${CRLF}<p:notes xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:p=\"http://schemas.openxmlformats.org/presentationml/2006/main\"><p:cSld><p:spTree><p:nvGrpSpPr><p:cNvPr id=\"1\" name=\"\"/><p:cNvGrpSpPr/><p:nvPr/></p:nvGrpSpPr><p:grpSpPr><a:xfrm><a:off x=\"0\" y=\"0\"/><a:ext cx=\"0\" cy=\"0\"/><a:chOff x=\"0\" y=\"0\"/><a:chExt cx=\"0\" cy=\"0\"/></a:xfrm></p:grpSpPr><p:sp><p:nvSpPr><p:cNvPr id=\"2\" name=\"Slide Image Placeholder 1\"/><p:cNvSpPr><a:spLocks noGrp=\"1\" noRot=\"1\" noChangeAspect=\"1\"/></p:cNvSpPr><p:nvPr><p:ph type=\"sldImg\"/></p:nvPr></p:nvSpPr><p:spPr/></p:sp><p:sp><p:nvSpPr><p:cNvPr id=\"3\" name=\"Notes Placeholder 2\"/><p:cNvSpPr><a:spLocks noGrp=\"1\"/></p:cNvSpPr><p:nvPr><p:ph type=\"body\" idx=\"1\"/></p:nvPr></p:nvSpPr><p:spPr/><p:txBody><a:bodyPr/><a:lstStyle/><a:p><a:r><a:rPr lang=\"en-US\" dirty=\"0\"/><a:t>${encodeXmlEntities(getNotesFromSlide(slide))}</a:t></a:r><a:endParaRPr lang=\"en-US\" dirty=\"0\"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id=\"4\" name=\"Slide Number Placeholder 3\"/><p:cNvSpPr><a:spLocks noGrp=\"1\"/></p:cNvSpPr><p:nvPr><p:ph type=\"sldNum\" sz=\"quarter\" idx=\"10\"/></p:nvPr></p:nvSpPr><p:spPr/><p:txBody><a:bodyPr/><a:lstStyle/><a:p><a:fld id=\"${SLDNUMFLDID}\" type=\"slidenum\"><a:rPr lang=\"en-US\"/><a:t>${slide._slideNum}</a:t></a:fld><a:endParaRPr lang=\"en-US\"/></a:p></p:txBody></p:sp></p:spTree><p:extLst><p:ext uri=\"{BB962C8B-B14F-4D97-AF65-F5344CB8AC3E}\"><p14:creationId xmlns:p14=\"http://schemas.microsoft.com/office/powerpoint/2010/main\" val=\"1024086991\"/></p:ext></p:extLst></p:cSld><p:clrMapOvr><a:masterClrMapping/></p:clrMapOvr></p:notes>`);\n}\n/**\n * Generates the XML layout resource from a layout object\n * @param {SlideLayout} layout - slide layout (master)\n * @return {string} XML\n */\nfunction makeXmlLayout(layout) {\n    return `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n\t\t<p:sldLayout xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:p=\"http://schemas.openxmlformats.org/presentationml/2006/main\" preserve=\"1\">\n\t\t${slideObjectToXml(layout)}\n\t\t<p:clrMapOvr><a:masterClrMapping/></p:clrMapOvr></p:sldLayout>`;\n}\n/**\n * Creates Slide Master 1 (`ppt/slideMasters/slideMaster1.xml`)\n * @param {PresSlide} slide - slide object that represents master slide layout\n * @param {SlideLayout[]} layouts - slide layouts\n * @return {string} XML\n */\nfunction makeXmlMaster(slide, layouts) {\n    // NOTE: Pass layouts as static rels because they are not referenced any time\n    const layoutDefs = layouts.map((_layoutDef, idx) => `<p:sldLayoutId id=\"${LAYOUT_IDX_SERIES_BASE + idx}\" r:id=\"rId${slide._rels.length + idx + 1}\"/>`);\n    let strXml = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' + CRLF;\n    strXml +=\n        '<p:sldMaster xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:p=\"http://schemas.openxmlformats.org/presentationml/2006/main\">';\n    strXml += slideObjectToXml(slide);\n    strXml +=\n        '<p:clrMap bg1=\"lt1\" tx1=\"dk1\" bg2=\"lt2\" tx2=\"dk2\" accent1=\"accent1\" accent2=\"accent2\" accent3=\"accent3\" accent4=\"accent4\" accent5=\"accent5\" accent6=\"accent6\" hlink=\"hlink\" folHlink=\"folHlink\"/>';\n    strXml += '<p:sldLayoutIdLst>' + layoutDefs.join('') + '</p:sldLayoutIdLst>';\n    strXml += '<p:hf sldNum=\"0\" hdr=\"0\" ftr=\"0\" dt=\"0\"/>';\n    strXml +=\n        '<p:txStyles>' +\n            ' <p:titleStyle>' +\n            '  <a:lvl1pPr algn=\"ctr\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:spcBef><a:spcPct val=\"0\"/></a:spcBef><a:buNone/><a:defRPr sz=\"4400\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mj-lt\"/><a:ea typeface=\"+mj-ea\"/><a:cs typeface=\"+mj-cs\"/></a:defRPr></a:lvl1pPr>' +\n            ' </p:titleStyle>' +\n            ' <p:bodyStyle>' +\n            '  <a:lvl1pPr marL=\"342900\" indent=\"-342900\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:spcBef><a:spcPct val=\"20000\"/></a:spcBef><a:buFont typeface=\"Arial\" pitchFamily=\"34\" charset=\"0\"/><a:buChar char=\"•\"/><a:defRPr sz=\"3200\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl1pPr>' +\n            '  <a:lvl2pPr marL=\"742950\" indent=\"-285750\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:spcBef><a:spcPct val=\"20000\"/></a:spcBef><a:buFont typeface=\"Arial\" pitchFamily=\"34\" charset=\"0\"/><a:buChar char=\"–\"/><a:defRPr sz=\"2800\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl2pPr>' +\n            '  <a:lvl3pPr marL=\"1143000\" indent=\"-228600\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:spcBef><a:spcPct val=\"20000\"/></a:spcBef><a:buFont typeface=\"Arial\" pitchFamily=\"34\" charset=\"0\"/><a:buChar char=\"•\"/><a:defRPr sz=\"2400\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl3pPr>' +\n            '  <a:lvl4pPr marL=\"1600200\" indent=\"-228600\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:spcBef><a:spcPct val=\"20000\"/></a:spcBef><a:buFont typeface=\"Arial\" pitchFamily=\"34\" charset=\"0\"/><a:buChar char=\"–\"/><a:defRPr sz=\"2000\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl4pPr>' +\n            '  <a:lvl5pPr marL=\"2057400\" indent=\"-228600\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:spcBef><a:spcPct val=\"20000\"/></a:spcBef><a:buFont typeface=\"Arial\" pitchFamily=\"34\" charset=\"0\"/><a:buChar char=\"»\"/><a:defRPr sz=\"2000\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl5pPr>' +\n            '  <a:lvl6pPr marL=\"2514600\" indent=\"-228600\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:spcBef><a:spcPct val=\"20000\"/></a:spcBef><a:buFont typeface=\"Arial\" pitchFamily=\"34\" charset=\"0\"/><a:buChar char=\"•\"/><a:defRPr sz=\"2000\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl6pPr>' +\n            '  <a:lvl7pPr marL=\"2971800\" indent=\"-228600\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:spcBef><a:spcPct val=\"20000\"/></a:spcBef><a:buFont typeface=\"Arial\" pitchFamily=\"34\" charset=\"0\"/><a:buChar char=\"•\"/><a:defRPr sz=\"2000\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl7pPr>' +\n            '  <a:lvl8pPr marL=\"3429000\" indent=\"-228600\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:spcBef><a:spcPct val=\"20000\"/></a:spcBef><a:buFont typeface=\"Arial\" pitchFamily=\"34\" charset=\"0\"/><a:buChar char=\"•\"/><a:defRPr sz=\"2000\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl8pPr>' +\n            '  <a:lvl9pPr marL=\"3886200\" indent=\"-228600\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:spcBef><a:spcPct val=\"20000\"/></a:spcBef><a:buFont typeface=\"Arial\" pitchFamily=\"34\" charset=\"0\"/><a:buChar char=\"•\"/><a:defRPr sz=\"2000\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl9pPr>' +\n            ' </p:bodyStyle>' +\n            ' <p:otherStyle>' +\n            '  <a:defPPr><a:defRPr lang=\"en-US\"/></a:defPPr>' +\n            '  <a:lvl1pPr marL=\"0\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1800\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl1pPr>' +\n            '  <a:lvl2pPr marL=\"457200\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1800\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl2pPr>' +\n            '  <a:lvl3pPr marL=\"914400\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1800\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl3pPr>' +\n            '  <a:lvl4pPr marL=\"1371600\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1800\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl4pPr>' +\n            '  <a:lvl5pPr marL=\"1828800\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1800\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl5pPr>' +\n            '  <a:lvl6pPr marL=\"2286000\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1800\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl6pPr>' +\n            '  <a:lvl7pPr marL=\"2743200\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1800\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl7pPr>' +\n            '  <a:lvl8pPr marL=\"3200400\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1800\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl8pPr>' +\n            '  <a:lvl9pPr marL=\"3657600\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1800\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl9pPr>' +\n            ' </p:otherStyle>' +\n            '</p:txStyles>';\n    strXml += '</p:sldMaster>';\n    return strXml;\n}\n/**\n * Generates XML string for a slide layout relation file\n * @param {number} layoutNumber - 1-indexed number of a layout that relations are generated for\n * @param {SlideLayout[]} slideLayouts - Slide Layouts\n * @return {string} XML\n */\nfunction makeXmlSlideLayoutRel(layoutNumber, slideLayouts) {\n    return slideObjectRelationsToXml(slideLayouts[layoutNumber - 1], [\n        {\n            target: '../slideMasters/slideMaster1.xml',\n            type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideMaster',\n        },\n    ]);\n}\n/**\n * Creates `ppt/_rels/slide*.xml.rels`\n * @param {PresSlide[]} slides\n * @param {SlideLayout[]} slideLayouts - Slide Layout(s)\n * @param {number} `slideNumber` 1-indexed number of a layout that relations are generated for\n * @return {string} XML\n */\nfunction makeXmlSlideRel(slides, slideLayouts, slideNumber) {\n    return slideObjectRelationsToXml(slides[slideNumber - 1], [\n        {\n            target: `../slideLayouts/slideLayout${getLayoutIdxForSlide(slides, slideLayouts, slideNumber)}.xml`,\n            type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout',\n        },\n        {\n            target: `../notesSlides/notesSlide${slideNumber}.xml`,\n            type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesSlide',\n        },\n    ]);\n}\n/**\n * Generates XML string for a slide relation file.\n * @param {number} slideNumber - 1-indexed number of a layout that relations are generated for\n * @return {string} XML\n */\nfunction makeXmlNotesSlideRel(slideNumber) {\n    return `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n\t\t<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">\n\t\t\t<Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesMaster\" Target=\"../notesMasters/notesMaster1.xml\"/>\n\t\t\t<Relationship Id=\"rId2\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide\" Target=\"../slides/slide${slideNumber}.xml\"/>\n\t\t</Relationships>`;\n}\n/**\n * Creates `ppt/slideMasters/_rels/slideMaster1.xml.rels`\n * @param {PresSlide} masterSlide - Slide object\n * @param {SlideLayout[]} slideLayouts - Slide Layouts\n * @return {string} XML\n */\nfunction makeXmlMasterRel(masterSlide, slideLayouts) {\n    const defaultRels = slideLayouts.map((_layoutDef, idx) => ({\n        target: `../slideLayouts/slideLayout${idx + 1}.xml`,\n        type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout',\n    }));\n    defaultRels.push({ target: '../theme/theme1.xml', type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme' });\n    return slideObjectRelationsToXml(masterSlide, defaultRels);\n}\n/**\n * Creates `ppt/notesMasters/_rels/notesMaster1.xml.rels`\n * @return {string} XML\n */\nfunction makeXmlNotesMasterRel() {\n    return `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>${CRLF}<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">\n\t\t<Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme\" Target=\"../theme/theme1.xml\"/>\n\t\t</Relationships>`;\n}\n/**\n * For the passed slide number, resolves name of a layout that is used for.\n * @param {PresSlide[]} slides - srray of slides\n * @param {SlideLayout[]} slideLayouts - array of slideLayouts\n * @param {number} slideNumber\n * @return {number} slide number\n */\nfunction getLayoutIdxForSlide(slides, slideLayouts, slideNumber) {\n    for (let i = 0; i < slideLayouts.length; i++) {\n        if (slideLayouts[i]._name === slides[slideNumber - 1]._slideLayout._name) {\n            return i + 1;\n        }\n    }\n    // IMPORTANT: Return 1 (for `slideLayout1.xml`) when no def is found\n    // So all objects are in Layout1 and every slide that references it uses this layout.\n    return 1;\n}\n// XML-GEN: Last 5 functions create root /ppt files\n/**\n * Creates `ppt/theme/theme1.xml`\n * @return {string} XML\n */\nfunction makeXmlTheme(pres) {\n    var _a, _b, _c, _d;\n    const majorFont = ((_a = pres.theme) === null || _a === void 0 ? void 0 : _a.headFontFace) ? `<a:latin typeface=\"${(_b = pres.theme) === null || _b === void 0 ? void 0 : _b.headFontFace}\"/>` : '<a:latin typeface=\"Calibri Light\" panose=\"020F0302020204030204\"/>';\n    const minorFont = ((_c = pres.theme) === null || _c === void 0 ? void 0 : _c.bodyFontFace) ? `<a:latin typeface=\"${(_d = pres.theme) === null || _d === void 0 ? void 0 : _d.bodyFontFace}\"/>` : '<a:latin typeface=\"Calibri\" panose=\"020F0502020204030204\"/>';\n    return `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><a:theme xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" name=\"Office Theme\"><a:themeElements><a:clrScheme name=\"Office\"><a:dk1><a:sysClr val=\"windowText\" lastClr=\"000000\"/></a:dk1><a:lt1><a:sysClr val=\"window\" lastClr=\"FFFFFF\"/></a:lt1><a:dk2><a:srgbClr val=\"44546A\"/></a:dk2><a:lt2><a:srgbClr val=\"E7E6E6\"/></a:lt2><a:accent1><a:srgbClr val=\"4472C4\"/></a:accent1><a:accent2><a:srgbClr val=\"ED7D31\"/></a:accent2><a:accent3><a:srgbClr val=\"A5A5A5\"/></a:accent3><a:accent4><a:srgbClr val=\"FFC000\"/></a:accent4><a:accent5><a:srgbClr val=\"5B9BD5\"/></a:accent5><a:accent6><a:srgbClr val=\"70AD47\"/></a:accent6><a:hlink><a:srgbClr val=\"0563C1\"/></a:hlink><a:folHlink><a:srgbClr val=\"954F72\"/></a:folHlink></a:clrScheme><a:fontScheme name=\"Office\"><a:majorFont>${majorFont}<a:ea typeface=\"\"/><a:cs typeface=\"\"/><a:font script=\"Jpan\" typeface=\"游ゴシック Light\"/><a:font script=\"Hang\" typeface=\"맑은 고딕\"/><a:font script=\"Hans\" typeface=\"等线 Light\"/><a:font script=\"Hant\" typeface=\"新細明體\"/><a:font script=\"Arab\" typeface=\"Times New Roman\"/><a:font script=\"Hebr\" typeface=\"Times New Roman\"/><a:font script=\"Thai\" typeface=\"Angsana New\"/><a:font script=\"Ethi\" typeface=\"Nyala\"/><a:font script=\"Beng\" typeface=\"Vrinda\"/><a:font script=\"Gujr\" typeface=\"Shruti\"/><a:font script=\"Khmr\" typeface=\"MoolBoran\"/><a:font script=\"Knda\" typeface=\"Tunga\"/><a:font script=\"Guru\" typeface=\"Raavi\"/><a:font script=\"Cans\" typeface=\"Euphemia\"/><a:font script=\"Cher\" typeface=\"Plantagenet Cherokee\"/><a:font script=\"Yiii\" typeface=\"Microsoft Yi Baiti\"/><a:font script=\"Tibt\" typeface=\"Microsoft Himalaya\"/><a:font script=\"Thaa\" typeface=\"MV Boli\"/><a:font script=\"Deva\" typeface=\"Mangal\"/><a:font script=\"Telu\" typeface=\"Gautami\"/><a:font script=\"Taml\" typeface=\"Latha\"/><a:font script=\"Syrc\" typeface=\"Estrangelo Edessa\"/><a:font script=\"Orya\" typeface=\"Kalinga\"/><a:font script=\"Mlym\" typeface=\"Kartika\"/><a:font script=\"Laoo\" typeface=\"DokChampa\"/><a:font script=\"Sinh\" typeface=\"Iskoola Pota\"/><a:font script=\"Mong\" typeface=\"Mongolian Baiti\"/><a:font script=\"Viet\" typeface=\"Times New Roman\"/><a:font script=\"Uigh\" typeface=\"Microsoft Uighur\"/><a:font script=\"Geor\" typeface=\"Sylfaen\"/><a:font script=\"Armn\" typeface=\"Arial\"/><a:font script=\"Bugi\" typeface=\"Leelawadee UI\"/><a:font script=\"Bopo\" typeface=\"Microsoft JhengHei\"/><a:font script=\"Java\" typeface=\"Javanese Text\"/><a:font script=\"Lisu\" typeface=\"Segoe UI\"/><a:font script=\"Mymr\" typeface=\"Myanmar Text\"/><a:font script=\"Nkoo\" typeface=\"Ebrima\"/><a:font script=\"Olck\" typeface=\"Nirmala UI\"/><a:font script=\"Osma\" typeface=\"Ebrima\"/><a:font script=\"Phag\" typeface=\"Phagspa\"/><a:font script=\"Syrn\" typeface=\"Estrangelo Edessa\"/><a:font script=\"Syrj\" typeface=\"Estrangelo Edessa\"/><a:font script=\"Syre\" typeface=\"Estrangelo Edessa\"/><a:font script=\"Sora\" typeface=\"Nirmala UI\"/><a:font script=\"Tale\" typeface=\"Microsoft Tai Le\"/><a:font script=\"Talu\" typeface=\"Microsoft New Tai Lue\"/><a:font script=\"Tfng\" typeface=\"Ebrima\"/></a:majorFont><a:minorFont>${minorFont}<a:ea typeface=\"\"/><a:cs typeface=\"\"/><a:font script=\"Jpan\" typeface=\"游ゴシック\"/><a:font script=\"Hang\" typeface=\"맑은 고딕\"/><a:font script=\"Hans\" typeface=\"等线\"/><a:font script=\"Hant\" typeface=\"新細明體\"/><a:font script=\"Arab\" typeface=\"Arial\"/><a:font script=\"Hebr\" typeface=\"Arial\"/><a:font script=\"Thai\" typeface=\"Cordia New\"/><a:font script=\"Ethi\" typeface=\"Nyala\"/><a:font script=\"Beng\" typeface=\"Vrinda\"/><a:font script=\"Gujr\" typeface=\"Shruti\"/><a:font script=\"Khmr\" typeface=\"DaunPenh\"/><a:font script=\"Knda\" typeface=\"Tunga\"/><a:font script=\"Guru\" typeface=\"Raavi\"/><a:font script=\"Cans\" typeface=\"Euphemia\"/><a:font script=\"Cher\" typeface=\"Plantagenet Cherokee\"/><a:font script=\"Yiii\" typeface=\"Microsoft Yi Baiti\"/><a:font script=\"Tibt\" typeface=\"Microsoft Himalaya\"/><a:font script=\"Thaa\" typeface=\"MV Boli\"/><a:font script=\"Deva\" typeface=\"Mangal\"/><a:font script=\"Telu\" typeface=\"Gautami\"/><a:font script=\"Taml\" typeface=\"Latha\"/><a:font script=\"Syrc\" typeface=\"Estrangelo Edessa\"/><a:font script=\"Orya\" typeface=\"Kalinga\"/><a:font script=\"Mlym\" typeface=\"Kartika\"/><a:font script=\"Laoo\" typeface=\"DokChampa\"/><a:font script=\"Sinh\" typeface=\"Iskoola Pota\"/><a:font script=\"Mong\" typeface=\"Mongolian Baiti\"/><a:font script=\"Viet\" typeface=\"Arial\"/><a:font script=\"Uigh\" typeface=\"Microsoft Uighur\"/><a:font script=\"Geor\" typeface=\"Sylfaen\"/><a:font script=\"Armn\" typeface=\"Arial\"/><a:font script=\"Bugi\" typeface=\"Leelawadee UI\"/><a:font script=\"Bopo\" typeface=\"Microsoft JhengHei\"/><a:font script=\"Java\" typeface=\"Javanese Text\"/><a:font script=\"Lisu\" typeface=\"Segoe UI\"/><a:font script=\"Mymr\" typeface=\"Myanmar Text\"/><a:font script=\"Nkoo\" typeface=\"Ebrima\"/><a:font script=\"Olck\" typeface=\"Nirmala UI\"/><a:font script=\"Osma\" typeface=\"Ebrima\"/><a:font script=\"Phag\" typeface=\"Phagspa\"/><a:font script=\"Syrn\" typeface=\"Estrangelo Edessa\"/><a:font script=\"Syrj\" typeface=\"Estrangelo Edessa\"/><a:font script=\"Syre\" typeface=\"Estrangelo Edessa\"/><a:font script=\"Sora\" typeface=\"Nirmala UI\"/><a:font script=\"Tale\" typeface=\"Microsoft Tai Le\"/><a:font script=\"Talu\" typeface=\"Microsoft New Tai Lue\"/><a:font script=\"Tfng\" typeface=\"Ebrima\"/></a:minorFont></a:fontScheme><a:fmtScheme name=\"Office\"><a:fillStyleLst><a:solidFill><a:schemeClr val=\"phClr\"/></a:solidFill><a:gradFill rotWithShape=\"1\"><a:gsLst><a:gs pos=\"0\"><a:schemeClr val=\"phClr\"><a:lumMod val=\"110000\"/><a:satMod val=\"105000\"/><a:tint val=\"67000\"/></a:schemeClr></a:gs><a:gs pos=\"50000\"><a:schemeClr val=\"phClr\"><a:lumMod val=\"105000\"/><a:satMod val=\"103000\"/><a:tint val=\"73000\"/></a:schemeClr></a:gs><a:gs pos=\"100000\"><a:schemeClr val=\"phClr\"><a:lumMod val=\"105000\"/><a:satMod val=\"109000\"/><a:tint val=\"81000\"/></a:schemeClr></a:gs></a:gsLst><a:lin ang=\"5400000\" scaled=\"0\"/></a:gradFill><a:gradFill rotWithShape=\"1\"><a:gsLst><a:gs pos=\"0\"><a:schemeClr val=\"phClr\"><a:satMod val=\"103000\"/><a:lumMod val=\"102000\"/><a:tint val=\"94000\"/></a:schemeClr></a:gs><a:gs pos=\"50000\"><a:schemeClr val=\"phClr\"><a:satMod val=\"110000\"/><a:lumMod val=\"100000\"/><a:shade val=\"100000\"/></a:schemeClr></a:gs><a:gs pos=\"100000\"><a:schemeClr val=\"phClr\"><a:lumMod val=\"99000\"/><a:satMod val=\"120000\"/><a:shade val=\"78000\"/></a:schemeClr></a:gs></a:gsLst><a:lin ang=\"5400000\" scaled=\"0\"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w=\"6350\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"><a:solidFill><a:schemeClr val=\"phClr\"/></a:solidFill><a:prstDash val=\"solid\"/><a:miter lim=\"800000\"/></a:ln><a:ln w=\"12700\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"><a:solidFill><a:schemeClr val=\"phClr\"/></a:solidFill><a:prstDash val=\"solid\"/><a:miter lim=\"800000\"/></a:ln><a:ln w=\"19050\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"><a:solidFill><a:schemeClr val=\"phClr\"/></a:solidFill><a:prstDash val=\"solid\"/><a:miter lim=\"800000\"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad=\"57150\" dist=\"19050\" dir=\"5400000\" algn=\"ctr\" rotWithShape=\"0\"><a:srgbClr val=\"000000\"><a:alpha val=\"63000\"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val=\"phClr\"/></a:solidFill><a:solidFill><a:schemeClr val=\"phClr\"><a:tint val=\"95000\"/><a:satMod val=\"170000\"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape=\"1\"><a:gsLst><a:gs pos=\"0\"><a:schemeClr val=\"phClr\"><a:tint val=\"93000\"/><a:satMod val=\"150000\"/><a:shade val=\"98000\"/><a:lumMod val=\"102000\"/></a:schemeClr></a:gs><a:gs pos=\"50000\"><a:schemeClr val=\"phClr\"><a:tint val=\"98000\"/><a:satMod val=\"130000\"/><a:shade val=\"90000\"/><a:lumMod val=\"103000\"/></a:schemeClr></a:gs><a:gs pos=\"100000\"><a:schemeClr val=\"phClr\"><a:shade val=\"63000\"/><a:satMod val=\"120000\"/></a:schemeClr></a:gs></a:gsLst><a:lin ang=\"5400000\" scaled=\"0\"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri=\"{05A4C25C-085E-4340-85A3-A5531E510DB2}\"><thm15:themeFamily xmlns:thm15=\"http://schemas.microsoft.com/office/thememl/2012/main\" name=\"Office Theme\" id=\"{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}\" vid=\"{4A3C46E8-61CC-4603-A589-7422A47A8E4A}\"/></a:ext></a:extLst></a:theme>`;\n}\n/**\n * Create presentation file (`ppt/presentation.xml`)\n * @see https://docs.microsoft.com/en-us/office/open-xml/structure-of-a-presentationml-document\n * @see http://www.datypic.com/sc/ooxml/t-p_CT_Presentation.html\n * @param {IPresentationProps} pres - presentation\n * @return {string} XML\n */\nfunction makeXmlPresentation(pres) {\n    let strXml = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>${CRLF}` +\n        '<p:presentation xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" ' +\n        `xmlns:p=\"http://schemas.openxmlformats.org/presentationml/2006/main\" ${pres.rtlMode ? 'rtl=\"1\"' : ''} saveSubsetFonts=\"1\" autoCompressPictures=\"0\">`;\n    // STEP 1: Add slide master (SPEC: tag 1 under <presentation>)\n    strXml += '<p:sldMasterIdLst><p:sldMasterId id=\"2147483648\" r:id=\"rId1\"/></p:sldMasterIdLst>';\n    // STEP 2: Add all Slides (SPEC: tag 3 under <presentation>)\n    strXml += '<p:sldIdLst>';\n    pres.slides.forEach(slide => (strXml += `<p:sldId id=\"${slide._slideId}\" r:id=\"rId${slide._rId}\"/>`));\n    strXml += '</p:sldIdLst>';\n    // STEP 3: Add Notes Master (SPEC: tag 2 under <presentation>)\n    // (NOTE: length+2 is from `presentation.xml.rels` func (since we have to match this rId, we just use same logic))\n    // IMPORTANT: In this order (matches PPT2019) PPT will give corruption message on open!\n    // IMPORTANT: Placing this before `<p:sldIdLst>` causes warning in modern powerpoint!\n    // IMPORTANT: Presentations open without warning Without this line, however, the pres isnt preview in Finder anymore or viewable in iOS!\n    strXml += `<p:notesMasterIdLst><p:notesMasterId r:id=\"rId${pres.slides.length + 2}\"/></p:notesMasterIdLst>`;\n    // STEP 4: Add sizes\n    strXml += `<p:sldSz cx=\"${pres.presLayout.width}\" cy=\"${pres.presLayout.height}\"/>`;\n    strXml += `<p:notesSz cx=\"${pres.presLayout.height}\" cy=\"${pres.presLayout.width}\"/>`;\n    // STEP 5: Add text styles\n    strXml += '<p:defaultTextStyle>';\n    for (let idy = 1; idy < 10; idy++) {\n        strXml +=\n            `<a:lvl${idy}pPr marL=\"${(idy - 1) * 457200}\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\">` +\n                '<a:defRPr sz=\"1800\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/>' +\n                `</a:defRPr></a:lvl${idy}pPr>`;\n    }\n    strXml += '</p:defaultTextStyle>';\n    // STEP 6: Add Sections (if any)\n    if (pres.sections && pres.sections.length > 0) {\n        strXml += '<p:extLst><p:ext uri=\"{521415D9-36F7-43E2-AB2F-B90AF26B5E84}\">';\n        strXml += '<p14:sectionLst xmlns:p14=\"http://schemas.microsoft.com/office/powerpoint/2010/main\">';\n        pres.sections.forEach(sect => {\n            strXml += `<p14:section name=\"${encodeXmlEntities(sect.title)}\" id=\"{${getUuid('xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx')}}\"><p14:sldIdLst>`;\n            sect._slides.forEach(slide => (strXml += `<p14:sldId id=\"${slide._slideId}\"/>`));\n            strXml += '</p14:sldIdLst></p14:section>';\n        });\n        strXml += '</p14:sectionLst></p:ext>';\n        strXml += '<p:ext uri=\"{EFAFB233-063F-42B5-8137-9DF3F51BA10A}\"><p15:sldGuideLst xmlns:p15=\"http://schemas.microsoft.com/office/powerpoint/2012/main\"/></p:ext>';\n        strXml += '</p:extLst>';\n    }\n    // Done\n    strXml += '</p:presentation>';\n    return strXml;\n}\n/**\n * Create `ppt/presProps.xml`\n * @return {string} XML\n */\nfunction makeXmlPresProps() {\n    return `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>${CRLF}<p:presentationPr xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:p=\"http://schemas.openxmlformats.org/presentationml/2006/main\"/>`;\n}\n/**\n * Create `ppt/tableStyles.xml`\n * @see: http://openxmldeveloper.org/discussions/formats/f/13/p/2398/8107.aspx\n * @return {string} XML\n */\nfunction makeXmlTableStyles() {\n    return `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>${CRLF}<a:tblStyleLst xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" def=\"{5C22544A-7EE6-4342-B048-85BDC9FD1C3A}\"/>`;\n}\n/**\n * Creates `ppt/viewProps.xml`\n * @return {string} XML\n */\nfunction makeXmlViewProps() {\n    return `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>${CRLF}<p:viewPr xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:p=\"http://schemas.openxmlformats.org/presentationml/2006/main\"><p:normalViewPr horzBarState=\"maximized\"><p:restoredLeft sz=\"15611\"/><p:restoredTop sz=\"94610\"/></p:normalViewPr><p:slideViewPr><p:cSldViewPr snapToGrid=\"0\" snapToObjects=\"1\"><p:cViewPr varScale=\"1\"><p:scale><a:sx n=\"136\" d=\"100\"/><a:sy n=\"136\" d=\"100\"/></p:scale><p:origin x=\"216\" y=\"312\"/></p:cViewPr><p:guideLst/></p:cSldViewPr></p:slideViewPr><p:notesTextViewPr><p:cViewPr><p:scale><a:sx n=\"1\" d=\"1\"/><a:sy n=\"1\" d=\"1\"/></p:scale><p:origin x=\"0\" y=\"0\"/></p:cViewPr></p:notesTextViewPr><p:gridSpacing cx=\"76200\" cy=\"76200\"/></p:viewPr>`;\n}\n\n/**\n *  :: pptxgen.ts ::\n *\n *  JavaScript framework that creates PowerPoint (pptx) presentations\n *  https://github.com/gitbrent/PptxGenJS\n *\n *  This framework is released under the MIT Public License (MIT)\n *\n *  PptxGenJS (C) 2015-present Brent Ely -- https://github.com/gitbrent\n *\n *  Some code derived from the OfficeGen project:\n *  github.com/Ziv-Barber/officegen/ (Copyright 2013 Ziv Barber)\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\nconst VERSION = '4.0.1';\nclass PptxGenJS {\n    set layout(value) {\n        const newLayout = this.LAYOUTS[value];\n        if (newLayout) {\n            this._layout = value;\n            this._presLayout = newLayout;\n        }\n        else {\n            throw new Error('UNKNOWN-LAYOUT');\n        }\n    }\n    get layout() {\n        return this._layout;\n    }\n    get version() {\n        return this._version;\n    }\n    set author(value) {\n        this._author = value;\n    }\n    get author() {\n        return this._author;\n    }\n    set company(value) {\n        this._company = value;\n    }\n    get company() {\n        return this._company;\n    }\n    set revision(value) {\n        this._revision = value;\n    }\n    get revision() {\n        return this._revision;\n    }\n    set subject(value) {\n        this._subject = value;\n    }\n    get subject() {\n        return this._subject;\n    }\n    set theme(value) {\n        this._theme = value;\n    }\n    get theme() {\n        return this._theme;\n    }\n    set title(value) {\n        this._title = value;\n    }\n    get title() {\n        return this._title;\n    }\n    set rtlMode(value) {\n        this._rtlMode = value;\n    }\n    get rtlMode() {\n        return this._rtlMode;\n    }\n    get masterSlide() {\n        return this._masterSlide;\n    }\n    get slides() {\n        return this._slides;\n    }\n    get sections() {\n        return this._sections;\n    }\n    get slideLayouts() {\n        return this._slideLayouts;\n    }\n    get AlignH() {\n        return this._alignH;\n    }\n    get AlignV() {\n        return this._alignV;\n    }\n    get ChartType() {\n        return this._chartType;\n    }\n    get OutputType() {\n        return this._outputType;\n    }\n    get presLayout() {\n        return this._presLayout;\n    }\n    get SchemeColor() {\n        return this._schemeColor;\n    }\n    get ShapeType() {\n        return this._shapeType;\n    }\n    get charts() {\n        return this._charts;\n    }\n    get colors() {\n        return this._colors;\n    }\n    get shapes() {\n        return this._shapes;\n    }\n    constructor() {\n        /**\n         * PptxGenJS Library Version\n         */\n        this._version = VERSION;\n        // Exposed class props\n        this._alignH = AlignH;\n        this._alignV = AlignV;\n        this._chartType = ChartType;\n        this._outputType = OutputType;\n        this._schemeColor = SchemeColor;\n        this._shapeType = ShapeType;\n        /**\n         * @depricated use `ChartType`\n         */\n        this._charts = CHART_TYPE;\n        /**\n         * @depricated use `SchemeColor`\n         */\n        this._colors = SCHEME_COLOR_NAMES;\n        /**\n         * @depricated use `ShapeType`\n         */\n        this._shapes = SHAPE_TYPE;\n        /**\n         * Provides an API for `addTableDefinition` to create slides as needed for auto-paging\n         * @param {AddSlideProps} options - slide masterName and/or sectionTitle\n         * @return {PresSlide} new Slide\n         */\n        this.addNewSlide = (options) => {\n            // Continue using sections if the first slide using auto-paging has a Section\n            const sectAlreadyInUse = this.sections.length > 0 &&\n                this.sections[this.sections.length - 1]._slides.filter(slide => slide._slideNum === this.slides[this.slides.length - 1]._slideNum).length > 0;\n            options.sectionTitle = sectAlreadyInUse ? this.sections[this.sections.length - 1].title : null;\n            return this.addSlide(options);\n        };\n        /**\n         * Provides an API for `addTableDefinition` to get slide reference by number\n         * @param {number} slideNum - slide number\n         * @return {PresSlide} Slide\n         * @since 3.0.0\n         */\n        this.getSlide = (slideNum) => this.slides.filter(slide => slide._slideNum === slideNum)[0];\n        /**\n         * Enables the `Slide` class to set PptxGenJS [Presentation] master/layout slidenumbers\n         * @param {SlideNumberProps} slideNum - slide number config\n         */\n        this.setSlideNumber = (slideNum) => {\n            // 1: Add slideNumber to slideMaster1.xml\n            this.masterSlide._slideNumberProps = slideNum;\n            // 2: Add slideNumber to DEF_PRES_LAYOUT_NAME layout\n            this.slideLayouts.filter(layout => layout._name === DEF_PRES_LAYOUT_NAME)[0]._slideNumberProps = slideNum;\n        };\n        /**\n         * Create all chart and media rels for this Presentation\n         * @param {PresSlide | SlideLayout} slide - slide with rels\n         * @param {JSZip} zip - JSZip instance\n         * @param {Promise<string>[]} chartPromises - promise array\n         */\n        this.createChartMediaRels = (slide, zip, chartPromises) => {\n            slide._relsChart.forEach(rel => chartPromises.push(createExcelWorksheet(rel, zip)));\n            slide._relsMedia.forEach(rel => {\n                if (rel.type !== 'online' && rel.type !== 'hyperlink') {\n                    // A: Loop vars\n                    let data = rel.data && typeof rel.data === 'string' ? rel.data : '';\n                    // B: Users will undoubtedly pass various string formats, so correct prefixes as needed\n                    if (!data.includes(',') && !data.includes(';'))\n                        data = 'image/png;base64,' + data;\n                    else if (!data.includes(','))\n                        data = 'image/png;base64,' + data;\n                    else if (!data.includes(';'))\n                        data = 'image/png;' + data;\n                    // C: Add media\n                    zip.file(rel.Target.replace('..', 'ppt'), data.split(',').pop(), { base64: true });\n                }\n            });\n        };\n        /**\n         * Create and export the .pptx file\n         * @param {string} exportName - output file type\n         * @param {Blob} blobContent - Blob content\n         * @return {Promise<string>} Promise with file name\n         */\n        this.writeFileToBrowser = (exportName, blobContent) => __awaiter(this, void 0, void 0, function* () {\n            // STEP 1: Create element\n            const eleLink = document.createElement('a');\n            eleLink.setAttribute('style', 'display:none;');\n            eleLink.dataset.interception = 'off'; // @see https://docs.microsoft.com/en-us/sharepoint/dev/spfx/hyperlinking\n            document.body.appendChild(eleLink);\n            // STEP 2: Download file to browser\n            // DESIGN: Use `createObjectURL()` to D/L files in client browsers (FYI: synchronously executed)\n            if (window.URL.createObjectURL) {\n                const url = window.URL.createObjectURL(new Blob([blobContent], { type: 'application/vnd.openxmlformats-officedocument.presentationml.presentation' }));\n                eleLink.href = url;\n                eleLink.download = exportName;\n                eleLink.click();\n                // Clean-up (NOTE: Add a slight delay before removing to avoid 'blob:null' error in Firefox Issue#81)\n                setTimeout(() => {\n                    window.URL.revokeObjectURL(url);\n                    document.body.removeChild(eleLink);\n                }, 100);\n                // Done\n                return yield Promise.resolve(exportName);\n            }\n        });\n        /**\n         * Create and export the .pptx file\n         * @param {WRITE_OUTPUT_TYPE} outputType - output file type\n         * @return {Promise<string | ArrayBuffer | Blob | Buffer | Uint8Array>} Promise with data or stream (node) or filename (browser)\n         */\n        this.exportPresentation = (props) => __awaiter(this, void 0, void 0, function* () {\n            const arrChartPromises = [];\n            let arrMediaPromises = [];\n            const zip = new (jszip__WEBPACK_IMPORTED_MODULE_0___default())();\n            // STEP 1: Read/Encode all Media before zip as base64 content, etc. is required\n            this.slides.forEach(slide => {\n                arrMediaPromises = arrMediaPromises.concat(encodeSlideMediaRels(slide));\n            });\n            this.slideLayouts.forEach(layout => {\n                arrMediaPromises = arrMediaPromises.concat(encodeSlideMediaRels(layout));\n            });\n            arrMediaPromises = arrMediaPromises.concat(encodeSlideMediaRels(this.masterSlide));\n            // STEP 2: Wait for Promises (if any) then generate the PPTX file\n            return yield Promise.all(arrMediaPromises).then(() => __awaiter(this, void 0, void 0, function* () {\n                // A: Add empty placeholder objects to slides that don't already have them\n                this.slides.forEach(slide => {\n                    if (slide._slideLayout)\n                        addPlaceholdersToSlideLayouts(slide);\n                });\n                // B: Add all required folders and files\n                zip.folder('_rels');\n                zip.folder('docProps');\n                zip.folder('ppt').folder('_rels');\n                zip.folder('ppt/charts').folder('_rels');\n                zip.folder('ppt/embeddings');\n                zip.folder('ppt/media');\n                zip.folder('ppt/slideLayouts').folder('_rels');\n                zip.folder('ppt/slideMasters').folder('_rels');\n                zip.folder('ppt/slides').folder('_rels');\n                zip.folder('ppt/theme');\n                zip.folder('ppt/notesMasters').folder('_rels');\n                zip.folder('ppt/notesSlides').folder('_rels');\n                zip.file('[Content_Types].xml', makeXmlContTypes(this.slides, this.slideLayouts, this.masterSlide)); // TODO: pass only `this` like below! 20200206\n                zip.file('_rels/.rels', makeXmlRootRels());\n                zip.file('docProps/app.xml', makeXmlApp(this.slides, this.company)); // TODO: pass only `this` like below! 20200206\n                zip.file('docProps/core.xml', makeXmlCore(this.title, this.subject, this.author, this.revision)); // TODO: pass only `this` like below! 20200206\n                zip.file('ppt/_rels/presentation.xml.rels', makeXmlPresentationRels(this.slides));\n                zip.file('ppt/theme/theme1.xml', makeXmlTheme(this));\n                zip.file('ppt/presentation.xml', makeXmlPresentation(this));\n                zip.file('ppt/presProps.xml', makeXmlPresProps());\n                zip.file('ppt/tableStyles.xml', makeXmlTableStyles());\n                zip.file('ppt/viewProps.xml', makeXmlViewProps());\n                // C: Create a Layout/Master/Rel/Slide file for each SlideLayout and Slide\n                this.slideLayouts.forEach((layout, idx) => {\n                    zip.file(`ppt/slideLayouts/slideLayout${idx + 1}.xml`, makeXmlLayout(layout));\n                    zip.file(`ppt/slideLayouts/_rels/slideLayout${idx + 1}.xml.rels`, makeXmlSlideLayoutRel(idx + 1, this.slideLayouts));\n                });\n                this.slides.forEach((slide, idx) => {\n                    zip.file(`ppt/slides/slide${idx + 1}.xml`, makeXmlSlide(slide));\n                    zip.file(`ppt/slides/_rels/slide${idx + 1}.xml.rels`, makeXmlSlideRel(this.slides, this.slideLayouts, idx + 1));\n                    // Create all slide notes related items. Notes of empty strings are created for slides which do not have notes specified, to keep track of _rels.\n                    zip.file(`ppt/notesSlides/notesSlide${idx + 1}.xml`, makeXmlNotesSlide(slide));\n                    zip.file(`ppt/notesSlides/_rels/notesSlide${idx + 1}.xml.rels`, makeXmlNotesSlideRel(idx + 1));\n                });\n                zip.file('ppt/slideMasters/slideMaster1.xml', makeXmlMaster(this.masterSlide, this.slideLayouts));\n                zip.file('ppt/slideMasters/_rels/slideMaster1.xml.rels', makeXmlMasterRel(this.masterSlide, this.slideLayouts));\n                zip.file('ppt/notesMasters/notesMaster1.xml', makeXmlNotesMaster());\n                zip.file('ppt/notesMasters/_rels/notesMaster1.xml.rels', makeXmlNotesMasterRel());\n                // D: Create all Rels (images, media, chart data)\n                this.slideLayouts.forEach(layout => {\n                    this.createChartMediaRels(layout, zip, arrChartPromises);\n                });\n                this.slides.forEach(slide => {\n                    this.createChartMediaRels(slide, zip, arrChartPromises);\n                });\n                this.createChartMediaRels(this.masterSlide, zip, arrChartPromises);\n                // E: Wait for Promises (if any) then generate the PPTX file\n                return yield Promise.all(arrChartPromises).then(() => __awaiter(this, void 0, void 0, function* () {\n                    if (props.outputType === 'STREAM') {\n                        // A: stream file\n                        return yield zip.generateAsync({ type: 'nodebuffer', compression: props.compression ? 'DEFLATE' : 'STORE' });\n                    }\n                    else if (props.outputType) {\n                        // B: Node [fs]: Output type user option or default\n                        return yield zip.generateAsync({ type: props.outputType });\n                    }\n                    else {\n                        // C: Browser: Output blob as app/ms-pptx\n                        return yield zip.generateAsync({ type: 'blob', compression: props.compression ? 'DEFLATE' : 'STORE' });\n                    }\n                }));\n            }));\n        });\n        const layout4x3 = { name: 'screen4x3', width: 9144000, height: 6858000 };\n        const layout16x9 = { name: 'screen16x9', width: 9144000, height: 5143500 };\n        const layout16x10 = { name: 'screen16x10', width: 9144000, height: 5715000 };\n        const layoutWide = { name: 'custom', width: 12192000, height: 6858000 };\n        // Set available layouts\n        this.LAYOUTS = {\n            LAYOUT_4x3: layout4x3,\n            LAYOUT_16x9: layout16x9,\n            LAYOUT_16x10: layout16x10,\n            LAYOUT_WIDE: layoutWide,\n        };\n        // Core\n        this._author = 'PptxGenJS';\n        this._company = 'PptxGenJS';\n        this._revision = '1'; // Note: Must be a whole number\n        this._subject = 'PptxGenJS Presentation';\n        this._title = 'PptxGenJS Presentation';\n        // PptxGenJS props\n        this._presLayout = {\n            name: this.LAYOUTS[DEF_PRES_LAYOUT].name,\n            _sizeW: this.LAYOUTS[DEF_PRES_LAYOUT].width,\n            _sizeH: this.LAYOUTS[DEF_PRES_LAYOUT].height,\n            width: this.LAYOUTS[DEF_PRES_LAYOUT].width,\n            height: this.LAYOUTS[DEF_PRES_LAYOUT].height,\n        };\n        this._rtlMode = false;\n        //\n        this._slideLayouts = [\n            {\n                _margin: DEF_SLIDE_MARGIN_IN,\n                _name: DEF_PRES_LAYOUT_NAME,\n                _presLayout: this._presLayout,\n                _rels: [],\n                _relsChart: [],\n                _relsMedia: [],\n                _slide: null,\n                _slideNum: 1000,\n                _slideNumberProps: null,\n                _slideObjects: [],\n            },\n        ];\n        this._slides = [];\n        this._sections = [];\n        this._masterSlide = {\n            addChart: null,\n            addImage: null,\n            addMedia: null,\n            addNotes: null,\n            addShape: null,\n            addTable: null,\n            addText: null,\n            //\n            _name: null,\n            _presLayout: this._presLayout,\n            _rId: null,\n            _rels: [],\n            _relsChart: [],\n            _relsMedia: [],\n            _slideId: null,\n            _slideLayout: null,\n            _slideNum: null,\n            _slideNumberProps: null,\n            _slideObjects: [],\n        };\n    }\n    // EXPORT METHODS\n    /**\n     * Export the current Presentation to stream\n     * @param {WriteBaseProps} props - output properties\n     * @returns {Promise<string | ArrayBuffer | Blob | Buffer | Uint8Array>} file stream\n     */\n    stream(props) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.exportPresentation({\n                compression: props === null || props === void 0 ? void 0 : props.compression,\n                outputType: 'STREAM',\n            });\n        });\n    }\n    /**\n     * Export the current Presentation as JSZip content with the selected type\n     * @param {WriteProps} props output properties\n     * @returns {Promise<string | ArrayBuffer | Blob | Buffer | Uint8Array>} file content in selected type\n     */\n    write(props) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // DEPRECATED: @deprecated v3.5.0 - outputType - [[remove in v4.0.0]]\n            const propsOutpType = typeof props === 'object' && (props === null || props === void 0 ? void 0 : props.outputType) ? props.outputType : props ? props : null;\n            const propsCompress = typeof props === 'object' && (props === null || props === void 0 ? void 0 : props.compression) ? props.compression : false;\n            return yield this.exportPresentation({\n                compression: propsCompress,\n                outputType: propsOutpType,\n            });\n        });\n    }\n    /**\n     * Export the current Presentation.\n     * Write the generated presentation to disk (Node) or trigger a download (browser).\n     * @param {WriteFileProps} props - output file properties\n     * @returns {Promise<string>} the presentation name\n     */\n    writeFile(props) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            // STEP 1: Figure out where we are running\n            const isNode = typeof process !== 'undefined' && !!((_a = process.versions) === null || _a === void 0 ? void 0 : _a.node) && ((_b = process.release) === null || _b === void 0 ? void 0 : _b.name) === 'node';\n            // STEP 2: Normalise the user arguments\n            if (typeof props === 'string') {\n                // DEPRECATED: @deprecated v3.5.0 - fileName - [[remove in v4.0.0]]\n                console.warn('[WARNING] writeFile(string) is deprecated - pass { fileName } instead.');\n                props = { fileName: props };\n            }\n            const { fileName: rawName = 'Presentation.pptx', compression = false } = props;\n            const fileName = rawName.toLowerCase().endsWith('.pptx') ? rawName : `${rawName}.pptx`;\n            // STEP 3: Get the binary/Blob from exportPresentation()\n            const outputType = isNode ? 'nodebuffer' : null;\n            const data = yield this.exportPresentation({ compression, outputType });\n            // STEP 4: Write the file out\n            if (isNode) {\n                // Dynamically import to avoid bundling fs in the browser build\n                const { promises: fs } = yield Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! node:fs */ \"node:fs\", 23));\n                const { writeFile } = fs;\n                yield writeFile(fileName, data);\n                return fileName;\n            }\n            // Browser branch - push a download\n            yield this.writeFileToBrowser(fileName, data);\n            return fileName;\n        });\n    }\n    // PRESENTATION METHODS\n    /**\n     * Add a new Section to Presentation\n     * @param {ISectionProps} section - section properties\n     * @example pptx.addSection({ title:'Charts' });\n     */\n    addSection(section) {\n        if (!section)\n            console.warn('addSection requires an argument');\n        else if (!section.title)\n            console.warn('addSection requires a title');\n        const newSection = {\n            _type: 'user',\n            _slides: [],\n            title: section.title,\n        };\n        if (section.order)\n            this.sections.splice(section.order, 0, newSection);\n        else\n            this._sections.push(newSection);\n    }\n    /**\n     * Add a new Slide to Presentation\n     * @param {AddSlideProps} options - slide options\n     * @returns {PresSlide} the new Slide\n     */\n    addSlide(options) {\n        // TODO: DEPRECATED: arg0 string \"masterSlideName\" dep as of 3.2.0\n        const masterSlideName = typeof options === 'string' ? options : (options === null || options === void 0 ? void 0 : options.masterName) ? options.masterName : '';\n        let slideLayout = {\n            _name: this.LAYOUTS[DEF_PRES_LAYOUT].name,\n            _presLayout: this.presLayout,\n            _rels: [],\n            _relsChart: [],\n            _relsMedia: [],\n            _slideNum: this.slides.length + 1,\n        };\n        if (masterSlideName) {\n            const tmpLayout = this.slideLayouts.filter(layout => layout._name === masterSlideName)[0];\n            if (tmpLayout)\n                slideLayout = tmpLayout;\n        }\n        const newSlide = new Slide({\n            addSlide: this.addNewSlide,\n            getSlide: this.getSlide,\n            presLayout: this.presLayout,\n            setSlideNum: this.setSlideNumber,\n            slideId: this.slides.length + 256,\n            slideRId: this.slides.length + 2,\n            slideNumber: this.slides.length + 1,\n            slideLayout,\n        });\n        // A: Add slide to pres\n        this._slides.push(newSlide);\n        // B: Sections\n        // B-1: Add slide to section (if any provided)\n        // B-2: Handle slides without a section when sections are already is use (\"loose\" slides arent allowed, they all need a section)\n        if (options === null || options === void 0 ? void 0 : options.sectionTitle) {\n            const sect = this.sections.filter(section => section.title === options.sectionTitle)[0];\n            if (!sect)\n                console.warn(`addSlide: unable to find section with title: \"${options.sectionTitle}\"`);\n            else\n                sect._slides.push(newSlide);\n        }\n        else if (this.sections && this.sections.length > 0 && (!(options === null || options === void 0 ? void 0 : options.sectionTitle))) {\n            const lastSect = this._sections[this.sections.length - 1];\n            // CASE 1: The latest section is a default type - just add this one\n            if (lastSect._type === 'default')\n                lastSect._slides.push(newSlide);\n            // CASE 2: There latest section is NOT a default type - create the defualt, add this slide\n            else {\n                this._sections.push({\n                    title: `Default-${this.sections.filter(sect => sect._type === 'default').length + 1}`,\n                    _type: 'default',\n                    _slides: [newSlide],\n                });\n            }\n        }\n        return newSlide;\n    }\n    /**\n     * Create a custom Slide Layout in any size\n     * @param {PresLayout} layout - layout properties\n     * @example pptx.defineLayout({ name:'A3', width:16.5, height:11.7 });\n     */\n    defineLayout(layout) {\n        // @see https://support.office.com/en-us/article/Change-the-size-of-your-slides-040a811c-be43-40b9-8d04-0de5ed79987e\n        if (!layout)\n            console.warn('defineLayout requires `{name, width, height}`');\n        else if (!layout.name)\n            console.warn('defineLayout requires `name`');\n        else if (!layout.width)\n            console.warn('defineLayout requires `width`');\n        else if (!layout.height)\n            console.warn('defineLayout requires `height`');\n        else if (typeof layout.height !== 'number')\n            console.warn('defineLayout `height` should be a number (inches)');\n        else if (typeof layout.width !== 'number')\n            console.warn('defineLayout `width` should be a number (inches)');\n        this.LAYOUTS[layout.name] = {\n            name: layout.name,\n            _sizeW: Math.round(Number(layout.width) * EMU),\n            _sizeH: Math.round(Number(layout.height) * EMU),\n            width: Math.round(Number(layout.width) * EMU),\n            height: Math.round(Number(layout.height) * EMU),\n        };\n    }\n    /**\n     * Create a new slide master [layout] for the Presentation\n     * @param {SlideMasterProps} props - layout properties\n     */\n    defineSlideMaster(props) {\n        // (ISSUE#406;PULL#1176) deep clone the props object to avoid mutating the original object\n        const propsClone = JSON.parse(JSON.stringify(props));\n        if (!propsClone.title)\n            throw new Error('defineSlideMaster() object argument requires a `title` value. (https://gitbrent.github.io/PptxGenJS/docs/masters.html)');\n        const newLayout = {\n            _margin: propsClone.margin || DEF_SLIDE_MARGIN_IN,\n            _name: propsClone.title,\n            _presLayout: this.presLayout,\n            _rels: [],\n            _relsChart: [],\n            _relsMedia: [],\n            _slide: null,\n            _slideNum: 1000 + this.slideLayouts.length + 1,\n            _slideNumberProps: propsClone.slideNumber || null,\n            _slideObjects: [],\n            background: propsClone.background || null,\n            bkgd: propsClone.bkgd || null,\n        };\n        // STEP 1: Create the Slide Master/Layout\n        createSlideMaster(propsClone, newLayout);\n        // STEP 2: Add it to layout defs\n        this.slideLayouts.push(newLayout);\n        // STEP 3: Add background (image data/path must be captured before `exportPresentation()` is called)\n        if (propsClone.background || propsClone.bkgd)\n            addBackgroundDefinition(propsClone.background, newLayout);\n        // STEP 4: Add slideNumber to master slide (if any)\n        if (newLayout._slideNumberProps && !this.masterSlide._slideNumberProps)\n            this.masterSlide._slideNumberProps = newLayout._slideNumberProps;\n    }\n    // HTML-TO-SLIDES METHODS\n    /**\n     * Reproduces an HTML table as a PowerPoint table - including column widths, style, etc. - creates 1 or more slides as needed\n     * @param {string} eleId - table HTML element ID\n     * @param {TableToSlidesProps} options - generation options\n     */\n    tableToSlides(eleId, options = {}) {\n        // @note `verbose` option is undocumented; used for verbose output of layout process\n        genTableToSlides(this, eleId, options, (options === null || options === void 0 ? void 0 : options.masterSlideName) ? this.slideLayouts.filter(layout => layout._name === options.masterSlideName)[0] : null);\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcHB0eGdlbmpzL2Rpc3QvcHB0eGdlbi5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUMwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQjtBQUNBLHNDQUFzQyxFQUFFO0FBQ3hDLDZCQUE2QjtBQUM3QjtBQUNBLDBCQUEwQjtBQUMxQixtREFBbUQ7QUFDbkQsMkJBQTJCO0FBQzNCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0Isa0RBQWtEO0FBQ2xELDBCQUEwQjtBQUMxQix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQyxzQkFBc0IscUNBQXFDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QyxtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEUsMENBQTBDO0FBQzFDO0FBQ0EsMENBQTBDO0FBQzFDLDhDQUE4QztBQUM5QywwQ0FBMEM7QUFDMUM7QUFDQSx1RkFBdUYsY0FBYztBQUNyRztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsTUFBTTtBQUN6QixvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixtRkFBbUY7QUFDcEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDLG9CQUFvQiw0REFBNEQ7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOENBQUs7QUFDakM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxSEFBcUg7QUFDckg7QUFDQSxxRkFBcUY7QUFDckYsa0hBQWtIO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsUUFBUTtBQUNwRSxrRUFBa0UsUUFBUTtBQUMxRSxpQkFBaUI7QUFDakI7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RCxzREFBc0QsUUFBUTtBQUM5RDtBQUNBLDBEQUEwRCxRQUFRO0FBQ2xFLGdFQUFnRSxRQUFRO0FBQ3hFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsMEVBQTBFO0FBQ25JO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCx3QkFBd0I7QUFDakY7QUFDQTtBQUNBO0FBQ0EseURBQXlELG9FQUFvRTtBQUM3SDtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNULDRCQUE0QjtBQUM1Qiw2QkFBNkI7QUFDN0IsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixpQkFBaUIsNERBQTREO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQiw0REFBNEQ7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLFdBQVc7QUFDNUYsMEJBQTBCO0FBQzFCO0FBQ0Esb0JBQW9CLCtEQUErRDtBQUNuRixvRkFBb0YsUUFBUTtBQUM1RjtBQUNBO0FBQ0EseURBQXlELHlCQUF5QjtBQUNsRjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZSxRQUFRLG9IQUFpQjtBQUNoRSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsa0NBQWtDLGdCQUFnQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLHFCQUFxQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtFQUFrRTtBQUN4RztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixvQ0FBb0Msb0NBQW9DO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG9CQUFvQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLG9CQUFvQjtBQUNuQztBQUNBLHFDQUFxQztBQUNyQyxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBOztBQUVnQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NuYXAyc2xpZGVzLXByby8uL25vZGVfbW9kdWxlcy9wcHR4Z2VuanMvZGlzdC9wcHR4Z2VuLmVzLmpzPzc1ZTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyogUHB0eEdlbkpTIDQuMC4xIEAgMjAyNS0wNi0yNVQyMzozNTozNS4wOThaICovXG5pbXBvcnQgSlNaaXAgZnJvbSAnanN6aXAnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sLCBJdGVyYXRvciAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG4vKipcbiAqIFBwdHhHZW5KUyBFbnVtc1xuICogTk9URTogYGVudW1gIHdvbnQgd29yayBmb3Igb2JqZWN0cywgc28gdXNlIGBPYmplY3QuZnJlZXplYFxuICovXG4vLyBDT05TVFxuY29uc3QgRU1VID0gOTE0NDAwOyAvLyBPbmUgKDEpIGluY2ggKE9mZmljZVhNTCBtZWFzdXJlcyBpbiBFTVUgKEVuZ2xpc2ggTWV0cmljIFVuaXRzKSlcbmNvbnN0IE9ORVBUID0gMTI3MDA7IC8vIE9uZSAoMSkgcG9pbnQgKHB0KVxuY29uc3QgQ1JMRiA9ICdcXHJcXG4nOyAvLyBBS0E6IENocigxMykgJiBDaHIoMTApXG5jb25zdCBMQVlPVVRfSURYX1NFUklFU19CQVNFID0gMjE0NzQ4MzY0OTtcbmNvbnN0IFJFR0VYX0hFWF9DT0xPUiA9IC9eWzAtOWEtZkEtRl17Nn0kLztcbmNvbnN0IExJTkVIX01PRElGSUVSID0gMS42NzsgLy8gQUtBOiBHb2xkZW4gUmF0aW8gVHlwb2dyYXBoeVxuY29uc3QgREVGX0JVTExFVF9NQVJHSU4gPSAyNztcbmNvbnN0IERFRl9DRUxMX0JPUkRFUiA9IHsgdHlwZTogJ3NvbGlkJywgY29sb3I6ICc2NjY2NjYnLCBwdDogMSB9O1xuY29uc3QgREVGX0NFTExfTUFSR0lOX0lOID0gWzAuMDUsIDAuMSwgMC4wNSwgMC4xXTsgLy8gXCJOb3JtYWxcIiBtYXJnaW5zIGluIFBQVC0yMDIxIChcIk5hcnJvd1wiIGlzIGAwLjA1YCBmb3IgYWxsIDQpXG5jb25zdCBERUZfQ0hBUlRfQk9SREVSID0geyBjb2xvcjogJzM2MzYzNicsIHB0OiAxIH07XG5jb25zdCBERUZfQ0hBUlRfR1JJRExJTkUgPSB7IGNvbG9yOiAnODg4ODg4Jywgc3R5bGU6ICdzb2xpZCcsIHNpemU6IDEsIGNhcDogJ2ZsYXQnIH07XG5jb25zdCBERUZfRk9OVF9DT0xPUiA9ICcwMDAwMDAnO1xuY29uc3QgREVGX0ZPTlRfU0laRSA9IDEyO1xuY29uc3QgREVGX0ZPTlRfVElUTEVfU0laRSA9IDE4O1xuY29uc3QgREVGX1BSRVNfTEFZT1VUID0gJ0xBWU9VVF8xNng5JztcbmNvbnN0IERFRl9QUkVTX0xBWU9VVF9OQU1FID0gJ0RFRkFVTFQnO1xuY29uc3QgREVGX1NIQVBFX0xJTkVfQ09MT1IgPSAnMzMzMzMzJztcbmNvbnN0IERFRl9TSEFQRV9TSEFET1cgPSB7IHR5cGU6ICdvdXRlcicsIGJsdXI6IDMsIG9mZnNldDogMjMwMDAgLyAxMjcwMCwgYW5nbGU6IDkwLCBjb2xvcjogJzAwMDAwMCcsIG9wYWNpdHk6IDAuMzUsIHJvdGF0ZVdpdGhTaGFwZTogdHJ1ZSB9O1xuY29uc3QgREVGX1NMSURFX01BUkdJTl9JTiA9IFswLjUsIDAuNSwgMC41LCAwLjVdOyAvLyBUUkJMLXN0eWxlXG5jb25zdCBERUZfVEVYVF9TSEFET1cgPSB7IGNvbG9yOiAnMDAwMDAwJ307XG5jb25zdCBERUZfVEVYVF9HTE9XID0geyBzaXplOiA4LCBjb2xvcjogJ0ZGRkZGRicsIG9wYWNpdHk6IDAuNzUgfTtcbmNvbnN0IEFYSVNfSURfVkFMVUVfUFJJTUFSWSA9ICcyMDk0NzM0NTUyJztcbmNvbnN0IEFYSVNfSURfVkFMVUVfU0VDT05EQVJZID0gJzIwOTQ3MzQ1NTMnO1xuY29uc3QgQVhJU19JRF9DQVRFR09SWV9QUklNQVJZID0gJzIwOTQ3MzQ1NTQnO1xuY29uc3QgQVhJU19JRF9DQVRFR09SWV9TRUNPTkRBUlkgPSAnMjA5NDczNDU1NSc7XG5jb25zdCBBWElTX0lEX1NFUklFU19QUklNQVJZID0gJzIwOTQ3MzQ1NTYnO1xuY29uc3QgTEVUVEVSUyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWicuc3BsaXQoJycpO1xuY29uc3QgQkFSQ0hBUlRfQ09MT1JTID0gW1xuICAgICdDMDUwNEQnLFxuICAgICc0RjgxQkQnLFxuICAgICc5QkJCNTknLFxuICAgICc4MDY0QTInLFxuICAgICc0QkFDQzYnLFxuICAgICdGNzk2NDYnLFxuICAgICc2MjhGQzYnLFxuICAgICdDODYzNjAnLFxuICAgICdDMDUwNEQnLFxuICAgICc0RjgxQkQnLFxuICAgICc5QkJCNTknLFxuICAgICc4MDY0QTInLFxuICAgICc0QkFDQzYnLFxuICAgICdGNzk2NDYnLFxuICAgICc2MjhGQzYnLFxuICAgICdDODYzNjAnXG5dO1xuY29uc3QgUElFQ0hBUlRfQ09MT1JTID0gW1xuICAgICc1REE1REEnLFxuICAgICdGQUE0M0EnLFxuICAgICc2MEJENjgnLFxuICAgICdGMTdDQjAnLFxuICAgICdCMjkxMkYnLFxuICAgICdCMjc2QjInLFxuICAgICdERUNGM0YnLFxuICAgICdGMTU4NTQnLFxuICAgICdBN0E3QTcnLFxuICAgICc1REE1REEnLFxuICAgICdGQUE0M0EnLFxuICAgICc2MEJENjgnLFxuICAgICdGMTdDQjAnLFxuICAgICdCMjkxMkYnLFxuICAgICdCMjc2QjInLFxuICAgICdERUNGM0YnLFxuICAgICdGMTU4NTQnLFxuICAgICdBN0E3QTcnLFxuXTtcbnZhciBURVhUX0hBTElHTjtcbihmdW5jdGlvbiAoVEVYVF9IQUxJR04pIHtcbiAgICBURVhUX0hBTElHTltcImxlZnRcIl0gPSBcImxlZnRcIjtcbiAgICBURVhUX0hBTElHTltcImNlbnRlclwiXSA9IFwiY2VudGVyXCI7XG4gICAgVEVYVF9IQUxJR05bXCJyaWdodFwiXSA9IFwicmlnaHRcIjtcbiAgICBURVhUX0hBTElHTltcImp1c3RpZnlcIl0gPSBcImp1c3RpZnlcIjtcbn0pKFRFWFRfSEFMSUdOIHx8IChURVhUX0hBTElHTiA9IHt9KSk7XG52YXIgVEVYVF9WQUxJR047XG4oZnVuY3Rpb24gKFRFWFRfVkFMSUdOKSB7XG4gICAgVEVYVF9WQUxJR05bXCJiXCJdID0gXCJiXCI7XG4gICAgVEVYVF9WQUxJR05bXCJjdHJcIl0gPSBcImN0clwiO1xuICAgIFRFWFRfVkFMSUdOW1widFwiXSA9IFwidFwiO1xufSkoVEVYVF9WQUxJR04gfHwgKFRFWFRfVkFMSUdOID0ge30pKTtcbmNvbnN0IFNMRE5VTUZMRElEID0gJ3tGNzAyMTQ1MS0xMzg3LTRDQTYtODE2Ri0zODc5Rjk3QjVDQkN9Jztcbi8vIEVOVU1cbi8vIFRPRE86IDMuNSBvciB2NC4wOiByYXRpb25hbGl6ZSB0cy1kZWYgZXhwb3J0ZWQgZW51bSBuYW1lcy9jYXNlIVxuLy8gTk9URTogRmlyc3QgdHNkZWYgZW51bSBuYW1lZCBjb3JyZWN0bHkgKHNoYXBlcyAtPiAnU2hhcGUnLCBjb2xvcnMgLT4gJ0NvbG9yJyksIGV0Yy5cbnZhciBPdXRwdXRUeXBlO1xuKGZ1bmN0aW9uIChPdXRwdXRUeXBlKSB7XG4gICAgT3V0cHV0VHlwZVtcImFycmF5YnVmZmVyXCJdID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgIE91dHB1dFR5cGVbXCJiYXNlNjRcIl0gPSBcImJhc2U2NFwiO1xuICAgIE91dHB1dFR5cGVbXCJiaW5hcnlzdHJpbmdcIl0gPSBcImJpbmFyeXN0cmluZ1wiO1xuICAgIE91dHB1dFR5cGVbXCJibG9iXCJdID0gXCJibG9iXCI7XG4gICAgT3V0cHV0VHlwZVtcIm5vZGVidWZmZXJcIl0gPSBcIm5vZGVidWZmZXJcIjtcbiAgICBPdXRwdXRUeXBlW1widWludDhhcnJheVwiXSA9IFwidWludDhhcnJheVwiO1xufSkoT3V0cHV0VHlwZSB8fCAoT3V0cHV0VHlwZSA9IHt9KSk7XG52YXIgQ2hhcnRUeXBlO1xuKGZ1bmN0aW9uIChDaGFydFR5cGUpIHtcbiAgICBDaGFydFR5cGVbXCJhcmVhXCJdID0gXCJhcmVhXCI7XG4gICAgQ2hhcnRUeXBlW1wiYmFyXCJdID0gXCJiYXJcIjtcbiAgICBDaGFydFR5cGVbXCJiYXIzZFwiXSA9IFwiYmFyM0RcIjtcbiAgICBDaGFydFR5cGVbXCJidWJibGVcIl0gPSBcImJ1YmJsZVwiO1xuICAgIENoYXJ0VHlwZVtcImJ1YmJsZTNkXCJdID0gXCJidWJibGUzRFwiO1xuICAgIENoYXJ0VHlwZVtcImRvdWdobnV0XCJdID0gXCJkb3VnaG51dFwiO1xuICAgIENoYXJ0VHlwZVtcImxpbmVcIl0gPSBcImxpbmVcIjtcbiAgICBDaGFydFR5cGVbXCJwaWVcIl0gPSBcInBpZVwiO1xuICAgIENoYXJ0VHlwZVtcInJhZGFyXCJdID0gXCJyYWRhclwiO1xuICAgIENoYXJ0VHlwZVtcInNjYXR0ZXJcIl0gPSBcInNjYXR0ZXJcIjtcbn0pKENoYXJ0VHlwZSB8fCAoQ2hhcnRUeXBlID0ge30pKTtcbnZhciBTaGFwZVR5cGU7XG4oZnVuY3Rpb24gKFNoYXBlVHlwZSkge1xuICAgIFNoYXBlVHlwZVtcImFjY2VudEJvcmRlckNhbGxvdXQxXCJdID0gXCJhY2NlbnRCb3JkZXJDYWxsb3V0MVwiO1xuICAgIFNoYXBlVHlwZVtcImFjY2VudEJvcmRlckNhbGxvdXQyXCJdID0gXCJhY2NlbnRCb3JkZXJDYWxsb3V0MlwiO1xuICAgIFNoYXBlVHlwZVtcImFjY2VudEJvcmRlckNhbGxvdXQzXCJdID0gXCJhY2NlbnRCb3JkZXJDYWxsb3V0M1wiO1xuICAgIFNoYXBlVHlwZVtcImFjY2VudENhbGxvdXQxXCJdID0gXCJhY2NlbnRDYWxsb3V0MVwiO1xuICAgIFNoYXBlVHlwZVtcImFjY2VudENhbGxvdXQyXCJdID0gXCJhY2NlbnRDYWxsb3V0MlwiO1xuICAgIFNoYXBlVHlwZVtcImFjY2VudENhbGxvdXQzXCJdID0gXCJhY2NlbnRDYWxsb3V0M1wiO1xuICAgIFNoYXBlVHlwZVtcImFjdGlvbkJ1dHRvbkJhY2tQcmV2aW91c1wiXSA9IFwiYWN0aW9uQnV0dG9uQmFja1ByZXZpb3VzXCI7XG4gICAgU2hhcGVUeXBlW1wiYWN0aW9uQnV0dG9uQmVnaW5uaW5nXCJdID0gXCJhY3Rpb25CdXR0b25CZWdpbm5pbmdcIjtcbiAgICBTaGFwZVR5cGVbXCJhY3Rpb25CdXR0b25CbGFua1wiXSA9IFwiYWN0aW9uQnV0dG9uQmxhbmtcIjtcbiAgICBTaGFwZVR5cGVbXCJhY3Rpb25CdXR0b25Eb2N1bWVudFwiXSA9IFwiYWN0aW9uQnV0dG9uRG9jdW1lbnRcIjtcbiAgICBTaGFwZVR5cGVbXCJhY3Rpb25CdXR0b25FbmRcIl0gPSBcImFjdGlvbkJ1dHRvbkVuZFwiO1xuICAgIFNoYXBlVHlwZVtcImFjdGlvbkJ1dHRvbkZvcndhcmROZXh0XCJdID0gXCJhY3Rpb25CdXR0b25Gb3J3YXJkTmV4dFwiO1xuICAgIFNoYXBlVHlwZVtcImFjdGlvbkJ1dHRvbkhlbHBcIl0gPSBcImFjdGlvbkJ1dHRvbkhlbHBcIjtcbiAgICBTaGFwZVR5cGVbXCJhY3Rpb25CdXR0b25Ib21lXCJdID0gXCJhY3Rpb25CdXR0b25Ib21lXCI7XG4gICAgU2hhcGVUeXBlW1wiYWN0aW9uQnV0dG9uSW5mb3JtYXRpb25cIl0gPSBcImFjdGlvbkJ1dHRvbkluZm9ybWF0aW9uXCI7XG4gICAgU2hhcGVUeXBlW1wiYWN0aW9uQnV0dG9uTW92aWVcIl0gPSBcImFjdGlvbkJ1dHRvbk1vdmllXCI7XG4gICAgU2hhcGVUeXBlW1wiYWN0aW9uQnV0dG9uUmV0dXJuXCJdID0gXCJhY3Rpb25CdXR0b25SZXR1cm5cIjtcbiAgICBTaGFwZVR5cGVbXCJhY3Rpb25CdXR0b25Tb3VuZFwiXSA9IFwiYWN0aW9uQnV0dG9uU291bmRcIjtcbiAgICBTaGFwZVR5cGVbXCJhcmNcIl0gPSBcImFyY1wiO1xuICAgIFNoYXBlVHlwZVtcImJlbnRBcnJvd1wiXSA9IFwiYmVudEFycm93XCI7XG4gICAgU2hhcGVUeXBlW1wiYmVudFVwQXJyb3dcIl0gPSBcImJlbnRVcEFycm93XCI7XG4gICAgU2hhcGVUeXBlW1wiYmV2ZWxcIl0gPSBcImJldmVsXCI7XG4gICAgU2hhcGVUeXBlW1wiYmxvY2tBcmNcIl0gPSBcImJsb2NrQXJjXCI7XG4gICAgU2hhcGVUeXBlW1wiYm9yZGVyQ2FsbG91dDFcIl0gPSBcImJvcmRlckNhbGxvdXQxXCI7XG4gICAgU2hhcGVUeXBlW1wiYm9yZGVyQ2FsbG91dDJcIl0gPSBcImJvcmRlckNhbGxvdXQyXCI7XG4gICAgU2hhcGVUeXBlW1wiYm9yZGVyQ2FsbG91dDNcIl0gPSBcImJvcmRlckNhbGxvdXQzXCI7XG4gICAgU2hhcGVUeXBlW1wiYnJhY2VQYWlyXCJdID0gXCJicmFjZVBhaXJcIjtcbiAgICBTaGFwZVR5cGVbXCJicmFja2V0UGFpclwiXSA9IFwiYnJhY2tldFBhaXJcIjtcbiAgICBTaGFwZVR5cGVbXCJjYWxsb3V0MVwiXSA9IFwiY2FsbG91dDFcIjtcbiAgICBTaGFwZVR5cGVbXCJjYWxsb3V0MlwiXSA9IFwiY2FsbG91dDJcIjtcbiAgICBTaGFwZVR5cGVbXCJjYWxsb3V0M1wiXSA9IFwiY2FsbG91dDNcIjtcbiAgICBTaGFwZVR5cGVbXCJjYW5cIl0gPSBcImNhblwiO1xuICAgIFNoYXBlVHlwZVtcImNoYXJ0UGx1c1wiXSA9IFwiY2hhcnRQbHVzXCI7XG4gICAgU2hhcGVUeXBlW1wiY2hhcnRTdGFyXCJdID0gXCJjaGFydFN0YXJcIjtcbiAgICBTaGFwZVR5cGVbXCJjaGFydFhcIl0gPSBcImNoYXJ0WFwiO1xuICAgIFNoYXBlVHlwZVtcImNoZXZyb25cIl0gPSBcImNoZXZyb25cIjtcbiAgICBTaGFwZVR5cGVbXCJjaG9yZFwiXSA9IFwiY2hvcmRcIjtcbiAgICBTaGFwZVR5cGVbXCJjaXJjdWxhckFycm93XCJdID0gXCJjaXJjdWxhckFycm93XCI7XG4gICAgU2hhcGVUeXBlW1wiY2xvdWRcIl0gPSBcImNsb3VkXCI7XG4gICAgU2hhcGVUeXBlW1wiY2xvdWRDYWxsb3V0XCJdID0gXCJjbG91ZENhbGxvdXRcIjtcbiAgICBTaGFwZVR5cGVbXCJjb3JuZXJcIl0gPSBcImNvcm5lclwiO1xuICAgIFNoYXBlVHlwZVtcImNvcm5lclRhYnNcIl0gPSBcImNvcm5lclRhYnNcIjtcbiAgICBTaGFwZVR5cGVbXCJjdWJlXCJdID0gXCJjdWJlXCI7XG4gICAgU2hhcGVUeXBlW1wiY3VydmVkRG93bkFycm93XCJdID0gXCJjdXJ2ZWREb3duQXJyb3dcIjtcbiAgICBTaGFwZVR5cGVbXCJjdXJ2ZWRMZWZ0QXJyb3dcIl0gPSBcImN1cnZlZExlZnRBcnJvd1wiO1xuICAgIFNoYXBlVHlwZVtcImN1cnZlZFJpZ2h0QXJyb3dcIl0gPSBcImN1cnZlZFJpZ2h0QXJyb3dcIjtcbiAgICBTaGFwZVR5cGVbXCJjdXJ2ZWRVcEFycm93XCJdID0gXCJjdXJ2ZWRVcEFycm93XCI7XG4gICAgU2hhcGVUeXBlW1wiY3VzdEdlb21cIl0gPSBcImN1c3RHZW9tXCI7XG4gICAgU2hhcGVUeXBlW1wiZGVjYWdvblwiXSA9IFwiZGVjYWdvblwiO1xuICAgIFNoYXBlVHlwZVtcImRpYWdTdHJpcGVcIl0gPSBcImRpYWdTdHJpcGVcIjtcbiAgICBTaGFwZVR5cGVbXCJkaWFtb25kXCJdID0gXCJkaWFtb25kXCI7XG4gICAgU2hhcGVUeXBlW1wiZG9kZWNhZ29uXCJdID0gXCJkb2RlY2Fnb25cIjtcbiAgICBTaGFwZVR5cGVbXCJkb251dFwiXSA9IFwiZG9udXRcIjtcbiAgICBTaGFwZVR5cGVbXCJkb3VibGVXYXZlXCJdID0gXCJkb3VibGVXYXZlXCI7XG4gICAgU2hhcGVUeXBlW1wiZG93bkFycm93XCJdID0gXCJkb3duQXJyb3dcIjtcbiAgICBTaGFwZVR5cGVbXCJkb3duQXJyb3dDYWxsb3V0XCJdID0gXCJkb3duQXJyb3dDYWxsb3V0XCI7XG4gICAgU2hhcGVUeXBlW1wiZWxsaXBzZVwiXSA9IFwiZWxsaXBzZVwiO1xuICAgIFNoYXBlVHlwZVtcImVsbGlwc2VSaWJib25cIl0gPSBcImVsbGlwc2VSaWJib25cIjtcbiAgICBTaGFwZVR5cGVbXCJlbGxpcHNlUmliYm9uMlwiXSA9IFwiZWxsaXBzZVJpYmJvbjJcIjtcbiAgICBTaGFwZVR5cGVbXCJmbG93Q2hhcnRBbHRlcm5hdGVQcm9jZXNzXCJdID0gXCJmbG93Q2hhcnRBbHRlcm5hdGVQcm9jZXNzXCI7XG4gICAgU2hhcGVUeXBlW1wiZmxvd0NoYXJ0Q29sbGF0ZVwiXSA9IFwiZmxvd0NoYXJ0Q29sbGF0ZVwiO1xuICAgIFNoYXBlVHlwZVtcImZsb3dDaGFydENvbm5lY3RvclwiXSA9IFwiZmxvd0NoYXJ0Q29ubmVjdG9yXCI7XG4gICAgU2hhcGVUeXBlW1wiZmxvd0NoYXJ0RGVjaXNpb25cIl0gPSBcImZsb3dDaGFydERlY2lzaW9uXCI7XG4gICAgU2hhcGVUeXBlW1wiZmxvd0NoYXJ0RGVsYXlcIl0gPSBcImZsb3dDaGFydERlbGF5XCI7XG4gICAgU2hhcGVUeXBlW1wiZmxvd0NoYXJ0RGlzcGxheVwiXSA9IFwiZmxvd0NoYXJ0RGlzcGxheVwiO1xuICAgIFNoYXBlVHlwZVtcImZsb3dDaGFydERvY3VtZW50XCJdID0gXCJmbG93Q2hhcnREb2N1bWVudFwiO1xuICAgIFNoYXBlVHlwZVtcImZsb3dDaGFydEV4dHJhY3RcIl0gPSBcImZsb3dDaGFydEV4dHJhY3RcIjtcbiAgICBTaGFwZVR5cGVbXCJmbG93Q2hhcnRJbnB1dE91dHB1dFwiXSA9IFwiZmxvd0NoYXJ0SW5wdXRPdXRwdXRcIjtcbiAgICBTaGFwZVR5cGVbXCJmbG93Q2hhcnRJbnRlcm5hbFN0b3JhZ2VcIl0gPSBcImZsb3dDaGFydEludGVybmFsU3RvcmFnZVwiO1xuICAgIFNoYXBlVHlwZVtcImZsb3dDaGFydE1hZ25ldGljRGlza1wiXSA9IFwiZmxvd0NoYXJ0TWFnbmV0aWNEaXNrXCI7XG4gICAgU2hhcGVUeXBlW1wiZmxvd0NoYXJ0TWFnbmV0aWNEcnVtXCJdID0gXCJmbG93Q2hhcnRNYWduZXRpY0RydW1cIjtcbiAgICBTaGFwZVR5cGVbXCJmbG93Q2hhcnRNYWduZXRpY1RhcGVcIl0gPSBcImZsb3dDaGFydE1hZ25ldGljVGFwZVwiO1xuICAgIFNoYXBlVHlwZVtcImZsb3dDaGFydE1hbnVhbElucHV0XCJdID0gXCJmbG93Q2hhcnRNYW51YWxJbnB1dFwiO1xuICAgIFNoYXBlVHlwZVtcImZsb3dDaGFydE1hbnVhbE9wZXJhdGlvblwiXSA9IFwiZmxvd0NoYXJ0TWFudWFsT3BlcmF0aW9uXCI7XG4gICAgU2hhcGVUeXBlW1wiZmxvd0NoYXJ0TWVyZ2VcIl0gPSBcImZsb3dDaGFydE1lcmdlXCI7XG4gICAgU2hhcGVUeXBlW1wiZmxvd0NoYXJ0TXVsdGlkb2N1bWVudFwiXSA9IFwiZmxvd0NoYXJ0TXVsdGlkb2N1bWVudFwiO1xuICAgIFNoYXBlVHlwZVtcImZsb3dDaGFydE9mZmxpbmVTdG9yYWdlXCJdID0gXCJmbG93Q2hhcnRPZmZsaW5lU3RvcmFnZVwiO1xuICAgIFNoYXBlVHlwZVtcImZsb3dDaGFydE9mZnBhZ2VDb25uZWN0b3JcIl0gPSBcImZsb3dDaGFydE9mZnBhZ2VDb25uZWN0b3JcIjtcbiAgICBTaGFwZVR5cGVbXCJmbG93Q2hhcnRPbmxpbmVTdG9yYWdlXCJdID0gXCJmbG93Q2hhcnRPbmxpbmVTdG9yYWdlXCI7XG4gICAgU2hhcGVUeXBlW1wiZmxvd0NoYXJ0T3JcIl0gPSBcImZsb3dDaGFydE9yXCI7XG4gICAgU2hhcGVUeXBlW1wiZmxvd0NoYXJ0UHJlZGVmaW5lZFByb2Nlc3NcIl0gPSBcImZsb3dDaGFydFByZWRlZmluZWRQcm9jZXNzXCI7XG4gICAgU2hhcGVUeXBlW1wiZmxvd0NoYXJ0UHJlcGFyYXRpb25cIl0gPSBcImZsb3dDaGFydFByZXBhcmF0aW9uXCI7XG4gICAgU2hhcGVUeXBlW1wiZmxvd0NoYXJ0UHJvY2Vzc1wiXSA9IFwiZmxvd0NoYXJ0UHJvY2Vzc1wiO1xuICAgIFNoYXBlVHlwZVtcImZsb3dDaGFydFB1bmNoZWRDYXJkXCJdID0gXCJmbG93Q2hhcnRQdW5jaGVkQ2FyZFwiO1xuICAgIFNoYXBlVHlwZVtcImZsb3dDaGFydFB1bmNoZWRUYXBlXCJdID0gXCJmbG93Q2hhcnRQdW5jaGVkVGFwZVwiO1xuICAgIFNoYXBlVHlwZVtcImZsb3dDaGFydFNvcnRcIl0gPSBcImZsb3dDaGFydFNvcnRcIjtcbiAgICBTaGFwZVR5cGVbXCJmbG93Q2hhcnRTdW1taW5nSnVuY3Rpb25cIl0gPSBcImZsb3dDaGFydFN1bW1pbmdKdW5jdGlvblwiO1xuICAgIFNoYXBlVHlwZVtcImZsb3dDaGFydFRlcm1pbmF0b3JcIl0gPSBcImZsb3dDaGFydFRlcm1pbmF0b3JcIjtcbiAgICBTaGFwZVR5cGVbXCJmb2xkZXJDb3JuZXJcIl0gPSBcImZvbGRlckNvcm5lclwiO1xuICAgIFNoYXBlVHlwZVtcImZyYW1lXCJdID0gXCJmcmFtZVwiO1xuICAgIFNoYXBlVHlwZVtcImZ1bm5lbFwiXSA9IFwiZnVubmVsXCI7XG4gICAgU2hhcGVUeXBlW1wiZ2VhcjZcIl0gPSBcImdlYXI2XCI7XG4gICAgU2hhcGVUeXBlW1wiZ2VhcjlcIl0gPSBcImdlYXI5XCI7XG4gICAgU2hhcGVUeXBlW1wiaGFsZkZyYW1lXCJdID0gXCJoYWxmRnJhbWVcIjtcbiAgICBTaGFwZVR5cGVbXCJoZWFydFwiXSA9IFwiaGVhcnRcIjtcbiAgICBTaGFwZVR5cGVbXCJoZXB0YWdvblwiXSA9IFwiaGVwdGFnb25cIjtcbiAgICBTaGFwZVR5cGVbXCJoZXhhZ29uXCJdID0gXCJoZXhhZ29uXCI7XG4gICAgU2hhcGVUeXBlW1wiaG9tZVBsYXRlXCJdID0gXCJob21lUGxhdGVcIjtcbiAgICBTaGFwZVR5cGVbXCJob3Jpem9udGFsU2Nyb2xsXCJdID0gXCJob3Jpem9udGFsU2Nyb2xsXCI7XG4gICAgU2hhcGVUeXBlW1wiaXJyZWd1bGFyU2VhbDFcIl0gPSBcImlycmVndWxhclNlYWwxXCI7XG4gICAgU2hhcGVUeXBlW1wiaXJyZWd1bGFyU2VhbDJcIl0gPSBcImlycmVndWxhclNlYWwyXCI7XG4gICAgU2hhcGVUeXBlW1wibGVmdEFycm93XCJdID0gXCJsZWZ0QXJyb3dcIjtcbiAgICBTaGFwZVR5cGVbXCJsZWZ0QXJyb3dDYWxsb3V0XCJdID0gXCJsZWZ0QXJyb3dDYWxsb3V0XCI7XG4gICAgU2hhcGVUeXBlW1wibGVmdEJyYWNlXCJdID0gXCJsZWZ0QnJhY2VcIjtcbiAgICBTaGFwZVR5cGVbXCJsZWZ0QnJhY2tldFwiXSA9IFwibGVmdEJyYWNrZXRcIjtcbiAgICBTaGFwZVR5cGVbXCJsZWZ0Q2lyY3VsYXJBcnJvd1wiXSA9IFwibGVmdENpcmN1bGFyQXJyb3dcIjtcbiAgICBTaGFwZVR5cGVbXCJsZWZ0UmlnaHRBcnJvd1wiXSA9IFwibGVmdFJpZ2h0QXJyb3dcIjtcbiAgICBTaGFwZVR5cGVbXCJsZWZ0UmlnaHRBcnJvd0NhbGxvdXRcIl0gPSBcImxlZnRSaWdodEFycm93Q2FsbG91dFwiO1xuICAgIFNoYXBlVHlwZVtcImxlZnRSaWdodENpcmN1bGFyQXJyb3dcIl0gPSBcImxlZnRSaWdodENpcmN1bGFyQXJyb3dcIjtcbiAgICBTaGFwZVR5cGVbXCJsZWZ0UmlnaHRSaWJib25cIl0gPSBcImxlZnRSaWdodFJpYmJvblwiO1xuICAgIFNoYXBlVHlwZVtcImxlZnRSaWdodFVwQXJyb3dcIl0gPSBcImxlZnRSaWdodFVwQXJyb3dcIjtcbiAgICBTaGFwZVR5cGVbXCJsZWZ0VXBBcnJvd1wiXSA9IFwibGVmdFVwQXJyb3dcIjtcbiAgICBTaGFwZVR5cGVbXCJsaWdodG5pbmdCb2x0XCJdID0gXCJsaWdodG5pbmdCb2x0XCI7XG4gICAgU2hhcGVUeXBlW1wibGluZVwiXSA9IFwibGluZVwiO1xuICAgIFNoYXBlVHlwZVtcImxpbmVJbnZcIl0gPSBcImxpbmVJbnZcIjtcbiAgICBTaGFwZVR5cGVbXCJtYXRoRGl2aWRlXCJdID0gXCJtYXRoRGl2aWRlXCI7XG4gICAgU2hhcGVUeXBlW1wibWF0aEVxdWFsXCJdID0gXCJtYXRoRXF1YWxcIjtcbiAgICBTaGFwZVR5cGVbXCJtYXRoTWludXNcIl0gPSBcIm1hdGhNaW51c1wiO1xuICAgIFNoYXBlVHlwZVtcIm1hdGhNdWx0aXBseVwiXSA9IFwibWF0aE11bHRpcGx5XCI7XG4gICAgU2hhcGVUeXBlW1wibWF0aE5vdEVxdWFsXCJdID0gXCJtYXRoTm90RXF1YWxcIjtcbiAgICBTaGFwZVR5cGVbXCJtYXRoUGx1c1wiXSA9IFwibWF0aFBsdXNcIjtcbiAgICBTaGFwZVR5cGVbXCJtb29uXCJdID0gXCJtb29uXCI7XG4gICAgU2hhcGVUeXBlW1wibm9TbW9raW5nXCJdID0gXCJub1Ntb2tpbmdcIjtcbiAgICBTaGFwZVR5cGVbXCJub25Jc29zY2VsZXNUcmFwZXpvaWRcIl0gPSBcIm5vbklzb3NjZWxlc1RyYXBlem9pZFwiO1xuICAgIFNoYXBlVHlwZVtcIm5vdGNoZWRSaWdodEFycm93XCJdID0gXCJub3RjaGVkUmlnaHRBcnJvd1wiO1xuICAgIFNoYXBlVHlwZVtcIm9jdGFnb25cIl0gPSBcIm9jdGFnb25cIjtcbiAgICBTaGFwZVR5cGVbXCJwYXJhbGxlbG9ncmFtXCJdID0gXCJwYXJhbGxlbG9ncmFtXCI7XG4gICAgU2hhcGVUeXBlW1wicGVudGFnb25cIl0gPSBcInBlbnRhZ29uXCI7XG4gICAgU2hhcGVUeXBlW1wicGllXCJdID0gXCJwaWVcIjtcbiAgICBTaGFwZVR5cGVbXCJwaWVXZWRnZVwiXSA9IFwicGllV2VkZ2VcIjtcbiAgICBTaGFwZVR5cGVbXCJwbGFxdWVcIl0gPSBcInBsYXF1ZVwiO1xuICAgIFNoYXBlVHlwZVtcInBsYXF1ZVRhYnNcIl0gPSBcInBsYXF1ZVRhYnNcIjtcbiAgICBTaGFwZVR5cGVbXCJwbHVzXCJdID0gXCJwbHVzXCI7XG4gICAgU2hhcGVUeXBlW1wicXVhZEFycm93XCJdID0gXCJxdWFkQXJyb3dcIjtcbiAgICBTaGFwZVR5cGVbXCJxdWFkQXJyb3dDYWxsb3V0XCJdID0gXCJxdWFkQXJyb3dDYWxsb3V0XCI7XG4gICAgU2hhcGVUeXBlW1wicmVjdFwiXSA9IFwicmVjdFwiO1xuICAgIFNoYXBlVHlwZVtcInJpYmJvblwiXSA9IFwicmliYm9uXCI7XG4gICAgU2hhcGVUeXBlW1wicmliYm9uMlwiXSA9IFwicmliYm9uMlwiO1xuICAgIFNoYXBlVHlwZVtcInJpZ2h0QXJyb3dcIl0gPSBcInJpZ2h0QXJyb3dcIjtcbiAgICBTaGFwZVR5cGVbXCJyaWdodEFycm93Q2FsbG91dFwiXSA9IFwicmlnaHRBcnJvd0NhbGxvdXRcIjtcbiAgICBTaGFwZVR5cGVbXCJyaWdodEJyYWNlXCJdID0gXCJyaWdodEJyYWNlXCI7XG4gICAgU2hhcGVUeXBlW1wicmlnaHRCcmFja2V0XCJdID0gXCJyaWdodEJyYWNrZXRcIjtcbiAgICBTaGFwZVR5cGVbXCJyb3VuZDFSZWN0XCJdID0gXCJyb3VuZDFSZWN0XCI7XG4gICAgU2hhcGVUeXBlW1wicm91bmQyRGlhZ1JlY3RcIl0gPSBcInJvdW5kMkRpYWdSZWN0XCI7XG4gICAgU2hhcGVUeXBlW1wicm91bmQyU2FtZVJlY3RcIl0gPSBcInJvdW5kMlNhbWVSZWN0XCI7XG4gICAgU2hhcGVUeXBlW1wicm91bmRSZWN0XCJdID0gXCJyb3VuZFJlY3RcIjtcbiAgICBTaGFwZVR5cGVbXCJydFRyaWFuZ2xlXCJdID0gXCJydFRyaWFuZ2xlXCI7XG4gICAgU2hhcGVUeXBlW1wic21pbGV5RmFjZVwiXSA9IFwic21pbGV5RmFjZVwiO1xuICAgIFNoYXBlVHlwZVtcInNuaXAxUmVjdFwiXSA9IFwic25pcDFSZWN0XCI7XG4gICAgU2hhcGVUeXBlW1wic25pcDJEaWFnUmVjdFwiXSA9IFwic25pcDJEaWFnUmVjdFwiO1xuICAgIFNoYXBlVHlwZVtcInNuaXAyU2FtZVJlY3RcIl0gPSBcInNuaXAyU2FtZVJlY3RcIjtcbiAgICBTaGFwZVR5cGVbXCJzbmlwUm91bmRSZWN0XCJdID0gXCJzbmlwUm91bmRSZWN0XCI7XG4gICAgU2hhcGVUeXBlW1wic3F1YXJlVGFic1wiXSA9IFwic3F1YXJlVGFic1wiO1xuICAgIFNoYXBlVHlwZVtcInN0YXIxMFwiXSA9IFwic3RhcjEwXCI7XG4gICAgU2hhcGVUeXBlW1wic3RhcjEyXCJdID0gXCJzdGFyMTJcIjtcbiAgICBTaGFwZVR5cGVbXCJzdGFyMTZcIl0gPSBcInN0YXIxNlwiO1xuICAgIFNoYXBlVHlwZVtcInN0YXIyNFwiXSA9IFwic3RhcjI0XCI7XG4gICAgU2hhcGVUeXBlW1wic3RhcjMyXCJdID0gXCJzdGFyMzJcIjtcbiAgICBTaGFwZVR5cGVbXCJzdGFyNFwiXSA9IFwic3RhcjRcIjtcbiAgICBTaGFwZVR5cGVbXCJzdGFyNVwiXSA9IFwic3RhcjVcIjtcbiAgICBTaGFwZVR5cGVbXCJzdGFyNlwiXSA9IFwic3RhcjZcIjtcbiAgICBTaGFwZVR5cGVbXCJzdGFyN1wiXSA9IFwic3RhcjdcIjtcbiAgICBTaGFwZVR5cGVbXCJzdGFyOFwiXSA9IFwic3RhcjhcIjtcbiAgICBTaGFwZVR5cGVbXCJzdHJpcGVkUmlnaHRBcnJvd1wiXSA9IFwic3RyaXBlZFJpZ2h0QXJyb3dcIjtcbiAgICBTaGFwZVR5cGVbXCJzdW5cIl0gPSBcInN1blwiO1xuICAgIFNoYXBlVHlwZVtcInN3b29zaEFycm93XCJdID0gXCJzd29vc2hBcnJvd1wiO1xuICAgIFNoYXBlVHlwZVtcInRlYXJkcm9wXCJdID0gXCJ0ZWFyZHJvcFwiO1xuICAgIFNoYXBlVHlwZVtcInRyYXBlem9pZFwiXSA9IFwidHJhcGV6b2lkXCI7XG4gICAgU2hhcGVUeXBlW1widHJpYW5nbGVcIl0gPSBcInRyaWFuZ2xlXCI7XG4gICAgU2hhcGVUeXBlW1widXBBcnJvd1wiXSA9IFwidXBBcnJvd1wiO1xuICAgIFNoYXBlVHlwZVtcInVwQXJyb3dDYWxsb3V0XCJdID0gXCJ1cEFycm93Q2FsbG91dFwiO1xuICAgIFNoYXBlVHlwZVtcInVwRG93bkFycm93XCJdID0gXCJ1cERvd25BcnJvd1wiO1xuICAgIFNoYXBlVHlwZVtcInVwRG93bkFycm93Q2FsbG91dFwiXSA9IFwidXBEb3duQXJyb3dDYWxsb3V0XCI7XG4gICAgU2hhcGVUeXBlW1widXR1cm5BcnJvd1wiXSA9IFwidXR1cm5BcnJvd1wiO1xuICAgIFNoYXBlVHlwZVtcInZlcnRpY2FsU2Nyb2xsXCJdID0gXCJ2ZXJ0aWNhbFNjcm9sbFwiO1xuICAgIFNoYXBlVHlwZVtcIndhdmVcIl0gPSBcIndhdmVcIjtcbiAgICBTaGFwZVR5cGVbXCJ3ZWRnZUVsbGlwc2VDYWxsb3V0XCJdID0gXCJ3ZWRnZUVsbGlwc2VDYWxsb3V0XCI7XG4gICAgU2hhcGVUeXBlW1wid2VkZ2VSZWN0Q2FsbG91dFwiXSA9IFwid2VkZ2VSZWN0Q2FsbG91dFwiO1xuICAgIFNoYXBlVHlwZVtcIndlZGdlUm91bmRSZWN0Q2FsbG91dFwiXSA9IFwid2VkZ2VSb3VuZFJlY3RDYWxsb3V0XCI7XG59KShTaGFwZVR5cGUgfHwgKFNoYXBlVHlwZSA9IHt9KSk7XG4vKipcbiAqIFRPRE86IEZVVFVSRTogdjQuMDogcmVuYW1lIHRvIGBUaGVtZUNvbG9yYFxuICovXG52YXIgU2NoZW1lQ29sb3I7XG4oZnVuY3Rpb24gKFNjaGVtZUNvbG9yKSB7XG4gICAgU2NoZW1lQ29sb3JbXCJ0ZXh0MVwiXSA9IFwidHgxXCI7XG4gICAgU2NoZW1lQ29sb3JbXCJ0ZXh0MlwiXSA9IFwidHgyXCI7XG4gICAgU2NoZW1lQ29sb3JbXCJiYWNrZ3JvdW5kMVwiXSA9IFwiYmcxXCI7XG4gICAgU2NoZW1lQ29sb3JbXCJiYWNrZ3JvdW5kMlwiXSA9IFwiYmcyXCI7XG4gICAgU2NoZW1lQ29sb3JbXCJhY2NlbnQxXCJdID0gXCJhY2NlbnQxXCI7XG4gICAgU2NoZW1lQ29sb3JbXCJhY2NlbnQyXCJdID0gXCJhY2NlbnQyXCI7XG4gICAgU2NoZW1lQ29sb3JbXCJhY2NlbnQzXCJdID0gXCJhY2NlbnQzXCI7XG4gICAgU2NoZW1lQ29sb3JbXCJhY2NlbnQ0XCJdID0gXCJhY2NlbnQ0XCI7XG4gICAgU2NoZW1lQ29sb3JbXCJhY2NlbnQ1XCJdID0gXCJhY2NlbnQ1XCI7XG4gICAgU2NoZW1lQ29sb3JbXCJhY2NlbnQ2XCJdID0gXCJhY2NlbnQ2XCI7XG59KShTY2hlbWVDb2xvciB8fCAoU2NoZW1lQ29sb3IgPSB7fSkpO1xudmFyIEFsaWduSDtcbihmdW5jdGlvbiAoQWxpZ25IKSB7XG4gICAgQWxpZ25IW1wibGVmdFwiXSA9IFwibGVmdFwiO1xuICAgIEFsaWduSFtcImNlbnRlclwiXSA9IFwiY2VudGVyXCI7XG4gICAgQWxpZ25IW1wicmlnaHRcIl0gPSBcInJpZ2h0XCI7XG4gICAgQWxpZ25IW1wianVzdGlmeVwiXSA9IFwianVzdGlmeVwiO1xufSkoQWxpZ25IIHx8IChBbGlnbkggPSB7fSkpO1xudmFyIEFsaWduVjtcbihmdW5jdGlvbiAoQWxpZ25WKSB7XG4gICAgQWxpZ25WW1widG9wXCJdID0gXCJ0b3BcIjtcbiAgICBBbGlnblZbXCJtaWRkbGVcIl0gPSBcIm1pZGRsZVwiO1xuICAgIEFsaWduVltcImJvdHRvbVwiXSA9IFwiYm90dG9tXCI7XG59KShBbGlnblYgfHwgKEFsaWduViA9IHt9KSk7XG52YXIgU0hBUEVfVFlQRTtcbihmdW5jdGlvbiAoU0hBUEVfVFlQRSkge1xuICAgIFNIQVBFX1RZUEVbXCJBQ1RJT05fQlVUVE9OX0JBQ0tfT1JfUFJFVklPVVNcIl0gPSBcImFjdGlvbkJ1dHRvbkJhY2tQcmV2aW91c1wiO1xuICAgIFNIQVBFX1RZUEVbXCJBQ1RJT05fQlVUVE9OX0JFR0lOTklOR1wiXSA9IFwiYWN0aW9uQnV0dG9uQmVnaW5uaW5nXCI7XG4gICAgU0hBUEVfVFlQRVtcIkFDVElPTl9CVVRUT05fQ1VTVE9NXCJdID0gXCJhY3Rpb25CdXR0b25CbGFua1wiO1xuICAgIFNIQVBFX1RZUEVbXCJBQ1RJT05fQlVUVE9OX0RPQ1VNRU5UXCJdID0gXCJhY3Rpb25CdXR0b25Eb2N1bWVudFwiO1xuICAgIFNIQVBFX1RZUEVbXCJBQ1RJT05fQlVUVE9OX0VORFwiXSA9IFwiYWN0aW9uQnV0dG9uRW5kXCI7XG4gICAgU0hBUEVfVFlQRVtcIkFDVElPTl9CVVRUT05fRk9SV0FSRF9PUl9ORVhUXCJdID0gXCJhY3Rpb25CdXR0b25Gb3J3YXJkTmV4dFwiO1xuICAgIFNIQVBFX1RZUEVbXCJBQ1RJT05fQlVUVE9OX0hFTFBcIl0gPSBcImFjdGlvbkJ1dHRvbkhlbHBcIjtcbiAgICBTSEFQRV9UWVBFW1wiQUNUSU9OX0JVVFRPTl9IT01FXCJdID0gXCJhY3Rpb25CdXR0b25Ib21lXCI7XG4gICAgU0hBUEVfVFlQRVtcIkFDVElPTl9CVVRUT05fSU5GT1JNQVRJT05cIl0gPSBcImFjdGlvbkJ1dHRvbkluZm9ybWF0aW9uXCI7XG4gICAgU0hBUEVfVFlQRVtcIkFDVElPTl9CVVRUT05fTU9WSUVcIl0gPSBcImFjdGlvbkJ1dHRvbk1vdmllXCI7XG4gICAgU0hBUEVfVFlQRVtcIkFDVElPTl9CVVRUT05fUkVUVVJOXCJdID0gXCJhY3Rpb25CdXR0b25SZXR1cm5cIjtcbiAgICBTSEFQRV9UWVBFW1wiQUNUSU9OX0JVVFRPTl9TT1VORFwiXSA9IFwiYWN0aW9uQnV0dG9uU291bmRcIjtcbiAgICBTSEFQRV9UWVBFW1wiQVJDXCJdID0gXCJhcmNcIjtcbiAgICBTSEFQRV9UWVBFW1wiQkFMTE9PTlwiXSA9IFwid2VkZ2VSb3VuZFJlY3RDYWxsb3V0XCI7XG4gICAgU0hBUEVfVFlQRVtcIkJFTlRfQVJST1dcIl0gPSBcImJlbnRBcnJvd1wiO1xuICAgIFNIQVBFX1RZUEVbXCJCRU5UX1VQX0FSUk9XXCJdID0gXCJiZW50VXBBcnJvd1wiO1xuICAgIFNIQVBFX1RZUEVbXCJCRVZFTFwiXSA9IFwiYmV2ZWxcIjtcbiAgICBTSEFQRV9UWVBFW1wiQkxPQ0tfQVJDXCJdID0gXCJibG9ja0FyY1wiO1xuICAgIFNIQVBFX1RZUEVbXCJDQU5cIl0gPSBcImNhblwiO1xuICAgIFNIQVBFX1RZUEVbXCJDSEFSVF9QTFVTXCJdID0gXCJjaGFydFBsdXNcIjtcbiAgICBTSEFQRV9UWVBFW1wiQ0hBUlRfU1RBUlwiXSA9IFwiY2hhcnRTdGFyXCI7XG4gICAgU0hBUEVfVFlQRVtcIkNIQVJUX1hcIl0gPSBcImNoYXJ0WFwiO1xuICAgIFNIQVBFX1RZUEVbXCJDSEVWUk9OXCJdID0gXCJjaGV2cm9uXCI7XG4gICAgU0hBUEVfVFlQRVtcIkNIT1JEXCJdID0gXCJjaG9yZFwiO1xuICAgIFNIQVBFX1RZUEVbXCJDSVJDVUxBUl9BUlJPV1wiXSA9IFwiY2lyY3VsYXJBcnJvd1wiO1xuICAgIFNIQVBFX1RZUEVbXCJDTE9VRFwiXSA9IFwiY2xvdWRcIjtcbiAgICBTSEFQRV9UWVBFW1wiQ0xPVURfQ0FMTE9VVFwiXSA9IFwiY2xvdWRDYWxsb3V0XCI7XG4gICAgU0hBUEVfVFlQRVtcIkNPUk5FUlwiXSA9IFwiY29ybmVyXCI7XG4gICAgU0hBUEVfVFlQRVtcIkNPUk5FUl9UQUJTXCJdID0gXCJjb3JuZXJUYWJzXCI7XG4gICAgU0hBUEVfVFlQRVtcIkNST1NTXCJdID0gXCJwbHVzXCI7XG4gICAgU0hBUEVfVFlQRVtcIkNVQkVcIl0gPSBcImN1YmVcIjtcbiAgICBTSEFQRV9UWVBFW1wiQ1VSVkVEX0RPV05fQVJST1dcIl0gPSBcImN1cnZlZERvd25BcnJvd1wiO1xuICAgIFNIQVBFX1RZUEVbXCJDVVJWRURfRE9XTl9SSUJCT05cIl0gPSBcImVsbGlwc2VSaWJib25cIjtcbiAgICBTSEFQRV9UWVBFW1wiQ1VSVkVEX0xFRlRfQVJST1dcIl0gPSBcImN1cnZlZExlZnRBcnJvd1wiO1xuICAgIFNIQVBFX1RZUEVbXCJDVVJWRURfUklHSFRfQVJST1dcIl0gPSBcImN1cnZlZFJpZ2h0QXJyb3dcIjtcbiAgICBTSEFQRV9UWVBFW1wiQ1VSVkVEX1VQX0FSUk9XXCJdID0gXCJjdXJ2ZWRVcEFycm93XCI7XG4gICAgU0hBUEVfVFlQRVtcIkNVUlZFRF9VUF9SSUJCT05cIl0gPSBcImVsbGlwc2VSaWJib24yXCI7XG4gICAgU0hBUEVfVFlQRVtcIkNVU1RPTV9HRU9NRVRSWVwiXSA9IFwiY3VzdEdlb21cIjtcbiAgICBTSEFQRV9UWVBFW1wiREVDQUdPTlwiXSA9IFwiZGVjYWdvblwiO1xuICAgIFNIQVBFX1RZUEVbXCJESUFHT05BTF9TVFJJUEVcIl0gPSBcImRpYWdTdHJpcGVcIjtcbiAgICBTSEFQRV9UWVBFW1wiRElBTU9ORFwiXSA9IFwiZGlhbW9uZFwiO1xuICAgIFNIQVBFX1RZUEVbXCJET0RFQ0FHT05cIl0gPSBcImRvZGVjYWdvblwiO1xuICAgIFNIQVBFX1RZUEVbXCJET05VVFwiXSA9IFwiZG9udXRcIjtcbiAgICBTSEFQRV9UWVBFW1wiRE9VQkxFX0JSQUNFXCJdID0gXCJicmFjZVBhaXJcIjtcbiAgICBTSEFQRV9UWVBFW1wiRE9VQkxFX0JSQUNLRVRcIl0gPSBcImJyYWNrZXRQYWlyXCI7XG4gICAgU0hBUEVfVFlQRVtcIkRPVUJMRV9XQVZFXCJdID0gXCJkb3VibGVXYXZlXCI7XG4gICAgU0hBUEVfVFlQRVtcIkRPV05fQVJST1dcIl0gPSBcImRvd25BcnJvd1wiO1xuICAgIFNIQVBFX1RZUEVbXCJET1dOX0FSUk9XX0NBTExPVVRcIl0gPSBcImRvd25BcnJvd0NhbGxvdXRcIjtcbiAgICBTSEFQRV9UWVBFW1wiRE9XTl9SSUJCT05cIl0gPSBcInJpYmJvblwiO1xuICAgIFNIQVBFX1RZUEVbXCJFWFBMT1NJT04xXCJdID0gXCJpcnJlZ3VsYXJTZWFsMVwiO1xuICAgIFNIQVBFX1RZUEVbXCJFWFBMT1NJT04yXCJdID0gXCJpcnJlZ3VsYXJTZWFsMlwiO1xuICAgIFNIQVBFX1RZUEVbXCJGTE9XQ0hBUlRfQUxURVJOQVRFX1BST0NFU1NcIl0gPSBcImZsb3dDaGFydEFsdGVybmF0ZVByb2Nlc3NcIjtcbiAgICBTSEFQRV9UWVBFW1wiRkxPV0NIQVJUX0NBUkRcIl0gPSBcImZsb3dDaGFydFB1bmNoZWRDYXJkXCI7XG4gICAgU0hBUEVfVFlQRVtcIkZMT1dDSEFSVF9DT0xMQVRFXCJdID0gXCJmbG93Q2hhcnRDb2xsYXRlXCI7XG4gICAgU0hBUEVfVFlQRVtcIkZMT1dDSEFSVF9DT05ORUNUT1JcIl0gPSBcImZsb3dDaGFydENvbm5lY3RvclwiO1xuICAgIFNIQVBFX1RZUEVbXCJGTE9XQ0hBUlRfREFUQVwiXSA9IFwiZmxvd0NoYXJ0SW5wdXRPdXRwdXRcIjtcbiAgICBTSEFQRV9UWVBFW1wiRkxPV0NIQVJUX0RFQ0lTSU9OXCJdID0gXCJmbG93Q2hhcnREZWNpc2lvblwiO1xuICAgIFNIQVBFX1RZUEVbXCJGTE9XQ0hBUlRfREVMQVlcIl0gPSBcImZsb3dDaGFydERlbGF5XCI7XG4gICAgU0hBUEVfVFlQRVtcIkZMT1dDSEFSVF9ESVJFQ1RfQUNDRVNTX1NUT1JBR0VcIl0gPSBcImZsb3dDaGFydE1hZ25ldGljRHJ1bVwiO1xuICAgIFNIQVBFX1RZUEVbXCJGTE9XQ0hBUlRfRElTUExBWVwiXSA9IFwiZmxvd0NoYXJ0RGlzcGxheVwiO1xuICAgIFNIQVBFX1RZUEVbXCJGTE9XQ0hBUlRfRE9DVU1FTlRcIl0gPSBcImZsb3dDaGFydERvY3VtZW50XCI7XG4gICAgU0hBUEVfVFlQRVtcIkZMT1dDSEFSVF9FWFRSQUNUXCJdID0gXCJmbG93Q2hhcnRFeHRyYWN0XCI7XG4gICAgU0hBUEVfVFlQRVtcIkZMT1dDSEFSVF9JTlRFUk5BTF9TVE9SQUdFXCJdID0gXCJmbG93Q2hhcnRJbnRlcm5hbFN0b3JhZ2VcIjtcbiAgICBTSEFQRV9UWVBFW1wiRkxPV0NIQVJUX01BR05FVElDX0RJU0tcIl0gPSBcImZsb3dDaGFydE1hZ25ldGljRGlza1wiO1xuICAgIFNIQVBFX1RZUEVbXCJGTE9XQ0hBUlRfTUFOVUFMX0lOUFVUXCJdID0gXCJmbG93Q2hhcnRNYW51YWxJbnB1dFwiO1xuICAgIFNIQVBFX1RZUEVbXCJGTE9XQ0hBUlRfTUFOVUFMX09QRVJBVElPTlwiXSA9IFwiZmxvd0NoYXJ0TWFudWFsT3BlcmF0aW9uXCI7XG4gICAgU0hBUEVfVFlQRVtcIkZMT1dDSEFSVF9NRVJHRVwiXSA9IFwiZmxvd0NoYXJ0TWVyZ2VcIjtcbiAgICBTSEFQRV9UWVBFW1wiRkxPV0NIQVJUX01VTFRJRE9DVU1FTlRcIl0gPSBcImZsb3dDaGFydE11bHRpZG9jdW1lbnRcIjtcbiAgICBTSEFQRV9UWVBFW1wiRkxPV0NIQVJUX09GRkxJTkVfU1RPUkFHRVwiXSA9IFwiZmxvd0NoYXJ0T2ZmbGluZVN0b3JhZ2VcIjtcbiAgICBTSEFQRV9UWVBFW1wiRkxPV0NIQVJUX09GRlBBR0VfQ09OTkVDVE9SXCJdID0gXCJmbG93Q2hhcnRPZmZwYWdlQ29ubmVjdG9yXCI7XG4gICAgU0hBUEVfVFlQRVtcIkZMT1dDSEFSVF9PUlwiXSA9IFwiZmxvd0NoYXJ0T3JcIjtcbiAgICBTSEFQRV9UWVBFW1wiRkxPV0NIQVJUX1BSRURFRklORURfUFJPQ0VTU1wiXSA9IFwiZmxvd0NoYXJ0UHJlZGVmaW5lZFByb2Nlc3NcIjtcbiAgICBTSEFQRV9UWVBFW1wiRkxPV0NIQVJUX1BSRVBBUkFUSU9OXCJdID0gXCJmbG93Q2hhcnRQcmVwYXJhdGlvblwiO1xuICAgIFNIQVBFX1RZUEVbXCJGTE9XQ0hBUlRfUFJPQ0VTU1wiXSA9IFwiZmxvd0NoYXJ0UHJvY2Vzc1wiO1xuICAgIFNIQVBFX1RZUEVbXCJGTE9XQ0hBUlRfUFVOQ0hFRF9UQVBFXCJdID0gXCJmbG93Q2hhcnRQdW5jaGVkVGFwZVwiO1xuICAgIFNIQVBFX1RZUEVbXCJGTE9XQ0hBUlRfU0VRVUVOVElBTF9BQ0NFU1NfU1RPUkFHRVwiXSA9IFwiZmxvd0NoYXJ0TWFnbmV0aWNUYXBlXCI7XG4gICAgU0hBUEVfVFlQRVtcIkZMT1dDSEFSVF9TT1JUXCJdID0gXCJmbG93Q2hhcnRTb3J0XCI7XG4gICAgU0hBUEVfVFlQRVtcIkZMT1dDSEFSVF9TVE9SRURfREFUQVwiXSA9IFwiZmxvd0NoYXJ0T25saW5lU3RvcmFnZVwiO1xuICAgIFNIQVBFX1RZUEVbXCJGTE9XQ0hBUlRfU1VNTUlOR19KVU5DVElPTlwiXSA9IFwiZmxvd0NoYXJ0U3VtbWluZ0p1bmN0aW9uXCI7XG4gICAgU0hBUEVfVFlQRVtcIkZMT1dDSEFSVF9URVJNSU5BVE9SXCJdID0gXCJmbG93Q2hhcnRUZXJtaW5hdG9yXCI7XG4gICAgU0hBUEVfVFlQRVtcIkZPTERFRF9DT1JORVJcIl0gPSBcImZvbGRlckNvcm5lclwiO1xuICAgIFNIQVBFX1RZUEVbXCJGUkFNRVwiXSA9IFwiZnJhbWVcIjtcbiAgICBTSEFQRV9UWVBFW1wiRlVOTkVMXCJdID0gXCJmdW5uZWxcIjtcbiAgICBTSEFQRV9UWVBFW1wiR0VBUl82XCJdID0gXCJnZWFyNlwiO1xuICAgIFNIQVBFX1RZUEVbXCJHRUFSXzlcIl0gPSBcImdlYXI5XCI7XG4gICAgU0hBUEVfVFlQRVtcIkhBTEZfRlJBTUVcIl0gPSBcImhhbGZGcmFtZVwiO1xuICAgIFNIQVBFX1RZUEVbXCJIRUFSVFwiXSA9IFwiaGVhcnRcIjtcbiAgICBTSEFQRV9UWVBFW1wiSEVQVEFHT05cIl0gPSBcImhlcHRhZ29uXCI7XG4gICAgU0hBUEVfVFlQRVtcIkhFWEFHT05cIl0gPSBcImhleGFnb25cIjtcbiAgICBTSEFQRV9UWVBFW1wiSE9SSVpPTlRBTF9TQ1JPTExcIl0gPSBcImhvcml6b250YWxTY3JvbGxcIjtcbiAgICBTSEFQRV9UWVBFW1wiSVNPU0NFTEVTX1RSSUFOR0xFXCJdID0gXCJ0cmlhbmdsZVwiO1xuICAgIFNIQVBFX1RZUEVbXCJMRUZUX0FSUk9XXCJdID0gXCJsZWZ0QXJyb3dcIjtcbiAgICBTSEFQRV9UWVBFW1wiTEVGVF9BUlJPV19DQUxMT1VUXCJdID0gXCJsZWZ0QXJyb3dDYWxsb3V0XCI7XG4gICAgU0hBUEVfVFlQRVtcIkxFRlRfQlJBQ0VcIl0gPSBcImxlZnRCcmFjZVwiO1xuICAgIFNIQVBFX1RZUEVbXCJMRUZUX0JSQUNLRVRcIl0gPSBcImxlZnRCcmFja2V0XCI7XG4gICAgU0hBUEVfVFlQRVtcIkxFRlRfQ0lSQ1VMQVJfQVJST1dcIl0gPSBcImxlZnRDaXJjdWxhckFycm93XCI7XG4gICAgU0hBUEVfVFlQRVtcIkxFRlRfUklHSFRfQVJST1dcIl0gPSBcImxlZnRSaWdodEFycm93XCI7XG4gICAgU0hBUEVfVFlQRVtcIkxFRlRfUklHSFRfQVJST1dfQ0FMTE9VVFwiXSA9IFwibGVmdFJpZ2h0QXJyb3dDYWxsb3V0XCI7XG4gICAgU0hBUEVfVFlQRVtcIkxFRlRfUklHSFRfQ0lSQ1VMQVJfQVJST1dcIl0gPSBcImxlZnRSaWdodENpcmN1bGFyQXJyb3dcIjtcbiAgICBTSEFQRV9UWVBFW1wiTEVGVF9SSUdIVF9SSUJCT05cIl0gPSBcImxlZnRSaWdodFJpYmJvblwiO1xuICAgIFNIQVBFX1RZUEVbXCJMRUZUX1JJR0hUX1VQX0FSUk9XXCJdID0gXCJsZWZ0UmlnaHRVcEFycm93XCI7XG4gICAgU0hBUEVfVFlQRVtcIkxFRlRfVVBfQVJST1dcIl0gPSBcImxlZnRVcEFycm93XCI7XG4gICAgU0hBUEVfVFlQRVtcIkxJR0hUTklOR19CT0xUXCJdID0gXCJsaWdodG5pbmdCb2x0XCI7XG4gICAgU0hBUEVfVFlQRVtcIkxJTkVfQ0FMTE9VVF8xXCJdID0gXCJib3JkZXJDYWxsb3V0MVwiO1xuICAgIFNIQVBFX1RZUEVbXCJMSU5FX0NBTExPVVRfMV9BQ0NFTlRfQkFSXCJdID0gXCJhY2NlbnRDYWxsb3V0MVwiO1xuICAgIFNIQVBFX1RZUEVbXCJMSU5FX0NBTExPVVRfMV9CT1JERVJfQU5EX0FDQ0VOVF9CQVJcIl0gPSBcImFjY2VudEJvcmRlckNhbGxvdXQxXCI7XG4gICAgU0hBUEVfVFlQRVtcIkxJTkVfQ0FMTE9VVF8xX05PX0JPUkRFUlwiXSA9IFwiY2FsbG91dDFcIjtcbiAgICBTSEFQRV9UWVBFW1wiTElORV9DQUxMT1VUXzJcIl0gPSBcImJvcmRlckNhbGxvdXQyXCI7XG4gICAgU0hBUEVfVFlQRVtcIkxJTkVfQ0FMTE9VVF8yX0FDQ0VOVF9CQVJcIl0gPSBcImFjY2VudENhbGxvdXQyXCI7XG4gICAgU0hBUEVfVFlQRVtcIkxJTkVfQ0FMTE9VVF8yX0JPUkRFUl9BTkRfQUNDRU5UX0JBUlwiXSA9IFwiYWNjZW50Qm9yZGVyQ2FsbG91dDJcIjtcbiAgICBTSEFQRV9UWVBFW1wiTElORV9DQUxMT1VUXzJfTk9fQk9SREVSXCJdID0gXCJjYWxsb3V0MlwiO1xuICAgIFNIQVBFX1RZUEVbXCJMSU5FX0NBTExPVVRfM1wiXSA9IFwiYm9yZGVyQ2FsbG91dDNcIjtcbiAgICBTSEFQRV9UWVBFW1wiTElORV9DQUxMT1VUXzNfQUNDRU5UX0JBUlwiXSA9IFwiYWNjZW50Q2FsbG91dDNcIjtcbiAgICBTSEFQRV9UWVBFW1wiTElORV9DQUxMT1VUXzNfQk9SREVSX0FORF9BQ0NFTlRfQkFSXCJdID0gXCJhY2NlbnRCb3JkZXJDYWxsb3V0M1wiO1xuICAgIFNIQVBFX1RZUEVbXCJMSU5FX0NBTExPVVRfM19OT19CT1JERVJcIl0gPSBcImNhbGxvdXQzXCI7XG4gICAgU0hBUEVfVFlQRVtcIkxJTkVfQ0FMTE9VVF80XCJdID0gXCJib3JkZXJDYWxsb3V0NFwiO1xuICAgIFNIQVBFX1RZUEVbXCJMSU5FX0NBTExPVVRfNF9BQ0NFTlRfQkFSXCJdID0gXCJhY2NlbnRDYWxsb3V0Mz00XCI7XG4gICAgU0hBUEVfVFlQRVtcIkxJTkVfQ0FMTE9VVF80X0JPUkRFUl9BTkRfQUNDRU5UX0JBUlwiXSA9IFwiYWNjZW50Qm9yZGVyQ2FsbG91dDRcIjtcbiAgICBTSEFQRV9UWVBFW1wiTElORV9DQUxMT1VUXzRfTk9fQk9SREVSXCJdID0gXCJjYWxsb3V0NFwiO1xuICAgIFNIQVBFX1RZUEVbXCJMSU5FXCJdID0gXCJsaW5lXCI7XG4gICAgU0hBUEVfVFlQRVtcIkxJTkVfSU5WRVJTRVwiXSA9IFwibGluZUludlwiO1xuICAgIFNIQVBFX1RZUEVbXCJNQVRIX0RJVklERVwiXSA9IFwibWF0aERpdmlkZVwiO1xuICAgIFNIQVBFX1RZUEVbXCJNQVRIX0VRVUFMXCJdID0gXCJtYXRoRXF1YWxcIjtcbiAgICBTSEFQRV9UWVBFW1wiTUFUSF9NSU5VU1wiXSA9IFwibWF0aE1pbnVzXCI7XG4gICAgU0hBUEVfVFlQRVtcIk1BVEhfTVVMVElQTFlcIl0gPSBcIm1hdGhNdWx0aXBseVwiO1xuICAgIFNIQVBFX1RZUEVbXCJNQVRIX05PVF9FUVVBTFwiXSA9IFwibWF0aE5vdEVxdWFsXCI7XG4gICAgU0hBUEVfVFlQRVtcIk1BVEhfUExVU1wiXSA9IFwibWF0aFBsdXNcIjtcbiAgICBTSEFQRV9UWVBFW1wiTU9PTlwiXSA9IFwibW9vblwiO1xuICAgIFNIQVBFX1RZUEVbXCJOT05fSVNPU0NFTEVTX1RSQVBFWk9JRFwiXSA9IFwibm9uSXNvc2NlbGVzVHJhcGV6b2lkXCI7XG4gICAgU0hBUEVfVFlQRVtcIk5PVENIRURfUklHSFRfQVJST1dcIl0gPSBcIm5vdGNoZWRSaWdodEFycm93XCI7XG4gICAgU0hBUEVfVFlQRVtcIk5PX1NZTUJPTFwiXSA9IFwibm9TbW9raW5nXCI7XG4gICAgU0hBUEVfVFlQRVtcIk9DVEFHT05cIl0gPSBcIm9jdGFnb25cIjtcbiAgICBTSEFQRV9UWVBFW1wiT1ZBTFwiXSA9IFwiZWxsaXBzZVwiO1xuICAgIFNIQVBFX1RZUEVbXCJPVkFMX0NBTExPVVRcIl0gPSBcIndlZGdlRWxsaXBzZUNhbGxvdXRcIjtcbiAgICBTSEFQRV9UWVBFW1wiUEFSQUxMRUxPR1JBTVwiXSA9IFwicGFyYWxsZWxvZ3JhbVwiO1xuICAgIFNIQVBFX1RZUEVbXCJQRU5UQUdPTlwiXSA9IFwiaG9tZVBsYXRlXCI7XG4gICAgU0hBUEVfVFlQRVtcIlBJRVwiXSA9IFwicGllXCI7XG4gICAgU0hBUEVfVFlQRVtcIlBJRV9XRURHRVwiXSA9IFwicGllV2VkZ2VcIjtcbiAgICBTSEFQRV9UWVBFW1wiUExBUVVFXCJdID0gXCJwbGFxdWVcIjtcbiAgICBTSEFQRV9UWVBFW1wiUExBUVVFX1RBQlNcIl0gPSBcInBsYXF1ZVRhYnNcIjtcbiAgICBTSEFQRV9UWVBFW1wiUVVBRF9BUlJPV1wiXSA9IFwicXVhZEFycm93XCI7XG4gICAgU0hBUEVfVFlQRVtcIlFVQURfQVJST1dfQ0FMTE9VVFwiXSA9IFwicXVhZEFycm93Q2FsbG91dFwiO1xuICAgIFNIQVBFX1RZUEVbXCJSRUNUQU5HTEVcIl0gPSBcInJlY3RcIjtcbiAgICBTSEFQRV9UWVBFW1wiUkVDVEFOR1VMQVJfQ0FMTE9VVFwiXSA9IFwid2VkZ2VSZWN0Q2FsbG91dFwiO1xuICAgIFNIQVBFX1RZUEVbXCJSRUdVTEFSX1BFTlRBR09OXCJdID0gXCJwZW50YWdvblwiO1xuICAgIFNIQVBFX1RZUEVbXCJSSUdIVF9BUlJPV1wiXSA9IFwicmlnaHRBcnJvd1wiO1xuICAgIFNIQVBFX1RZUEVbXCJSSUdIVF9BUlJPV19DQUxMT1VUXCJdID0gXCJyaWdodEFycm93Q2FsbG91dFwiO1xuICAgIFNIQVBFX1RZUEVbXCJSSUdIVF9CUkFDRVwiXSA9IFwicmlnaHRCcmFjZVwiO1xuICAgIFNIQVBFX1RZUEVbXCJSSUdIVF9CUkFDS0VUXCJdID0gXCJyaWdodEJyYWNrZXRcIjtcbiAgICBTSEFQRV9UWVBFW1wiUklHSFRfVFJJQU5HTEVcIl0gPSBcInJ0VHJpYW5nbGVcIjtcbiAgICBTSEFQRV9UWVBFW1wiUk9VTkRFRF9SRUNUQU5HTEVcIl0gPSBcInJvdW5kUmVjdFwiO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHVwbGljYXRlLWVudW0tdmFsdWVzXG4gICAgU0hBUEVfVFlQRVtcIlJPVU5ERURfUkVDVEFOR1VMQVJfQ0FMTE9VVFwiXSA9IFwid2VkZ2VSb3VuZFJlY3RDYWxsb3V0XCI7XG4gICAgU0hBUEVfVFlQRVtcIlJPVU5EXzFfUkVDVEFOR0xFXCJdID0gXCJyb3VuZDFSZWN0XCI7XG4gICAgU0hBUEVfVFlQRVtcIlJPVU5EXzJfRElBR19SRUNUQU5HTEVcIl0gPSBcInJvdW5kMkRpYWdSZWN0XCI7XG4gICAgU0hBUEVfVFlQRVtcIlJPVU5EXzJfU0FNRV9SRUNUQU5HTEVcIl0gPSBcInJvdW5kMlNhbWVSZWN0XCI7XG4gICAgU0hBUEVfVFlQRVtcIlNNSUxFWV9GQUNFXCJdID0gXCJzbWlsZXlGYWNlXCI7XG4gICAgU0hBUEVfVFlQRVtcIlNOSVBfMV9SRUNUQU5HTEVcIl0gPSBcInNuaXAxUmVjdFwiO1xuICAgIFNIQVBFX1RZUEVbXCJTTklQXzJfRElBR19SRUNUQU5HTEVcIl0gPSBcInNuaXAyRGlhZ1JlY3RcIjtcbiAgICBTSEFQRV9UWVBFW1wiU05JUF8yX1NBTUVfUkVDVEFOR0xFXCJdID0gXCJzbmlwMlNhbWVSZWN0XCI7XG4gICAgU0hBUEVfVFlQRVtcIlNOSVBfUk9VTkRfUkVDVEFOR0xFXCJdID0gXCJzbmlwUm91bmRSZWN0XCI7XG4gICAgU0hBUEVfVFlQRVtcIlNRVUFSRV9UQUJTXCJdID0gXCJzcXVhcmVUYWJzXCI7XG4gICAgU0hBUEVfVFlQRVtcIlNUQVJfMTBfUE9JTlRcIl0gPSBcInN0YXIxMFwiO1xuICAgIFNIQVBFX1RZUEVbXCJTVEFSXzEyX1BPSU5UXCJdID0gXCJzdGFyMTJcIjtcbiAgICBTSEFQRV9UWVBFW1wiU1RBUl8xNl9QT0lOVFwiXSA9IFwic3RhcjE2XCI7XG4gICAgU0hBUEVfVFlQRVtcIlNUQVJfMjRfUE9JTlRcIl0gPSBcInN0YXIyNFwiO1xuICAgIFNIQVBFX1RZUEVbXCJTVEFSXzMyX1BPSU5UXCJdID0gXCJzdGFyMzJcIjtcbiAgICBTSEFQRV9UWVBFW1wiU1RBUl80X1BPSU5UXCJdID0gXCJzdGFyNFwiO1xuICAgIFNIQVBFX1RZUEVbXCJTVEFSXzVfUE9JTlRcIl0gPSBcInN0YXI1XCI7XG4gICAgU0hBUEVfVFlQRVtcIlNUQVJfNl9QT0lOVFwiXSA9IFwic3RhcjZcIjtcbiAgICBTSEFQRV9UWVBFW1wiU1RBUl83X1BPSU5UXCJdID0gXCJzdGFyN1wiO1xuICAgIFNIQVBFX1RZUEVbXCJTVEFSXzhfUE9JTlRcIl0gPSBcInN0YXI4XCI7XG4gICAgU0hBUEVfVFlQRVtcIlNUUklQRURfUklHSFRfQVJST1dcIl0gPSBcInN0cmlwZWRSaWdodEFycm93XCI7XG4gICAgU0hBUEVfVFlQRVtcIlNVTlwiXSA9IFwic3VuXCI7XG4gICAgU0hBUEVfVFlQRVtcIlNXT09TSF9BUlJPV1wiXSA9IFwic3dvb3NoQXJyb3dcIjtcbiAgICBTSEFQRV9UWVBFW1wiVEVBUlwiXSA9IFwidGVhcmRyb3BcIjtcbiAgICBTSEFQRV9UWVBFW1wiVFJBUEVaT0lEXCJdID0gXCJ0cmFwZXpvaWRcIjtcbiAgICBTSEFQRV9UWVBFW1wiVVBfQVJST1dcIl0gPSBcInVwQXJyb3dcIjtcbiAgICBTSEFQRV9UWVBFW1wiVVBfQVJST1dfQ0FMTE9VVFwiXSA9IFwidXBBcnJvd0NhbGxvdXRcIjtcbiAgICBTSEFQRV9UWVBFW1wiVVBfRE9XTl9BUlJPV1wiXSA9IFwidXBEb3duQXJyb3dcIjtcbiAgICBTSEFQRV9UWVBFW1wiVVBfRE9XTl9BUlJPV19DQUxMT1VUXCJdID0gXCJ1cERvd25BcnJvd0NhbGxvdXRcIjtcbiAgICBTSEFQRV9UWVBFW1wiVVBfUklCQk9OXCJdID0gXCJyaWJib24yXCI7XG4gICAgU0hBUEVfVFlQRVtcIlVfVFVSTl9BUlJPV1wiXSA9IFwidXR1cm5BcnJvd1wiO1xuICAgIFNIQVBFX1RZUEVbXCJWRVJUSUNBTF9TQ1JPTExcIl0gPSBcInZlcnRpY2FsU2Nyb2xsXCI7XG4gICAgU0hBUEVfVFlQRVtcIldBVkVcIl0gPSBcIndhdmVcIjtcbn0pKFNIQVBFX1RZUEUgfHwgKFNIQVBFX1RZUEUgPSB7fSkpO1xudmFyIENIQVJUX1RZUEU7XG4oZnVuY3Rpb24gKENIQVJUX1RZUEUpIHtcbiAgICBDSEFSVF9UWVBFW1wiQVJFQVwiXSA9IFwiYXJlYVwiO1xuICAgIENIQVJUX1RZUEVbXCJCQVJcIl0gPSBcImJhclwiO1xuICAgIENIQVJUX1RZUEVbXCJCQVIzRFwiXSA9IFwiYmFyM0RcIjtcbiAgICBDSEFSVF9UWVBFW1wiQlVCQkxFXCJdID0gXCJidWJibGVcIjtcbiAgICBDSEFSVF9UWVBFW1wiQlVCQkxFM0RcIl0gPSBcImJ1YmJsZTNEXCI7XG4gICAgQ0hBUlRfVFlQRVtcIkRPVUdITlVUXCJdID0gXCJkb3VnaG51dFwiO1xuICAgIENIQVJUX1RZUEVbXCJMSU5FXCJdID0gXCJsaW5lXCI7XG4gICAgQ0hBUlRfVFlQRVtcIlBJRVwiXSA9IFwicGllXCI7XG4gICAgQ0hBUlRfVFlQRVtcIlJBREFSXCJdID0gXCJyYWRhclwiO1xuICAgIENIQVJUX1RZUEVbXCJTQ0FUVEVSXCJdID0gXCJzY2F0dGVyXCI7XG59KShDSEFSVF9UWVBFIHx8IChDSEFSVF9UWVBFID0ge30pKTtcbnZhciBTQ0hFTUVfQ09MT1JfTkFNRVM7XG4oZnVuY3Rpb24gKFNDSEVNRV9DT0xPUl9OQU1FUykge1xuICAgIFNDSEVNRV9DT0xPUl9OQU1FU1tcIlRFWFQxXCJdID0gXCJ0eDFcIjtcbiAgICBTQ0hFTUVfQ09MT1JfTkFNRVNbXCJURVhUMlwiXSA9IFwidHgyXCI7XG4gICAgU0NIRU1FX0NPTE9SX05BTUVTW1wiQkFDS0dST1VORDFcIl0gPSBcImJnMVwiO1xuICAgIFNDSEVNRV9DT0xPUl9OQU1FU1tcIkJBQ0tHUk9VTkQyXCJdID0gXCJiZzJcIjtcbiAgICBTQ0hFTUVfQ09MT1JfTkFNRVNbXCJBQ0NFTlQxXCJdID0gXCJhY2NlbnQxXCI7XG4gICAgU0NIRU1FX0NPTE9SX05BTUVTW1wiQUNDRU5UMlwiXSA9IFwiYWNjZW50MlwiO1xuICAgIFNDSEVNRV9DT0xPUl9OQU1FU1tcIkFDQ0VOVDNcIl0gPSBcImFjY2VudDNcIjtcbiAgICBTQ0hFTUVfQ09MT1JfTkFNRVNbXCJBQ0NFTlQ0XCJdID0gXCJhY2NlbnQ0XCI7XG4gICAgU0NIRU1FX0NPTE9SX05BTUVTW1wiQUNDRU5UNVwiXSA9IFwiYWNjZW50NVwiO1xuICAgIFNDSEVNRV9DT0xPUl9OQU1FU1tcIkFDQ0VOVDZcIl0gPSBcImFjY2VudDZcIjtcbn0pKFNDSEVNRV9DT0xPUl9OQU1FUyB8fCAoU0NIRU1FX0NPTE9SX05BTUVTID0ge30pKTtcbnZhciBNQVNURVJfT0JKRUNUUztcbihmdW5jdGlvbiAoTUFTVEVSX09CSkVDVFMpIHtcbiAgICBNQVNURVJfT0JKRUNUU1tcImNoYXJ0XCJdID0gXCJjaGFydFwiO1xuICAgIE1BU1RFUl9PQkpFQ1RTW1wiaW1hZ2VcIl0gPSBcImltYWdlXCI7XG4gICAgTUFTVEVSX09CSkVDVFNbXCJsaW5lXCJdID0gXCJsaW5lXCI7XG4gICAgTUFTVEVSX09CSkVDVFNbXCJyZWN0XCJdID0gXCJyZWN0XCI7XG4gICAgTUFTVEVSX09CSkVDVFNbXCJ0ZXh0XCJdID0gXCJ0ZXh0XCI7XG4gICAgTUFTVEVSX09CSkVDVFNbXCJwbGFjZWhvbGRlclwiXSA9IFwicGxhY2Vob2xkZXJcIjtcbn0pKE1BU1RFUl9PQkpFQ1RTIHx8IChNQVNURVJfT0JKRUNUUyA9IHt9KSk7XG52YXIgU0xJREVfT0JKRUNUX1RZUEVTO1xuKGZ1bmN0aW9uIChTTElERV9PQkpFQ1RfVFlQRVMpIHtcbiAgICBTTElERV9PQkpFQ1RfVFlQRVNbXCJjaGFydFwiXSA9IFwiY2hhcnRcIjtcbiAgICBTTElERV9PQkpFQ1RfVFlQRVNbXCJoeXBlcmxpbmtcIl0gPSBcImh5cGVybGlua1wiO1xuICAgIFNMSURFX09CSkVDVF9UWVBFU1tcImltYWdlXCJdID0gXCJpbWFnZVwiO1xuICAgIFNMSURFX09CSkVDVF9UWVBFU1tcIm1lZGlhXCJdID0gXCJtZWRpYVwiO1xuICAgIFNMSURFX09CSkVDVF9UWVBFU1tcIm9ubGluZVwiXSA9IFwib25saW5lXCI7XG4gICAgU0xJREVfT0JKRUNUX1RZUEVTW1wicGxhY2Vob2xkZXJcIl0gPSBcInBsYWNlaG9sZGVyXCI7XG4gICAgU0xJREVfT0JKRUNUX1RZUEVTW1widGFibGVcIl0gPSBcInRhYmxlXCI7XG4gICAgU0xJREVfT0JKRUNUX1RZUEVTW1widGFibGVjZWxsXCJdID0gXCJ0YWJsZWNlbGxcIjtcbiAgICBTTElERV9PQkpFQ1RfVFlQRVNbXCJ0ZXh0XCJdID0gXCJ0ZXh0XCI7XG4gICAgU0xJREVfT0JKRUNUX1RZUEVTW1wibm90ZXNcIl0gPSBcIm5vdGVzXCI7XG59KShTTElERV9PQkpFQ1RfVFlQRVMgfHwgKFNMSURFX09CSkVDVF9UWVBFUyA9IHt9KSk7XG52YXIgUExBQ0VIT0xERVJfVFlQRVM7XG4oZnVuY3Rpb24gKFBMQUNFSE9MREVSX1RZUEVTKSB7XG4gICAgUExBQ0VIT0xERVJfVFlQRVNbXCJ0aXRsZVwiXSA9IFwidGl0bGVcIjtcbiAgICBQTEFDRUhPTERFUl9UWVBFU1tcImJvZHlcIl0gPSBcImJvZHlcIjtcbiAgICBQTEFDRUhPTERFUl9UWVBFU1tcImltYWdlXCJdID0gXCJwaWNcIjtcbiAgICBQTEFDRUhPTERFUl9UWVBFU1tcImNoYXJ0XCJdID0gXCJjaGFydFwiO1xuICAgIFBMQUNFSE9MREVSX1RZUEVTW1widGFibGVcIl0gPSBcInRibFwiO1xuICAgIFBMQUNFSE9MREVSX1RZUEVTW1wibWVkaWFcIl0gPSBcIm1lZGlhXCI7XG59KShQTEFDRUhPTERFUl9UWVBFUyB8fCAoUExBQ0VIT0xERVJfVFlQRVMgPSB7fSkpO1xuLyoqXG4gKiBOT1RFOiAyMDE3MDMwNDogQlVMTEVUX1RZUEVTOiBPbmx5IGRlZmF1bHQgaXMgdXNlZCBzbyBmYXIuIEknZCBsaWtlIHRvIGNvbWJpbmUgdGhlIHR3byBwaWVjZXMgb2YgY29kZSB0aGF0IHVzZSB0aGVzZSBiZWZvcmUgaW1wbGVtZW50aW5nIHRoZXNlIGFzIG9wdGlvbnNcbiAqIFNpbmNlIHdlIGNsb3NlIDxwPiB3aXRoaW4gdGhlIHRleHQgb2JqZWN0IGJ1bGxldHMsIGl0cyBzbGlnaHRseSBtb3JlIGRpZmZpY3VsdCB0aGFuIGNvbWJpbmluZyBpbnRvIGEgZnVuYyBhbmQgY2FsbGluZyB0byBnZXQgdGhlIHBhcmFQcm9wXG4gKiBhbmQgaSdtIG5vdCBzdXJlIGlmIGFueW9uZSB3aWxsIGV2ZW4gdXNlIHRoZXNlLi4uIHNvLCBza2lwcGluZyBmb3Igbm93LlxuICovXG52YXIgQlVMTEVUX1RZUEVTO1xuKGZ1bmN0aW9uIChCVUxMRVRfVFlQRVMpIHtcbiAgICBCVUxMRVRfVFlQRVNbXCJERUZBVUxUXCJdID0gXCImI3gyMDIyO1wiO1xuICAgIEJVTExFVF9UWVBFU1tcIkNIRUNLXCJdID0gXCImI3gyNzEzO1wiO1xuICAgIEJVTExFVF9UWVBFU1tcIlNUQVJcIl0gPSBcIiYjeDI2MDU7XCI7XG4gICAgQlVMTEVUX1RZUEVTW1wiVFJJQU5HTEVcIl0gPSBcIiYjeDI1QjY7XCI7XG59KShCVUxMRVRfVFlQRVMgfHwgKEJVTExFVF9UWVBFUyA9IHt9KSk7XG4vLyBJTUFHRVMgKGJhc2U2NClcbmNvbnN0IElNR19CUk9LRU4gPSAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFHUUFBQUIzQ0FZQUFBRDFvT1ZoQUFBR0FVbEVRVlI0WHUyZFQweGNSUnpIZjd0QVlTc2MwRUJTSXEyeEVnOG10VEdlYlZ6RXFPVklvbHowc2lSRTRnR1RTdHFLd2RwV3NYb3lHaE11eUFWSk9IQmdxeXZMTmdvbkRrYWJlQ0JZVy84a1RVcjB3c0pDK1dmbTBiZnV2bjM3Wm5iZW05bVI5MzAzbUpuZi9QYjdlZDk1TTdQREk1SklKUFlKVjVFQzdlM3QxTi9mVDYydHJkcVZpUUNJdStiVmdwSUhFby9IcWJlM1Yvc2RZVktIeVdTU1ptWm04aWxWQTBvZXlOalltRW5hVkMyWHZyNitxZzVmQU9KQXo0RFUxZFVSR3pGU3FaUlZxdE1wQUZJR3lNaklDQzB2TDlQRXhJUldLQURpQVlUTnNoWVdGclJDQVJBT0VGWmNDS1d0clkwR0JnYVVUWWtCUkFDSUU0cktad3FBQ0FMUjVSUUFxUUNJRHFjQVNJVkFWRHNGUUNTQXFIUUtnRWdDVWVVVUFQRUJSSVZUQU1RbkVCdks1T1FrYlc5dms5OTFDb0FFQU1RSnhjODZCVUFDQWhLVVV3QWtRQ0JCT0FWQUFnYmkxeWtBb2dDSUg2Y0FpQ0lnc2s0QkVJVkFaSndDSUlxQlZMcWlCeEFOUUZnWFMwdExORDQremwwOEFvZ21JRzVPU1NRUzFnR0t3Z3RBTkFJUmNRcUFhQWJDZTZZQVNCV0EyRTZ4RHlleURVbDcrQUtRTWtEWVlldm01bVpIYWJBL0xpNHVVaWFUc1lMYXU4UUE0Z0xFL2hVN3dhanlZdHYxaFJlREFpQU94UWNIQnltYnphcms0QmtiUUtvbS9YOGRwOU5wbXBxYXNuNEJJQVlBWVNuWXArNEJCRUFNVWNDd05PQ1FzQUtabnA2Mk50UU93OFdtd1QwOVBVbytpamFIc09NeDdHcHBhYUg2K25vbEgwWjEwSzJ0TFZwZFhiVzZVZlYzbU5xQmRIZDNVMU5UazJydGxNUmZXMXVqMmRsWkFGR2lya1JRQUpFUVRXVVRBRkdwcmtSc0FKRVFUV1VUQUZHcHJrUnNBSkVRVFdVVEFGR3Bya1JzQUpFUVRXVVRBRkdwcmtSc0FKRVFUV1VUQUZHcHJrUnNBSkVRVFdVVEFHSHFybThjYVB6UTBXQzFsb2diZWlDN1gzeEptMFB2VW1Semg0NWN1a2kxNTg4RkFtVm45Qk82UDN5Rjl1dHJxR0gwTXRXODJTOFVOOVJBOXYvNGs3SW5qaGNKRlRzL1RMVlhMd21KVjY3Uzd2RDd0SEY1cEtpNDZmWWRvc2RPY09PR0c4ajFPY3FlZmJGRUpEOVEzR0N3RGhxVDMxSGtsUzRBOFZSZ2ZZTTJPcDZrM2J0L0JRSmw1OEo3bFB2d2c1SllOY2NlcGFNcnkwTFBxRkE3aENtMzkrTk55cDJKMDE3MmIxOVF5c0dJTmo1Q3NSdHBpajU3bXVzT1ZpSDBRUEpRWG42Sjl1N2RsWUpTRmtick1Zb2xyd3ZEQUpBQytXV2RFcFF6N0ZUZ0VDZVVDcHppNll4dnZxWG9NNmVFaHFuQ1NnRGlrRXpVS1VFN0F3N3h1SGN0S0I1T1lVM2RabE5SOXN5UWRBYUFjQVlUQzBwWEYrMzljMDlvMklrKzNFcXhWS3FpQjdoYllBeFprazRwYkJhRU0rQVFvZnYrd1RyRnd5bEJPUU5BQklHd2F2ZGZlNE8ycGc1ZWxPKzg2bDk5blk1OC9WVUYwYnlyWXNqaVNGbHVObFhZck9IY0JhcjcrRW9nVUFERVEwWVJHSGJ6b0tBQVNCa2cyKzljcE0xclYwdEsyUU9jWFc3YkxFRkFBUkFYSUY0dzJEckRXb2VVV2FmNGhRSWdEaUE4R1BaMmlOZmkwUThVQUNrQUlnckRickozODVlRHhhUExMckVzRkFCNW9HNmxNUEpRUExaWlpLQUFDQkdWaGNHMlErYm11THUybms1NWU0anFQdjFJZUVvY2VpQmVYN3MyekNhNU1BcWRzdGw5MXZmWHdhRUdzdi9yYjVUdE9GazZ0V1hPdUpHaDZLbW5oTzlzYXlyTW5pblB4MTAzSkJ0WGJsSGtpY2U1OGNJTlpQNEh5cjV3cGtna2RpQ2hFbWM0Rldhekx6ZW5OS2EvcDBqbmN3RGlxY0Q2QnVXZVBrMDd0MWFzYXRaR29ZUXpTcUE0bkZKN3NvTmlQLytFVXlmYzI1R0kyR0c1M2RIUHJLbzFnLzFDdzRwSVhMcnpPKzFjKy93Zzd0QmJGRGxlL0ViUWNqRkNQV1FKQ2F1NUVvQm9GcHpYSFlEd0ZOSmNEaUNhQmVkMUJ5QThoVFNYQTRobXdYbmRBUWhQSWMzbEFLSlpjRjUzQU1KVFNITTVnR2dXbk5jZGdQQVUwbHdPSUpvRjUzVUhJRHlGTkpjZlNpQ2RuWjBVaThVMFN4bE1kN2xjanVibjU2MWdoK1kxc2NGSVUvMG8vM3NnZUxPMTJFMms3VVhLWXVtZ0ZvQVlkZzhBQ0lBWXBvQmg2Y0FoQUdLWUFvYWxBNGNBaUdFS0dKWU9IQUlnaGlsZ1dEcHdDSUFZcG9CaDZjQWhBR0tZQW9hbEE0Y0FpR0VLR0pZT0hBSWdoaWxnV0Rwd0NJQVlwb0JoNlpRNEpCNlBLenZpWXRobk55NGQ5aCsxTTVtTWxWY2trVWpzRzVkaGlCTUNFTVBnL3d1T2ZyWlovUlN5d1FBQUFBQkpSVTVFcmtKZ2dnPT0nO1xuY29uc3QgSU1HX1BMQVlCVE4gPSAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUI0QUFBQVZuQ0FZQUFBQ3pmSERWQUFBQVlIcFVXSFJTWVhjZ2NISnZabWxzWlNCMGVYQmxJR1Y0YVdZQUFIamFWY2pKRFlBd0RFWEJ1NnVnaEJmSCtZbkxRU3dTSFZBK1lya3d4N0h0UEhhYkh1RVdyUStsQkJBWjZUTXdlQldvQ3dVSDhxdVpINlZXRlhWVDY5Nnp4cDEyQVJrVkZFcW44d0I4QUFBQUNYQklXWE1BQUM0akFBQXVJd0Y0cFQ5MkFBRFpMa2xFUVZSNDJ1emRkNWhWOVowLzhNK2RtY3NVWm1Eb3ZZT2hLQ2lLWWhSN0pKdW9TVENXR0ZJMFdVeGlqQm9UVFhhelZseXphNG1hWW05clRSU0ppZ1ZzcUNETlFoSEJBb2dLQ0VnUk1qTU1VKzd2ajkzc0w4a3FDbExtblB0NlBZK1BlWFpNOXZQOXZPOGpaK1k5NTV4TWZKTGpvckJyUk11U2dtaVZpeWpOMUVlMm9TQ3l1Y2JJQkFBQUFBQUFBQURiWGFZZ2NvV05VWmNyaXJwTWJkUnN5c2E2OXdiRityZ2dHcmY0Mzl2U0Y3c2VGMTJhRlVUbnh2b29zR0lBQUFBQUFBQ0FYYWNnb3FFZ0YrKy9WUmdyNHI1bytLaC9wdkQvL0Y4dWlJSStMYVBydW0vRVh6cXVpMmIxZGRIR0tnRUFBQUFBQUFCMnJWeEVRV01tV3JRdGpIWmxBNk4ydzJ0Ujg0Ly96UDhwZ0h1M2liNk5CZEcremRxb3JLNktWVVhaYUI4NWozc0dBQUFBQUFBQWFBb2FHNk93SUJkdHluZVAyUEJhYlB6YnIvMWRBZHgzVkhSdHlFU0hpSWhjWXpRckxvN1dtVnprY2ptUGdBWUFBQUFBQUFCb1NncHkwZUlmUytEL0xZRDdmeTNhYkM2SW5uLzdYMmhzakVMbEx3QUFBQUFBQUVEVDlEOGxjTTFmSHdkZEZCRnh5QVZSOU02ODZQVnAvZ2ZxYXlLaUppTHFMQk1BQUFBQUFBQmdoOGhHUkdsRVVla24vNlBGRWIzaWtOZ1FrNk8rS0NKaTZkem9rc3Y4My9jQi8xWDl4b2lhSmRtb1d4bFJWMWRrMlFBQUFBQUFBQUE3UVRaYkg5bXVFUlg5NnY3bjl0Ny9xNkV4aW5xM2k4NkxJOTRwak9PaXNIVXUrdVl5a2Ztb2Y3aCtZOFNhNmFWUnQ3NGdHaHM5RFJvQUFBQUFBQUJnWjJsc0xJaTY5UVd4ZVVVbVNqczAvdmVkd1I4aGs0dXlkU2ZFK3dWZDZxT3lNZk14Ny9tdGo5andVdGJqbmdFQUFBQUFBQUIyb2JycW9sZzdJeHRSLzlGZmI0d283UDVHdEN3b2JSYVZIL2MvVXZObU51cXFQZklaQUFBQUFBQUFZRmVycXk2S21qZXpIL3Yxa3Rwb1ZaQnIvUGdDZU1ON3lsOEFBQUFBQUFDQXBtSkxIVzVqVVZRV05EU1ArUTNaZUxjbzRpOS8rOFg2dGVIUnp3QUFBQUFBQUFCTlNkMy9kTG4vb0xBb3FxSXVWaFhGeGhoU0dCL3hxR2psTHdBQUFBQUFBRUNUVTFlVGphSy9LWFNMSXY3U1dCK2JjNWtvOVl4bkFBQUFBQUFBZ0FUSkZ2MzkzYnoxRWVWLy9jOEYxZ01BQUFBQUFBQ1FEZ3BnQUFBQUFBQUFnSlJRQUFNQUFBQUFBQUNraEFJWUFBQUFBQUFBSUNVVXdBQUFBQUFBQUFBcG9RQUdBQUFBQUFBQVNBa0ZNQUFBQUFBQUFFQktLSUFCQUFBQUFBQUFVa0lCREFBQUFBQUFBSkFTQ21BQUFBQUFBQUNBbEZBQUF3QUFBQUFBQUtTRUFoZ0FBQUFBQUFBZ0pSVEFBQUFBQUFBQUFDbWhBQVlBQUFBQUFBQklDUVV3QUFBQUFBQUFRRW9vZ0FFQUFBQUFBQUJTUWdFTUFBQUFBQUFBa0JJS1lBQUFBQUFBQUlDVVVBQURBQUFBQUFBQXBJUUNHQUFBQUFBQUFDQWxGTUFBQUFBQUFBQUFLYUVBQmdBQUFBQUFBRWdKQlRBQUFBQUFBQUJBU2lpQUFRQUFBQUFBQUZKQ0FRd0FBQUFBQUFDUUVncGdBQUFBQUFBQWdKUlFBQU1BQUFBQUFBQ2toQUlZQUFBQUFBQUFJQ1VVd0FBQUFBQUFBQUFwb1FBR0FBQUFBQUFBU0FrRk1BQUFBQUFBQUVCS0tJQUJBQUFBQUFBQVVrSUJEQUFBQUFBQUFKQVNDbUFBQUFBQUFBQ0FsRkFBQXdBQUFBQUFBS1NFQWhnQUFBQUFBQUFnSlJUQUFBQUFBQUFBQUNtaEFBWUFBQUFBQUFCSUNRVXdBQUFBQUFBQVFFb29nQUVBQUFBQUFBQlNRZ0VNQUFBQUFBQUFrQklLWUFBQUFBQUFBSUNVVUFBREFBQUFBQUFBcElRQ0dBQUFBQUFBQUNBbEZNQUFBQUFBQUFBQUthRUFCZ0FBQUFBQUFFZ0pCVEFBQUFBQUFBQkFTaWlBQVFBQUFBQUFBRkpDQVF3QUFBQUFBQUNRRWdwZ0FBQUFBQUFBZ0pSUUFBTUFBQUFBQUFDa2hBSVlBQUFBQUFBQUlDVVV3QUFBQUFBQUFBQXBvUUFHQUFBQUFBQUFTQWtGTUFBQUFBQUFBRUJLS0lBQkFBQUFBQUFBVWtJQkRBQUFBQUFBQUpBU0NtQUFBQUFBQUFDQWxGQUFBd0FBQUFBQUFLU0VBaGdBQUFBQUFBQWdKUlRBQUFBQUFBQUFBQ21oQUFZQUFBQUFBQUJJQ1FVd0FBQUFBQUFBUUVvb2dBRUFBQUFBQUFCU1FnRU1BQUFBQUFBQWtCSUtZQUFBQUFBQUFJQ1VVQUFEQUFBQUFBQUFwSVFDR0FBQUFBQUFBQ0FsRk1BQUFBQUFBQUFBS2FFQUJnQUFBQUFBQUVnSkJUQUFBQUFBQUFCQVNpaUFBUUFBQUFBQUFGSkNBUXdBQUFBQUFBQ1FFZ3BnQUFBQUFBQUFnSlJRQUFNQUFBQUFBQUNraEFJWUFBQUFBQUFBSUNVVXdBQUFBQUFBQUFBcG9RQUdBQUFBQUFBQVNBa0ZNQUFBQUFBQUFFQktLSUFCQUFBQUFBQUFVa0lCREFBQUFBQUFBSkFTQ21BQUFBQUFBQUNBbEZBQUF3QUFBQUFBQUtTRUFoZ0FBQUFBQUFBZ0pSVEFBQUFBQUFBQUFDbWhBQVlBQUFBQUFBQklDUVV3QUFBQUFBQUFRRW9vZ0FFQUFBQUFBQUJTUWdFTUFBQUFBQUFBa0JJS1lBQUFBQUFBQUlDVVVBQURBQUFBQUFBQXBJUUNHQUFBQUFBQUFDQWxGTUFBQUFBQUFBQUFLYUVBQmdBQUFBQUFBRWdKQlRBQUFBQUFBQUJBU2lpQUFRQUFBQUFBQUZKQ0FRd0FBQUFBQUFDUUVncGdBQUFBQUFBQWdKUlFBQU1BQUFBQUFBQ2toQUlZQUFBQUFBQUFJQ1VVd0FBQUFBQUFBQUFwb1FBR0FBQUFBQUFBU0FrRk1BQUFBQUFBQUVCS0tJQUJBQUFBQUFBQVVrSUJEQUFBQUFBQUFKQVNDbUFBQUFBQUFBQ0FsRkFBQXdBQUFBQUFBS1NFQWhnQUFBQUFBQUFnSlJUQUFBQUFBQUFBQUNtaEFBWUFBQUFBQUFCSUNRVXdBQUFBQUFBQVFFb29nQUVBQUFBQUFBQlNRZ0VNQUFBQUFBQUFrQklLWUFBQUFBQUFBSUNVVUFBREFBQUFBQUFBcElRQ0dBQUFBQUFBQUNBbEZNQUFBQUFBQUFBQUthRUFCZ0FBQUFBQUFFZ0pCVEFBQUFBQUFBQkFTaWlBQVFBQUFBQUFBRkpDQVF3QUFBQUFBQUNRRWdwZ0FBQUFBQUFBZ0pSUUFBTUFBQUFBQUFDa2hBSVlBQUFBQUFBQUlDVVV3QUFBQUFBQUFBQXBvUUFHQUFBQUFBQUFTQWtGTUFBQUFBQUFBRUJLS0lBQkFBQUFBQUFBVWtJQkRBQUFBQUFBQUpBU0NtQUFBQUFBQUFDQWxGQUFBd0FBQUFBQUFLU0VBaGdBQUFBQUFBQWdKUlRBQUFBQUFBQUFBQ21oQUFZQUFBQUFBQUJJQ1FVd0FBQUFBQUFBUUVvb2dBRUFBQUFBQUFCU1FnRU1BQUFBQUFBQWtCSUtZQUFBQUFBQUFJQ1VVQUFEQUFBQUFBQUFwSVFDR0FBQUFBQUFBQ0FsRk1BQUFBQUFBQUFBS2FFQUJnQUFBQUFBQUVnSkJUQUFBQUFBQUFCQVNpaUFBUUFBQUFBQUFGSkNBUXdBQUFBQUFBQ1FFZ3BnQUFBQUFBQUFnSlJRQUFNQUFBQUFBQUNraEFJWUFBQUFBQUFBSUNVVXdBQUFBQUFBQUFBcG9RQUdBQUFBQUFBQVNBa0ZNQUFBQUFBQUFFQktLSUFCQUFBQUFBQUFVa0lCREFBQUFBQUFBSkFTQ21BQUFBQUFBQUNBbEZBQUF3QUFBQUFBQUtTRUFoZ0FBQUFBQUFBZ0pSVEFBQUFBQUFBQUFDbWhBQVlBQUFBQUFBQklDUVV3QUFBQUFBQUFRRW9vZ0FFQUFBQUFBQUJTUWdFTUFBQUFBQUFBa0JJS1lBQUFBQUFBQUlDVVVBQURBQUFBQUFBQXBJUUNHQUFBQUFBQUFDQWxGTUFBQUFBQUFBQUFLYUVBQmdBQUFBQUFBRWdKQlRBQUFBQUFBQUJBU2lpQUFRQUFBQUFBQUZKQ0FRd0FBQUFBQUFDUUVncGdBQUFBQUFBQWdKUlFBQU1BQUFBQUFBQ2toQUlZQUFBQUFBQUFJQ1VVd0FBQUFBQUFBQUFwb1FBR0FBQUFBQUFBU0FrRk1BQUFBQUFBQUVCS0tJQUJBQUFBQUFBQVVrSUJEQUFBQUFBQUFKQVNDbUFBQUFBQUFBQ0FsRkFBQXdBQUFBQUFBS1NFQWhnQUFBQUFBQUFnSlJUQUFBQUFBQUFBQUNtaEFBWUFBQUFBQUFCSUNRVXdBQUFBQUFBQVFFb29nQUVBQUFBQUFBQlNRZ0VNQUFBQUFBQUFrQklLWUFBQUFBQUFBSUNVVUFBREFBQUFBQUFBcElRQ0dBQUFBQUFBQUNBbEZNQUFBQUFBQUFBQUthRUFCZ0FBQUFBQUFFZ0pCVEFBQUFBQUFBQkFTaWlBQVFBQUFBQUFBRkpDQVF3QUFBQUFBQUNRRWdwZ0FBQUFBQUFBZ0pSUUFBTUFBQUFBQUFDa2hBSVlBQUFBQUFBQUlDVVV3QUFBQUFBQUFBQXBvUUFHQUFBQUFBQUFTQWtGTUFBQUFBQUFBRUJLS0lBQkFBQUFBQUFBVWtJQkRBQUFBQUFBQUpBU0NtQUFBQUFBQUFDQWxGQUFBd0FBQUFBQUFLU0VBaGdBQUFBQUFBQWdKUlRBQUFBQUFBQUFBQ21oQUFZQUFBQUFBQUJJQ1FVd0FBQUFBQUFBUUVvb2dBRUFBQUFBQUFCU1FnRU1BQUFBQUFBQWtCSUtZQUFBQUFBQUFJQ1VVQUFEQUFBQUFBQUFwSVFDR0FBQUFBQUFBQ0FsRk1BQUFBQUFBQUFBS2FFQUJnQUFBQUFBQUVnSkJUQUFBQUFBQUFCQVNpaUFBUUFBQUFBQUFGSkNBUXdBQUFBQUFBQ1FFZ3BnQUFBQUFBQUFnSlJRQUFNQUFBQUFBQUNraEFJWUFBQUFBQUFBSUNVVXdBQUFBQUFBQUFBcG9RQUdBQUFBQUFBQVNBa0ZNQUFBQUFBQUFFQktLSUFCQUFBQUFBQUFVa0lCREFBQUFBQUFBSkFTQ21BQUFBQUFBQUNBbEZBQUF3QUFBQUFBQUtTRUFoZ0FBQUFBQUFBZ0pSVEFBQUFBQUFBQUFDbWhBQVlBQUFBQUFBQklDUVV3QUFBQUFBQUFRRW9vZ0FFQUFBQUFBQUJTUWdFTUFBQUFBQUFBa0JJS1lBQUFBQUFBQUlDVVVBQURBQUFBQUFBQXBJUUNHQUFBQUFBQUFDQWxGTUFBQUFBQUFBQUFLYUVBQmdBQUFBQUFBRWdKQlRBQUFBQUFBQUJBU2lpQUFRQUFBQUFBQUZKQ0FRd0FBQUFBQUFDUUVncGdBQUFBQUFBQWdKUlFBQU1BQUFBQUFBQ2toQUlZQUFBQUFBQUFJQ1VVd0FBQUFBQUFBQUFwb1FBR0FBQUFBQUFBU0FrRk1BQUFBQUFBQUVCS0tJQUJBQUFBQUFBQVVrSUJEQUFBQUFBQUFKQVNDbUFBQUFBQUFBQ0FsRkFBQXdBQUFBQUFBS1NFQWhnQUFBQUFBQUFnSlJUQUFBQUFBQUFBQUNtaEFBWUFBQUFBQUFCSUNRVXdBQUFBQUFBQVFFb29nQUVBQUFBQUFBQlNRZ0VNQUFBQUFBQUFrQklLWUFBQUFBQUFBSUNVVUFBREFBQUFBQUFBcElRQ0dBQUFBQUFBQUNBbEZNQUFBQUFBQUFBQUthRUFCZ0FBQUFBQUFFZ0pCVEFBQUFBQUFBQkFTaWlBQVFBQUFBQUFBRkpDQVF3QUFBQUFBQUNRRWdwZ0FBQUFBQUFBZ0pSUUFBTUFBQUFBQUFDa2hBSVlBQUFBQUFBQUlDVVV3QUFBQUFBQUFBQXBvUUFHQUFBQUFBQUFTQWtGTUFBQUFBQUFBRUJLS0lBQkFBQUFBQUFBVWtJQkRBQUFBQUFBQUpBU0NtQUFBQUFBQUFDQWxGQUFBd0FBQUFBQUFLU0VBaGdBQUFBQUFBQWdKUlRBQUFBQUFBQUFBQ21oQUFZQUFBQUFBQUJJQ1FVd0FBQUFBQUFBUUVvb2dBRUFBQUFBQUFCU1FnRU1BQUFBQUFBQWtCSUtZQUFBQUFBQUFJQ1VVQUFEQUFBQUFBQUFwSVFDR0FBQUFBQUFBQ0FsRk1BQUFBQUFBQUFBS2FFQUJnQUFBQUFBQUVnSkJUQUFBQUFBQUFCQVNpaUFBUUFBQUFBQUFGSkNBUXdBQUFBQUFBQ1FFZ3BnQUFBQUFBQUFnSlJRQUFNQUFBQUFBQUNraEFJWUFBQUFBQUFBSUNVVXdBQUFBQUFBQUFBcG9RQUdBQUFBQUFBQVNBa0ZNQUFBQUFBQUFFQktLSUFCQUFBQUFBQUFVa0lCREFBQUFBQUFBSkFTQ21BQUFBQUFBQUNBbEZBQUF3QUFBQUFBQUtSRWtSVUFBQUN3clVwTFN3dUdEUnZXZk1DQUFTMjZkdTNhdkt5c3JMaWlvcUtrWmN1V3paczFhMWJjdkhuejB0TFMwckpzTnR1c3VMaTRlYk5telVvTENnbys4L2VpalkyTjlaczNiNjZwcmEydHFxdXIyMXhUVTFOZFZWVlZzMm5UcHRxTkd6ZFdiZGl3b2VZdmYvbkw1aFVyVmxRdFdMQmd3NnhaczZwcWFtb2FKUVlBQUVEYUtZQUJBQUNJaUlnaFE0YVVIblRRUVczNzl1M2JxbDI3ZHEzYXQyL2Zwa1dMRnEyYk4yOWVXVnBhMnFwWnMyYk5Dd3NMbTJlejJmTEN3c0x5b3FLaThzTEN3dEtrbksraG9hRzZ2cjYrcXFHaDRTOTFkWFYvYVdob3FOcThlWE5WVFUzTnVxcXFxdlViTm14WXUyclZxaldyVjY5ZTk5WmJiNjE3N3JublBwZ3paMDZOVHdZQUFBQkpvZ0FHQUFESUE4T0dEV3QreEJGSGRCd3dZRUNuTGwyNmRHamR1blhIRmkxYWRDZ3RMZTFZVWxMU3ZsbXpacTBLQ2dxSzA3eUR3c0xDc3NMQ3dyS0lhUGRwL3p1TmpZMjFtemR2WHJkcDA2WlZOVFUxNzIvWXNHSGwyclZyMzErMmJObktCUXNXckhqeXlTZmZuelZyVnBWUEdBQUFBRTFGcHVleHNkOUhmYUYrWmNTYWwwcHRDQUFBSUFFNmRlcVVQZjc0NHp2dHVlZWVYYnAzNzk2bGJkdTJYU29yS3p1WGxwWjJLUzB0N1ZCWVdGaGhTenRHUTBQRHhwcWFtcFUxTlRYTDE2OWZ2K3lERHo1WTlzNDc3eXliUFh2MnNqLzk2VThyVnF4WVVXZExBQUFBYkU5dDlxNkpvZzRmL1RVRk1BQUFRRUprczluTXQ3Lzk3WTRqUm96bzFiZHYzOTd0MnJYclhsNWUzcldzckt4emNYRngrNGdvc0tVbXA3RzJ0blpWVFUzTnNvMGJOeTVidFdyVjB0ZGZmLzJ0SjU5OGN2Rzk5OTY3Mm5vQUFBRFlGZ3BnQUFDQWhQbmU5NzdYNmE5RmIvdjI3WHUxYk5teVYxbFpXYThrdlhPWExhdXZyOS93bDcvOFpkRzZkZXNXTDF1MmJOSENoUXNYL2ZHUGYxdzhkZXJVamJZREFBREFsaWlBQVFBQW1xaHNOcHM1OWRSVHV4eDY2S0g5Ky9UcDg3bjI3ZHYzTHk4djcxOVVWT1NSelhscTA2Wk5Lelp1M1BqNisrKy8vOGFiYjc3NXhxT1BQdnJHM1hmZnZjcG1BQUFBK0NzRk1BQUFRQk54NnFtbmR2bmlGNzg0cUhmdjN2M2J0V3YzdVlxS2lzOFZGaGFXMnd4YlVsOWZ2MzdEaGcxdmZQREJCNjh2WHJ6NGpjY2VlMnoralRmZXVOeG1BQUFBOHBNQ0dBQUFZQmM0NXBoalduL3JXOS9hcTMvLy9rUGF0R25UdjZLaW9wOUhPTE85TkRRMFZHL2N1UEd0Tld2V0xGeTRjT0djTys2NDQ1V0hIbnBvcmMwQUFBQ2tud0lZQUFCZ0p6ampqRE82ZitsTFg5cXJWNjllZzF1M2JqMm9yS3lzUjBSa2JJYWRKRmRkWGIxMDNicDE4eGN2WGp6MzBVY2ZmZVhxcTY5K3gxb0FBQURTUndFTUFBQ3duWldXbGhiODZsZS8ydTNRUXc4ZDFyMTc5MzFidG13NXFMQ3dzTXhtYUVvYUdocXFQL3p3dy9udnZQUE96R2VlZVdiVzJMRmozNmlwcVdtMEdRQUFnR1JUQUFNQUFHd0hQLzd4ajd0KzlhdGYzYmRYcjE1RDI3WnR1MWMybTIxakt5UkpYVjNkbWc4KytPQ1ZSWXNXdmZ6blAvOTV4aC8rOElkbHRnSUFBSkE4Q21BQUFJQnRjT0tKSjdZNzVaUlREdWpYcjkrdzFxMWJEODFtczYxc2hUU3BxNnRidDNidDJwZmZmUFBOV2JmY2NzdlVlKys5ZDdXdEFBQUFOSDBLWUFBQWdFK2hvcUtpNElJTExoZzBZc1NJL2JwMjdicGZ5NVl0QjJZeW1VS2JJUi9rY3JtR0R6LzhjUDY3Nzc0NzQvbm5uNTl4NFlVWHZyWng0MGFQaXdZQUFHaUNGTUFBQUFBZjQvampqMi83L2U5Ly84RCsvZnNmMkxwMTYzMEtDZ3BLYkFVaUdoc2JONjFmdjM3ZVcyKzlOZVdHRzI1NDV1Njc3MTVsS3dBQUFFMkRBaGdBQU9CL1pMUFp6QVVYWFBDNUk0ODg4c0R1M2JzZldGRlJzVnRFRk5nTWJGbDFkZldTZDk5OWQ4cXNXYk5tbm52dXVTK3ZXN2V1d1ZZQUFBQjJEUVV3QUFDUTEwcExTd3N1dmZUU1FZY2Njc2pCWGJ0MkhWRldWdGJEVm1EYjFkYldybnIvL2ZkZm1EcDE2dVJmL3ZLWEw2NWV2YnJlVmdBQUFIWWVCVEFBQUpCM0JnMGFWSHJCQlJkOGZzODk5enl3UTRjT0J4UVZGYld3RmRqK0doc2JhOWV1WFR0cnpwdzVUNTkvL3ZtVFgzNzU1V3BiQVFBQTJMRVV3QUFBUUY0WU5teFk4L1BPTysvZ0lVT0dIT1o5dnJEei9XMFpmTkZGRnowN2E5YXNLbHNCQUFEWS9oVEFBQUJBYXJWcTFhcnd5aXV2M0hmRWlCRWpPM1RvY0ZCaFlXR1pyY0N1MTlEUVVQMysrKzgvTzJYS2xJay8rY2xQWm03Y3VMSFJWZ0FBQUxZUEJUQUFBSkFxclZxMUt2enRiMys3LzM3NzdYZDR4NDRkUnhRV0ZwYmJDalJkRFEwTkc5OS8vLzBwTTJiTWVPcUhQL3poQzhwZ0FBQ0F6MFlCREFBQXBNSlpaNTNWNDV2Zi9PYVJ2WHIxR2xsYVd0clZSaUI1YW1wcTNsMjhlUEhFTysrOGM5TFZWMS85am8wQUFBQnNQUVV3QUFDUVdNT0hEeSsvNktLTHZqQjQ4T0NqVzdSb01kQkdJRDArL1BERFYrZk5temZodlBQT2UzTDY5T2wvc1JFQUFJQlBSd0VNQUFBa1NxdFdyUXB2dU9HR1EvYmJiNzkvYXRPbXpYNlpUQ1pySzVCZXVWeXViczJhTlRObXpKangySmd4WXlhdlc3ZXV3VllBQUFBK25nSVlBQUJJaEIvLytNZGR2L2U5NzMybFo4K2UvMVJjWE56V1JpRC8xTmJXZnZEMjIyOC9kc3N0dHp6MDI5Lys5bDBiQVFBQStMOFV3QUFBUUpOVlVWRlJjTzIxMTM3KzRJTVBQcloxNjliN1pUS1pBbHNCSXFKeHpabzFNNTkvL3ZueHA1MTIyaFIzQlFNQUFQeC9DbUFBQUtESk9lV1VVenFlZnZycHgvYnUzZnRMMld5MmpZMEFINmUrdm43ajBxVkxIL3ZkNzM3M3grdXZ2MzZaalFBQUFQbE9BUXdBQURRSjJXdzJjK3V0dHg1d3lDR0huTkM2ZGV1OUk4TGR2c0RXYUZ5N2R1MUwwNlpOKy9PUGZ2U2paMWV2WGwxdkpRQUFRRDVTQUFNQUFMdFUvLzc5UzY2NTVwcC8yblBQUFk4dEx5L3ZheVBBWjFWVFU3TnN3WUlGNDg4OTk5d0hwMDZkdXRGR0FBQ0FmS0lBQmdBQWRvbWYvL3puUFU4NTVaUVR1M2J0ZW1SaFlXR1pqUURiVzJOalk5MktGU3Vldk9XV1crNjg5TkpMRjlrSUFBQ1FEeFRBQUFEQVR1TXh6OEN1c243OStybFBQLzMwZjUxODhzbFQ2K3JxY2pZQ0FBQ2tsUUlZQUFEWTRmcjI3VnY4aHovODRhK1BlZTVuSThDdVVsTlQ4KzY4ZWZQdS84RVBmdkRnd29VTE45a0lBQUNRTmdwZ0FBQmdoeGt5WkVqcE5kZGM4OVhCZ3dlZldGeGMzTUZHZ0thaXRyWjIxZHk1YysvNXlVOSs4dWM1YytiVTJBZ0FBSkFXV3lxQVBZb05BQURZSnFOSGorNHdiOTY4bjA2Wk11WFJZY09HbmFIOEJacWE0dUxpOXNPR0RUdGp5cFFwajg2Yk4rK25KNTEwVW50YkFRQUEwczRkd0FBQXdGWTU5OXh6ZTMzLys5Ly9kdWZPblkvSVpESlpHd0dTSXBmTDFTMWZ2dnpKRzI2NDRmYkxMcnZzYlJzQkFBQ1N5aU9nQVFDQXoreTg4ODdyKzUzdmZPZmJIVHQyUER5VHlSVGFDSkJVdVZ5dVljV0tGVS9jZE5OTi8vWHJYLzk2c1kwQUFBQkpvd0FHQUFDMjJXV1hYVGJvRzkvNHhnOWF0MjQ5ekRhQXRGbTdkdTJzdSsrKys5cHp6am5uTmRzQUFBQ1NRZ0VNQUFCc05jVXZrRThVd1FBQVFKSW9nQUVBZ0U5TjhRdmtzN1ZyMTg2NjU1NTdydnY1ejM4KzN6WUFBSUNtYWtzRmNHSGx3T2o2VVY5b3JJcW9XWkcxUFFBQXlCTy8rTVV2ZXQ5eHh4M25ISHJvb1Q4cExTM3RZaU5BUGlvdExlMnk3Nzc3SHZQOTczKy9YMWxaMlpJcFU2YXNzeFVBQUtDcEtldGNId1hsSC8wMUJUQUFBT1M1TTg0NG8vdTk5OTU3enBlLy9PV2ZsWmVYOTRxSWpLMEFlUzVUWGw3ZTgrQ0REeDcxL2U5L3YzZEV2RFZqeG93UHJRVUFBR2dxRk1BQUFNRC9jZUtKSjdhNzc3NzdmakpxMUtoL0tTOHY3eE9LWDRCL2xDa3ZMKzk5K09HSGovcld0NzdWZnZYcTFRdm56NTlmYlMwQUFNQ3V0cVVDMkR1QUFRQWd6d3dkT3JUcyt1dXZQNmwvLy80bkZSWVdsdGtJMjBOalkyTnMyclFwcXF1cm82YW1KdXJyNjJQVHBrMnhlZlBtcUsrdmorcnE2cWl2cjQvTm16ZkhwazJib3FHaFladi9meFVXRmtaSlNVazBhOVlzaW9xS29xeXNMSXFLaXFKWnMyWlJVbElTUlVWRlVWcGErcjkvRlJRVUNJanRvcUdob2VxMTExNjdhOHlZTWZmTW1UT254a1lBQUlCZFpVdnZBRllBQXdCQW51alVxVlAybm52dUdiWFhYbnVkbk0xbUsyMkVqOVBRMEJBYk4yNk1EUnMyL0orL05tN2NHQnMzYm95YW1wcll0R2xUYk5xMEtXcHFhcUsydHJiSm5xZTR1RGhLU2txaXRMVDBmLzllVVZFUkZSVVYwYUpGaS8velYwVkZSUlFXRnZvZzhMSHE2dXJXdnZqaWk3ZWNlT0tKZjE2OWVuVzlqUUFBQUR1YkFoZ0FBUExjWFhmZGRkQVh2L2pGMDB0TFM3dlpSbjdMNVhLeFljT0dXTHQyYmF4YnR5N1dybDM3ZDMrdFc3Y3VObXpZa1BkN2F0R2lSYlJ1M1RwYXRXb1ZyVnUzampadDJ2enZmMjdkdW5XMGFOSENoNG1vcnE1ZStzZ2pqMXp6bmU5OFo2cHRBQUFBTzVNQ0dBQUE4dFRWVjE4OStNUVRUenl6b3FKaW9HM2tqOGJHeGxpNWNtVXNYNzQ4UHZqZ2cxaTlldlgvL24zdDJyWFIyTmhvU1o5UllXRmh0R3JWS3RxMWF4ZHQyN2I5Mzc5Mzd0dzVPblRvNExIVGVXYkRoZzN6NzczMzNxdk9QUFBNZWJZQkFBRHNEQXBnQUFESU0xLzcydGZhWEhycHBhZDI3OTc5cUlqUVJLVlVRME5EckZxMUtsYXNXQkh2di8vKy8vNTk1Y3FWVGZxUnpHbFhYRndjSFRwMGlJNGRPMGJuenAyalk4ZU8wYWxUcDJqWHJwMUhTNmRZTHBkcmZPZWRkeDc2K2M5L2Z2MkVDUlBXMlFnQUFMQWpLWUFCQUNCUDlPclZxOWxkZDkzMWpUMzIyT003aFlXRlpUYVNIaDkrK0dHODg4NDdzWFRwMG5qdnZmZGl4WW9Wc1hyMTZtaG9hTENjaENnc0xJejI3ZHRIcDA2ZG9sdTNidEc5ZS9mbzNyMjd4MG1uVEVORFE5VzhlZk51KytZM3YvbkhKVXVXYkxZUkFBQmdSMUFBQXdCQUhyanJycnRHL05NLy9kT1pKU1VsWFd3ajJkYXZYeDlMbHk2TmQ5NTU1MzlMM3c4Ly9OQmlVcXF5c3ZKL3krQy8vdFdxVlN1TFNiaWFtcHBsanozMjJHOUdqeDQ5eFRZQUFJRHRUUUVNQUFBcDlxdGYvYXJQRDMvNHc1KzFhdFZxTDl0SW5vMGJOOGFTSlV2aXJiZmVpa1dMRnNWNzc3MFhtelp0c3BnOFYxSlNFbDI3ZG8wK2ZmcEUzNzU5bzNmdjNsRmVYbTR4Q2JSdTNicVhyNzMyMml2R2poMjd5RFlBQUlEdFJRRU1BQUFwTkdqUW9OSTc3cmpqdTd2dHR0dEpCUVVGV1J0Smh0V3JWOGViYjc0Wml4Y3ZqaVZMbHNUeTVjdWpzYkhSWXRpaWdvS0M2Tnk1Yy9UdTNUdDY5KzRkL2ZyMWk3WnQyMXBNUWpRMk50YTk4Y1liZDMzclc5KzZmZjc4K1RVMkFnQUFmRllLWUFBQVNKSFMwdEtDQng5ODhKajk5dHZ2bjdQWmJCc2JhYm9hR2hyaTdiZmZqcmZlZWlzV0xGZ1FTNVlzY1hjdjIwMUZSVVgwNnRVcit2YnRHMzM3OW8yZVBYdEdZV0doeFRSaGRYVjFhMmJNbUhIalY3N3lsWWRxYW1yODVnY0FBTERORk1BQUFKQVNwNTkrZXJkZi92S1g1MVpXVnU1akcwM1Q2dFdyNDdYWFhvdUZDeGZHbTIrK0dSczNiclFVZG9vV0xWcEUzNzU5WThDQUFURnc0RUIzQ0RkaDY5ZXZmL0UvL3VNLy92UHFxNjkreHpZQUFJQnRvUUFHQUlDRUd6Um9VT205OTk3N3c5NjlleCtieVdUYzR0ZUVyRisvUHViTm14Y0xGaXlJTjk1NFErRkxrOUdpUll2bzE2OWZEQmd3SVBiWVk0K29yS3kwbENZa2w4czFMRjY4ZU55Sko1NTRyY2RDQXdBQVcwc0JEQUFBQ1hiTk5kY01PZW1razM1UlZsYld5eloydlZ3dUYrKysrMjdNblRzM1hudnR0Vml5WklsMytOTGtGUlFVUks5ZXZXTFFvRUV4ZVBEZzZOYXRtNlUwRWRYVjFVdnV2dnZ1WC8va0p6K1pZeHNBQU1DbnBRQUdBSUFFT3Vxb28xcjk5cmUvL1ZtSERoME90NDFkYTlPbVRURjc5dXlZTzNkdUxGeTRNS3FxcWl5RlJHdmV2SG4wNzk4L0JnOGVISHZ1dVdlVWxKUll5aTYyY3VYS3AwNC8vZlRMSjB5WXNNNDJBQUNBVDZJQUJnQ0FoQmszYnR3UlJ4eHh4Rm5aYkxhTmJld2FWVlZWTVhmdTNKZzdkMjdNbno4L2FtdHJMWVZVS2k0dWpvRURCOGJnd1lOajhPREJVVjVlYmltN1NGMWQzWnFubm5ycXFsR2pSajFoR3dBQXdKWW9nQUVBSUNGT09lV1VqaGRkZE5Fdlc3ZHV2Wjl0N0h3clY2Nk1XYk5teGR5NWMrT2RkOTZKWEM1bktlU2R6cDA3eDk1Nzd4M0RoZzJMRGgwNldNZ3VzSGJ0Mmhubm5YZmVwYmZjY3N2N3RnRUFBSHdVQlRBQUFEUnhwYVdsQlU4OTlkUTNCdzhlL0wyQ2dnTFBZdDJKVnF4WUVTKzk5Rks4OU5KTHNYejVjZ3VCdi9IWE1uanZ2ZmVPVHAwNldjaE8xTmpZdUdudTNMazNIMzc0NFhmVjFOUjQwVGdBQVBCM0ZNQUFBTkNFalI0OXVzT2xsMTc2eXpadDJneTNqWjFqL2ZyMThlS0xMOGJNbVROajZkS2xGZ0tmUXMrZVBXUGZmZmVOWWNPR1JZc1dMU3hrSjFtelpzMEw1NTU3N3EvdnZ2dnVWYllCQUFEOGxRSVlBQUNhb0lxS2lvS0pFeWQrYy9EZ3dkOHZLQ2dvdHBFZGE4T0dEZkhpaXkvRzlPblRsYjd3R2ZYbzBTT0dEeDhldzRZTmk0cUtDZ3Zad2R3TkRBQUEvQ01GTUFBQU5ER25uSEpLeDdGangvNXJaV1hsTU52WWNlcnI2K1BWVjErTkdUTm14THg1ODZLdXJzNVNZRHZLWnJNeFpNaVEySGZmZldQMzNYZVB3c0pDUzltQjFxNWRPK01Ydi9qRnY5OTU1NTByYlFNQUFQS2JBaGdBQUpxSWJEYWJlZUtKSjQ3Zlo1OTlmdVN1M3gwamw4dkZ3b1VMWS9yMDZURjc5dXpZdEdtVHBjQk9VRnBhR2tPR0RJbmh3NGZIZ0FFRExHUUhhV2hvcUo0MmJkbzFSeDU1NUo5dEF3QUE4cGNDR0FBQW1vRGpqeisrN1pWWFh2bXIxcTFiZTlmdkRyQm16WnFZTm0xYXpKdzVNMWF1ZEhNYzdFb2RPM2FNejMvKzg3SC8vdnQ3WC9DTyszZmV0RFBQUFBPU2NlUEdmV0FiQUFDUWZ4VEFBQUN3aTkxMDAwMzdIWHZzc2Y5V1hGemMxamEybjF3dUY2Kzk5bG84Ly96ek1XL2V2S2l2cjdjVWFFS0tpb3BpenozM2pCRWpSc1RuUHZlNXlHUXlscklkMWRiV3J2cmpILzk0OFE5KzhJTlp0Z0VBQVBsRkFRd0FBTHZJa0NGRFN1Ky8vLzV6dW5UcDhrKzJzZjJzWGJzMkprK2VITk9uVDQ4UFAvelFRaUFCS2lzclk4U0lFWEhJSVlkRWVYbTVoV3hIeTVZdGUrenJYLy82Zjg2Wk02ZkdOZ0FBSUQ5c3FRQXVyQndZWFQvcUM0MVZFVFVyc3JZSEFBRGI2SUlMTHRqdDk3Ly8vVlZ0MnJRWlpodmJ4K0xGaTJQOCtQRng5OTEzeHh0dnZCRzF0YldXQWdteGFkT21lT09OTitMWlo1K050V3ZYUnBzMmJUd2VlanRwMGFKRnY1Tk9PdW1nMHRMU3VjOCsrK3hhR3dFQWdQUXI2MXdmQlIvenU3WHVBQVlBZ08wc204MW1KazJhOVBWaHc0YjlwS0Nnd0c5VmZrWjFkWFV4WThhTWVPYVpaK0s5OTk2ekVFaVJmdjM2eFNHSEhCSkRodzZOZ29JQ0MvbU1HaHNiTjgrWU1lT2FMMzd4aStQcTZ1cHlOZ0lBQU9ubEVkQUFBTENUSEgvODhXMnZ1dXFxQ3lvcksvZXhqYzltelpvMThkUlRUOFhVcVZOajA2Wk5GZ0lwVmxGUkVaLy8vT2Zqc01NT2k4cktTZ3Y1ak5hdlh6L3I5Tk5QdjNEY3VIRWYyQVlBQUtTVEFoZ0FBSGFDMjI2NzdmTmYrOXJYenN0bXM1VzJzZTBXTFZvVWp6LytlTXliTnk5eU9UZXdRVDRwS2lxS0lVT0d4QkZISEJHOWUvZTJrTStncnE1dTNRTVBQSERSeVNlZlBNMDJBQUFnZlJUQUFBQ3dBMVZVVkJROC9mVFRwd3djT1BDVVRDYmpHYWJiSUpmTHhhdXZ2aHBQUHZsa0xGeTQwRUlnejJVeW1SZ3dZRUFjY2NRUk1XalFJQXZaOW4rM05zNmZQLytXd3c4Ly9KYU5HemMyMmdnQUFLVEhsZ3Jnd3NxQjBmV2p2dEJZRlZHend1dktBQUJnUzA0ODhjUjJFeVpNdUx4NzkrNWZ6bVF5R1J2Wk9vMk5qVEZyMXF5NDlkWmI0OGtubjR3UFB2QzBVdUMvclY2OU9tYk1tQkZ6NXN5SjB0TFM2TlNwVS9qWDdOYkpaREtaOXUzYkQvMys5NzgvZFBueTVUTmZmZlhWYWxzQkFJQjBLT3RjSHdYbEgvTzlnRHVBQVFCZzI5eDY2NjM3SDN2c3NSY1dGUlcxc0kydFUxTlRFMDg5OVZROCsreXpzV0hEQmdzQlBsR0xGaTNpNElNUGpzTVBQenhLUy8yOFltdlYxOWQvT0c3Y3VQTlBQdm5rNmJZQkFBREo1eEhRQUFDd0hXV3oyY3l6eno3N3JTRkRodnpBSTUrM3pxWk5tMkx5NU1ueDFGTlBLWDZCYmRLaVJZczQ3TERENHBCRERsRUViNlZjTHRmd3lpdXZYSGZvb1lmZVdWZFg1eVhyQUFDUVlBcGdBQURZVG80NTVwalcxMTEzM2NXVmxaVjcyOGFudDJIRGhuajg4Y2RqeXBRcFVWdGJheUhBWjFaY1hCd0hIbmhnZlBHTFg0d1dMVHlJWVd1c1diTm0ycmUvL2Uzem4zbm1HYitKQXdBQUNlVWR3QUFBc0IxY2Z2bmx1MTkwMFVXL0xTOHY3MmNibjA1VlZWVk1tREFoYnJubGxuanp6VGVqb2FIQlVvRHRvcUdoSVpZc1dSTFBQZmRjMU5UVVJJOGVQU0tiOVhPTVQ2T3NyS3piMTcvKzlTUGJ0bTA3NzRrbm5saHRJd0FBa01EcmV1OEFCZ0NBeitiaGh4Lys4cUdISG5wT1FVRkJzVzE4c2syYk5zVXp6endUVHp6eFJGUlZWVmtJc01PVmw1ZkhrVWNlR1ljY2NrZ1VGL3RYOWFmUjJOaTQ2ZW1ubi83MU1jY2M4N2h0QUFCQXNuZ0VOQUFBYktOMjdkb1ZUWjQ4K1l4ZXZYb2RaeHVmcks2dUxwNSsrdW1ZT0hHaTRoZllKU29xS3VLTFgveGlISHp3d2U0SS9wUVdMVnIweDRNT091aWFkZXZXZVV3REFBQWtoRWRBQXdEQU5qajIyR1BiUHZ6d3c3L3AyTEhqb2JheFpYVjFkZkhrazAvR2RkZGRGM1Buem8yNnVqcExBWGFKelpzM3gydXZ2UmJQUGZkY1JFVDA2TkVqQ2dzTExXWUxXcmR1dmZ2M3Z2ZTlmZDkrKysxcEN4WXNxTFlSQUFCbytyYjBDR2dGTUFBQWZJVExMNzk4OXdzdXVPQjN6WnMzNzJVYkg2K3hzVEdtVEprUzExOS9mYnp5eWl1S1g2REoyTHg1Y3l4WXNDQ21UNThleGNYRjBhMWJ0OGhrTWhiek1VcEtTanA4K2N0ZlBySnQyN1p6dkJjWUFBQ2FQdThBQmdDQXJUQisvUGdqdi9DRkwveExRVUZCaVcxOHZBVUxGc1Q0OGVOajZkS2xsZ0UwZVQxNjlJaXZmT1VyTVdqUUlNdllnc2JHeHBxSkV5ZGVjdXl4eHo1cEd3QUEwSFI1QnpBQUFId0s3ZHExSzNydXVlZCsxcU5IajYvYXhzZGJ0R2hSM0gvLy9iRjQ4V0xMQUJLblY2OWVjZHh4eDBXZlBuMHNZd3VXTGwzNjU0TU9PdWp5MWF0WDE5c0dBQUEwUGQ0QkRBQUFuMkRZc0dITm4zNzY2VjkzNnRUcEM3YngwVFpzMkJEMzNYZGYvUEdQZjR5MWE5ZGFDSkJJNjlldmoyblRwc1c2ZGV1aVo4K2VVVkxpWVE4ZnBiS3lzdiszdi8zdC9sT21USm15ZlBseXovY0hBSUFteGp1QUFRQmdDMzcyczUvMXVQNzY2Njl0MGFLRjU0SitoSnFhbWhnL2ZuemNmUFBOOGZiYmIwY3VsN01VSU5GeXVWeTg4ODQ3OGN3enowUlZWVlgwN3QwN3Nsay9BL2xIWldWbDNVNDg4Y1RENitycVpreWZQdjFER3dFQWdDWjB2YTRBQmdDQWozYkZGVmZzY2RaWloxMWRYRnpjd1RiK1hpNlhpeGt6WnNSMTExMFhDeFlzaU1iR1Jrc0JVcVd4c1RHV0xGa1NNMmJNaVBMeTh1alNwVXRrTWhtTCtSdlpiTGJGUVFjZGRIaWJObTFtUC9IRUU2dHRCQUFBbW9ZdEZjRGVBUXdBUU42YU5HblNxQU1PT09Ec1RDWlRhQnQvYjlHaVJYSFBQZmZFdSsrK2F4bEEzdWpXclZ1Y2ROSkowYnQzYjh2NEI3bGNybTd5NU1tLy92S1h2L3lJYlFBQXdLNjNwWGNBSzRBQkFNZzdwYVdsQlRObnpqeXpUNTgreDl2RzM5dXdZVU9NR3pjdVpzeVk0VkhQUUY3S1pES3gzMzc3eGRlLy92V29xS2l3a0grd2FOR2lQKzI3Nzc1WDFkVFVlQ3dFQUFEc1FncGdBQUQ0SDkyNmRjdE9uano1VjUwNmRScHBHLzlmTHBlTHFWT254cC8vL09mWXVIR2poUUI1cjZLaUlrYU5HaFg3NzcrL3gwTC9nK1hMbHo5KzZLR0hYdkx1dSsvVzJRWUFBT3dhV3lxQXZRTVlBSUM4TVh6NDhQSW5ubmppeW5idDJvMndqZi92blhmZWlXdXZ2VGFlZSs2NTJMeDVzNFVBUk1UbXpadGp6cHc1OGRwcnIwWFBuajJqUllzV2x2SS9LaW9xK243clc5OGFNblhxMU9mZWUrODlmM0FBQU1BdXNLVjNBQ3VBQVFESUM5Lys5cmM3M243NzdYOW8wYUxGQU52NGIxVlZWWEhYWFhmRnZmZmVHK3ZYcjdjUWdJK3didDI2ZVA3NTUyUDkrdld4MjI2N1JWRlJrYVZFUkVsSlNlZmpqanZ1b0E4KytHREtLNis4OGhjYkFRQ0FuVXNCREFCQVhqdi8vUFA3WFh6eHhYOG9LU25wYkJ2L2JmcjA2WEh0dGRmR29rV0xMQVBnVTNqbm5YZGkyclJwMGJwMTYramMyUjhuRVJIWmJMYnlDMS80d2hFbEpTVXZUcDQ4ZVkyTkFBREF6cU1BQmdBZ2IvM3VkNy9iNjBjLyt0RlZSVVZGcld3allzMmFOWEh6elRmSHBFbVRvcmEyMWtJQXRrSnRiVzI4OU5KTDhjNDc3MFRmdm4yanRMUTA3M2RTV0ZoWU5uejQ4Qy8yNmRObjRVTVBQYlRNcHdRQUFIWU9CVEFBQUhucDFsdHYzZitiMy96bWZ4WVdGamJQOTEza2NybDQvdm5uNC9ycnI0L2x5NWY3Y0FCOEJpdFhyb3hwMDZaRlJVVkZkT3ZXTFRLWlRGN3ZvNkNnSUR0bzBLQkRCdzBhdE9pQkJ4NTR4eWNFQUFCMnZDMFZ3Sm1leDhaK0gvV0YrcFVSYTE3eW02d0FBQ1RUd3c4Ly9LWEREanZzWHpLWlRONi9yUEdERHo2STIyKy9QZDU0NHcwZkRJRHRiTUNBQWZHdGIzMHIyclJway9lN3lPVnlqVk9tVFBuMXlKRWpIL0xKQUFDQUhhdk4zalZSMU9HanY2WUFCZ0FnZFY1NTVaWFRQdmU1ejMwcjMvZlEwTkFRanozMldEeisrT05SVjFmbmd3R3dnMlN6MlRqNjZLUGpDMS80UWhRVUZPVDlQbDUvL2ZVNzl0cHJyOS83WkFBQXdJNmpBQVlBSUM5a3M5bk15eSsvZkZhZlBuMk96L2RkdlB2dXUzSGJiYmZGZSsrOTU0TUJzSk4wNjlZdHZ2T2Q3MFMzYnQzeWZoZExsaXk1ZjU5OTlybXlwcWFtMFNjREFBQzJQd1V3QUFDcFYxcGFXakJyMXF5emV2ZnVmVncrN3lHWHk4V1RUejRaRHo3NG9MdCtBWGFCYkRZYnh4eHpUQnh4eEJGNWZ6ZncwcVZMSHhnNmRPamxTbUFBQU5qK0ZNQUFBS1JhcjE2OW1rMmVQSGxzdTNidERzcm5QYXhjdVRKdXVlV1dlUHZ0dDMwb0FIYXhuajE3eGltbm5CSWRPblRJNnoyc1hyMTZ5aUdISFBJdlM1WXMyZXhUQVFBQTI4K1dDdURDeW9IUjlhTyswRmdWVWJNaWEzc0FBRFJwUTRjT0xYdnFxYWN1YjlPbXpmNzV1b05jTGhmUFBQTk1YSC85OWJGMjdWb2ZDb0FtWVAzNjlURmx5cFFvS1NtSm5qMTdSaWFUeWNzOU5HL2V2UHRKSjUwMFpQTGt5YytzV0xIQ295a0FBR0E3S2V0Y0h3WGxILzAxQlRBQUFJazFaTWlRMGtjZWVlU0tWcTFhN1oydk82aXVybzdiYjc4OW5uamlpV2hzOUlSTmdLYWtzYkV4NXMrZkgrKy8vMzRNR0RBZ3N0bjgvRGxMYVdscHA2OTk3V3VEbjNycXFhZFhybHhaNzVNQkFBQ2ZuUUlZQUlEVU9mVFFRMXM4K09DRHYyL1pzdVVlK2JxRE9YUG14TlZYWCsyUnp3Qk4zUExseStPRkYxNklqaDA3NXUwam9VdExTenVkY01JSis3LzAwa3RQdi8zMjI3VStGUUFBOE5rb2dBRUFTSlZodzRZMXYrKysrMzdUc21YTFFmbDQvdnI2K2hnL2Zuejg4WTkvak5wYVAwTUhTSUxObXpmSGl5KytHSnMzYjQ3ZGR0c3RDZ29LOG00SHhjWEZiWTg2NnFnOW4zdnV1YWVYTDEvdWNkQUFBUEFaS0lBQkFFaU5JNDg4c25MY3VIRy9iOUdpeGNCOFBQOTc3NzBYVjExMVZjeVpNOGVIQVNDQkZpMWFGQysvL0hMMDY5Y3ZXclJva1hmbkx5a3A2WERjY2NmdFAyZk9uR2NXTFZxMHlTY0NBQUMyalFJWUFJQlVPUExJSXl2dnZQUE8zNWFYbCsrV2orZC8rdW1uNDhZYmI0d1BQL3pRaHdFZ3dmN3lsNy9FQ3krOEVDVWxKZEdyVjYrOE8zK3paczNhSEhYVVVmc3BnUUVBWU5zcGdBRUFTTHhqanoyMjdXMjMzZmFINXMyYjk4bTNzMWRWVmNYTk45OGNUejMxVkRRMk52b3dBS1JBWTJOanpKOC9QNVl0V3hZREJneUlaczJhNWRYNW16VnIxdWFZWTQ0NThNMDMzM3htNGNLRk5UNFJBQUN3ZFJUQUFBQWsycUdISHRyaXR0dHV1em9meTkrMzMzNDdycm5tbWxpOGVMRVBBa0FLdmYvKysvSEtLNjlFbno1OW9yS3lNcS9PbnMxbUs0ODg4c2g5WnM2YytkVFNwVXMzK3pRQUFNQ25wd0FHQUNDeGpqamlpSmIzM252dnRlWGw1ZjN5NmR5NVhDNG1UWm9VTjk5OGMxUlZWZmtnQUtSWVZWVlZUSjA2TmJMWmJQVHAweWN5bVV6ZW5MMjR1TGp0VjcvNjFjKy84c29yVHkxZXZMaldwd0VBQUQ0ZEJUQUFBSWwwNktHSHRyajMzbnQvbDIvbGIzVjFkZHgwMDAweGVmTGt5T1Z5UGdnQWVTQ1h5OFdDQlF2aTNYZmZqZDEzM3oyeTJmejVtVXl6WnMxYUgzMzAwZnZObURIalNYY0NBd0RBcDZNQUJnQWdjWVlPSFZvMmZ2ejRxeXNxS2diazA3bVhMVnNXVjExMWxVYytBK1NwbFN0WHhpdXZ2QktmKzl6bm9xS2lJbS9PM2F4WnN6WkhIMzMwMEdlZWVlYkpGU3RXMVBra0FBREFsaW1BQVFCSWxDRkRocFErK3VpajE3UnMyWEwzZkRyMzFLbFQ0OXBycjQyTkd6ZjZFQURrc2FxcXFwZytmWHEwYmRzMnVuVHBramZuTGlrcGFUOXExS2loVHo3NTVKTXJWNjZzOTBrQUFJQ1B0NlVDdU1CNkFBQm9TanAxNnBTZE1HSEN2MWRXVnU2UkwyZHViR3lNY2VQR3hSMTMzQkYxZFc1NkFpQ2l0clkyYnI3NTVoZy9mbncwTmpibXpia3JLeXYzbURCaHdyOTM2OWJOWFFrQUFMQ05GTUFBQURRWnJWcTFLcHcrZmZvbGJkcTAyVDlmemx4ZFhSMi8rOTN2WXRLa1NkNzNDOERmeWVWeThmampqOGZ2Zi8vN3FLNnV6cHR6dDJuVFp2OHBVNlpjMHFwVnEwS2ZBZ0FBMkhvS1lBQUFtb1NLaW9xQzJiTm5YOUt1WGJ1RDh1WE1TNWN1allzdXVpam16NS92QXdEQXgzcjExVmZqb29zdWlxVkxsK2JObWR1MWEzZlE3Tm16LzcyaW9zTFByZ0FBWUN1NWlBWUFvRW1ZT1hQbXo5cTFhM2RJdnB6MzVaZGZqaXV1dUNMV3JWc25mQUErMGJwMTYrS0tLNjZJbDE5K09XL08zSzVkdTRObnpwejVNK2tEQU1EV1VRQURBTERMdmZqaWkyTjY5T2d4S2gvT21zdmw0b0VISG9nYmJyZ2hhbXRyaFEvQXAxWmJXeHMzM0hCRFBQREFBM256Mm9BZVBYcU1ldkhGRjhkSUh3QUFQajBGTUFBQXU5U2tTWk8rTm5EZ3dGUHk0YXgxZFhWeDg4MDN4OFNKRTczdkY0QnRrc3ZsWXVMRWlYSExMYmRFWFYxZFhweDU0TUNCSjArYU5PbHIwZ2NBZ0U5SEFRd0F3Qzd6NktPUEhuWGdnUWVla3c5blhiZHVYZno2MTcrT1diTm1DUjZBejJ6bXpKbng2MS8vT2w5ZUpaQTU4TUFEejNuMDBVZVBrandBQUh5eXdzcUIwZldqdnRCWUZWR3pJbXREQUFEc0VEZmVlT08rUng5OTlFV1pUS1l3N1dkZHZueDVYSFhWVmJGeTVVckJBN0RkYk5pd0lXYlBuaDBEQnc2TWlvcUt0QjgzMDcxNzkvMTc5dXo1NnNNUFA3eGMrZ0FBNUx1eXp2VlJVUDdSWDFNQUF3Q3cwMTF4eFJWN2ZQZTczNzJxb0tDZ1dkclBPbWZPblBqdGIzOGJHemR1RkR3QTIxMTFkWFZNbXpZdE9uZnVIQjA3ZGt6MVdUT1pUT0h1dSs5K2VKczJiVjZhTkduU0t1a0RBSkRQRk1BQUFEUVpaNXh4UnZlZi9leG52eTBzTEN4UCsxa25USmdRZDk5OWQ5VFgxd3NlZ0IybW9hRWhYbnJwcGNobXM5RzNiOTlVbnpXVHlSVHR0ZGRlQi8zbEwzOTVkdWJNbVJ1a0R3QkF2bElBQXdEUUpCeDAwRUVWZi9qREg2NHBMaTd1bE9aejVuSzVlT0NCQitLeHh4NFRPZ0E3N2MrZUJRc1dSRjFkWGZUdjN6OHltVXhxejFwUVVGQnl3QUVIREpzK2ZmcWtwVXVYYnBZK0FBRDVhRXNGY0lIMUFBQ3dNd3dhTktqMHZ2dnV1N3Fzckt4WG1zOVpWMWNYMTExM1hVeWFORW5vQU94MEV5ZE9qT3V2dno3cTZ1cFNmYzZ5c3JKZWYvclRuNjd1Mzc5L2lkUUJBT0R2S1lBQkFOamhLaW9xQ2g1NzdMR0xLeW9xQnFiNW5OWFYxWEhOTmRmRTdObXpoUTdBTHZQS0s2L0VsVmRlR1ZWVlZhaytaNHNXTFFaT25EaHhiRVZGaFo5dkFRREEzM0NCREFEQURqZHo1c3lmdFczYjlzQTBuM0hkdW5WeDJXV1h4UnR2dkNGd0FIYTV4WXNYeDJXWFhSWnIxNjVOOVRuYnRXdDM0TXlaTTM4bWNRQUErUDhVd0FBQTdGQlBQdm5rcUI0OWVveEs4eGxYclZvVlYxeHhSU3hmdmx6Z0FEUVpLMWFzaUN1dXVDSldybHlaNm5QMjZORmoxS1JKazBaSkhBQUEvbHRoNWNEbytsRmZhS3lLcUZtUnRTRUFBTGJaalRmZXVPK1h2dlNsQ3pPWlRHcC84ZkRkZDkrTks2KzhNdGF0V3lkd0FKcWM2dXJxbURWclZ2VHYzejhxS3l0VGU4NXUzYm9ONzltejU3eUhIMzdZYjJNQkFKQVh5anJYUjBINVIzOU5BUXdBd0E1eDNubm45VDMxMUZPdkxpZ29LRTdyR1Y5NzdiVzQ1cHByb3JxNld1QUFORm1iTjIrT0dUTm1SSThlUGFKOSsvYXBQR01ta3lrWU5HalFJWVdGaFZPZWUrNDV2NVVGQUVEcUtZQUJBTmlwampycXFGYi84Ui8vOFlkbXpacTFTdXNaWDM3NTViaisrdXVqcnE1TzRBQTBlUTBORGZIU1N5OUZwMDZkb2xPblRxazhZMEZCUVhiWXNHR2ZuejkvL3FRMzNuaGprOVFCQUVpekxSWEEzZ0VNQU1CMjFhMWJ0K3dOTjl6d255VWxKUjNUZXNZcFU2YkVqVGZlR1BYMTlRSUhJREhxNit2anhodHZqS2xUcDZiMmpDVWxKWjF1dU9HRy8raldyWnU3R2dBQXlGc0tZQUFBdHF1bm4zNzZYeW9ySy9kSTYva21UWm9VZDk1NVp6UTJOZ29iZ01ScGJHeU1PKzY0STU1ODhzblVuckd5c25MdzAwOC8vVXRwQXdDUXJ4VEFBQUJzTjg4Ly8vdzN1blRwOGs5cFBkL0VpUk5qM0xoeGtjdmxoQTFBWXVWeXViai8vdnRUWFFKMzZkTGxTODgrKyt5SjBnWUFJQjk1QnpBQUFOdkZUVGZkTlB6SUk0ODhMNVBKWk5KNHZzY2VleXpHang4dmFBQlM0N1hYWG90bXpacEYzNzU5VTNtK3pwMDc3OXVyVjY5NUR6Lzg4REpwQXdDUU5sdDZCN0FDR0FDQXord1h2L2hGN3gvKzhJZFhGeFFVTkV2aitSNTQ0SUY0NUpGSEJBMUE2aXhZc0NEcTZ1cGl3SUFCcVR0YkpwUEpEQm8wNk9ER3hzYm5wazZkdWw3YUFBQ2tpUUlZQUlBZDVvQUREcWo0M2U5Kzk5dG16WnExVGVQNXhvMGJGNU1tVFJJMEFLbTFhTkdpMkx4NWN3d2NPREIxWnlzb0tNanV0OTkrdzU1NzdybkgzM3Z2dmMzU0JnQWdMYlpVQUhzSE1BQUEyeXlieldidXZQUE9meWt0TGUyZXh2Tk5tREJCK1F0QVhwZzBhVkk4OU5CRHFUeGJhV2xwajN2dXVlZGZzdGxzUnRJQUFPUURCVEFBQU52cytlZWYvMDZIRGgwT1RlUFpIbjc0NFhqNDRZZUZERURlZU9TUlIrTFBmLzV6S3MvV29VT0h3NTU5OXRsdlN4a0FnSHlnQUFZQVlKdmNkOTk5aHc4ZVBQalVOSjd0L3Z2dmp3a1RKZ2daZ0x6ejJHT1B4WDMzM1pmS3MrMjU1NTQvK05PZi9uU1lsQUVBU0R2dkFBWUFZS3VkY2NZWjNjZU1HWE41UVVGQmNkck9ObkhpeEhqa2tVZUVERURlV3J4NGNXU3oyZWpidDIvYWpwYnAwNmZQdm4vNXkxOG16NXc1YzRPa0FRQklzaTI5QTFnQkRBREFWaGsyYkZqekcyKzg4US9ObWpWcmw3YXpQZnJvbzZsOTlDVUFiSTJGQ3hkR1VWRlI5T3ZYTDFYbktpZ29LRDd3d0FQM2UvTEpKeDlkc1dKRm5hUUJBRWlxTFJYQUhnRU5BTUJXdWZmZWUzOVpXbHJhUFczbmV2enh4K1BCQng4VU1BRDhqei8vK2M4eGNlTEUxSjJydExTMHgzMzMzZmRMQ1FNQWtGWUtZQUFBUHJWSmt5YU42dFNwMHhFcFBGZU1Iejlld0FEd0Q4YVBIeCtUSjA5TzNiazZkZXIwaFVtVEpuMVZ3Z0FBcEpGSFFBTUE4S21jZDk1NWZVODg4Y1IvejJReVJXazYxOHlaTStQdXUrOFdNQUI4ak5kZWV5MDZkdXdZblR0M1R0VzV1bmJ0dWs5QlFjSHp6ejMzM0RvcEF3Q1FOTjRCREFEQVozTEVFVWUwdk9LS0s2N05ack9WYVRyWHl5Ky9IRGZmZkhQa2Nqa2hBOERIeU9WeU1YdjI3T2pTcFV0MDZ0UXBOZWZLWkRKRisreXp6L0NwVTZjKzl1Njc3MjZXTkFBQVNlSWR3QUFBYkxOc05wdTU1WlpiL3Eya3BLUmptczYxWU1HQ3VQbm1tNk94c1ZISUFQQUpHaHNiNCthYmI0NDMzM3d6VmVjcUxTM3RjdmZkZDUrZnpXWXpVZ1lBSUMwVXdBQUFiTkdrU1pPKzNyWnQyd1BUZEtabHk1YkZEVGZjRVBYMTlRSUdnRStwcnE0dXJyMzIybGkrZkhtcXp0V3VYYnNESDMvODhWRVNCZ0FnTFR3Q0dnQ0FqM1haWlpjTit1cFh2em8yazhtazVoY0gzMy8vL2JqeXlpdWpxcXBLd0FDd2xlcnE2dUxsbDErT0lVT0dSSGw1ZVdyTzFhVkxsMzFMUzB1blB2UE1NMnVrREFCQUVuZ0VOQUFBVzYxLy8vNGxKNTk4OHE4eW1VeFJXczYwWWNPRytQM3ZmeDhiTjI0VU1BQnNvNDBiTjhidmZ2ZTdWUDE1V2xCUWtQM2hEMzk0ZnQrK2ZZc2xEQUJBNHE5dnJRQUFnSS95NElNUG5sMVdWdFlyTGVlcHJxNk8zL3ptTjdGcTFTcmhBc0JudEdyVnFyanl5aXVqdXJvNk5XY3FLeXZyOC9EREQ1OGxYUUFBa2s0QkRBREEvekYrL1BnanUzWHJkblJhemxOZlg1L0tkeFlDd0s2MGZQbnl1TzY2NjZLK3ZqNDFaK3JSbzhkWHg0MGJkNFIwQVFCSU1nVXdBQUIvNTN2ZisxNm5JNDQ0NHB5MG5DZVh5OFZ0dDkwV2I3enhobkFCWUR0Ny9mWFg0N2JiYm90Y0xwZWFNeDE1NUpIbmZ2dmIzKzRvWFFBQWtrb0JEQURBLzZxb3FDaTQrT0tMTHl3c0xDeFB5NW5Hang4ZnMyYk5FaTRBN0NDelpzMktoeDU2S0RYbktTd3NyUGoxcjM5OVFVVkZoWitiQVFDUVNDNWtBUUQ0WHhNblRoeGRXVms1T0MzbmVmNzU1MlBpeEltQ0JZQWQ3TEhISG9zWFhuZ2hOZWVwckt6Yzg5RkhIejFSc2dBQUpGRmg1Y0RvK2xGZmFLeUtxRm1SdFNFQWdEeHh3UVVYN0RacTFLZ0xNNWxNWVJyTzgrcXJyOFl0dDl5U3FrZFNBa0JULzdPM2QrL2UwYTVkdTFTY3AyUEhqa056dWR4elU2Wk1XU2RkQUFDYW1yTE85Vkh3TWMvd2N3Y3dBQURSdDIvZjRoLy8rTWNYWnpLWlZQd0c0SHZ2dlJjMzNIQkRORFkyQ2hjQWRwS0dob2E0N3Jycll0bXlaYWs0VDBGQlFmYnNzODhlMjdkdjMyTHBBZ0NRcUd0Wkt3QUFZUHo0OFQ4cUt5dnJrWWF6Yk5pd0lYNy8rOTlIYlcydFlBRmdKOXUwYVZQOC92ZS9qNDBiTjZiaVBHVmxaYjNHalJzM1JySUFBQ1NKQWhnQUlNL2RkTk5Ody92MDZYTjhHczVTWDE4ZjExNTdiYXhkdTFhd0FMQ0xyRm16SnE2OTl0cW9yNjlQeFhuNjlldjNqZC8vL3ZkREpRc0FRRklvZ0FFQTh0aEJCeDFVY2V5eHgvNXJSR1RTY0o0NzdyZ2pGaTllTEZnQTJNVVdMVm9VZDk1NVoxcU9VL0NOYjN6ajM0WU5HOVpjc2dBQUpPSUMxZ29BQVBMWHpUZmZmRlp4Y1hHN05KeGw0c1NKTVgzNmRLRUNRQk14YmRxMG1EUnBVaXJPVWxKUzB1bk9PKzg4UTZvQUFDU0JBaGdBSUUvOTEzLzkxNEZkdW5UNVVock84dHBycjhXZi8veG5vUUpBRXpOKy9QaFlzR0JCS3M3U3JWdTNvMis2NmFiaFVnVUFvS2xUQUFNQTVLRXZmZWxMbFYvNXlsZCtsWWF6ckZpeElxNi8vdnBvYkd3VUxBQTBNWTJOalhIZGRkZkZpaFVyMG5DY3pISEhIZmVyZ3c0NnFFS3lBQUEwWlFwZ0FJQThkUFhWVjUrZXpXWXJrMzZPbXBxYXVQYmFhMlBUcGsxQ0JZQW1hdE9tVFhIdHRkZEdUVTFONHMrU3pXYmIzbmpqalQrUktnQUFUWmtDR0FBZ3o5eDY2NjNEdTNUcDh1V2tueU9YeThVdHQ5d1NLMWV1RkNvQU5IRXJWNjZNVzIrOU5YSzVYT0xQNGxIUUFBQTBkUXBnQUlBOE1uVG8wTEt2ZnZXcnYwakRXU1pNbUJCejU4NFZLZ0FreEp3NWMrS3h4eDVMeFZsR2pScjFpNkZEaDVaSkZRQ0Fwa2dCREFDUVIrNjQ0NDRmRlJjWGQwejZPVjUrK2VWNDVKRkhCQW9BQ2ZQUVF3K2w0aGU0U2twS090NXh4eDAvbENnQUFFMlJBaGdBSUU5Y2Z2bmx1L2ZzMlhOVTBzL3h3UWNmeEIxMzNKR0tSMGdDUUw3SjVYSngyMjIzeFpvMWF4Si9scDQ5ZXg1NytlV1g3eTVWQUFDYUdnVXdBRUFlNk5hdFcvYTczLzN1djJZeW1VUmYvOVhYMThjTk45d1ExZFhWUWdXQWhLcXFxb29iYjd3eDZ1dnJFMzJPVENaVDhOM3ZmdmRYM2JwMXkwb1ZBSUNtUkFFTUFKQUh4bzhmZjBwWldWbXZwSi9qbm52dWlhVkxsd29VQUJKdXlaSWxjZDk5OXlYK0hHVmxaVDNIang5L2lrUUJBR2hLRk1BQUFDbjM4NS8vdk9lQUFRTkdKLzBjMDZkUGp5bFRwZ2dVQUZKaTh1VEpNV1BHak1TZlk4Q0FBYU4vL3ZPZjk1UW9BQUJOaFFJWUFDREZzdGxzNXF5enpqbzNrOGtrK3RHRUsxYXNpTHZ2dmx1Z0FKQXlkOTExVjZ4WXNTTFJaOGhrTXRtenpqcnIzR3cybTVFb0FBQk5nUUlZQUNERnhvMGI5OFhLeXNxOWtueUcydHJhdU9HR0c2SzJ0bGFnQUpBeWYvMXpmdlBtellrK1IyVmw1VjdqeG8wYktWRUFBSm9DQlRBQVFFb05IejY4L09DRER6NHQ2ZWU0Ly83N1kvbnk1UUlGZ0pSYXZueDVqQnMzTHZIbkdERml4SStIRFJ2V1hLSUFBT3hxQ21BQWdKUzY5ZFpiVDh0bXMyMlRmSVlaTTJiRWM4ODlKMHdBU0xuSmt5Zkh6Smt6RTMyRzR1TGl0cmZmZnZ0cDBnUUFZRmRUQUFNQXBOQlZWMTIxUjQ4ZVBiNlM1RE9zWExreTdycnJMbUVDUUo2NCsrNjc0NE1QUGtqMEdYcjI3UG5WSzY2NFlnOXBBZ0N3S3ltQUFRQlNwclMwdE9BYjMvakdUNU44cmRmWTJCaTMzMzY3OS80Q1FCNnBxYW1KMjI2N0xSb2JHNU44aklKdmZ2T2JaNWFXbHZxWkd3QUF1KzZpMUFvQUFOSmx3b1FKWDZ1b3FCaVE1RE9NSHo4K0ZpMWFKRXdBeUROdnZ2bG1QUGpnZzRrK1E0c1dMUVk5K09DRHgwZ1RBSUJkUlFFTUFKQWlSeDU1Wk9Xd1ljTitrT1F6ekowN041NTQ0Z2xoQWtDZW1qaHhZaXhZc0NEUlp4ZytmUGlQampqaWlKYlNCQUJnVjFBQUF3Q2t5QlZYWEhGeVVWRlJSVkxucjZxcWlqdnZ2RE55dVp3d0FTQlA1WEs1dVAzMjI2TzZ1anF4WnlncUttcnhtOS84NW1ScEFnQ3dLeWlBQVFCUzR2enp6Ky9YdTNmdjQ1SjhodHR2dnowKy9QQkRZUUpBbmx1M2JsM2NmdnZ0aVQ1RDc5Njlqei8vL1BQN1NSTUFnSjFOQVF3QWtBTFpiRFp6NnFtbi9qeVR5U1QyK203NjlPa3haODRjWVFJQUVSRXhlL2JzbURGalJtTG56MlF5QmFlZWV1clBzOWxzUnBvQUFPeE1DbUFBZ0JUNDR4Ly9lRVJsWmVYZ3BNNi9kdTNhdVBmZWV3VUpBUHlkZSs2NUo5YXRXNWZZK1Nzckt3Zi82VTkvK29Ja0FRRFltUlRBQUFBSjE3ZHYzK0pERGpua1Iwayt3OTEzM3gwMU5UWENCQUQrVGsxTlRkeDk5OTJKUHNQQkJ4LzhvNzU5K3haTEV3Q0FuVVVCREFDUWNIZmRkZGMzUzBwS09pVjEvc21USjhlOGVmTUVDUUI4cExsejU4YXp6ejZiMlBsTFNrbzYzblBQUGQrU0pBQUFPNHNDR0FBZ3diNzBwUzlWRGh3NDhLU2t6cjltelpvWVAzNjhJQUdBTFhyZ2dRZGl6Wm8xaVoyL2YvLytKeDExMUZHdEpBa0F3TTZnQUFZQVNMQXJycmppMU1MQ3d2SWt6cDdMNWVLMjIyNkxUWnMyQ1JJQTJLSk5temJGYmJmZEZybGNMcEh6RnhZV2xsMSsrZVUva0NRQUFEdURBaGdBSUtGKzhZdGY5TzdldmZ0WGtqci9zODgrRzIrODhZWWdBWUJQNVkwMzNvam5uMzgrc2ZOMzY5YnQ2Ri85NmxkOUpBa0F3STZtQUFZQVNLZ2YvdkNIUDhwa01vbThudnZnZ3cvaWdRY2VFQ0lBc0ZYR2pSc1g2OWF0UytUc21VeW00TlJUVC8yeEZBRUEyTkVVd0FBQUNYVGRkZGNOYTlldTNZRkpuRDJYeThVZGQ5d1J0YlcxZ2dRQXRzcW1UWnZpemp2dlRPejhiZHEwMmYrbW0yN2FUNUlBQU94SUNtQUFnSVFwTFMwdCtOclh2blo2VXVkLzRZVVhZdUhDaFlJRUFMYkpxNisrR2pObXpFanMvTWNjYzh6cEZSVVZmaVlIQU1BTzQySVRBQ0JoYnIvOTlvTXJLaXAyUytMc0d6WnNpSEhqeGdrUkFQaE03ci8vL3FpcXFrcms3T1hsNVgzLzY3Lys2d2dwQWdDd295aUFBUUFTcEtLaW91Q3d3dzQ3TmFuejMzdnZ2WW45WVMwQTBIUnMyTEFoN3IvLy9zVE9mOUJCQi8xenExYXRDaVVKQU1DT29BQUdBRWlRKysrLy8raXlzcktlU1p4OXpwdzU4ZEpMTHdrUkFOZ3VYbmpoaFZpd1lFRWlaeTh0TGUzMnh6Lys4U3RTQkFCZ1IxQUFBd0FrUk4rK2ZZdjMzWGZmZjA3aTdMVzF0WEh2dmZjS0VRRFlydTYrKys2b3E2dEw1T3o3N2JmZktmMzc5eStSSWdBQTI1c0NHQUFnSVc2KytlWlJ4Y1hGYlpNNCt5T1BQQkpyMTY0VklnQ3dYYTFhdFNvZWUreXhSTTZleldiYjNuampqVitUSWdBQTI1c0NHQUFnQVlZT0hWcTIxMTU3ZlNlSnM3LzMzbnZ4eEJOUENCRUEyQ0VtVHB3WUsxYXNTT1RzUTRZTStjN1FvVVBMcEFnQXdQYWtBQVlBU0lCcnI3MzJ4S0tpb3Nxa3paM0w1ZUtlZSs2SnhzWkdJUUlBTzBSOWZYM2NkZGRka2N2bEVqZDdVVkZSNWJYWFhudUNGQUVBMko0VXdBQUFUZHdCQnh4UU1XREFnRzhrY2ZZWk0yYkVXMis5SlVRQVlJZDY4ODAzNDhVWFgwems3QU1HRFBqRzhPSER5NlVJQU1EMm9nQUdBR2ppcnJycXFoT0tpb29xa2piM3BrMmI0b0VISGhBZ0FMQlQzSC8vL1ZGYlc1dTR1WXVLaWxwY2ZmWFY3Z0lHQUdDN1VRQURBRFJoQngxMFVFWC8vdjBUZWZmdnd3OC9IQjkrK0tFUUFZQ2RZdjM2OVRGaHdvUkV6ajV3NE1CdkhIREFBUlZTQkFCZ2UxQUFBd0EwWWYvNW4vOTViR0ZoWWZPa3piMXExYXFZUEhteUFBR0FuZXJwcDUrTzFhdFhKMjd1d3NMQzhzc3V1MnlVQkFFQTJCNFV3QUFBVGRRQkJ4eFFNV2pRb05GSm5QM3V1KytPK3ZwNklRSUFPMVY5ZlgzY2RkZGRpWng5OTkxMy8rYlFvVVBMcEFnQXdHZWxBQVlBYUtJdXYvenlZd3NMQzh1VE52ZmN1WE5qd1lJRkFnUUFkb2tGQ3hiRTNMbHpFemQzVVZGUmk5Lzk3bmRmbHlBQUFKK1ZBaGdBb0FrYU9uUm8yYUJCZ3hMMzd0KzZ1cnI0MDUvK0pFQUFZSmY2MDUvK0ZIVjFkWW1iZS9mZGQvL21rQ0ZEU2lVSUFNQm5vUUFHQUdpQ2Z2T2IzM3lscUtpb1pkTG1mdTY1NXhMNTNqMEFJRjFXcjE0ZHp6MzNYT0xtTGlvcWFubjExVmNmTFVFQUFENExCVEFBUUJQVHExZXZab01IRC81bTB1YXVycTZPUng1NVJJQUFRSlB3eUNPUFJIVjFkZUxtSGpKa3lMZTZkZXVXbFNBQUFOdEtBUXdBME1UY2ROTk54eFFYRjdkTjJ0d1RKa3lJcXFvcUFRSUFUVUpWVlZVaWZ6bXR1TGk0M2EyMzN1b3VZQUFBdHBrQ0dBQ2dDV25WcWxYaFhudnRkVkxTNWw2MWFsVTgrK3l6QWdRQW1wVEpreWZIcWxXckVqZjMwS0ZEUjdkcTFhcFFnZ0FBYkFzRk1BQkFFM0xMTGJjY1hsSlMwamxwY3ovNDRJTlJYMTh2UUFDZ1NhbXZyNDhISDN3d2NYT1hsSlIwdnVtbW13NlZJQUFBMjBJQkRBRFFSR1N6MmN3QkJ4enc3YVROdldqUm9uanBwWmNFQ0FBMFNTKzk5RklzWHJ3NGNYT1BHREhpTzlsc05pTkJBQUMybGdJWUFLQ0p1T2FhYS9ZdUx5L3ZtN1M1SDNyb29jamxjZ0lFQUpxa1hDNlh5THVBeTh2TCsxMTExVlY3U1JBQWdLMmxBQVlBYUNLKzhwV3ZmRGRwTTgrYk55OFdMbHdvUEFDZ1NWdTRjR0c4K3VxcnJnOEJBTWdMQ21BQWdDYmdzc3N1RzFSWldibFBrbWJPNVhJeGZ2eDQ0UUVBaWZEQUF3OGs3cWtsclZ1MzN2ZVNTeTdwTHowQUFMYUdBaGdBb0FrWU5XclVDVW1iZWZiczJiRnMyVExoQVFDSnNHelpzbmpsbFZjU04vY0pKNXh3b3ZRQUFOZ2FDbUFBZ0Yzc24vLzVuenQzN05qeGlDVE4zTmpZR0E4ODhJRHdBSUJFR1Q5K2ZEUTBOQ1JxNWs2ZE9uMWg5T2pSSGFRSEFNQ25wUUFHQU5qRmZ2U2pIMzB0azhrazZycHMyclJwc1dyVkt1RUJBSW15YXRXcWVPR0ZGeEkxY3lhVEtmenBUMzg2U25vQUFIeGFDbUFBZ0YxbzBLQkJwWDM2OVBscWttYXVyNitQQ1JNbUNBOEFTS1FKRXlaRVhWMWRvbWJ1MjdmdlYvcjI3VnNzUFFBQVBnMEZNQURBTG5UWlpaY2RYbFJVVkpHa21hZE9uUnByMTY0VkhnQ1FTT3ZYcjQ4cFU2WWthdWFpb3FMSzMvem1OMGRJRHdDQVQwTUJEQUN3aTJTejJjeSsrKzU3VXBKbXJxdXJjL2N2QUpCNGp6NzZhT0x1QXQ1Ly8vMVB5bWF6R2VrQkFQQkpGTUFBQUx2STFWZGZQYlNzckt4M2ttYWVNbVZLYk5pd1FYZ0FRS0p0MkxBaG5uLysrVVROWEZaVzF1ZXFxNjdhUzNvQUFId1NCVEFBd0M3eTVTOS8rYmdrelZ0Zlh4OFRKMDRVSEFDUUNvOC8vbmppN2dMKzBwZStkTHprQUFENEpBcGdBSUJkWVBUbzBSM2F0bTA3SWtrelQ1czJMZGF0V3ljOEFDQVZQdnp3dzVnK2ZYcWlabTdmdnYySTBhTkhkNUFlQUFCYm9nQUdBTmdGZnZyVG40N0taREtGU1ptM3ZyNCtIbm5rRWNFQkFLbnl5Q09QUkgxOWZXTG16V1F5aFQvOTZVKy9KamtBQUxaRUFRd0FzSk4xNnRRcDI2ZFBuNk9UTkxPN2Z3R0FORnEzYmwxTW16WXRVVFAzNmRQbm1FNmRPbVdsQndEQXgxRUFBd0RzWkZkZGRkVUIyV3kyZFZMbWJXeHNqRW1USmdtT1ZPdllzV04wNk9DSm1nRDVhTktrU2RIWTJKaVllYlBaYk91cnJycnFBTWtCQVBCeEZNQUFBRHZaaUJFanZwNmtlVjk4OGNWWXRXcVY0RWkxTGwyNnhJVVhYaGlublhaYWRPM2ExVUlBOHNpcVZhdmlwWmRlY2owSkFFQnFLSUFCQUhhaU04NDRvM3RsWmVYZVNaazNsOHZGeElrVEJVZGV5R1F5TVhqdzRQalZyMzRWWThhTWNVY3dRQjU1L1BISEk1ZkxKV2JleXNyS3ZjODQ0NHp1a2dNQTRLTW9nQUVBZHFKVFRqbmxxeEdSU2NxOEN4WXNpUGZlZTA5dzVKVk1KaE43NzcxM1hIamhoVEZtekpobzM3NjlwUUNrM0h2dnZSY0xGeTVNMUI5WC8zTmRDUUFBLzRjQ0dBQmdKK25WcTFlelhyMTZmVGxKTTN2M0wvbnNyMFh3QlJkY0VDZWZmSEswYmR2V1VnQlNMR25YUGIxNjlmcHlyMTY5bWtrT0FJQi9wQUFHQU5oSnJyamlpb09MaW9wYUptWGVCTjRKQXp0RVlXRmhEQjgrUEM2ODhNSVlQWHAwVkZaV1dncEFDaTFZc0NDV0xWdVdtSG1MaW9wYVhubmxsWWRJRGdDQWY2UUFCZ0RZU1lZUEgvNlZKTTJidEhmaHdZNVdWRlFVSTBhTWlFc3V1U1JHang0ZExWdTJ0QlNBRk1ubGN2SDQ0NDhuYXViOTl0dnZLNUlEQU9BZktZQUJBSGFDMGFOSGQ2aXNyQnlhbEhuWHJsMGJMNy84c3VEZ0kveTFDTDc0NG92amhCTk9pQll0V2xnS1FFcTg5TkpMc1c3ZHVzVE1XMWxadWRmbzBhTTdTQTRBZ0wrbEFBWUEyQWxPUC8zMG81SjA3ZlhNTTg5RVEwT0Q0R0FMaW91TDQ3REREb3V4WThmR3FGR2pvcXlzekZJQUVxNmhvU0dlZWVhWkpJMWM4RC9YbVFBQThQOHZFcTBBQUdESHltYXptWDc5K24wNUtmUFcxdGJHbENsVEJBZWZVbkZ4Y1l3Y09USXV2ZlRTR0RWcVZKU1dsbG9LUUlJOS8venpVVnRibTVoNSsvWHI5K1ZzTnB1UkhBQUFmNlVBQmdEWXdYN3ptOS9zV1ZKUzBqa3A4ODZZTVNPcXE2c0ZCMXVwcEtRa1JvNGNHWmRjY2trY2ZmVFJVVkpTWWlrQUNWUmRYUjB6Wjg1TTBwOC9uYSs0NG9yQmtnTUE0SzhVd0FBQU85Z1h2dkNGTHlWbDFsd3VGMDgvL2JUUTRETm8zcng1SEhYVVVYSEpKWmZFeUpFakk1dk5XZ3BBd2p6MTFGT1J5K1VTTSsrUlJ4NzVaYWtCQVBCWENtQUFnQjFveUpBaHBaMDdkejRpS2ZPKy92cnJzV0xGQ3NIQmRsQmVYaDZqUm8yS1N5KzlWQkVNa0RBclZxeUkxMTkvUFRIemR1blM1ZkQrL2Z0NzlBUUFBQkdoQUFZQTJLSEdqaDE3YUdGaFlXSmVDT3J1WDlqK0tpb3FZdFNvVVhIeHhSZkg0WWNmSGtWRlJaWUM0THBvdXlvc0xHeitILy94SHdkTERRQ0FDQVV3QU1BT3RlZWVleDZabEZuWHJsMGI4K2JORXhyc0lLMWF0WXJqano4K0xycm9vaGd4WWtRVUZQaDJES0FwbXpkdlhxeFpzeVl4OCs2MTExNUhTZzBBZ0FnRk1BREFEblBNTWNlMGJ0MjY5YjVKbWZlNTU1Nkx4c1pHd2NFTzFxWk5teGc5ZW5SY2ZQSEZpbUNBSnF5eHNUR2VlKzY1SlAzNU12eVlZNDVwTFRrQUFQeWtBUUJnQnpuenpETVB6MlF5aWJqZXFxK3ZqNmxUcHdvTmRxSzJiZHZHNk5HajQ3enp6b3ZodzRjcmdnR2FvQmRlZUNIcTYrc1RNV3Nta3lrODQ0d3pEcFVhQUFCK3dnQUFzSVAwNzkvL0MwbVpkYzZjT2JGaHd3YWh3UzdRcVZPbk9QbmtrK1BmL3UzZll1Kzk5NDVNSm1NcEFFM0VoZzBiWXZiczJZbVpkOENBQVI0RERRQ0FBaGdBWUVmNDN2ZSsxNm15c25LUHBNeWJwTWNiUWxwMTd0dzV4b3daRTcvNjFhOFV3UUJOeVBQUFA1K1lXU3NyS3dkLzczdmY2eVExQUlEOHBnQUdBTmdCVGo3NTVDTWlJaEh0emNxVksrUDExMThYR2pRUlhidDJqVEZqeHNRNTU1d1Rnd2NQdGhDQVhlejExMStQbFN0WEptWGN6TWtubjN5NDFBQUE4cHNDR0FCZ0IralhyMTlpSHY4OFpjcVV5T1Z5UW9NbXBuZnYzbkhhYWFmRk9lZWNFLzM3OTdjUWdGMGtsOHZGbENsVGtuUWQ2akhRQUFCNVRnRU1BTENkblg3NjZkMHFLaXAyUzhLczlmWDFNVzNhTktGQkU5YW5UNTg0NjZ5ejRweHp6b25kZHR2TlFnQjJnV25UcGtWOWZYMGlacTJvcU5qdDlOTlA3eVkxQUlEOHBRQUdBTmpPUm84ZWZVUlNacDAzYjE1czNMaFJhSkFBZmZyMGliUFBQanZPUFBQTTZObXpwNFVBN0VRYk4yNk1lZlBtdVI0RkFDQVJGTUFBQU50WnIxNjlFdlBldFNROXpoRDRid01HREloZi92S1hjZWFaWjBiMzd0MHRCR0FubVRwMWFwS3VSdytUR0FCQS9sSUFBd0JzUjJlY2NVYjM4dkx5dmttWWRmMzY5ZkhhYTY4SkRSSnF3SUFCOFMvLzhpOXgybW1uUmJkdW52UUpzS1BObno4L1B2end3MFRNV2w1ZTN1OUhQL3BSRjZrQkFPUW5CVEFBd0haMDNISEhIWlNVV1dmTW1CR05qWTFDZ3dUTFpESXhlUERnK05kLy9kY1lNMlpNZE9qUXdWSUFkcERHeHNhWU1XTkdZdWI5eGplK2NZalVBQUR5a3dJWUFHQTc2dE9uejhGSm1ET1h5eVhxTVliQWxtVXltZGg3Nzczandnc3ZqREZqeGtUNzl1MHRCV0FIZU9HRkY1SjBYWHFJeEFBQThwTUNHQUJnT3pucHBKUGF0MnpaY3Zja3pMcGt5WkpZdVhLbDBDQmwvbG9FWDNEQkJYSHl5U2RIMjdadExRVmdPMXF4WWtXOC9mYmJpWmkxc3JKeTBQSEhIKzhQQWdDQVBLUUFCZ0RZVHI3NzNlOGVHQkdaSk15YXBNY1hBbHV2c0xBd2hnOGZIaGRlZUdHTUhqMDZLaXNyTFFWZ081aytmWHBTUmkzNC92ZS9mNkRFQUFEeWp3SVlBR0E3MlgzMzNROU53cHoxOWZVeGMrWk1nVUVlS0NvcWloRWpSc1FsbDF3U28wZVBqcFl0VzFvS3dHYzBjK2JNcUsrdlQ4U3NBd2NPUEZSaUFBRDVSd0VNQUxBZEhIVFFRUlV0VzdiY0t3bXpMbHk0TUtxcnE0VUdlZVN2UmZERkYxOGNKNXh3UXJSbzBjSlNBTFpSVlZWVnZQNzY2NG1ZdFZXclZrT0hEeDllTGpVQWdQeWlBQVlBMkE3T1B2dnN6MmN5bWFJa3pPcnh6NUMvaW91TDQ3REREb3V4WThmR3FGR2pvcXlzekZJQXRrRlNucWFTeVdTeTU1NTc3dWNsQmdDUVh4VEFBQURid2U2NzczNUFFdWFzcmEyTk9YUG1DQXp5WEhGeGNZd2NPVEl1dmZSU1JUREFOcGc5ZTNiVTFkVWxZdFk5OXRqakFJa0JBT1FYQlRBQXdHZlVxbFdyd25idDJ1MmZoRm5uelpzWHRiVzFRZ01pSXFLa3BDUkdqaHdaWThlT2phT1BQanBLU2tvc0JlQlQyTFJwVTh5Yk55OFJzN1p2MzM3L2lvb0tQd01FQU1nakx2NEFBRDZqQ3krOGNQZWlvcUtLSk16NjRvc3ZDZ3o0UDVvM2J4NUhIWFZVWEhMSkpURnk1TWpJWnJPV0F2QUpaczJhbFlnNWk0cUtXbHg4OGNXREpBWUFrRDhVd0FBQW45R0JCeDZZaU1mcVZWZFhKK1pPRldEWEtDOHZqMUdqUnNXbGwxNnFDQWI0QlBQbXpZdWFtcHBFekhyUVFRZDVERFFBUUI1UkFBTUFmRVpkdTNZZG5vUTU1ODJiRi9YMTlRSURQbEZGUlVXTUdqVXFMcjc0NGpqODhNT2pxS2pJVWdEK1FWMWRYYno2NnF1Sm1MVkxseTc3U3d3QUlIOG9nQUVBUG9OVFRqbWxZM2w1K1c1Sm1QWGxsMThXR0xCVldyVnFGY2NmZjN4Y2RORkZNV0xFaUNnbzhDMGt3Tjk2NmFXWEVqRm5SVVhGYmllZGRGSjdpUUVBNUFmZnZRTUFmQVlubm5qaTU1TXdaMjF0YmN5ZlAxOWd3RFpwMDZaTmpCNDlPc2FPSGFzSUJ2Z2I4K2ZQajlyYTJpU01tdm51ZDcvN2VZa0JBT1FIMzdVREFId0duL3ZjNS9aTHdwd0xGeTZNdXJvNmdRR2Z5VitMNFBQT095K0dEeCt1Q0FieTN1Yk5tMlBod29XSm1MVmZ2MzdESlFZQWtCOTh0dzRBc0kxYXRXcFYyTHAxNjcyVE1LdkhQd1BiVTZkT25lTGtrMCtPYzg4OU53WU5HbVFoUUY2YlBYdDJJdVpzMDZiTjNoVVZGWDRXQ0FDUUIxejBBUUJzby9QUFAzOWdZV0ZoZVZPZnM3NitQdWJNbVNNd1lMdnIyYk5uL09RblA0bnp6anN2OXQ1Nzc4aGtNcFlDNUozWnMyZEhmWDE5azUrenFLaW80dnp6eng4b01RQ0E5Rk1BQXdCc28vMzMzMy9mSk16NSt1dXZSMDFOamNDQUhhWkxseTR4WnN5WU9PZWNjMkx3NE1FV0F1U1Y2dXJxZU9PTk54SXg2NEVISHJpUHhBQUEwazhCREFDd2picDI3WnFJeHovUG5UdFhXTUJPMGJ0Mzd6anR0TlBpbkhQT2lmNzkrMXNJa0RlU2NyM1Z2WHYzdmFVRkFKQitDbUFBZ0cwd1pNaVEwc3JLeWoyYStweTVYTTdqbjRHZHJrK2ZQbkhXV1dmRk9lZWNFN3Z0dHB1RkFLazNlL2JzeU9WeVRYN09saTFiN2psbzBLQlNpUUVBcEpzQ0dBQmdHNXg1NXBsN1pqS1piRk9mYzlteVpiRnUzVHFCQWJ0RW56NTk0dXl6ejQ0enp6d3pldmJzYVNGQWFxMWJ0eTZXTDEvZTVPZk1aRExaczg0NmE0akVBQURTcmNnS0FBQzIzdENoUTRjbFljNTU4K1lKQzlqbEJnd1lFQU1HRElnRkN4YkUrUEhqWStuU3BaWUNwTTY4ZWZPaVM1Y3VUWDdPZmZiWlo1K0ltQzR4QUlEMGNnY3dBTUEyNk5peDR6NUptSFArL1BuQ0FwcU1BUU1HeEM5LytjczQ3YlRUb2x1M2JoWUNwRXBTcnJzNmRlcTBqN1FBQU5KTkFRd0FzSldPT09LSWxoVVZGZjJhK3B4VlZWV3hhTkVpZ1FGTlNpYVRpY0dEQjhlLy91dS94cGd4WTZKRGh3NldBcVRDVzIrOUZWVlZWVTErem9xS2lzOGRldWloTFNRR0FKQmVDbUFBZ0sxMDhza25ENDZJVEZPZmMvNzgrZEhZMkNnd29FbktaREt4OTk1N3g0VVhYaGhqeG95Sjl1M2JXd3FRYUkyTmpiRmd3WUpFL0N2NHU5Lzk3aDRTQXdCSUx3VXdBTUJXMm4zMzNmZE13cHplL3dza3dWK0w0QXN1dUNCT1B2bmthTnUycmFVQWlaV1U2Ni9CZ3dmdktTMEFnUFFxc2dJQWdLM1RybDI3d1UxOXhsd3VsNVE3VUFBaUlxS3dzRENHRHg4ZSsreXpUMHliTmkwbVRKZ1E2OWV2dHhnZ1VSWXNXQkM1WEM0eW1hYjlzSmdPSFRvTWxoWUFRSHE1QXhnQVlDc01HalNvdEdYTGxnT2ErcHp2dmZkZWJOeTRVV0JBNGhRVkZjV0lFU1Bpa2tzdWlkR2pSMGZMbGkwdEJVaU1Eei84TUpZdFc5Yms1Mnpac3VYQS92MzdsMGdNQUNDZEZNQUFBRnZoeHovKzhhQk1KdFBrbjZMaTdsOGc2ZjVhQkk4ZE96Wk9PT0dFYU5HaWhhVUFpYkJ3NGNJbVAyTW1rOG4rNUNjL0dTQXRBSUIwVWdBREFHeUZ2ZmZlZTg4a3pKbUVIendDZkJyTm1qV0x3dzQ3TE1hT0hSdWpSbzJLc3JJeVN3R2F0S1Q4SWw1U3Jtc0JBTmg2M2dFTUFMQVZ1bmJ0T3FTcHoxaGZYeDl2dnZtbXNJQlVLUzR1anBFalI4YkJCeDhjeno3N2JEeisrT05SWFYxdE1VQ1Q4K2FiYjBaOWZYMFVGVFh0SDd0MTZkSmxUMmtCQUtTVE80QUJBRDZsaW9xS2dvcUtpa0ZOZmM0bFM1YkU1czJiQlFha1VrbEpTWXdjT1RMR2poMGJSeDk5ZEpTVWVJVWwwTFRVMXRiRzBxVkxtL3ljTFZ1MkhGUmFXdXBuZ3dBQUtlUWlEd0RnVXpyNzdMUDdGaFlXTnZsbmo3NzIybXZDQWxLdmVmUG1jZFJSUjhVbGwxd1NJMGVPakdiTm1sa0s0SHBzS3hRV0ZwYWZmZmJadmFRRkFKQStDbUFBZ0U5cC8vMzM3NStFT1Y5Ly9YVmhBWG1qdkx3OFJvMGFGZi8rNy84ZUkwZU9qR3cyYXltQTY3RlA2Zk9mLy94QWFRRUFwSThDR0FEZ1UrclJvOGZ1VFgzRzJ0cmFlUHZ0dDRVRjVKMktpb29ZTldwVVhIenh4WEg0NFljMytYZHZBdW0yZVBIaVJMeVNvMWV2WG9Pa0JRQ1FQZ3BnQUlCUHFYWHIxazMrRG9rbFM1WkVRME9Ec0lDODFhcFZxemorK09QajRvc3ZqaEVqUmtSQmdXOTdnWjJ2b2FFaGxpeFowdVRuYk5PbWpRSVlBQ0NGZkNjTUFQQXBEQmt5cExSNTgrYTltL3FjYjc3NXByQUFJcUoxNjlZeGV2VG9HRHQyckNJWWNGMzJNWm8zYjk1bjBLQkJwZElDQUVnWDN3RURBSHdLcDU1NmF2OU1KdFBrcjUzZWV1c3RZUUg4alRadDJzVG8wYVBqdlBQT2krSERoeXVDQWRkbGZ5T1R5UlQ4NEFjLytKeTBBQURTeFhlK0FBQ2Z3dURCZzV2ODQvSHE2K3RqMGFKRndnTDRDSjA2ZFlxVFR6NDUvdTNmL2kzMjNudnZ5R1F5bGdMc1VJc1hMMDdFcXpuMjNIUFBnZElDQUVnWEJUQUF3S2ZRcFV1WEFVMTl4bmZlZVNmcTZ1cUVCYkFGblR0M2pqRmp4aWlDZ1IydXRyWTIzbjMzM1NSYzUzb1BNQUJBeWlpQUFRQStoWll0Vy9adjZqTjYvRFBBcDllbFM1Y1lNMlpNbkh2dXVURjQ4R0FMQWZMMitpd0oxN2tBQUd3ZEJUQUF3Q2NZUG54NGVVbEpTZWVtUHFmSFB3TnN2VjY5ZXNWcHA1MFc1NXh6VHZUdnJ3TUI4dS82ckxTMHRQUHc0Y1BMcFFVQWtCNEtZQUNBVC9DdGIzMXJ0NGhvOHM4SVhieDRzYkFBdGxHZlBuM2lyTFBPaW5QT09TZDIyMjAzQ3dHMmk0VDhnbDdtMjkvK2RqOXBBUUNraHdJWUFPQVQ3TDc3N2syK0NWaTdkbTFzMkxCQldBQ2ZVWjgrZmVMc3M4K09NODg4TTNyMjdHa2h3R2Z5NFljZnhycDE2NXI4bkFNSERsUUFBd0NrU0pFVkFBQnNXYWRPblpyOEQ4VGVmdnR0UVFGc1J3TUdESWdCQXdiRWdnVUxZdno0OGJGMDZWSkxBYmI1T3ExVnExYXVkd0VBMkdrVXdBQUFuNkN5c2xJQkRKQ25CZ3dZRVAzNzk0OTU4K2JGUXc4OUZPKysrNjZsQUZ0bHlaSWxzZGRlZXpYMTYxM1B2Z2NBU0JFRk1BREFGblRxMUNuYnZIbnpYazE5emlWTGxnZ0xZQWZKWkRJeGVQRGcyR09QUGVMbGwxK09CeDk4TUZhdVhHa3hRR3F1MDVvM2I5NjdYYnQyUmF0WHI2NlhHQUJBOG5rSE1BREFGb3daTTZabkpwUEpOdVVaR3hzYlBab1VZQ2ZJWkRLeDk5NTd4NFVYWGhoanhveUo5dTNiV3dyd2laWXVYUnFOalkxTmVzYUNnb0xzcWFlZTJrTmFBQURwNEE1Z0FJQXQySHZ2dmZzMjlSbFhybHdadGJXMXdnTFlTZjVhQk8rNTU1NHhhOWFzbURCaFFxeGV2ZHBpZ0k5VVcxc2I3Ny8vZm5UdTNMbEp6emxzMkxDK0ViRklZZ0FBeWVjT1lBQ0FMZWpSbzBlVEw0RGZlZWNkUVFIc0FvV0ZoVEY4K1BDNDhNSUxZL1RvMFZGWldXa3BRR0t2MTVKdzNRc0F3S2VqQUFZQTJJTFdyVnMzK2ZmL3Z2dnV1NElDMklVS0N3dGp4SWdSY2NrbGw4VG8wYU9qWmN1V2xnSWs3bm90Q2RlOUFBQjhPaDRCRFFDd0JjMmJOKy9aMUdkVUFBTTBrVyt3aTRwaXhJZ1JzZDkrKzhXVUtWUGlzY2NlaXcwYk5sZ01FTys5OTE0U3Juc1Z3QUFBS2VFT1lBQ0FqOUcvZi8rU2twS1NqazE5VGdVd1FOUFNyRm16T095d3cyTHMyTEV4YXRTb0tDc3JzeFRJYzBtNFhpc3RMZTNVdDIvZllta0JBQ1NmQWhnQTRHT2NjTUlKM1pyNjlkSzZkZXVpcXFwS1dBQk5VSEZ4Y1l3Y09USisvZXRmSzRJaHoxVlZWY1g2OWV1YitwZ0YzL3ptTjd0TEN3QWcrUlRBQUFBZlk4aVFJVDJiK294SmVKd2dRTDc3YXhFOGR1ellPUHJvbzZPa3BNUlNJQThsNGJvdENkZS9BQUI4TWdVd0FNREg2TjY5ZTgrbVBxUEhQd01rUi9QbXplT29vNDZLU3k2NUpFYU9IQm5ObWpXekZNZ2pTYmh1UzhMMUx3QUFuMHdCREFEd01WcTFhdFdqcWMrNGJOa3lRUUVrVEhsNWVZd2FOU3IrL2QvL1BVYU9IQm5aYk5aU0lBOGs0Ym90Q2RlL0FBQjhNZ1V3QU1ESHFLaW82TlhVWjF5K2ZMbWdBSkw3NTB5TUdqVXFMcjc0NGpqODhNT2pxS2pJVWlERmtuRGQxckpseTE2U0FnQklQZ1V3QU1CSHlHYXptYkt5c3E1TmVjYkd4c1pZdFdxVnNBQVNybFdyVm5IODhjZkh4UmRmSENOR2pJaUNBdCtxUXhxdFdyVXFHaHNibS9TTUpTVWxYYlBaYkVaYUFBREo1cnRLQUlDUGNOeHh4N1VyS0Nnb2Jzb3pybDY5T3VycjY0VUZrQkt0VzdlTzBhTkh4OWl4WXhYQmtFSjFkWFh4d1FjZk5Pa1pDd29LaW84NzdyaDIwZ0lBU0RiZlRRSUFmSVRQZi83elhacjZqTysvLzc2Z0FGS29UWnMyTVhyMDZEai8vUE5qK1BEaGltQklrUlVyVnJnT0JnQmdoL05kSlArUHZUdVByN0k4ODhkL25Td0VraEQySFVRRVVWUkFvSWlvdUN0cTY0SmFiZDFhclZvcmJxTzJ0bFhiYWF2VE91MzhScWZmZG1wYnU5cldwWW9nc3FnRlJYQ3R0QUlLQXJKRGdBQUpCTEtRNUp6Zkg4V080K0RPY3A2VDkvdjE4ald2VHY2NTd1dDZoTnZuay90K0FJQ2QyRysvL2JMK3hWY1NYaUFDOFBGMTdkbzFMcjMwMHJqOTl0dGoyTEJoa1VxNWxSV1NMZ243dHlUc2d3RUFlSDhGV2dBQThIOTE3dHhaQUF4QVZ1amV2WHRjZWVXVnNYcjE2bmppaVNkaTl1elprY2xrTkFZU0tBbjd0eVRzZ3dFQWVIOENZQUNBbldqWHJwMHJvQUhJS2oxNjlJZ3JyN3d5bGk1ZEdwTW1UWW81Yytab0NpUk1Fdlp2U2RnSEF3RHcvZ1RBQUFBN1VWeGMzRDNiYXhRQUF6UlBmZnIwaWJGang4YVNKVXRpL1BqeHNXREJBazJCaEVqQy9pMEorMkFBQU42ZmJ3QURBT3hFU1VsSnoyeXVyN3E2T3VycTZnd0tvQm5iYjcvOTRsLys1Vi9pYTEvN1doeHd3QUVhQWdsUVYxY1gxZFhWOXNFQUFPeFdBbUFBZ0hjNS9QRERTd3NLQ3RwbWM0MFZGUlVHQlVCRVJQVHQyemR1dlBIR3VPR0dHMkxmZmZmVkVNaHkyYjZQS3lnb2FEdDgrUEFTa3dJQVNDNEJNQURBdTV4NDRvbGRzcjNHRFJzMkdCUUEvOHVBQVFQaUc5LzRSdHh3d3czUnUzZHZEUUg3dUUreUgrNXFVZ0FBeWVVYndBQUE3OUt2WDcrc0Q0RFhyMTl2VUFEczFJQUJBK0xBQXcrTXVYUG54b1FKRTJMbHlwV2FBbGtrQ1RlNUhIREFBVjBpNGkzVEFnQklKZ0V3QU1DN2RPL2V2WE8yMStnRU1BRHZKNVZLeGFCQmcyTGd3SUV4ZS9ic0dEOStmS3hidDA1andENHVaL2JEQUFDOE53RXdBTUM3dEcvZnZsTzIxeWdBQnVERFNLVlNNV3pZc0JnNmRHak1uajA3SG52c01iZEl3RjZXaEJQQVNkZ1BBd0R3M2dUQUFBRHYwcnAxNjZ3LzhaQ0VGNGNBWkkrM2crQkREejAwWG5ubGxaZzRjYUsvUzhBK0x0SDdZUUFBM3BzQUdBRGdYVXBLU3JMNnhFTmpZMk5zM3J6Wm9BRDR5UEx6OCtQd3d3K1A0Y09IeC9QUFB4OFRKMDZNcXFvcWpZRTlhUFBtemRIWTJCZ0ZCZG43V2k3Yjk4TUFBTHcvQVRBQXdMdTBiTm15U3piWFYxbFpHWmxNeHFBQStOank4L05qMUtoUk1YTGt5SGpoaFJjRXdiQUhaVEtacUtxcWlvNGRPOW9QQXdDd1d3aUFBUURlcGFpb0tLdXZ2S3VzckRRa0FIYUpnb0tDR0RWcVZJd1lNU0ptenB3Wmt5ZFBqaTFidG1nTTdJSDlYRFlId05tK0h3WUE0UDNsYVFFQXdQOFlQbng0U1g1K2ZrazIxeWdBQm1CWGE5R2lSUngvL1BGeHh4MTN4TmxubngwbEpTV2FBczE0UDVlZm4xOHlmUGh3ZnhBQUFDU1VBQmdBNEIyT09PS0lEdGxlbysvL0FyQzdGQlVWeGVqUm8rUDczLzkrbkgzMjJWRmNYS3dwc0JzazRjcjFKT3lMQVFEWU9RRXdBTUE3OU8zYnQxMjIxK2dFTUFDNzI5dEI4QjEzM0JHbm4zNTZ0R3JWU2xPZ21lM245dHR2djdZbUJRQ1FUQUpnQUlCMzZOU3Brd0FZQUhZb0tTbUp6M3ptTTNIbm5YZkc2TkdqbzBXTEZwb0N6V1EvbDRSOU1RQUFPeWNBQmdCNGh3NGRPclROOWhxVGNHVWdBTG1scEtRa3pqNzc3UGpPZDc0VG8wYU5pdno4ZkUyQkhOL1BKV0ZmREFEQXpnbUFBUURlb2F5c3JHMjIxeWdBQm1CdmFkKytmVngwMFVWeDU1MTN4Z2tubkJDRmhZV2FBam02bnlzckszTUNHQUFnb1FUQUFBRHZVRkpTMGo2YjY4dGtNbEZkWFcxUUFPeFY3ZHExaS9QT095KysrOTN2eHFoUm95SXZ6K3NGK0NpU3NKOHJMUzBWQUFNQUpKVC9RZ01BZUlmaTR1SzIyVnhmWFYxZE5EWTJHaFFBV2VIdEU4RjMzSEdISUJnK2dzYkd4cWlycTdNdkJnQmd0L0JmWmdBQTc5Q3FWYXVzUHVuZzlDOEEyYWhEaHc1eDBVVVh4YmUvL2UwNC9QRERCY0dRQS91Nm9xSWlKNEFCQUJMS2Y1RUJBTHhEUVVHQkFCZ0FQcWF1WGJ2R3BaZGVHdC82MXJkaTJMQmhrVXFsTkFVU3VxOXIwYUpGVzFNQ0FFaW1BaTBBQVBnZmhZV0ZaZGxjMzlhdFd3MEpnS3pYclZ1M3VQTEtLMlAxNnRYeHhCTlB4T3pac3lPVHlXZ01KR2hmbCszN1lnQUEzcHNBR0FEZ25adWpnb0xXMlZ5ZkU4QUFKRW1QSGozaXlpdXZqS1ZMbDhha1NaTml6cHc1bWdJSjJkZGwrNzRZQUlEMzVncG9BSUFkV3JkdW5aZWZuOTh5bTJzVUFBT1FSSDM2OUlteFk4ZkdMYmZjRWdNR0ROQVFTTUMrTGo4L3YxV3JWcTI4T3dRQVNDQ2JPQUNBSFFZTkdsUVNFVm45c2NKdDI3WVpGQUNKdGQ5Kys4VU5OOXdRWC92YTErS0FBdzdRRUpxMUJPenI4Z1lQSGx4c1VnQUF5U01BQmdEWTRZQUREaWpKOWhwcmFtb01Db0RFNjl1M2I5eDQ0NDF4d3cwM3hMNzc3cXNoTkV1MXRiVlpYMlAvL3YxTFRRb0FJSGw4QXhnQVlJZWVQWHRtL1F1dUpMd29CSUFQYThDQUFURmd3SUNZUDM5K2pCczNMcFl2WDY0cE5CdEoyTmYxNk5HanhLUUFBSkpIQUF3QXNFT25UcDBFd0FDd0Z3d1lNQ0FPUFBEQW1EdDNia3lZTUNGV3JseXBLZVM4Sk96cnVuYnRLZ0FHQUVnZ0FUQUF3QTVsWldWWi80S3JycTdPb0FESVNhbFVLZ1lOR2hRREJ3Nk0yYk5ueDRRSkUyTHQyclVhUTg1S1FnRGNwazBiVjBBREFDU1FBQmdBWUlleXNqSW5nQUZnTDB1bFVqRnMyTEFZT25Sb3pKNDlPOGFQSHgvcjFxM1RHSEtPQUJnQWdOMUZBQXdBc0VOSlNVbHh0dGZvQkRBQXpjWGJRZkNRSVVQaTVaZGZqb2tUSjBaRlJZWEdrRE9TRUFBbllYOE1BTUQvSlFBR0FOaWhxS2lvS050cnJLbXBNU2dBbXBXOHZMdzQvUEREWS9qdzRmSDg4OC9IRTA4OEVaV1ZsUnBENGlVaEFHN1Jva1dSU1FFQUpJOEFHQUJnaDhMQ3doYlpYRjg2blk3dDI3Y2JGQUROVW41K2Zvd2FOU3BHamh3Wkw3endRa3ljT0RHcXFxbzBoc1Rhdm4xN1pES1pTS1ZTV1Z0aml4WXRXcGdVQUVEeUNJQUJBSGJJOWdDNG9hSEJrQUJvOWdvS0NtTFVxRkV4WXNTSW1EbHpaa3llUERtMmJObWlNU1JPSnBPSmhvYUd5T2FNdGJDdzBBbGdBSUFrL25lVEZnQUE3TmdZRlJSazlRdXV4c1pHUXdLQUhWcTBhQkhISDM5OEhIbmtrZkhNTTgvRTFLbFRZOXUyYlJwRG9tUjdBSnp0KzJNQUFONWpINmNGQUFBN05rWlovb0xMOWM4QThIOFZGUlhGNk5HajQ5aGpqNDFubm5rbXBreVpFalUxTlJwREltVDdEUzhGQlFXdWdBWUFTQ0FCTUFEQTJ4dWpMSC9CNVFwb0FIaHZid2ZCUngxMVZFeWZQajJlZnZycHFLMnQxUml5bWdBWUFJRGRJVThMQUFEK1FRQU1BTWxYVWxJU24vbk1aK0xPTysrTTBhTkhaL1gxdWlBQUJnQmdkeEFBQXdEc2tPMVhRQXVBQWVEREt5a3BpYlBQUGp2KzdkLytMVWFQSGgyRmhZV2FndjNkUjVTZm45L1NsQUFBa2tjQURBRHc5c1lvTDg4SllBRElNYTFidDQ2enp6NDd2dmU5NzhVSko1d2dDTWIrN2lQSXo4LzNMd3dBUUFJSmdBRUFka2lsVWxtOU4ycHNiRFFrQVBpWTJyVnJGK2VkZDE1ODk3dmZqUk5PT0NFS0NnbzBCZnU3RDk0ZjU1c1NBRUR5Q0lBQkFIYkk5Z0E0blU0YkVnQjhRdTNidC85bkVEeHExS2pJeS9OcUJQdTc5OWtmcDB3SkFDQjUvRmNPQU1BT1huQUJRUFBSb1VPSHVPaWlpK0o3My91ZUlKaTlKcFBKWkh1Si9zVUFBRWdnbXpnQWdQK1IxUUZ3QWw0UUFrRGlkT3pZTVM2NjZLTDQxcmUrRlljZmZuajRmVERzNzk2eE9jN3lHM0lBQU5nNW16Z0FnSVRzalFUQUFMRDdkT3ZXTFM2OTlOTDQxcmUrRmNPR0RSTUVzMGRrK3hYUWVYbDUva1VBQUVpZ0FpMEFBUGlIYkgvQkpRQUdnTjJ2ZS9mdWNlV1ZWOGF5WmN2aWlTZWVpRGx6NW1nS3pYbC81L0FJQUVBQ0NZQUJBSGJJWkRKT0FBTUFFUkd4Nzc3N3h0aXhZMlBKa2lVeFljS0VtRDkvdnFaZ2Z3d0FRQ0lJZ0FFQS9vY3I3Z0NBLzJXLy9mYUxHMjY0SWQ1NjY2MFlQMzU4dlBubW01ckNMcFB0VjBDbjNJVU9BSkJJQW1BQWdCMnkvUVZYdHI4Z0JJQmMxcmR2MzdqeHhodmpyYmZlaW5IanhzV2lSWXMwaFUvTUZkQUFBTmpFQVFEc1hsbjlCczRCREFEWSsvcjI3UnMzMzN4ejNIREREZEc3ZDI4TklkZjNkNzVCQWdDUVFFNEFBd0Rza08wbk1BVEFBSkE5Qmd3WUVBTUdESWo1OCtmSEk0ODhFaXRYcnRRVWNuRi81d29hQUlBRWNnSVlBR0NIVkNxVnp2TDZEQWtBc3N5QUFRUGkxbHR2amJGangwYlBuajAxaEp6YTMyVVNjRWMxQUFEL2x4UEFBQUQvUXdBTUFIeXN2Nk1IRFJvVUJ4OThjRHovL1BNeGFkS2syTFJwazhhUStQMWR0ditDSkFBQU8rY0VNQURBRHVsMGRyL2ZFZ0FEUUhhcnI2K1Bpb3FLMkxadG0yYVFFL3U3ZERydEJEQUFRQUk1QVF3QThEK2NBQVlBUHJLNnVycDQrdW1uWTlxMGFjSmZjbTEvNXdRd0FFQUNDWUFCQVA2SEV3NEF3SWZXME5BUTA2Wk5peWVmZkRLMmJ0MnFJWHhrQ2ZnR3NBQVlBQ0NCQk1BQUFEdGtNcG1zRG9EejhueTlBd0N5d2R2QjcxTlBQUlhWMWRVYVFzN3U3d1RBQUFESkpBQUdBTmdoMjE5d0NZQUJZTzlxYkd5TUdUTm14Sk5QUGhtVmxaVWF3aWVXbjUrZjlWdGtVd0lBU0I0Qk1BREFEcGxNcGlHYjZ5c3NMRFFrQU5nTDB1bDB6Sm8xS3laUG5od2JOMjdVRUhhWmdvTHNmalhYMU5UVWFFb0FBQW5jWjJvQkFNQS9ORFkyYnMvbStnVEFBTEJucGRQcGVQbmxsMlB5NU1teGR1MWFEV0dYYTlHaVJiYi9PMUJ2U2dBQXlTTUFCZ0RZb2FtcFNRQU1BRVFtazRuWnMyZkg0NDgvSHVYbDVScENzOTNmTlRZMkNvQUJBQkpJQUF3QXNFTkRRME5XditBU0FBUEE3dlYyOFB2RUUwL0U2dFdyTllUZEx0dXZnTTcyRzNJQUFIaVBmYVlXQUFEOGd5dWdBYUQ1bWpOblRreWFOQ21XTGwycUdld3gyWDRGdEFBWUFDQ1pCTUFBQURzME5UVTVBUXdBemN5Q0JRdGl3b1FKOGRaYmIya0c5bmZ2MHREUUlBQUdBRWdnQVRBQXdBN1ovb0pMQUF3QXU4N0NoUXRqL1BqeHNYanhZczFncjhuMks2Q3ovUmNrQVFCNGozMm1GZ0FBL0VPMkI4QUZCUVdSbDVjWDZYVGFzQURnWTFxK2ZIbU1HemN1NXMrZnJ4bnNWWGw1ZVZrZkFHL2Z2dDBKWUFDQUJCSUFBd0RzME5EUWtQVW5IRnExYWhYYnRtMHpMQUQ0aUZhdVhCbVBQUEtJNEplczJ0Y2xZSDhzQUFZQVNDQUJNQURBRHJXMXRYWFpYcU1BR0FBK21uWHIxc1g0OGVOajl1elprY2xrTklTczJ0ZGx1N3E2dWxxVEFnQklIZ0V3QU1BT1c3ZHUzWnJ0TlNiaFJTRUFaSVAxNjlmSFk0ODlKdmpGdnU0VHFLNnUzbXBTQUFESkl3QUdBTmlocXFwS0FBd0FDYmRodzRaNC9QSEg0NVZYWG9tbXBpWU53Yjd1RTZpc3JIVDFEQUJBQWdtQUFRQjIyTFJwVTlhLzRHclpzcVZCQWNCT1ZGVlZ4Y1NKRStPRkYxNkl4c1pHRFNIckpTRUEzclJwa3hQQUFBQUpKQUFHQU5oaDNicDFXUjhBT3dFTUFQL2JsaTFiWXNLRUNZSmZFaWNKKzdyeThuSUJNQUJBQWdtQUFRQjJXTFpzbVN1Z0FTQWhxcXVyWS9Ma3lURno1c3lvcjYvWEVCSW5DZnU2cFV1WENvQUJBQkpJQUF3QXNNUDgrZk96L2dSd2NYR3hRUUhRck5YVTFNU1VLVlBpbVdlZUVmeVNhRW5ZMTczKyt1dStBUXdBa0VBQ1lBQ0FIUllzV0ZDWHlXUWFVcWxVWWJiVzJMcDFhNE1Db0ZtcXE2dUxwNTkrT3FaTm14YmJ0c21rU0w1czM5ZWwwK21HcFV1WGJqY3BBSURrRVFBREFMeERVMVBUdG9LQ2dyYlpXcDhBR0lEbVp2djI3VEY5K3ZSNDhza25ZK3RXdDlHU083SjlYOWZVMU9SZk9BQ0FoQklBQXdDOFEwTkR3OVpzRG9CTFMwc05DWURtOG5keVRKczJMWjU2NnFtb3JxN1dFSEpPdHUvckdoc2IvWXNIQUpCUUFtQUFnSGVvcjYrdmJOV3FWYzlzcmM4SllBQnlYV05qWTh5WU1TT2VmUExKcUt5czFCQnlWcmJ2NitycjY2dE1DUUFnbVFUQUFBRHYwTkRRa05Wdm1nWEFBT1NxZERvZHMyYk5pc21USjhmR2pSczFoSnlYN2Z1NmJOOFhBd0R3M2dUQUFBRHZVRmRYVjVYTjlaV1dsa1lxbFlwTUptTllBT1NFVENZVHI3MzJXanorK09PeGF0VXFEYUZaU0tWU1VWSlNrdFUxMXRiV1Zwa1VBRUF5Q1lBQkFONWgyN1p0bTdLNXZ2ejgvR2pWcWxYVTFOUVlGZ0NKbHNsa1l2YnMyZkg0NDQ5SGVYbTVodENzdEdyVkt2THo4N082eHExYnR6b0JEQUNRVUFKZ0FJQjNxSzZ1M3B6dE5aYVZsUW1BQVVpc3Q0UGZpUk1ueHBvMWF6U0VacW1zckN6cmE5eTJiVnVWU1FFQUpKTUFHQURnSGFxcXFqWmxlNDN0MnJXTHRXdlhHaFlBaVRObnpweVlOR2xTTEYyNlZETm8xdHExYTVmMU5XN2F0TWtKWUFDQUxOYlFXQmdGalEwUkVaRktSU2F2TUpyZS9wa0FHQURnSFNvcUtxcXl2Y1lrdkRBRWdIZGFzR0JCVEpnd0lkNTY2eTNOZ0lUczV6WnMyQ0FBQmdESVlvVUZEZjlNZWpNUnFhYjAvK1MrQW1BQWdIZFl0V3BWMXIvb2F0dTJyVUVCa0FnTEZ5Nk04ZVBIeCtMRml6VUQzaUVKQWZEcTFhdXJUQW9BSUprRXdBQUE3N0Jnd1lLc0Q0Q2RBQVlnMnkxZnZqekdqUnNYOCtmUDF3ellpU1Q4UWw4UzlzVUFBT3ljQUJnQTRCMmVlT0tKalpsTXBpbVZTdVZuYTQxT0FBT1FyVmF1WEJtUFBQS0k0QmMrUUxiL1FsOG1rMmw2NG9rbk5wb1VBRUF5Q1lBQkFONmh1cm82dlgzNzlnMUZSVVZkc3JWR0o0QUJ5RFpyMTY2TkNSTW14T3pac3lPVHlXZ0lKSHcvdDMzNzlnM1YxZFZwa3dJQVNDWUJNQURBdTlUVjFhMFhBQVBBQjF1L2ZuMDg5dGhqZ2wvSXNmMWNYVjNkZWxNQ0FFZ3VBVEFBd0x2VTFkVlZ0R25USm12ckt5a3BpUll0V3NUMjdkc05DNEM5b3FLaUlpWk9uQml2dlBKS05EVTFhUWg4QkVWRlJWRmNYSnoxKzJHVEFnQklMZ0V3QU1DN2JOMjZkVjJYTGxsN0FEaFNxVlIwN05neDFxeFpZMWdBN0ZGVlZWVXhjZUxFZVA3NTV3Vy84REYxN05neFVxbFUxdStIVFFvQUlMa0V3QUFBNzFKVlZaWDFKeDQ2ZGVva0FBWmdqOW04ZVhNOC92amo4Y0lMTDBSalk2T0d3Q2ZjeDlrUEF3Q3dPd21BQVFEZVpmMzY5Vm4vemJNa3ZEZ0VJUG0yYk5rU1U2Wk1pWmt6WjBaOWZiMkd3QzdRc1dOSCsyRUFBSFlyQVRBQXdMdXNYcjA2NjA4OEpPSEZJUURKVlZOVEUxT21USWxubm5sRzhBdTdXQkora1cvVnFsVUNZQUNBQkJNQUF3Qzh5OS8vL3Zlcy8rYVpBQmlBM2FHMnRqWW1UNTRjeno3N2JOVFYxV2tJTk5OOTNLdXZ2aW9BQmdCSU1BRXdBTUM3UFB6d3crdC8vT01mTjZSU3FjSnNyYkZ6NTg0R0JjQXVzMzM3OXBnK2ZYcE1uVG8xdG0zYnBpR3dHMlg3Q2VCME90M3c4TU1QQzRBQkFCSk1BQXdBOEM3VjFkWHB1cnE2OGxhdFd1MlRyVFYyNk5BaDh2THlJcDFPR3hnQUgxdERRME5NbXpZdG5ucnFxYWl1cnRZUTJNM3k4dktpUTRjT1dWMWpmWDM5bXRyYVdwdE1BSUFFRXdBREFPeEViVzN0bW13T2dBc0tDcUpkdTNheGNlTkd3d0xnSTJ0c2JJd1pNMmJFazA4K0daV1ZsUm9DZTBqNzl1MmpvQ0M3WDhmVjFOU1VteFFBUUxJSmdBRUFkbUx6NXMycjJyZHZuOVUxZHV2V1RRQU13RWVTVHFkajFxeFpNWG55WkgrSHdGN2F2Mlc3TFZ1MnJEUXBBSUJrRXdBREFPekVwazJiVnZmcDB5ZXJhK3pXclZ2TW16ZlBzQUQ0UUc4SHYxT21USWtOR3pab0NPekYvVnUyMjdCaHd4cVRBZ0JJTmdFd0FNQk9yRml4WXZXd1ljT3l1c1lrdkVBRVlPL0taREx4MGtzdnhaUXBVNks4M0sydXNMZDE3ZG8xNjJ0Y3RXclZLcE1DQUVnMkFUQUF3RTdNbno5LzlaZ3hZN0s2eGlTOFFBUmc3OGhrTWpGNzl1eVlPSEZpckZuak1COWtpeVQ4QXQrOGVmUDhvUUVBa0hBQ1lBQ0FuUmczYnR5YWIzN3ptNW1JU0dWcmpVNEFBN0F6YytiTWlTZWVlQ0tXTFZ1bUdaQmxFdkFMZkpseDQ4YXROaWtBZ0dRVEFBTUE3TVRycjc5ZTI5RFFzS213c0xCRHR0WllYRndjWldWbHNXWExGZ01ESUJZc1dCRGp4NCtQSlV1V2FBWmtvYkt5c2lndUxzN3FHaHNhR2pZdVdMQ2d6clFBQUpKTkFBd0E4QjYyYnQyNnZGMjdkaDJ5dWNhdVhic0tnQUdhdVlVTEY4YjQ4ZU5qOGVMRm1nRlpMQW0zdDJ6YnRtMjVTUUVBSko4QUdBRGdQVlJWVlMxdDE2N2QwR3l1c1dmUG5yRnc0VUxEQW1pR2xpMWJGbzg5OWxqTW56OWZNeUFCZXZic21mVTFWbFpXTGpVcEFJRGtFd0FEQUx5SGRldldMZXZUcDA5VzE1aUVGNGtBN0ZvclZxeUlSeDk5VlBBTENaT0VmZHZhdFd1WG1SUUFRUElKZ0FFQTNzUENoUXVYSFg3NDRWbGRZNjlldlF3S29KbFl0V3BWakI4L1B1Yk9uUnVaVEVaRElHR1NzRzlidUhEaE1wTUNBRWcrQVRBQXdIdVlObTNhMGtzdXVTU3JhK3pldlh2azUrZEhVMU9UZ1FIa3FIWHIxc1g0OGVOajl1elpnbDlJcUlLQ2drUjhBL2pwcDU5ZVpsb0FBRG13LzlRQ0FJQ2RlK2loaHpiY2Q5OTlXL1B6ODB1emRqTlhVQkJkdW5TSk5XdldHQmhBanFtb3FJaUpFeWZHeXkrL0hPbDBXa01nd2JwMjdSb0ZCZG45R3E2eHNiSDZrVWNlMldCYUFBREpKd0FHQUhnZjI3WnRXMTVXVm5ad050ZllxMWN2QVRCQURxbXFxb3FKRXlmRzg4OC83NFlIeUJGSitQN3Z0bTNibHBzVUFFQnVFQUFEQUx5UExWdTJMTXYyQUxobno1N3gwa3N2R1JaQXdtM2V2RGtlZi96eGVPR0ZGNkt4c1ZGRElJY2s0ZnUvVzdac1dXcFNBQUM1UVFBTUFQQSsxcTlmdnl6YlQyejA2TkhEb0FBU2JNdVdMVEZseXBTWU9YTm0xTmZYYXdqa29DVHMxOWF2WDcvTXBBQUFjb01BR0FEZ2ZTeFlzR0RoMEtGRHM3ckdmZmZkTjFLcFZHUXlHUU1EU0pDYW1wcVlNbVZLUFBQTU00SmZ5R0dwVkNyMjNYZmZySzl6L3Z6NUMwMExBQ0EzQ0lBQkFON0hvNDgrK3VZRkYxeVExVFdXbEpSRTU4NmRZOTI2ZFFZR2tBQzF0YlV4ZWZMa2VQYlpaNk91cms1RElNZDE3ZG8xV3JWcWxmVjEvdm5QZjE1a1dnQUF1VUVBREFEd1BpWk5tbFJWWDErL29haW9xR00yMTdudnZ2c0tnQUd5M1BidDIyUDY5T2t4ZGVyVTJMWnRtNFpBTTlHblQ1K3NyN0crdnI3aXlTZWZyREl0QUlEY0lBQUdBUGdBVzdkdVhaVHRBWENmUG4zaXBaZGVNaXlBTE5UUTBCRFRwazJMcDU1NktxcXJxelVFbXBra1hQKzhkZXRXcDM4QkFIS0lBQmdBNEFOVVZGUXM3TkNodzhoc3JqRUpMeFlCbXB2R3hzYVlNV05HUFBua2sxRlpXYWtoMEV3bFlaOVdVVkhoKzc4QUFEbEVBQXdBOEFHV0xsMjY2TUFERDh6cUdudjE2aFVGQlFYUjJOaG9ZQUI3V1RxZGpsbXpac1drU1pOaTA2Wk5HZ0xOV0dGaFlmVHMyVE1SKzEzVEFnRElIUUpnQUlBUE1IUG16RVdubm5wcWRtL3FDZ3FpWjgrZXNXelpNZ01EMkV2ZURuNG5UNTRjR3pkdTFCQWc5dGxubjhqUHowL0NmbmV4YVFFQTVJNDhMUUFBZUgrLy9PVXZWNmJUNmJwc3I3TlBuejZHQmJBWFpES1plUEhGRitPNzMvMXUzSC8vL2NKZjRKK1NjUDF6T3AydSsrVXZmN25TdEFBQWNvY1R3QUFBSDZDNnVqcGRYVjI5dUUyYk5vZGtjNTM5K3ZXTDZkT25HeGpBSHBMSlpHTDI3Tmt4Y2VMRVdMTm1qWVlBTzkyZkpXQ3Z1N2k2dWpwdFdnQUF1VU1BREFEd0lXellzR0ZldGdmQS9mdjNOeWlBUGVUVlYxK05TWk1teGFwVnF6UUQyS2xVS3BXSS9kbUdEUnZtbWhZQVFHNFJBQU1BZkFpTEZ5OStvMi9mdmxsZFkxbFpXWFR1M0RuV3IxOXZZQUM3eVlJRkMyTDgrUEd4Wk1rU3pRRGVWNWN1WGFLMHREUUorOXo1cGdVQWtGc0V3QUFBSDhKVFR6MzErdWpSbzdPK3p2MzMzMThBRExBYkxGeTRNTWFQSHgrTEZ5L1dET0JENzh1U1lNcVVLYStiRmdCQWJzblRBZ0NBRC9hTFgveGlUV05qWTFXMjE1bVVGNDBBU2JGczJiSzQrKzY3NHovKzR6K0V2OEJIa29Udi96WTBORlRlZSsrOXEwMExBQ0MzT0FFTUFQQWhORFEwWkRadjNqeS9RNGNPSTdPNVRnRXd3SzZ4WXNXS2VQVFJSMlArZkRlakFybTdMOXV5WllzLzVBQUFjcEFBR0FEZ1ExcTNibDNXQjhBZE8zYU1ObTNheE9iTm13ME00R05ZdFdwVmpCOC9QdWJPblJ1WlRFWkRnSStsYmR1MjBhRkRoMFRzYjAwTEFDRDNDSUFCQUQ2a2VmUG16VHZvb0lPeXZzNEREend3WG5ycEpRTUQrQWpXclZzWDQ4ZVBqOW16Wnd0K2dWMnlIMHVDdVhQbnpqTXRBSURjSXdBR0FQaVEvdnpuUDg4Lzc3enpzcjdPQXc0NFFBQU04Q0ZWVkZURXVISGpCTC9BTHQrUEpjSEREei9zQkRBQVFBNFNBQU1BZkVnVEowNnNySzJ0WGRHcVZhdDlzcm5PZ3c4KzJMQUFQa0JWVlZWTW5EZ3hubi8rK1docWF0SVFZSmRLd3EweE5UVTF5eWRObWxSbFdnQUF1VWNBREFEd0VXellzT0h2dlhyMXl1b0F1RzNidHRHMWE5ZFl1M2F0Z1FHOHkrYk5tK1B4eHgrUEYxNTRJUm9iR3pVRTJPVzZkZXNXYmR1MlRjUysxclFBQUhLVEFCZ0E0Q05ZdUhEaGE3MTY5VG9qMitzY01HQ0FBQmpnSGJaczJSSlRwa3lKNTU1N0xyWnYzNjRod0c2VGxPLy9MbHk0OE8rbUJRQ1Ftd1RBQUFBZndjU0pFLzkrd2drblpIMmRCeDU0WUV5ZlB0M0FnR2F2cHFZbXBreVpFczg4ODB6VTE5ZHJDTERiRFJnd0lCRjFqaDgvL3UrbUJRQ1Ftd1RBQUFBZndiMzMzcnY2QnovNHdmcWlvcUxPMlZ6bkFRY2NFSGw1ZVpGT3B3ME5hSlpxYTJ0ajh1VEo4ZXl6ejBaZFhaMkdBSHRFWGw1ZTlPL2ZQK3ZycksrdlgzZmZmZmVWbXhnQVFHNFNBQU1BZkVTVmxaVnp1M2J0bXRYSGdGdTFhaFg3N0xOUExGdTJ6TUNBWnFXdXJpNmVmdnJwbURadFdtemJ0azFEZ0QxcW4zMzJpVmF0V21WOW5aczJiWnBqV2dBQXVVc0FEQUR3RVMxZHVuUjJ0Z2ZBRVJHREJnMFNBQVBOUmtORFEweWJOaTJlZXVxcHFLNnUxaEJncisyL2t1Q3R0OTc2bTJrQkFPUXVBVEFBd0VjMGZmcjB2NDhjT1RMcjZ4dzRjR0JNbUREQndJQ2MxdERRRU04OTkxdzgrZVNUVVZsWnFTSEFYdDkvSmNHMGFkUCtibG9BQUxsTEFBd0E4Qkg5eDMvOHg5SmJicm1sT2o4L3YzVTIxOW1yVjY4b0t5dUxMVnUyR0JxUWM5THBkTXlhTlNzbVRab1Vtelp0MGhCZ3J5c3JLNHRldlhwbGZaMk5qWTFiN3Jubm5tVW1CZ0NRdXdUQUFBQWZVVzF0YlhyRGhnMS83ZEtseTNIWlhHY3FsWXFCQXdmR3JGbXpEQTNJR1c4SHY1TW5UNDZOR3pkcUNKQTFCZzRjR0tsVUt1dnIzTGh4NHl1MXRiVnBFd01BeUYwQ1lBQ0FqK0d0dDk1Nkpkc0Q0SWdRQUFNNUk1MU94OHN2dnh4VHBreUo4dkp5RFFHeWN0K1ZCSXNXTFhyRnRBQUFjcHNBR0FEZ1l4Zy9mdndyUnh4eFJOYlhlZEJCQjBWQlFVRTBOallhR3BCSW1Vd21acytlSFJNblRvdzFhOVpvQ0pDVkNnb0s0cUNERGtwRXJZODg4b2dBR0FBZ3grVnBBUURBUi9makgvOTRaWDE5L2Zwc3I3T29xQ2o2OWV0bllFQWl2ZnJxcTNISEhYZkV6My8rYytFdmtOWDY5ZXNYUlVWRldWOW5YVjFkK2IzMzNydmF4QUFBY3BzVHdBQUFIOU9HRFJ0ZTZkR2p4NmV6dmM1Qmd3YkZnZ1VMREF4SWpDVkxsc1NFQ1JOaS92ejVtZ0Vrd3VEQmd4TlI1L3IxNjUzK0JRQm9CZ1RBQUFBZjA3eDU4MTVPUWdBOGJOaXdlUGpoaHlPVHlSZ2FrTlhlZlBQTm1EQmhRaXhldkZnemdNUklwVkl4ZE9qUVJOUTZkKzdjbDB3TUFDRDNDWUFCQUQ2bSsrNjc3K1hSbzBkbklpS1Z6WFcyYmRzMmV2ZnVIY3VXTFRNMElDc3RXN1lzSG52c01TZCtnVVRxMDZkUHRHM2JOZ21scHUrOTk5Ni9taGdBUU80VEFBTUFmRXdUSjA2czNMcDE2NUxTMHRLKzJWN3JrQ0ZEQk1CQTFsbXhZa1U4K3VpamdsOGcwWVlNR1pLSU9xdXJxeGMrL2ZUVG0wME1BQ0QzQ1lBQkFENkI4dkx5bC9mZmYvK3NENEFIRHg0YzQ4YU5NekFnSzZ4Y3VUSW1USmdRYytmT2RUMDlrSGhKK2Y3dm1qVnJmUDhYQUtDWkVBQURBSHdDTTJmT2ZHNy8vZmYvZkxiWDJhMWJ0K2pXclZ1VWw1Y2JHckRYckZ1M0xzYVBIeCt6Wjg4Vy9BSTVvV2ZQbnRHbFM1ZEUxRHBqeG96blRBd0FvSGtRQUFNQWZBSzMzWGJiYTVkY2NrbDFmbjUrNjJ5dmRjaVFJUUpnWUs5WXYzNTlQUGJZWTRKZklPY2s1ZnJueHNiR3piZmRkdHM4RXdNQWFCNEV3QUFBbjBCbFpXWFRoZzBiL3RxbFM1ZmpzcjNXUXc4OU5DWk5tbVJvd0o3OE16S2VlT0tKZVA3NTU2T3BxVWxEZ0p4ejZLR0hKcUxPaW9xS1Y2cXJxOU1tQmdEUVBBaUFBUUErb1huejVzMU1RZ0RjdTNkdjEwQURlMFJWVlZWTW5EZ3hYbmpoaFdoc2JOUVFJQ2QxNzk0OWV2YnNtWlQ5cXV1ZkFRQ2FrVHd0QUFENFpQNzd2Lzk3VmtRazRrVEZwejcxS1FNRGRwc3RXN2JFUXc4OUZMZmZmbnM4OTl4endsOGdwdzBmUGp3UmRXWXltZlRkZDkvOWdva0JBRFFmVGdBREFIeENreVpOcXRxeVpjdUNzckt5ZzdLOTF1SERoOGZqano5dWFNQXVWVk5URTFPbVRJbG5ubmttNnV2ck5RVEllYWxVS2c0NzdMQkUxTHBseTViWHAwK2Z2c1hVQUFDYUR3RXdBTUF1c0h6NThsa0RCdzdNK2dDNFM1Y3UwYXRYcjFpNWNxV2hBWjlZYlcxdFRKNDhPWjU5OXRtb3E2dlRFS0RaNk4yN2QzVHMyREV4KzFRVEF3Qm9YZ1RBQUFDN3dMUFBQdnZDd0lFRHIwaENyY09HRFJNQUE1OUlYVjFkUFAzMDB6RnQyclRZdG0yYmhnRE56ckJod3hKVDYxLys4cGNYVFF3QW9IbnhEV0FBZ0YzZzFsdHZuVjlmWDc4MkNiVWVmdmpoa1VxbERBMzR5Qm9hR21McTFLbHg2NjIzeHVPUFB5NzhCWnFsSkYzL1hGZFh0L3JXVzI5ZFlHb0FBTTJMRThBQUFMdEFRME5EWnMyYU5jLzE2ZFBuczlsZWE3dDI3YUpQbno2eFpNa1Nnd00rN0o5eE1XM2F0SGpxcWFlaXVycGFRNEJtYmIvOTlvdTJiZHNtb3RiVnExZlBOREVBZ09aSEFBd0FzSXM4Kyt5ejA1SVFBRWRFSEhIRUVRSmc0QU9sMCttWU5XdFdUSm8wS1RadDJxUWhBQkZ4NUpGSEpxYlc2ZE9uVHpNeEFJRG14eFhRQUFDN3lDMjMzUEphUTBORFpSSnFIVDU4ZUxSbzBjTFFnSjFLcDlQeDNIUFB4VzIzM1JiMzMzKy84QmRnaDZLaW92alVwejZWaUZvYkdobzIzSExMTFhOTkRRQ2crWEVDR0FCZ0Y2bXVyazZYbDVjL3Q4OCsrNXlSN2JXMmJOa3lEajMwMEhqNTVaY05EdmluZERvZEw3Lzhja3laTWlYS3k4czFCT0JkaGd3WkVrVkZSWW1vZGMyYU5jL1YxdGFtVFEwQW9Qa1JBQU1BN0VJdnZ2amlNMGtJZ0NNaVJvNGNLUUFHSWlJaWs4bkU3Tm16WStMRWliRm16Um9OQVhpZi9WTlN6Sm8xNjFrVEF3Qm9uZ1RBQUFDNzBPMjMzLzdLT2VlY3N6VS9QNzgwMjJzZE1HQkF0Ry9mM3RXdTBNeTkrdXFyTVduU3BGaTFhcFZtQUx5UGpoMDd4Z0VISEpDSVdoc2JHNnUvOFkxdi9OWFVBQUNhSndFd0FNQXV0SExseW9iMTY5ZlA2dGF0Mitoc3J6V1ZTc1hoaHg4ZWt5Wk5NamhvaHViTW1ST1RKMCtPSlV1V2FBYkFoM0Q0NFlkSEtwVktSSzNyMTYrZlZWRlIwV2hxQUFETlU1NFdBQURzV3ErKyttcGlydHM3N0xERERBeWFtVGZmZkRQKy9kLy9QWDd5azU4SWZ3RStwRlFxRlNOR2pFaE12YSs4OHNvenBnWUEwSHc1QVF3QXNJdmRkTk5OejUxNjZxblYrZm41cmJPOTFtN2R1a1gvL3YxajRjS0ZCZ2M1YnRteVpmSFlZNC9GL1Buek5RUGdJenJnZ0FPaWMrZk9pYWkxc2JGeHk0MDMzampMMUFBQW1pOEJNQURBTHJaeTVjcUc4dkx5R1QxNzl2eDBFdW85K3VpakJjQ1F3NVl2WHg3anhvMFQvQUo4d3YxU1VwU1hsejlUWGw3ZVlHb0FBTTJYQUJnQVlEZVlNV1BHVXhkY2NFRWlBdUFoUTRaRTY5YXRvN3E2MnVBZ2g2eGN1VEltVEpnUWMrZk9qVXdtb3lFQUgxT2JObTNpMEVNUFRVeTl6ejc3N0ZPbUJnRFF2UGtHTUFEQWJ2RFZyMzcxbFlhR2hrMUpxTFdnb0NDT09PSUlRNE1jc1c3ZHV2ajV6MzhlZDk1NVo4eVpNMGY0Qy9BSmpSdzVNdkx6OHhOUmEwTkR3OGFiYnJycFZWTURBR2plbkFBR0FOZ05LaXNybTFhdFdqVzlUNTgrNXlTaDNxT1BQanFlZlBKSlFSRWsyUHIxNitPeHh4NkwyYk5uKzNjWllCZEpwVkl4YXRTb3hOUzdjdVhLYWRYVjFXbVRBd0JvM3B3QUJnRFlUYVpObTVhWTYvYzZkdXdZQXdZTU1EUklvQTBiTnNTdmYvM3IrTmQvL2RkNDlkVlhoYjhBdTlDQUFRT2lZOGVPaWFuMzZhZWZmdExVQUFBUUFBTUE3Q1pmKzlyWDV0VFgxMWNrcGQ2ampqckswQ0JCcXFxcTR2Nzc3NDl2Zi92YjhlS0xMMFpUVTVPbUFPeGlSeDU1WkdKcXJhK3ZYL2VOYjN6amRWTURBTUFWMEFBQXUwbHRiVzE2eFlvVlQrKy8vLzZmVDBLOWh4NTZhTFJ0MnphcXFxb01EN0xZbGkxYllzcVVLZkhjYzgvRjl1M2JOUVJnTjJuYnRtME1HVElrTWZVdVg3NzhxZHJhV3RjL0F3RGdCREFBd083MHh6LytjVUpTYXMzUHo0L2pqanZPMENCTDFkVFV4S09QUGhxMzNYWmIvT1V2ZnhIK0F1eG14eDU3Yk9UbjV5ZWwzTXl2Zi8zckNhWUdBRUNFQUJnQVlMZTY2NjY3bGxaWFY4OVBTcjFISDMxMHRHalJ3dUFnaTd3ZC9IN2pHOStJcVZPblJuMTl2YVlBN0dZdFdyU0lvNDgrT2pIMWJ0bXk1WTE3N3Jsbmhja0JBQkRoQ21nQWdOM3U5ZGRmbjNUNDRZY1BTRUt0eGNYRmNkaGhoOFhNbVRNTkR2YXl1cnE2ZVBycHAyUGF0R214YmRzMkRRSFlndzQ3N0xBb0tTbEpUTDN6NXMxN3d0UUFBSGliRThBQUFMdlo5NzczdmFucGRMb2hLZldlY01JSmtVcWxEQTcya29hR2hwZzZkV3JjZXV1dDhmampqd3QvQWZhd1ZDb1ZKNXh3UW1McVRhZlQyNy83M2U4K1pYSUFBTHpOQ1dBQWdOMXMrdlRwV3lvcUttWjI2ZElsRVIvWTdkNjllL1R2M3ovZWZQTk53NE05cUtHaElhWk5teFpQUGZWVVZGZFhhd2pBWG5MQUFRZEU5KzdkRTFOdlJVWEZjek5telBBWEJ3QUEvK1FFTUFEQUhqQnIxcXhFWGN1WHBGTXZrSFRwZERxZWUrNjV1UDMyMitQUlJ4OFYvZ0xzWmNjZmYzeWk2cDB4WThZa1V3TUE0SjJjQUFZQTJBTysrdFd2dm5UNjZhZFhGUllXdGsxQ3ZRTUhEb3lPSFR2R2hnMGJEQTkyazNRNkhiTm16WXJKa3lmSHhvMGJOUVFnQzNUczJERUdEaHlZbUhvYkdob3FiNzc1NXBkTURnQ0FkM0lDR0FCZ0R5Z3ZMMjlZc1dMRjFNUnNFdlB5NHNRVFR6UTQyQTNTNlhTOCtPS0w4WjN2ZkNmdXYvOSs0UzlBRmpucHBKTWlMeTg1cjh0V3JGZ3hwYUtpb3RIa0FBQjRKd0V3QU1BZThxdGYvZXJSaU1na3BkNmpqam9xeXNyS0RBNTJrVXdtRTYrKyttcDg3M3ZmaTEvLyt0ZXhkdTFhVFFISUltVmxaWEhVVVVjbDZxK1cvLzd2Ly82enlRRUE4RzRDWUFDQVBlUS8vL00vbDFkV1Z2NHRLZlVXRmhiR01jY2NZM0N3Qzd3ZC9QNzg1eitQTld2V2FBaEFGanJ1dU9PaW9DQTVYMHVycXFxYS9kT2YvblMxeVFFQThHNENZQUNBUGVpbGwxNGFsNlI2anp2dXVDZ3FLakk0K0pqbXpKa1RkOTExVi96ODV6K1AxYXU5b3dmSVZrVkZSWW43eGJjWFhuaGhuTWtCQUxBekJWb0FBTERuakIwNzlwa0ZDeFpVRmhZV3RrdEN2U1VsSlhIRUVVZkU5T25URFE4K2dqZmZmRFBHang4ZmI3MzFsbVlBSk1DUlJ4NFpKU1VsaWFtM29hRmgwelhYWFBPc3lRRUFzRE1DWUFDQVBhaTh2THhoNmRLbEUvdjM3Mzl4VW1vKzhjUVQ0OWxubjQxME9tMkE4QUVXTFZvVWp6MzJXQ3hldkZnekFCSWlMeTh2VGp6eHhFVFZ2R1RKa2lmS3k4c2JUQThBZ0ozdWNiVUFBR0RQK3UxdmZ6c3hJakpKcWJkang0NHhkT2hRZzRQM3NYejU4cmo3N3J2alJ6LzZrZkFYSUdHR0RSc1dIVHAwU0ZMSm1kLzg1amVQbXh3QUFPOUZBQXdBc0lmOTUzLys1L0pObXphOWtxU2FUei85OUVpbFVvWUg3N0p5NWNyNHlVOStFdC8vL3Zkai92ejVHZ0tRTUhsNWVYSEdHV2NrcXVaTm16YTlmTTg5OTZ3d1BRQUEzb3Nyb0FFQTlvS1hYbnBwL0ttbm5ucFlVdXJ0MnJWckRCa3lKR2JQbm0xNEVCSHIxcTJMOGVQSHgrelpzeU9UeVdnSVFFSU5IVG8wT25mdW5LaWFYM2poaFFrbUJ3REEreEVBQXdEc0JaZGZmdmt6UzVZc1dWZFVWTlFsS1RXZmNjWVo4YmUvL1UzWVJiTzJmdjM2ZU95eHh3Uy9BRGtnbFVyRjZhZWZucWlhNitycTFseDIyV1hUVFE4QWdQY2pBQVlBMkFzcUt5dWI1cytmLzhpaGh4NTZkVkpxN3RhdG0xUEFORnNiTm15SXh4OS9QRjU1NVpWb2FtclNFSUFjOEtsUGZTcTZkdTJhcUpyZmVPT05jZFhWMVduVEF3RGcvZmdHTUFEQVh2TDFyMzk5WERxZHJrdFN6YjRGVEhOVFZWVVY5OTkvZjN6NzI5K09GMTk4VWZnTGtDTlNxVlI4K3RPZlRsVE42WFM2OXB2Zi9PWmpwZ2NBd0FkeEFoZ0FZQytaTVdORzlabzFhLzdTczJmUHhMeDk3TjY5ZXd3Y09ERG16SmxqZ09TMExWdTJ4SVFKRStLRkYxNkl4c1pHRFFISU1ZY2VlbWgwNjlZdFVUV3ZYcjM2cVJrelpsU2JIZ0FBSDhRSllBQ0F2ZWpYdi83MUh5TWlVUjhTUGV1c3M1d0NKbWR0MjdZdEhuMzAwYmp0dHR2aXVlZWVFLzRDNUtDOHZMd1lNMlpNMHNyTy9PcFh2L3FUNlFFQThLSDJ2Rm9BQUxEM2ZQLzczMytycXFvcVVSL1Y3ZEdqUjN6cVU1OHlQSEpLZlgxOVRKMDZOYjcxclcvRjFLbFRvNzYrWGxNQWN0U0lFU09pUzVjdWlhcDUwNlpOZjczcnJydVdtaDRBQUIrR0FCZ0FZQzk3NXBsbkhrcGF6V2VjY1ViazVkbEtranZtelpzWGp6NzZhR3pkdWxVekFISllRVUZCbkg3NjZZbXJlOXEwYVErYUhnQUFINWEzZGdBQWU5bllzV05uMXRmWHIwMVN6WjA3ZDQ3RERqdk04QUNBUkJrNWNtUjA2TkFoVVRYWDFkV3RIanQyN1BPbUJ3REFoeVVBQmdEWXl5b3JLNXRlZSsyMVB5YXQ3alBQUERNS0Nnb01FQUJJaEJZdFdpVHk5Ty9zMmJQL1VGMWRuVFpCQUFBK0xBRXdBRUFXdU9xcXF5WTBOalpXSmFubTl1M2J4OUZISDIxNEFFQWlISGZjY2RHbVRadEUxZHpRMExEeGlpdXVtR2g2QUFCOEZBSmdBSUFzc0dEQmdycUZDeGMrbHJTNlI0OGVIWVdGaFFZSUFHUzFsaTFieHNrbm41eTR1aGN1WERodTZkS2wyMDBRQUlDUFFnQU1BSkFsdnY3MXIvOHBuVTdYSnFubXRtM2J4aW1ubkdKNEFFQldPKzIwMDZLMHREUlJOVGMxTmRWKzdXdGZlOGowQUFENHFBVEFBQUJaNHVtbm45NjhmUG55eEYzeE4zcjA2R2pYcnAwQkFnQlpxVU9IRG5IODhjY25ydTVseTVaTm1ENTkraFlUQkFEZ294SUFBd0Jra2J2dnZ2dFBtVXltS1VrMUZ4WVd4dW1ubjI1NEFFQldPdlBNTXhQM3lZcE1KdE40MTExMy9kSDBBQUQ0T0FUQUFBQlo1QmUvK01XYXRXdlhUa3RhM1VjY2NVVDA2dFhMQUFHQXJOSzdkKzg0N0xEREVsZDNlWG41WCs2Ly8vNTFKZ2dBd01jaEFBWUF5RElQUC96d241SldjeXFWaWpQUFBOUHdBSUNzTW1iTW1FaWxVb21yKzhFSEgveVQ2UUVBOEhFSmdBRUFzc3pYdi83MU56WnMyREFyYVhVUEhEZ3dEajc0WUFNRUFMTENvRUdEWXNDQUFZbXJ1NktpWXVhdHQ5NjZ3QVFCQVBpNEJNQUFBRmxvM0xoeHYwMWkzV1BHakltOFBGdE1BR0R2eXN2TGl6Rmp4aVN5OWovLytjKy9OVUVBQUQ3UmZsZ0xBQUN5ei9YWFh6K25xcXJxcjBtcnUxZXZYbkhVVVVjWklBQ3dWeDF6ekRIUnZYdjN4Tlc5YWRPbVYyNjY2YWE1SmdnQXdDY2hBQVlBeUZKLyt0T2Y3azFpM1dQR2pJblMwbElEQkFEMmlqWnQyc1JaWjUyVnlOb2ZlT0NCZTAwUUFJQlBTZ0FNQUpDbGJycnBwcmxKUEFWY1hGd2NaNTU1cGdFQ0FIdkZXV2VkRlMxYnRreGMzWnMyYlhybDVwdHZubWVDQUFCOFVnSmdBSUFzTm03Y3VGOGxzZTVSbzBaRjc5NjlEUkFBMktQNjlPa1RJMGVPVEdUdGp6MzIySzlNRUFDQVhVRUFEQUNReGNhT0hUdTdxcXJxYjBtck81Vkt4Zm5ubngrcFZNb1FBWUE5dHYvNC9PYy9uOGo5UjJWbDVkK3V1ZWFhdjVraUFBQzdnZ0FZQUNETFRaMDY5YmRKckx0djM3NHhaTWdRQXdRQTlvakREanNzc1RlUVRKNDgrVGNtQ0FEQXJpSUFCZ0RJY3BkZWV1bUxWVlZWcnlheDlzOS8vdk5SWEZ4c2lBREFibFZhV2hybm4zOStJbXV2cXFyNjYrV1hYLzZTS1FJQXNLc0lnQUVBRXVDaGh4NzZXUkxyTGlzcmk5TlBQOTBBQVlEZDZxeXp6b3FTa3BJa2xwNzUzZTkrOTFNVEJBQmdWeElBQXdBa3dBMDMzREIzdzRZTnM1SlkrM0hISFJkOSt2UXhSQUJndCtqYnQyOGNkZFJSaWF5OW9xSmkxdGUvL3ZVM1RCRUFnRjFKQUF3QWtCQS8vL25QZnhvUjZhVFZuVXFsNHZPZi8zems1ZGw2QWdDN1ZuNStmbHgwMFVXUlNxV1NXSDc2RjcvNHhYK2JJZ0FBdTVxM2NBQUFDWEhISFhlOHRXN2R1dWxKckwxMzc5NXh6REhIR0NJQXNFdWRjTUlKMGIxNzkwVFdYbDVlL3BjNzdyampMVk1FQUdCWEV3QURBQ1RJM1hmZmZXOG1rMmxLWXUxbm5YVld0RzNiMWhBQmdGMmlRNGNPY2ZycHB5ZXk5a3dtMDNUMzNYZi8zQlFCQU5nZEJNQUFBQWx5enozM3JDZ3ZMMzg2aWJXM2JOa3l6ajMzWEVNRUFIYUpjODg5TjFxMGFKSEkydGVzV1RQMXh6Lys4VXBUQkFCZ2R4QUFBd0FrekE5LytNT2ZaektaaGlUV1BuejQ4QmcwYUpBaEFnQ2Z5S0dISGhwRGh3NU5aTzNwZExyaEJ6LzR3UzlNRVFDQTNVVUFEQUNRTVBmZWUrL3FSWXNXUFpEVStpKysrT0lvS1NreFNBRGdZMm5kdW5WY2ZQSEZpYTEvNGNLRmY3anZ2dnZLVFJJQWdOMUZBQXdBa0VDWFhYYlpyeHNhR2pZbHNmYXlzakpYUVFNQUg5dTU1NTRicGFXbGlheTlvYUZoNCtXWFgvNDdVd1FBWUhjU0FBTUFKTkRzMmJOclhuMzExVjhudGY0ampqZ2lEajc0WUlNRUFENlN3WU1IeCtHSEg1N1krbDk1NVpYN1pzK2VYV09TQUFEc1RnSmdBSUNFT3VlY2N4NnRxYWxabXRUNkw3cm9vbWpac3FWQkFnQWZTc3VXTGVOem4vdGNZdXV2cWFsWk1tYk1tTWRNRWdDQTNVMEFEQUNRVUpXVmxVM1RwazM3UlZMcmI5KytmWngrK3VrR0NRQjhLR2VjY1VhMGI5OCtzZlUvK2VTVDkxWlhWNmRORWdDQTNVMEFEQUNRWU9lZGQ5NjBxcXFxVjVKYS93a25uT0FxYUFEZ0F4MTg4TUZ4L1BISEo3YitUWnMydlh6QkJSYzhhNUlBQU93SkFtQUFnSVQ3NHgvL2VHOUVaSkpZZXlxVmlnc3V1TUJWMEFEQWUyclpzbVZjY01FRmtVcWxrcnFFelAzMzMvOHprd1FBWUU4UkFBTUFKTnpOTjk4OGI5V3FWVThrdGY2T0hUc20rbnQrQU1EdWRjRUZGMFRIamgwVFcvK0tGU3NlLy9yWHYvNkdTUUlBc0tjSWdBRUFjc0NOTjk3NGs2YW1wcTFKclgva3lKRXhkT2hRZ3dRQS9wZFBmZXBUTVdMRWlNVFczOVRVVkgzenpUZi90MGtDQUxBbkNZQUJBSExBeElrVEsvLys5Ny8vS3NscnVQRENDNk9zck13d0FZQ0lpR2pUcGsxOC92T2ZUL1FhWnMrZWZkL0VpUk1yVFJNQWdEMUpBQXdBa0NQT1B2dnNoMnBxYXBZbnRmN1MwdEs0NktLTERCSUFpRlFxRlYvODRoZWp0TFEwc1d1b3FhbDU2Nnl6em5yWU5BRUEyTk1Fd0FBQU9hS2lvcUp4MHFSSlAwN3lHZ1lQSGh3alI0NDBUQUJvNW80NDRvZzQ2S0NERXIyR0o1NTQ0cWVWbFpWTnBna0F3SjRtQUFZQXlDR1hYSExKeklxS2lobEpYc01GRjF3UTNicDFNMHdBYUtaNjl1eVorS3VmS3lvcVpuemhDMStZWlpvQUFPd05BbUFBZ0J6emIvLzJiL2VrMCtudFNhMi9SWXNXY2VXVlYwWmhZYUZoQWtBelUxaFlHRi82MHBjU3ZROUlwOVBiLyszZi91MGUwd1FBWUc4UkFBTUE1Smg3NzcxMzlhSkZpeDVNOGhxNmQrOGVaNTU1cG1FQ1FETnp4aGxuUlBmdTNSTzloc1dMRno5NDc3MzNyalpOQUFEMkZnRXdBRUFPK3V4blAvdkwydHJhUkw5NFBQSEVFMlB3NE1HR0NRRE54S0JCZytLa2swNUs5QnBxYTJ0WG4zdnV1YjgwVFFBQTlpWUJNQUJBRGxxOGVISDl1SEhqL2ozSmEwaWxVbkhKSlpkRTI3WnREUlFBY2x5Yk5tM2lra3N1aVZRcWxlaDFqQnMzN3Q4WEwxNWNiNklBQU94TkFtQUFnQngxK2VXWHYxUlJVVEVqeVdzb0xTMk5MM3poQzRsL0dRd0F2TGUzZittcmRldldpVjVIUlVYRk01ZGZmdmxMSmdvQXdONG1BQVlBeUdFMzNIRERYVTFOVFZ1VHZJYUREanJJOTRBQklJZDk1ak9maVVNT09TVFJhMmhxYXFxKzRZWWJmbWlhQUFCa0F3RXdBRUFPR3pkdTNNYlpzMmNuL2p0MHA1eHlpdThCQTBBT091U1FRK0xUbi81MDR0ZngxNy8rOWVmanhvM2JhS0lBQUdRREFUQUFRSTc3ekdjKzgxQjFkZlhDSks4aGxVckZGNy80eGVqUW9ZT0JBa0NPNk5peFkzenBTMTlLL0tjZU5tL2VQTyswMDA1N3hFUUJBTWdXQW1BQWdCeFhYVjJkZnVDQkIzNFVFZWtrcjZPNHVEZ3V2ZlRTeU11emhRV0FwTXZQejQvTExyc3Npb3VMazc2VTlQMzMzLytmdGJXMWFWTUZBQ0JiZUhzR0FOQU1YSC85OVhNV0xWcjBZTkxYc2YvKys4ZTU1NTVyb0FDUWNPZWRkMTcwN2RzMzhldFl1SERoSDcvNjFhKyticUlBQUdRVEFUQUFRRE54eVNXWC9MeXVycTQ4NmVzNC92ampmUThZQUJKczJMQmhjY3d4eHlSK0hYVjFkV3N1dlBEQyswd1VBSUJzSXdBR0FHZ21YbnZ0dGRvSEhuamd1eEdSU2ZJNlVxbFVmT2xMWDRvZVBYb1lLZ0FrVE8vZXZlUFNTeTlOL0hkL0l5THp3QU1QZk8vMTExK3ZOVlVBQUxLTkFCZ0FvQm01K3Vxci83WjA2ZEpIazc2T29xS2lHRHQyYkpTV2xob3FBQ1JFNjlhdDQ2cXJyb3JDd3NMRXIyWDU4dVhqcnI3NjZyK1pLZ0FBMlVnQURBRFF6SngzM25uL3I2NnViblhTMTlHaFE0ZTQvUExMSXkvUGxoWUFzbDFlWGw1Y2Z2bmwwYjU5KzhTdnBiNitmdDBsbDF6eUUxTUZBQ0JyOTk5YUFBRFF2THorK3V1MUR6NzQ0UGNqNFZkQlIwUU1HREFnempyckxFTUZnQ3czWnN5WU9QREFBM05pTFk4OTl0Z1BYbm5sbFcybUNnQkF0aElBQXdBMFExLzV5bGYrdW1iTm1xbTVzSmFUVHo0NURqMzBVRU1GZ0N3MVpNaVFPT21razNKaUxXdlhydjNMcFpkZStvS3BBZ0NRelFUQUFBRE4xR1dYWGZZZjlmWDFGVWxmUnlxVmlrc3Z2VFM2ZCs5dXFBQ1FaWHIwNkJGZi9PSVhJNVZLSlg0dERRME5tNjY1NXBvZm1pb0FBTmxPQUF3QTBFek5tREdqK29FSEh2aE81TUJWMEMxYnRvenJyNzgrMnJadGE3QUFrQ1hhdFdzWDExMTNYYlJzMlRJWGxwTjU2S0dIL25YU3BFbFZKZ3NBUUxZVEFBTUFOR05mK2NwWC9ycGt5WkkvNThKYTJyWnRHMWRmZlhXMGFOSENZQUZnTDJ2Um9rVmNmZlhWT2ZQTFdVdVhMbjMwaWl1dWVObGtBUUJJQWdFd0FFQXpkKzY1NS82a3RyWjJlUzZzcFhmdjNqbHp6U1FBSk5YYm4yZllaNTk5Y21JOXRiVzF5ODg1NTV3Zm15d0FBRWtoQUFZQWFPWVdMRmhROTdPZi9lemJtVXltTVJmV00yellzRGpsbEZNTUZnRDJrazkvK3RNeGRPalFuRmhMSnBOcC9OblBmdmJ0QlFzVzFKa3NBQUJKSVFBR0FDQnV2ZlhXQmZQbno3OC9WOVp6NXBsbnh1REJndzBXQVBhdzRjT0h4MmMrODVtY1djLzgrZk4vZCt1dHR5NHdXUUFBa2tRQURBQkFSRVNNR1RQbXZwcWFtcmR5WVMycFZDb3V1K3l5Nk5tenA4RUN3QjdTdTNmdnVQamlpM1BtVXd4YnQyNWRkUHJwcC8vYVpBRUFTQm9CTUFBQUVSR3hjdVhLaGgvKzhJZTNwZFBwbkxqaXNHWExsdkV2Ly9JdjBhVkxGOE1GZ04yc1M1Y3VjZjMxMTBkUlVWRk9yS2VwcWFubXU5Lzk3amZLeThzYlRCY0FnS1FSQUFNQThFOTMzWFhYMHVlZmYvNmVYRmxQYVdscFhIdnR0VkZXVm1hNEFMQ2JsSldWeFhYWFhSY2xKU1U1czZhWk0yZmUvZi8rMy85Ylpib0FBQ1NSQUJnQWdQL2w1Sk5QSGxkZVh2NTBycXluVTZkT01YYnMySnc1a1FRQTJhU29xQ2l1dWVhYTZOaXhZODZzcWJ5OC9NbFRUejExZ3VrQ0FKQlVBbUFBQVA2UFN5NjU1SzY2dXJxMXViS2VmZmZkTjY2NDRvckl5N1A5QllCZEpTOHZMNjY4OHNybzNidDN6cXlwcnE2dS9KSkxMdm1oNlFJQWtPaTl1aFlBQVBCdXMyYk5xbjdvb1lmdWpJaDBycXhwNE1DQmNkNTU1eGt1QU93aTU1OS9maHh5eUNHNXRLVDBndzgrZU9lc1diT3FUUmNBZ0NUTGIzdFE5Tnpwam5kYlJHMTVvUTRCQURSVEV5ZE9YRE5tekppOFRwMDZEYzJWTmZYcDB5Znk4L1BqelRmZk5HQUErQVRPT3V1c09PbWtrM0pxVGErLy92cDlaNTU1NWtUVEJRQWdDWXE3TjBaZTZjNS81Z1F3QUFEdjZkUlRULzMxbGkxYlhzK2xOWjEyMm1seDlORkhHeTRBZkV6SEhudHNuSHJxcVRtMXBpMWJ0cnh4Mm1tbi9jWjBBUURJQlFKZ0FBRGVVMFZGUmVPTk45NzRqY2JHeHFwY1d0Y0ZGMXdRUng1NXBBRUR3RWQwNUpGSHh1Yys5N21jV2xOalkyUFZ6VGZmL0kyS2lvcEdFd1lBSUJjSWdBRUFlRjkvL09NZjF6L3l5Q1BmaVJ6NkhuQXFsWXFMTHJvb2hnd1pZc0FBOENFTkhUbzBMcnJvb2tpbFVybTByUFFqanp6eW5mdnZ2MytkQ1FNQWtDc0V3QUFBZktCTEw3MzBoUVVMRnZ3dXB6YkNlWG54cFM5OUtmYmZmMzhEQm9BUGNOQkJCOFdYdnZTbHlNdkxyVmRKQ3hZcytOMmxsMTc2Z2drREFKQkxCTUFBQUh3b28wZVAvbVZWVmRYY1hGcFRZV0ZoZk9Vclg0a2VQWG9ZTUFDOGgxNjllc1VWVjF3UkJRVUZPYld1cXFxcU9hTkhqLzZsQ1FNQWtHc0V3QUFBZkNnVkZSV05WMTExMVMwTkRRMGJjbWxkSlNVbGNmUE5OOGMrKyt4anlBRHdMcjE3OTQ2YmJyb3Bpb3VMYzJwZERRME5HNjY2NnFxdisrNHZBQUM1U0FBTUFNQ0hObUhDaEUzMzMzLy90ektaVERxWDFsVmNYQnpYWFhkZGRPL2UzWkFCWUlmdTNidkh0ZGRlRzYxYXRjcXBkV1V5bWZUOTk5Ly9yUWtUSm13eVpRQUFjcEVBR0FDQWoyVHMyTEd6NTgrZi85dGNXMWZyMXEzanV1dXVpdzRkT2hneUFNMWVodzRkNHJycnJvdldyVnZuM05ybXo1Ly9tN0ZqeDg0MlpRQUFjcFVBR0FDQWoreTQ0NDc3eGFaTm0xN010WFcxYTljdWJyenh4bWpYcnAwaEE5QnN0VzNiTm1mL1B0eTRjZU9MeHgxM25PLytBZ0NRMHdUQUFBQjhaTlhWMWVtTEw3NzRXM1YxZGF0emJXMGRPM2FNRzIrOE1kcTBhV1BRQURRN1pXVmxjZU9OTjBiSGpoMXpibTIxdGJXckw3end3dHVycTZ2VEpnMEFRQzdMYjN0UTlOelpEOUxiSW1yTEMzVUlBSUNkV3Jac1dmMzI3ZHRmT3ZiWVkwL055OHRya1V0ckt5a3BpYUZEaDhacnI3MFdOVFUxaGcxQXM5Q2hRNGY0MnRlK0ZwMDZkY3E1dFRVMU5XMzl6bmUrTS9iQkJ4OWNiOUlBQU9TQzR1Nk5rVmU2ODU4SmdBRUErTmhlZlBIRnpZY2Njc2l5QVFNR25CZ1JxWnphUkJjWHg1QWhRNFRBQURRTEhUdDJqSnR1dWlrNmRPaVFpOHRMang4Ly9yYXZmdldyYzB3YUFJQmM4WDRCc0N1Z0FRRDRSQzY4OE1JWmI3enh4bTl5Y1czdDI3ZVBtMjY2S1NkUFFnSEEyenAxNnBUTDRXKzg4Y1lidjc3d3dndWZNMmtBQUpvTEFUQUFBSi9ZcUZHamZyRmh3NGFadWJpMnQwUGd6cDA3R3pRQU9hZHo1ODV4MDAwM1JmdjI3WE55ZlJzMmJKZzVhdFNvKzB3YUFJRG1SQUFNQU1BblZsdGJtNzdzc3N1K1YxZFh0em9YMTlldVhidTQ0WVlib21QSGpvWU5RTTdvMEtGRFhILzk5ZEd1WGJ0YzNaK3Mvc0lYdnZEZDJ0cmF0R2tEQU5DYytBWXdBQUM3eEpJbFMrb2o0cFZSbzBhZG1wZVgxeUxYMWxkY1hCeERodzZOdVhQbnhyWnQyd3djZ0VUcjBxVkwzSGpqalRsNzdYTlRVMVAxblhmZWVjMGYvdkNIZGFZTkFFQXVlcjl2QUF1QUFRRFlaV2JObWxYVm8wZVB1WWNlZXVqb1ZDcVZuMnZyYTlXcVZZd1lNU0lXTFZvVWxaV1ZCZzVBSXUyMzMzNXgwMDAzUlZsWldVNnVMNTFPTi96NjE3Kys0ZmJiYjMvVHRBRUF5RlVDWUFBQTlwaEpreWF0UGVxb296YnN1KysrUitmaStnb0xDMlA0OE9HeGJObXkyTEJoZzRFRGtDZ0RCZ3lJYTYrOU5scTFhcFd6YTV3MmJkcS9YWExKSmMrWk5nQUF1ZXo5QW1EZkFBWUFZSmM3N2JUVEhuL3JyYmNlek5YMUZSVVZ4VFhYWEJORGhnd3hiQUFTWThpUUlYSE5OZGRFVVZGUnpxNXh3WUlGdnp2OTlOT2ZNRzBBQUpvekFUQUFBTHZGRVVjY2NjK0dEUnRtNXVyNkNnb0s0c29ycjR3ampqakNzQUZJd3QvTGNlV1ZWMFpCUVVIT3JyRzh2UHlwRVNORy9MZHBBd0RRM0FtQUFRRFlMYXFycTlNWFhYVFJkMnByYTFmazdHWTZMeTh1dnZqaU9QTElJdzBjZ0t3MWF0U291UGppaXlNdkwzZGZBMjNkdW5YeFp6LzcyZTgzTkRSa1RCd0FnT2JPTjRBQkFOaHRsaTlmdnIybXB1YUZZNDg5OXVUOC9QeVd1YmpHVkNvVmd3WU5pa3dtRTRzV0xUSjBBTExLNmFlZkh1ZWVlMjZrVXFtY1hXTjlmWDNGRFRmY2NNM1VxVk9yVEJ3QWdPYmkvYjRCTEFBR0FHQzNldm5sbDdjVUZCUzhjTVFSUjR6T3k4dHJrWXRyVEtWU2NjQUJCMFNuVHAxaTd0eTVrY2s0ZkFUQTNsVllXQmhYWEhGRkhIUE1NVG05enNiR3h1bzc3N3p6S3ovNzJjOVdtem9BQU0ySkFCZ0FnTDFxeG93WmxiMTY5WHA5OE9EQko2ZFNxZnhjWFdmUG5qMmpiOSsrOGZlLy96MGFHeHNOSG9DOW9sV3JWbkgxMVZmSHdJRURjM3FkNlhTNjRiZS8vZTJOdDkxMjJ3SlRCd0NndVJFQUF3Q3cxejN4eEJQbHc0Y1BYOU92WDc5akl5Sm43NkhzMkxGakRCdzRNT2JNbVJOMWRYVUdEOEFlMWE1ZHU3anh4aHVqVDU4K3ViN1U5SlFwVTc3OXhTOSs4WGxUQndDZ09YcS9BRGhQZXdBQTJGUEdqQmt6OVkwMzN2aDFycSt6WjgrZWNlT05OMGJIamgwTkhZQTlwa3VYTG5IVFRUZEY5KzdkYzM2dGMrZk8vZVU1NTV6ekYxTUhBSUQvU3dBTUFNQWU5YWxQZmVyblM1Y3VmVGpYMTltbFM1ZTQ5ZFpiNDhBRER6UjBBSGE3Z1FNSHhqZS8rYzNvMUtsVHpxLzFyYmZlZW1qRWlCRy9NblVBQU5nNUFUQUFBSHZjc2NjZWU4L0dqUnRmeVBWMUZoY1h4N1hYWGhzalJvd3dkQUIybThNUFB6eXV1dXFxYU5teVpjNnZkZVBHamM4ZmZmVFI5NWc2QUFDOE53RXdBQUI3WEVWRlJlTnh4eDMzOWNyS3lyL2wrbG9MQ2dyaXNzc3VpL1BQUHo5U3FaVGhBN0RMcEZLcE9QLzg4K1BTU3krTmdvS0NuRi92cGsyYlhqN3NzTU51cWF5c2JESjlBQUI0YndKZ0FBRDJpc1dMRjllZmRkWlpOMWRYVjcvWkhOWjcvUEhIeDVlLy9PVW9LaW95ZkFBK3NSWXRXc1NYdi96bE9QNzQ0NXZGZXF1cnE5OGNNMmJNTjhyTHl4dE1Id0FBM2w5KzI0T2k1ODUra040V1VWdGVxRU1BQU93MmE5YXNhVmkxYXRXczBhTkhIMWRRVU5BNjE5ZmJyVnUzT09DQUEyTGV2SGxSWDEvdkFRRGdZeWtySzR0cnJya21EanJvb0dheDNycTZ1dkt4WThkZTg5UlRUMjAyZlFBQStJZmk3bzJSVjdyem53bUFBUURZcStiTm0xZXpldlhxWjA0KytlVGpDd29LU25OOXZlM2F0WXVSSTBmRzh1WExZK1BHalI0QUFENlMvdjM3eDAwMzNSUmR1M1p0RnV1dHI2OWZkOTExMTMzNVQzLzZVNFhwQXdEQS94QUFBd0NRMWViTW1iTXRsVXE5Zk9TUlI1NlVsNWVYODNja3QyalJJa2FNR0JHMXRiV3hkT2xTRHdBQUg4cnh4eDhmWC9yU2w1ck41d1FhR3h1MzNIWFhYZGY5OUtjL1hXbjZBQUR3dndtQUFRREllak5uenF6czJiUG42NE1IRHo0cGxVcmw1L3A2VTZsVUhITElJZEdxVmF0WXNHQkJaRElaRHdFQU81V1hseGVmL2V4bjQvVFRUNDlVS3RVczFweE9wN2YvL3ZlLy8rbzN2dkdOMXowQkFBRHdmd21BQVFCSWhFbVRKcFh2czg4Kzh3WU9ISGhDS3BVcWFBNXIzbSsvL1dMQWdBRXhkKzVjM3dVRzRQOG9LeXVMNjY2N0xvWU5HOVpzMXB4T3A3Zi84WTkvdk9tcXE2NzZxeWNBQUFCMlRnQU1BRUJpVEp3NGNjM0JCeCs4NU1BRER6d3VsVXJsTlljMXQyL2ZQb1lPSFJxTEZpMktMVnUyZUFnQWlJaUlmZmJaSjY2Ly92cm8yYk5uczFsekpwTnBuREJod20xZi9PSVhuL2NFQUFEQWV4TUFBd0NRS0k4Kyt1ankvZmZmLzQyRERqcm9oT1p3SFhSRVJIRnhjUngxMUZIUjJOZ1liNzMxbG9jQW9Ka2JQWHAwWEhIRkZWRlNVdEpzMXB4T3B4c2VmdmpocjE1eXlTV3pQQUVBQVBEK0JNQUFBQ1RPK1BIalZ3MGNPSERwQVFjY2NHeHpPUW1jU3FWaXdJQUIwYVZMbDNqampUZWlxYW5KZ3dEUXpCUVZGY1dsbDE0YUo1NTRZclA1M20vRVAwNytQdjc0NDdkZmZQSEZNejBGQUFEd3dRVEFBQUFrMGlPUFBMTHMwRU1QWGJiLy92czNteEE0SXFKSGp4NHhaTWlRZVBQTk4yUHIxcTBlQklCbW9udjM3dkV2Ly9JdmNjQUJCelNyZFdjeW1hWW5ubmppOXM5OTduUFBlQW9BQU9EREVRQURBSkJZRHovODhOSmpqamxtWSsvZXZZK0tpR1p6RktxMHREU0dEeDhlcTFldmp2WHIxM3NRQUhMY3dJRUQ0NXBycm9sMjdkbzF0NlZuWnN5WThZT3p6anBycXFjQUFBQStQQUV3QUFDSmR2Lzk5Nzk1ekRISFZPNnp6ejVIUkRNS2dWdTBhQkdISFhaWXRHelpNaFl1WEJqcGROckRBSkJqQ2dvSzRweHp6b256eno4L1dyUm8wZHlXbjM3dXVlZnVPdVdVVXlaNEVnQUE0S01SQUFNQWtIaS8vLzN2NXc4Yk5teEYzNzU5ajJsTzEwR25VcW5vMjdkdkRCMDZOQll2WGh4YnRtenhNQURraUo0OWU4WU5OOXdRZ3djUGJsYmYrNDM0eDdYUFU2Wk0rZmJwcDU4KzJaTUFBQUFmblFBWUFJQ2M4T0NERHk0Wk5tellpbjc5K2pXckVEZ2lvblhyMW5IRUVVZEVmWDE5TEYyNjFNTUFrR0NwVkNwT09PR0V1T0tLSzZKTm16Yk5idjA3d3Q5dm5YUE9PWC94TkFBQXdNY2pBQVlBSUdjODlOQkRTNFlORzdhOFg3OSt4emEzRURnL1B6OE9QdmpnNk5XclY4eWZQejhhR2hvOEVBQUpVMUpTRXBkZmZubWNjTUlKa1orZjMrelduOGxrR3A5NDRvbHZmZmF6bjUzbWFRQUFnSTlQQUF3QVFFNTU2S0dIbG80Y09YSmRuejU5UnFXYTI1MlpFZEcxYTljWU5teFlMRnUyTENvckt6MFFBQW5SdDIvZnVPNjY2MksvL2Zacmx1dlBaRExwcDU5Kytydm5uSFBPMDU0R0FBRDRaQVRBQUFEa25ELzk2VStMRGozMDBLWDc3NzkvczdzT09pS2l1TGc0amp6eXlDZ3BLWWszMzN3ejB1bTBod0lnU3hVVUZNUm5QL3ZadVBEQ0M2T2twS1JaOWlDZFRqYzg4c2dqdDV4Ly92blRQUkVBQVBESkNZQUJBTWhKRHovODhOSWQzd1FlbFVxbG10MDltcWxVS3ZyMDZSTUhIM3h3TEZ5NE1MWnQyK2FoQU1neW5UdDNqckZqeDhiUW9VT2pHVjVhRVJIL0NIK2ZlT0tKMnkrODhNTG5QQkVBQUxCckNJQUJBTWhaRHozMDBKSWVQWHE4Tm1qUW9HUHo4dkphTk1jZXRHM2JOa2FOR2hWTlRVMnhaTWtTRHdWQUZraWxVakY2OU9pNDhzb3JvME9IRHMyMkQwMU5UZHQrKzl2Zi9zdGxsMTMyb3FjQ0FBQjJIUUV3QUFBNWJkS2tTZVhkdTNlZk0zanc0R1liQXVmbjU4ZUFBUU9pVjY5ZXNXREJndGkrZmJzSEEyQXZhZDI2ZFZ4NjZhVngvUEhIUjM1K2ZyUHRRMk5qWS9XdmZ2V3JmN251dXV0ZTgxUUFBTUN1SlFBR0FDRG5UWjQ4ZVcxalkrT01JNDQ0NHVpQ2dvS1M1dHFIcmwyN3hxaFJvMkxidG0yeGN1VktEd2JBSHBSS3BXTFVxRkV4ZHV6WTZOV3JWN1B1UlgxOS9mbzc3cmpqSzkvNjFyY1dlaklBQUdEWEV3QURBTkFzUFAvODgxVWJObXg0NXJqampqdXFzTEN3ckxuMm9iQ3dNQVlOR2hUNzdiZGZMRjY4T0dwcmF6MGNBTHRaKy9idDQ0b3Jyb2dUVHp3eENndWI5L3VVMnRyYWxUZmZmUFBWUC9uSlQxWjdNZ0FBWVBjUUFBTUEwR3o4N1c5LzI3cDI3ZG9aSjV4d3dzakN3c0syemJrWG5UcDFpcEVqUjBaMWRiWFR3QUM3MGNpUkkrUHFxNitPSGoxNk5QdGUxTlRVTEwvaGhodXUvZTF2Zjd2T2t3RUFBTHVQQUJnQWdHYmx0ZGRlMnpwdjNyeW5Uem5sbEtGRlJVV2Rtbk12Q2dzTDQ5QkRENDM5OXRzdkZpMWE1RFF3d0M3MDlxbmZrMDgrdWRtZitvMkkyTHg1ODd5TEw3NzR1bkhqeG0zMGRBQUF3TzcxZmdGd2F0OXpZc1RPZnRDNExtTGpxNjEwRHdDQXhPclZxMWZoczg4Kys2OWR1M1k5UVRjaUdob2FZdXJVcVRGNTh1Um9iR3pVRUlDUHFhQ2dJRTQ5OWRRWVBYcTA0SGVIOHZMeXA0NDk5dGp2cmx5NXNrRTNBQUJnOStzd3JEWUt1dXo4WndKZ0FBQnlXdXZXcmZOZWV1bWxtL2ZkZDkremRlTWZWcTllSGZmZmYzOHNXYkpFTXdBK292MzIyeTh1dXVnaTF6Mi93OEtGQzM4L2ZQanduelkwTkdSMEF3QUE5Z3dCTUFBQXpkN3p6ejkvOGFHSEhucDFSS1IwSXlLVHljVE1tVFBqejMvK2M5VFYxV2tJd0Fjb0tTbUo4ODQ3TDBhTUdCR3BsTDlLZGtpLy9QTEw5eHg3N0xFUGFnVUFBT3haN3hjQSt3WXdBQUROd24zMzNUZm4rT09QMzl5clY2L0RRd2djcVZRcWV2ZnVIY09IRDQ5MTY5WkZSVVdGaHdUZ1BSeHl5Q0V4ZHV6WTZOKy92L0IzaDB3bTAvak1NOC84Mjhrbm56eE9Od0FBWU05N3YyOEFDNEFCQUdnMmZ2ZTczNzB4ZVBEZ0pmMzY5VHM2bFVybDYwaEVjWEZ4akJneElucjA2QkZMbHk2TjJ0cGFUUUhZb1VPSER2R0ZMM3doemp6enpDZ3VMdGFRSFpxYW1tb2VlT0NCV3o3M3VjOU4xdzBBQU5nN0JNQUFBTEREd3c4L3ZLeWdvT0M1NGNPSEgxRlFVRkNxSS8vUXJWdTNPTzY0NDZLMHREUVdMMTRjVFUxTm1nSTBXeTFidG94enpqa25McjMwMHVqZXZidUd2RU50YmUySzIyNjc3YXJiYnJ2dERkMEFBSUM5UndBTUFBRHY4T3l6ejI1YXZIangweWVkZE5LUW9xS2lUanJ5RDNsNWVkR25UNThZT1hKa2JOMjZOVmF0V3FVcFFMTnorT0dIeDFlKzhwVVlNR0JBNU9YbGFjZzdWRlZWL2UzQ0N5Kzgvb0VISHZEZEFBQUEyTXNFd0FBQThDN3o1OCt2ZWZiWlo1OCs0NHd6K2hjWEYvZlNrZi9Sc21YTEdESmtTT3l6eno2eGRPblNxS21wMFJRZzUzWHMyREcrK01VdnhpbW5uQkl0VzdiVWtIZFp0MjdkTXllZmZQSTNYbjc1NVcyNkFRQUFlOS83QmNDcGZjK0pFVHY3UWVPNmlJMnZ0dEk5QUFCeVdtRmhZZXI1NTUvLzBzRUhIM3k1YnZ4ZlRVMU44Znp6ejhmNDhlT2p1cnBhUTRDYzA3cDE2emp6ekRQanlDT1BkT0ozNXpKLy8vdmZmM3JNTWNmYzM5RFFrTkVPQUFESURoMkcxVVpCbDUzL1RBQU1BQUFSTVduU3BNOGNjOHd4dDZSU0tkZmc3RVJOVFUxTW1USWxwazJiRmcwTkRSb0NKRjVoWVdHY2Nzb3BjZEpKSjBWUlVaR0c3RVE2bmE2Zk9uWHFkODg1NTV5LzZBWUFBR1NYOXd1QVhRRU5BQUFSOFljLy9HSGhmdnZ0OThhQUFRT095c3ZMa3dTOFMyRmhZUXdZTUNDR0RoMGFtelp0aW5YcjFta0trRmlEQncrT3E2NjZLb1lPSFJvRkJRVWFzaE9OalkxVnYvLzk3Mi81d2hlK01FczNBQUFnKy9nR01BQUFmQWdUSmt4WVhWMWRQZjNJSTQvOFZHRmhZVHNkK2I5S1MwdmpzTU1PaS83OSs4ZWFOV3RpOCtiTm1nSWtSdS9ldmVQeXl5K1BVMDQ1SlVwTFN6WGtQV3pkdW5YeExiZmNjczMzdnZlOWhib0JBQURaeVRlQUFRRGdJK2pUcDArTEo1OTg4dXM5ZXZRNFRUZmUzL3o1OCtPUlJ4NkpsU3RYYWdhUXRYcjE2aFhubkhOT0RCZ3dRRE0rd0twVnE1NDQ0WVFUZnJCeTVVcjMvUU1BUUJiekRXQUFBUGdZbm5ubW1mT0hEeDkrZlNxVnl0T045NWJKWkdMMjdOa3hidHk0cUtpbzBCQWdhM1R1M0RuT091dXNHRHAwYUtSU0tRMTUvei9MbTJiTm12WERrMDgrK1RIZEFBQ0E3T2Nid0FBQThESDg1amUvZVgzLy9mZC8vY0FERHp6U2Q0SGZXeXFWaXU3ZHU4Y3h4eHdUN2RxMWkyWExsa1Y5ZmIzR0FIdE4yN1p0NDl4eno0MkxMNzQ0ZXZUb0lmejlBSTJOamRVUFB2amdMWi85N0dmL29oc0FBSkFNdmdFTUFBQWYwL2p4NDFkRnhQT0hIWGJZaU1MQ3dqSWRlVzk1ZVhuUnUzZnZPT3FvbzZLZ29DQldybHdaalkyTkdnUHNNY1hGeFhIS0thZkVsNzcwcGVqYnQyL2s1Ym5BNFlQVTF0YXUrTUVQZm5EOUxiZmNNazgzQUFBZ1FmLzk0eHZBQUFEd3lRd2VQTGpWbzQ4KytzMXUzYnFkcEJzZlRuMTlmVHp6ekRNeGRlclUyTFp0bTRZQXUwMVpXVm1jZXVxcGNlU1JSMFpSa1FzYlBxeVZLMWMrL3VsUGYvcEhpeGN2ZG0wREFBQWtqRzhBQXdEQUx2TGtrMCtlZGVTUlI5NlVTcVZjbC9NaENZS0IzZVh0RTcvSEhudXM0UGNqeUdReURiTm16Zm9QMy9zRkFJRGs4ZzFnQUFEWVJYNy8rOTh2Nk5HangydUhISExJeVB6OGZMOHgrU0VVRkJSRXYzNzk0cWlqam9xOHZMeFl0V3FWcTZHQlQ2Umx5NVp4d2drbnhCVlhYQkVISFhSUUZCUVVhTXFIMU5EUXNPRzN2LzN0MXo3LytjOC9veHNBQUpCY3JvQUdBSUJkN0x6enp1dDQ5OTEzMzltMmJkdkJ1dkhSMU5UVXhMUFBQaHZUcGsyTExWdTJhQWp3b1pXVmxjWHh4eDhmeHh4elRCUVhGMnZJUjFSVlZmVzNhNis5OXZaSEhubGtnMjRBQUVDeXVRSWFBQUIyZzA2ZE9oVk1telp0Yk4rK2ZUOFhFU2tkK1dnYUdocmkrZWVmanllZmZESTJiSkJGQU8vNzUyMmNkTkpKY2NRUlIwUmhvZHZLUG9iTW9rV0wvblRzc2NmK3BMS3lza2s3QUFBZytRVEFBQUN3Ry8zaEQzOFlkZnJwcDk5V1VGRFFSamMrdW5RNkhhKysrbXBNblRvMVZxNWNxU0hBUC9YcTFTdE9PZVdVR0RwMGFPVGw1V25JeDlEWTJGZzFZY0tFT3k2NjZLS1p1Z0VBQUxsREFBd0FBTHZaYWFlZDF2YmVlKy85ZG9jT0hVYnF4c2UzZlBueW1EWnRXcno4OHN1UlRxYzFCSnFodkx5OE9PeXd3K0w0NDQrUDNyMTdhOGduc0hIanh1ZS8vT1V2ZjNmU3BFbFZ1Z0VBQUxsRkFBd0FBSHRBWVdGaDZxbW5uanB2K1BEaDE2UlNLWGVVZmdJYk5teUlHVE5teEhQUFBSYzFOVFVhQXMxQWNYRnhqQm8xS280Kyt1am8yTEdqaG53Q21VeW00WlZYWHZsL0o1MTAwa01ORFEwWkhRRUFnTnp6ZmdGd2Z0dURvdWZPZnBEZUZsRmI3cDBWQUFCOFdPbDBPbjd6bTkrOFhscGErdUxnd1lNL1ZWaFlXS1lySDA5eGNYRU1HREFnamozMjJHalRwazJzWGJzMmFtdHJOUVp5VUljT0hlS01NODZJU3krOU5BWU9IQmpGeGNXYThnblUxdGF1K3NsUGZuTGp4UmRmL0l5YkZBQUFJSGNWZDIrTXZOS2QvOHdKWUFBQTJBMU9QUEhFTnZmZGQ5K3RuVHAxT2xvM1Bybkd4c2I0MjkvK0ZzOCsrMndzV3JSSVF5QUg5T3ZYTDQ0Kyt1Z1lObXhZRkJRVWFNZ3VVRkZSOGN3WHYvakZmNXMrZmZvVzNRQUFnTnptQ21nQUFOaExIbjc0NFJOR2p4Nzk5WUtDZ3RhNnNXdXNYNzgrWnM2Y0djOC8vM3hVVjFkckNDUklhV2xwSEhua2tYSFVVVWRGNTg2ZE5XUVhhV3hzM0RKMTZ0UzdQdnZaei81Rk53QUFvSGtRQUFNQXdGNTB5U1dYZFAzKzk3Ly9yWGJ0MmczVmpWMm5zYkV4WG52dHRYanV1ZWRpL3Z6NUdnSlpiTUNBQVRGcTFLZ1lQSGl3MDc2N1dGVlYxYXRmLy9yWHYvZTczLzF1clc0QUFFRHpJUUFHQUlDOXJGMjdkdmxUcDA2OTlPQ0RENzQwbFVybDY4aXV0WHo1OG5qKytlZmo1WmRmanBxYUdnMkJMRkJTVWhMRGh3K1BJNDQ0SW5yMzdxMGh1MWdtazJtY04yL2VmU2VlZU9KdnE2dXJmZXdYQUFDYUdRRXdBQUJraWE5Ly9ldjczWGpqamY5YVdscmFYemQydlhRNkhXKysrV1k4OTl4ejhkcHJyMFZqWTZPbXdCNVVVRkFRZ3djUGpsR2pSc1VCQnh3UWVYbDVtckliVkZkWEwvelAvL3pQZi8zQkQzNndSRGNBQUtCNUVnQURBRUFXT2ZqZ2cxdjkrYzkvdnJaMzc5NWpJaUtsSTd0SFpXVmx2UGppaS9IQ0N5L0V1blhyTkFSMm82NWR1OGJJa1NQajhNTVBqN1p0MjJySTdwTlp1blRwbjg4ODg4ei90M2p4NG5ydEFBQ0E1a3NBREFBQVdlanV1KzhlZVBIRkY5L1dxbFVyZDZQdVp1WGw1ZkhxcTYvR1N5KzlGT3ZYcjljUTJBVTZkKzRjSTBhTWlHSERoa1czYnQwMFpEZXJxYWxaOXR2Zi92Yk9tMjY2YWE1dUFBQUFBbUFBQU1oUy9mcjFLM3I0NFljdjc5Ky8vNFdwVk1wZHFYdkE4dVhMNDZXWFhvcVhYMzQ1cXF1ck5RUStnckt5c2hnK2ZIaU1HREhDZDMzM2tFd21rMTY0Y09FZnpqNzc3RjhzWGJwMHU0NEFBQUFSQW1BQUFNaDZQLzNwVDRkOTduT2YrMmJMbGkxNzZNYWUwZERRRUhQbnpvMi8vdld2TVhmdTNOaStYYTRDTzlPeVpjc1lOR2hRREJzMkxBNDU1SkFvS0NqUWxEMmt0cloyMVIvLytNYzdycjMyMnIvckJnQUE4RTRDWUFBQVNJQStmZnEwZVBUUlI2OXdHbmpQUzZmVHNYVHAwbmoxMVZlZERJYUlhTnUyYlF3Yk5peUdEUnNXZmZyMGlidzhmeVR0U1psTXB1RzExMTc3K1psbm52bW5pb3FLUmgwQkFBRGVUUUFNQUFBSjh1TWYvL2pRQ3k2NDRKdXRXclhhUnpmMnZMZFBCcytlUFR2bXpwMGJkWFYxbWtLelVGWldGb01IRDQ1aHc0WkYvLzc5SXo4L1gxUDJncHFhbW1YMzMzLy9uVGZjY0lOdi9RSUFBTzlKQUF3QUFBblRybDI3L0hIanhwMzdxVTk5NnFxOHZEd2I4NzBrazhuRWloVXJZdTdjdVRGbnpweFlzV0pGWkRJWmpTRW5wRktwNk51M2J3d2JOaXdHRFJvVUhUdDIxSlM5cUttcHFmYlZWMS85MlpneFkvNWNXVm5acENNQUFNRDdFUUFEQUVCQ2ZmbkxYKzV4KysyM2Y3VjkrL2FINjhiZXQyWExsbmpqalRkaXpwdzVNVy9ldktpdnI5Y1VFcVZseTVaeDhNRUh4NkJCZytLUVF3NkowdEpTVGNrQ0d6ZHVmUEc3My8zdXYvL2lGNzlZb3hzQUFNQ0hJUUFHQUlBRUt5d3NURTJjT1BHTWtTTkhYbE5RVU5CYVI3SkRYVjFkdlBubW0vSEdHMi9FRzIrOEVldlhyOWNVc2xLWExsM2lvSU1PaW9NT09pZ09PT0NBS0NvcTBwUXMwZGpZdUdYbXpKay9QdlBNTXljMk5EUzRYZ0FBQVBqUUJNQUFBSkFEamp6eXlOWS8rOW5QcnVqYnQrKzVFWkduSTltbHVybzZGaTVjR1BQbno0OTU4K1pGWldXbHByQlh0R3ZYTGc0NTVKQVlNR0JBOU8vZlAxcTM5bnNqV1NqOTFsdHYvZm1xcTY3NnhheFpzNnExQXdBQStLZ0V3QUFBa0VOKytjdGZqaGd6WnN5TnJWcTE2cTBiMlNtZFRzZktsU3RqMGFKRnNYRGh3bGk4ZUhGczI3Wk5ZOWd0U2twS29sKy9mdEcvZi8vWWYvLzlvMWV2WHBHWDUzZEVzbFZOVGMzeVJ4OTk5RWRYWG5ubEs3b0JBQUI4WEFKZ0FBRElNZDI2ZFN0OCtPR0hQemQ0OE9ETDh2UHpiZHl6WENhVGlUVnIxc1RDaFF0ajBhSkZzV2pSb3RpeVpZdkc4TEdVbFpWRi8vNzkveG42ZHUvZVBWS3BsTVprdWFhbXBwclhYbnZ0VjJQR2pIbWdvcUtpVVVjQUFJQlBRZ0FNQUFBNTZyampqaXY3ci8vNnI4dGRDNTA4bXpkdmp1WExsOGVLRlN0aStmTGxzWGp4NHFpcHFkRVkvcGZpNHVMbzE2OWY5TzdkTy9iWlo1L1lkOTk5bzZ5c1RHTVNKSlBKcEpjc1dmTG42NjY3N3BmVHAwLzNteDhBQU1BdUlRQUdBSUFjOTlPZi9uVEl1ZWVlZTNOcGFXbGYzVWlteHNiR1dMbHlaU3hkdWpTV0xWc1d5NWN2ajNYcjFrVW1rOUdjWmlLVlNrV1hMbDFpbjMzMmlUNTkra1NmUG4yaVY2OWVVVkJRb0RrSnRYWHIxc1VQUHZqZ2o2Njk5dHEvNndZQUFMQXJDWUFCQUtBWmFOZXVYZjY0Y2VQT0dUcDA2QlVGQlFXdGRTVDU2dXZyWStYS2xmODhLYnhpeFlwWXUzWnRwTk5welVtNHZMeTg2TnExYSt5enp6Ny8vS2RYcjE3UnNtVkx6Y2tCalkyTlcvNzYxNy8rNHB4enpubTBzckt5U1VjQUFJQmRUUUFNQUFETnlJa25udGptbm52dXVYemZmZmNkazBxbEhCM01NZHUzYjQ4MWE5YkVtalZyWXUzYXRiRjI3ZG9vTHkrUERSczJDSWF6VUY1ZVhuVHMyREc2ZGVzV1hidDJqVzdkdWtXM2J0MmlSNDhlVVZoWXFFRTVKcFBKTkM1WnN1UlIxejBEQUFDN213QVlBQUNhb2E5KzlhdjdYbmZkZGRkMTZORGhDTjNJZlkyTmpmOE1oTmV0V3hmcjFxMkxpb3FLV0xkdVhXemJ0azJEZHJQUzB0TG8zTG56UC8vcDBxVkxkTzNhTmJwMjdlb0s1MlppdzRZTk0vL3J2LzdyeHovNjBZK1c2d1lBQUxDN0NZQUJBS0FaKytVdmZ6bmlyTFBPdXE2NHVOajNnWnVwbXBxYVdMOSsvVC8vcWFpb2lNckt5cWlzckl4Tm16WkZZMk9qSm4yQWdvS0NhTisrZmJScjF5N2F0MjhmSFR0MmpDNWR1a1NuVHAyaWMrZk9VVnhjckVuTjFOYXRXOThhUDM3OFBWZGNjY1hMdWdFQUFPd3BBbUFBQUdqbTJyVnJsLy9nZ3crZU9XTEVpQ3NMQ3d2YjZnanZ0SG56NW4rR3daczJiWXJLeXNxb3JxNk9MVnUyeEpZdFc2SzZ1anFxcTZzams4bmszTnBUcVZTMGJ0MDZXcmR1SFdWbFpkR21UWnNvTFMzOVgyRnZ1M2J0b2syYk5oNFUvcGVHaG9iS2wxNTY2ZWZubkhQTytPcnFhdmV2QXdBQWU1UUFHQUFBaUlpSW9VT0hGdDk3NzcwWEhIamdnUmZrNStjN3NzaUhsazZuL3hrRVYxZFhSMDFOemZ2K2s4bGtvcmEyTnRMcGROVFgxMGRUVTFQVTFkWHQwdThVNStYbFJjdVdMU00vUHorS2lvb2lMeTh2V3JWcUZhbFVLb3FMaTNmNlQwbEpTYlJxMWVxZmdXOXBhV25rNWVVWk1COWFVMU5UellJRkMvNzQ1UzkvK1krelo4K3UwUkVBQUdCdkVBQURBQUQveTJtbm5kYjJycnZ1dXJSUG56NW41K1hsRmVvSWU5TGJnZkRidG0vZi9yN1hVQmNVRkVTTEZpMysrYi9mRG54aFQ4cGtNZzFMbGl3WmQ4c3R0L3hxMHFSSlZUb0NBQURzVFFKZ0FBQmdwMDQ3N2JTMmQ5NTU1NFg3NzcvLzV3VEJBUDlYSnBOcFdMaHc0UU8zM25yckh3Uy9BQUJBdG5pL0FEaS83VUhSYzJjL1NHK0xxQzMzL2djQUFITFpva1dMNnU2OTk5NVgwdW4wc3djZGRGQ25rcEtTM3JvQzhBOFZGUlV6LzcvLzcvKzc3YUtMTHBxNmFOR2lPaDBCQUFDeVJYSDN4c2dyM2ZuUEJNQUFBRURNbkRtejh1Njc3MzZxcWFscFdyOSsvWXBidDI3ZE41VktwWFFHYUc0eW1VeDZ6Wm8xVSs2NTU1NS9QZWVjY3g2Y09YTm1wYTRBQUFEWlJnQU1BQUI4S0RObnpxejg4WTkvL0d3Nm5aNHVDQWFhazdlRDM3dnZ2dnRmenovLy9NY0V2d0FBUURZVEFBTUFBQitKSUJob0xnUy9BQUJBRWdtQUFRQ0FqK1h0SUxpc3JPeUZ2bjM3ZGl3dUx1NFZFWUpnSUJka0tpb3FucnYzM251L1BXYk1tRWNFdndBQVFKSzhYd0NjMnZlY0dMR3pIelN1aTlqNGFpdmRBd0FBL3VucXE2L3U4Wld2Zk9YOFBuMzZuSldYbDlkQ1I0Q2tTYWZUOVV1WExoMy9YLy8xWHcvODRoZS9XS01qQUFCQUVuVVlWaHNGWFhiK013RXdBQUR3a1oxeHhobnRiNy85OXJNUFBQREE4L1B6ODF2ckNKRHRtcHFhcWhjc1dQRGdkNzd6blVjbVRwem90QzhBQUpCb0FtQUFBR0MzR0Q1OGVNa1BmL2pEend3ZVBQamlvcUtpampvQ1pKdjYrdm9OcjczMjJ1OXZ2UEhHeDJmUG5sMmpJd0FBUUM0UUFBTUFBTHZWMEtGRGkrKzU1NTZ6RGpua2tQT0tpb3E2Nmdpd3Q5WFYxYTE5L2ZYWEg3eisrdXZIQzM0QkFJQmNJd0FHQUFEMmlGYXRXdVhkYzg4OXcwNDU1WlR6TzNic2VKU09BSHRZWnNPR0RiT21USm55NFBYWFgvOXFiVzF0V2tzQUFJQmNKQUFHQUFEMnVILzkxMy90Zi83NTU1L2RxMWV2MC9MeThscm9DTEM3cE5QcCtwVXJWMDUrNElFSEh2bk9kNzZ6U0VjQUFJQmNKd0FHQUFEMm1qUE9PS1A5N2JmZmZ2WUJCeHp3MllLQ2dqWTZBdXdxalkyTlZXKysrZWFmdi9lOTd6MDZZY0tFVFRvQ0FBQTBGd0pnQUFCZ3J4cytmSGpKOTcvLy9kR0RCZzBhVTFwYXVyK09BQjlYZFhYMXd0ZGVlKzNScjM3MXExTmZlKzIxV2gwQkFBQ2FHd0V3QUFDUVZiNzYxYS91ZThFRkYzeTZiOSsrWnhVVUZMVFdFZUNETkRZMmJubnJyYmZHLytFUGY1ajRveC85YUxtT0FBQUF6WmtBR0FBQXlFcERodzR0L3NFUGZuRHk0TUdEejI3ZHVuVi9IUUhlcmJxNitzMlhYMzc1d2V1dXUrN3BwVXVYYnRjUkFBQUFBVEFBQUpEbENnc0xVM2ZmZmZlUTBhTkhuOUcxYTlmajh2THlpblFGbXE5ME9sMVhYbDQrYmNxVUtST3V2ZmJhditzSUFBREEveVlBQmdBQUVxTlBuejR0L3YzZi8zM1V5SkVqejJyZnZ2Mm5JaUtsSzlBc1pEWnQydlRYRjE1NDRiR3ZmZTFyenpudEN3QUE4TjRFd0FBQVFDSmRkTkZGWGE2Kyt1cVREenp3d0xOYnRtelpUVWNnOTlUVjFhMVpzR0RCdUovKzlLZFAzbi8vL2V0MEJBQUE0SU1KZ0FFQWdFVHIxcTFiNGQxMzMzM2s0WWNmZm1xSERoMk95TXZMSzlRVlNLNTBPdDJ3Y2VQR1diTm16WnA4L2ZYWHo2cW9xR2pVRlFBQWdBOVBBQXdBQU9TTW80OCt1dld0dDk1Ni9DR0hISEpLdTNidEJrZEVucTVBSXFRckt5dGZtemR2M3VRNzc3eHorb3daTTZxMUJBQUE0T01SQUFNQUFEbnB1T09PSy92R043NXgvQ0dISEhKYTI3WnRCNGJ2QlVPMnlWUlZWYzJkTjIvZXBPOS8vL3ZUcGsrZnZrVkxBQUFBUGprQk1BQUFrUE51dSsyMnZtZWRkZFpKZmZyME9hNVZxMWE5ZFFUMm50cmEydVhMbHkrZi91aWpqejUxeHgxM3ZLVWpBQUFBdTVZQUdBQUFhRmErOUtVdmRidjQ0b3VQN3QrLy93bE9Cc01la2FtcXFwcTdjT0hDdi96Kzk3K2ZjZDk5OTVWckNRQUF3TzRqQUFZQUFKcXRTeTY1cE90bGwxMTJqREFZZHJsMFZWWFZ2SVVMRi83bFY3LzYxYk8vKzkzdjFtb0pBQURBbmlFQUJnQUFpSWlycjc2Nngvbm5uejlxLy8zM1A3Sk5telpEVXFsVWdhN0FoNWZKWkJvcUt5di92bmp4NHVmKzlLYy96YnIzM250WDZ3b0FBTUNlSndBR0FBQjRsMzc5K2hWOTdXdGZHelJ5NU1oUlBYdjJQTGFvcUtpenJzRC9WVjlmdjM3VnFsWFB2UERDQzgvOSs3Ly8rNXpGaXhmWDZ3b0FBTURlSlFBR0FBQjRINjFidDg2Nzg4NDdCeDU5OU5GSGRlL2VmVVJwYWVuKzRhcG9tcS9NMXExYkY2OVpzK2JGNTU1N2J0WTN2L25OT2RYVjFXbHRBUUFBeUI0Q1lBQUFnSTlnOE9EQnJjYU9IWHZJOE9IREQrdmV2ZnZ3MXExYkh4QUNZWEpYcHJxNitzMDFhOWE4OHNvcnI3ejhrNS84Wk41cnI3MVdxeTBBQUFEWlN3QU1BQUR3Q1Z4Ly9mWDduSEhHR1lmMTY5ZHZlUHYyN1lmbTUrZTMxaFdTckxHeHNYcmp4bzJ2dnZYV1d5K1BIei8rbFIvLytNY3JkUVVBQUNBNUJNQUFBQUM3MEplLy9PVWU1NXh6enZBK2Zmb003dGl4NDVDaW9xS3V1a0kycTYrdlg3dDI3ZG9YRnk5ZVBHZml4SW12M1h2dnZhdDFCUUFBSUxrRXdBQUFBTHZSbDcvODVSNmYrY3huQnZmcjEyOVFseTVkRG0vWnNxVkFtTDJxcnE1dTdicDE2d1MrQUFBQU9Vb0FEQUFBc0llMGF0VXE3NXBycnRubjJHT1BQWGkvL2ZZN3VIMzc5b2VVbHBiMlRhVlMrYnJEYnBLdXFhbFp0bkhqeG5sdnZmWFczR2VmZlhiZWYvM1hmeTJ2cmExTmF3MEFBRUJ1RWdBREFBRHNSUWNlZUdETHE2Kysrb0FoUTRZYzNMTm56NFBidG0xN3NHdWorYmlhbXBxcXE2cXFYaTh2TDU4M1o4NmNlYi84NVMvbnZmamlpMXQxQmdBQW9Qa1FBQU1BQUdTWm9VT0hGbi94aTEvY2Y5Q2dRUWYyNk5IandIYnQyaDNZcWxXcjNxbFVLazkzMkNGZFUxT3p2TEt5Y3NIcTFhc1h6Smt6WjhHZi8vem5KVE5tektqV0dnQUFnT1pOQUF3QUFKQUF4eDEzWE5rRkYxeHc0TUVISDN4QTE2NWREeXd0TGQyM3BLUmtuMVFxVmFnN3VTMlR5VFJzMjdadFJYVjE5ZEoxNjlZdGZPT05OeFpPbURCaDRZUUpFemJwRGdBQUFPOG1BQVlBQUVpdzg4NDdyK09KSjU3WXAzLy8vdnQxNmRLbFQ1czJiZlpyM2JwMXYvejgvR0xkU1phbXBxYWE2dXJxeFpzM2IxNnlidDI2cFFzWExsenk5Tk5QTDMzb29ZYzI2QTRBQUFBZmxnQVlBQUFneDdScjF5Ny9ra3N1NlRGa3lKQ2UrKzY3Yjg5T25UcjFLaXNyNjFWY1hOeXpaY3VXM1ZLcFZMNHU3UjJaVEthcHJxNnV2S2FtWnRXV0xWdFdWbFJVckZ5NmRPbksyYk5ucjdyLy92dlhWRlpXTnVrU0FBQUFuNFFBR0FBQW9CbnAxS2xUd2VjKzk3bHVRNGNPN2JuUFB2djBhTmV1WGFmV3JWdDNMaTR1N3RxeVpjdk9SVVZGbmZMeThscm8xTWVUVHFlMzE5ZlhyNitycTZ1b3FhbFpXMTFkdmI2eXNuTDlpaFVyVnIvNjZxdXJIbnp3d2JVVkZSV05PZ1VBQU1EdUlnQUdBQURnZnpuampEUGFIM2JZWVozNjlPblR1VXVYTHAzS3lzcmFsNVNVdEMwdUx1NVlWRlRVcnFpb3FHMkxGaTA2NU9mbmx6YVhualExTlczZHZuMzd4dnI2K3FyNit2ckttcHFhRGR1MmJhdmFzbVhMcG5YcjFsVXNYYnAwL1lzdnZyaCs0c1NKbFo0Z0FBQUE5aVlCTUFBQUFCOUxyMTY5Q2tlTkd0WHVvSU1PYXRleFk4ZXk5dTNibDdacDA2WjFTVWxKV1hGeGNldFdyVnExYnRHaVJWbFJVVkhyd3NMQzFoR1JYMWhZV0JvUitRVUZCU1Y1ZVhrRmVYbDV1LzAvTHRQcGRHMDZuVzVzYkd6Y0ZoRk5EUTBOVzNmODMrcjYrdnJxN2R1M2I2bXRyYTJ1cWFtcDNyWnRXL1htelp1ck4yM2FWTDFodzRZdEN4WXNxSm8xYTFibDBxVkx0NXM0QUFBQVNTQUFCZ0FBWUsvcTE2OWZVZmZ1M1Z2c3M4OCt4U1VsSlFWdi8vOExDd3RUM2JwMSs4QlR4dVhsNVZzYkdob3liLy92YmR1Mk5hNVlzYUptelpvMTJ4Y3ZYbHl2d3dBQUFEUW43eGNBRjJnUEFBQUF1OXZpeFl2cmR3UzExYm9CQUFBQXUwK2VGZ0FBQUFBQUFBRGtCZ0V3QUFBQUFBQUFRSTRRQUFNQUFBQUFBQURrQ0FFd0FBQUFBQUFBUUk0UUFBTUFBQUFBQUFEa0NBRXdBQUFBQUFBQVFJNFFBQU1BQUFBQUFBRGtDQUV3QUFBQUFBQUFRSTRRQUFNQUFBQUFBQURrQ0FFd0FBQUFBQUFBUUk0UUFBTUFBQUFBQUFEa0NBRXdBQUFBQUFBQVFJNFFBQU1BQUFBQUFBRGtDQUV3QUFBQUFBQUFRSTRvMEFJQUFBQUFBQUNBNUdob0xJeUN4b2FJaUVpbElwTlhHRTF2LzB3QURBQUFBQUFBQUpBZ2hRVU4vMHg2TXhHcHB2VC81TDZ1Z0FZQUFBQUFBQURJRVFKZ0FBQUFBQUFBZ0J3aEFBWUFBQUFBQUFESUVRSmdBQUFBQUFBQWdCd2hBQVlBQUFBQUFBRElFUUpnQUFBQUFBQUFnQndoQUFZQUFBQUFBQURJRVFKZ0FBQUFBQUFBZ0J3aEFBWUFBQUFBQUFESUVRSmdBQUFBQUFBQWdCd2hBQVlBQUFBQUFBRElFUUpnQUFBQUFBQUFnQndoQUFZQUFBQUFBQURJRVFKZ0FBQUFBQUFBZ0J3aEFBWUFBQUFBQUFESUVRSmdBQUFBQUFBQWdCd2hBQVlBQUFBQUFBRElFUUpnQUFBQUFBQUFnQndoQUFZQUFBQUFBQURJRVFKZ0FBQUFBQUFBZ0J3aEFBWUFBQUFBQUFESUVRSmdBQUFBQUFBQWdCd2hBQVlBQUFBQUFBRElFUUpnQUFBQUFBQUFnQndoQUFZQUFBQUFBQURJRVFKZ0FBQUFBQUFBZ0J3aEFBWUFBQUFBQUFESUVRSmdBQUFBQUFBQWdCd2hBQVlBQUFBQUFBRElFUUpnQUFBQUFBQUFnQndoQUFZQUFBQUFBQURJRVFKZ0FBQUFBQUFBZ0J3aEFBWUFBQUFBQUFESUVRSmdBQUFBQUFBQWdCd2hBQVlBQUFBQUFBRElFUUpnQUFBQUFBQUFnQndoQUFZQUFBQUFBQURJRVFKZ0FBQUFBQUFBZ0J3aEFBWUFBQUFBQUFESUVRSmdBQUFBQUFBQWdCd2hBQVlBQUFBQUFBRElFUUpnQUFBQUFBQUFnQndoQUFZQUFBQUFBQURJRVFKZ0FBQUFBQUFBZ0J3aEFBWUFBQUFBQUFESUVRSmdBQUFBQUFBQWdCd2hBQVlBQUFBQUFBRElFUUpnQUFBQUFBQUFnQndoQUFZQUFBQUFBQURJRVFKZ0FBQUFBQUFBZ0J3aEFBWUFBQUFBQUFESUVRSmdBQUFBQUFBQWdCd2hBQVlBQUFBQUFBRElFUUpnQUFBQUFBQUFnQndoQUFZQUFBQUFBQURJRVFKZ0FBQUFBQUFBZ0J3aEFBWUFBQUFBQUFESUVRSmdBQUFBQUFBQWdCd2hBQVlBQUFBQUFBRElFUUpnQUFBQUFBQUFnQndoQUFZQUFBQUFBQURJRVFKZ0FBQUFBQUFBZ0J3aEFBWUFBQUFBQUFESUVRSmdBQUFBQUFBQWdCd2hBQVlBQUFBQUFBRElFUUpnQUFBQUFBQUFnQndoQUFZQUFBQUFBQURJRVFKZ0FBQUFBQUFBZ0J3aEFBWUFBQUFBQUFESUVRSmdBQUFBQUFBQWdCd2hBQVlBQUFBQUFBRElFUUpnQUFBQUFBQUFnQndoQUFZQUFBQUFBQURJRVFKZ0FBQUFBQUFBZ0J3aEFBWUFBQUFBQUFESUVRSmdBQUFBQUFBQWdCd2hBQVlBQUFBQUFBRElFUUpnQUFBQUFBQUFnQndoQUFZQUFBQUFBQURJRVFKZ0FBQUFBQUFBZ0J3aEFBWUFBQUFBQUFESUVRSmdBQUFBQUFBQWdCd2hBQVlBQUFBQUFBRElFUUpnQUFBQUFBQUFnQndoQUFZQUFBQUFBQURJRVFKZ0FBQUFBQUFBZ0J3aEFBWUFBQUFBQUFESUVRSmdBQUFBQUFBQWdCd2hBQVlBQUFBQUFBRElFUUpnQUFBQUFBQUFnQndoQUFZQUFBQUFBQURJRVFKZ0FBQUFBQUFBZ0J3aEFBWUFBQUFBQUFESUVRSmdBQUFBQUFBQWdCd2hBQVlBQUFBQUFBRElFUUpnQUFBQUFBQUFnQndoQUFZQUFBQUFBQURJRVFKZ0FBQUFBQUFBZ0J3aEFBWUFBQUFBQUFESUVRSmdBQUFBQUFBQWdCd2hBQVlBQUFBQUFBRElFUUpnQUFBQUFBQUFnQndoQUFZQUFBQUFBQURJRVFKZ0FBQUFBQUFBZ0J3aEFBWUFBQUFBQUFESUVRSmdBQUFBQUFBQWdCd2hBSWIvdjUyNzJaSGl1c000L0ZaMU5Va3o5c1F3T0Y0RXlaSnRwSkN3eXNhNWpTeTRuMXhQRXFSSXVRRnZ2ZkdTZ0l3Qk96R1JRQVFFUm54MGQxVVcwY2dXR3ZLeHNNR3ZubWZWZGM3LzFPSnNmK29DQUFBQUFBQ0FFZ0l3QUFBQUFBQUFRQWtCR0FBQUFBQUFBS0NFQUF3QUFBQUFBQUJRUWdBR0FBQUFBQUFBS0NFQUF3QUFBQUFBQUpRUWdBRUFBQUFBQUFCS0NNQUFBQUFBQUFBQUpRUmdBQUFBQUFBQWdCSUNNQUFBQUFBQUFFQUpBUmdBQUFBQUFBQ2doQUFNQUFBQUFBQUFVRUlBQmdBQUFBQUFBQ2doQUFNQUFBQUFBQUNVRUlBQkFBQUFBQUFBU2dqQUFBQUFBQUFBQUNVRVlBQUFBQUFBQUlBU0FqQUFBQUFBQUFCQUNRRVlBQUFBQUFBQW9JUUFEQUFBQUFBQUFGQkNBQVlBQUFBQUFBQW9JUUFEQUFBQUFBQUFsQkNBQVFBQUFBQUFBRW9Jd0FBQUFBQUFBQUFsQkdBQUFBQUFBQUNBRWdJd0FBQUFBQUFBUUFrQkdBQUFBQUFBQUtDRUFBd0FBQUFBQUFCUVFnQUdBQUFBQUFBQUtDRUFBd0FBQUFBQUFKUVFnQUVBQUFBQUFBQktDTUFBQUFBQUFBQUFKUVJnQUFBQUFBQUFnQklDTUFBQUFBQUFBRUFKQVJnQUFBQUFBQUNnaEFBTUFBQUFBQUFBVUVJQUJnQUFBQUFBQUNnaEFBTUFBQUFBQUFDVUVJQUJBQUFBQUFBQVNnakFBQUFBQUFBQUFDVUVZQUFBQUFBQUFJQVNBakFBQUFBQUFBQkFDUUVZQUFBQUFBQUFvSVFBREFBQUFBQUFBRkJDQUFZQUFBQUFBQUFvSVFBREFBQUFBQUFBbEJDQUFRQUFBQUFBQUVvSXdBQUFBQUFBQUFBbEJHQUFBQUFBQUFDQUVnSXdBQUFBQUFBQVFBa0JHQUFBQUFBQUFLQ0VBQXdBQUFBQUFBQlFRZ0FHQUFBQUFBQUFLQ0VBQXdBQUFBQUFBSlFRZ0FFQUFBQUFBQUJLQ01BQUFBQUFBQUFBSlFSZ0FBQUFBQUFBZ0JJQ01BQUFBQUFBQUVBSkFSZ0FBQUFBQUFDZ2hBQU1BQUFBQUFBQVVFSUFCZ0FBQUFBQUFDZ2hBQU1BQUFBQUFBQ1VFSUFCQUFBQUFBQUFTZ2pBQUFBQUFBQUFBQ1VFWUFBQUFBQUFBSUFTQWpBQUFBQUFBQUJBQ1FFWUFBQUFBQUFBb0lRQURBQUFBQUFBQUZCQ0FBWUFBQUFBQUFBb0lRQURBQUFBQUFBQWxCQ0FBUUFBQUFBQUFFb0l3QUFBQUFBQUFBQWxCR0FBQUFBQUFBQ0FFZ0l3QUFBQUFBQUFRQWtCR0FBQUFBQUFBS0NFQUF3QUFBQUFBQUJRUWdBR0FBQUFBQUFBS0NFQUF3QUFBQUFBQUpRUWdBRUFBQUFBQUFCS0NNQUFBQUFBQUFBQUpRUmdBQUFBQUFBQWdCSUNNQUFBQUFBQUFFQUpBUmdBQUFBQUFBQ2doQUFNQUFBQUFBQUFVRUlBQmdBQUFBQUFBQ2doQUFNQUFBQUFBQUNVRUlBQkFBQUFBQUFBU2dqQUFBQUFBQUFBQUNVRVlBQUFBQUFBQUlBU0FqQUFBQUFBQUFCQUNRRVlBQUFBQUFBQW9JUUFEQUFBQUFBQUFGQkNBQVlBQUFBQUFBQW9JUUFEQUFBQUFBQUFsQkNBQVFBQUFBQUFBRW9Jd0FBQUFBQUFBQUFsQkdBQUFBQUFBQUNBRWdJd0FBQUFBQUFBUUFrQkdBQUFBQUFBQUtDRUFBd0FBQUFBQUFCUVFnQUdBQUFBQUFBQUtDRUFBd0FBQUFBQUFKUVFnQUVBQUFBQUFBQktDTUFBQUFBQUFBQUFKUVJnQUFBQUFBQUFnQklDTUFBQUFBQUFBRUFKQVJnQUFBQUFBQUNnaEFBTUFBQUFBQUFBVUVJQUJnQUFBQUFBQUNnaEFBTUFBQUFBQUFDVUVJQUJBQUFBQUFBQVNnakFBQUFBQUFBQUFDVUVZQUFBQUFBQUFJQVNBakFBQUFBQUFBQkFDUUVZQUFBQUFBQUFvSVFBREFBQUFBQUFBRkJDQUFZQUFBQUFBQUFvSVFBREFBQUFBQUFBbEJDQUFRQUFBQUFBQUVvSXdBQUFBQUFBQUFBbEJHQUFBQUFBQUFDQUVnSXdBQUFBQUFBQVFBa0JHQUFBQUFBQUFLQ0VBQXdBQUFBQUFBQlFRZ0FHQUFBQUFBQUFLQ0VBQXdBQUFBQUFBSlFRZ0FFQUFBQUFBQUJLQ01BQUFBQUFBQUFBSlFSZ0FBQUFBQUFBZ0JJQ01BQUFBQUFBQUVBSkFSZ0FBQUFBQUFDZ2hBQU1BQUFBQUFBQVVFSUFCZ0FBQUFBQUFDZ2hBQU1BQUFBQUFBQ1VFSUFCQUFBQUFBQUFTZ2pBQUFBQUFBQUFBQ1VFWUFBQUFBQUFBSUFTQWpBQUFBQUFBQUJBQ1FFWUFBQUFBQUFBb0lRQURBQUFBQUFBQUZCQ0FBWUFBQUFBQUFBb0lRQURBQUFBQUFBQWxCQ0FBUUFBQUFBQUFFb0l3QUFBQUFBQUFBQWxCR0FBQUFBQUFBQ0FFZ0l3QUFBQUFBQUFRQWtCR0FBQUFBQUFBS0NFQUF3QUFBQUFBQUJRUWdBR0FBQUFBQUFBS0NFQUF3QUFBQUFBQUpRUWdBRUFBQUFBQUFCS0NNQUFBQUFBQUFBQUpRUmdBQUFBQUFBQWdCSUNNQUFBQUFBQUFFQUpBUmdBQUFBQUFBQ2doQUFNQUFBQUFBQUFVRUlBQmdBQUFBQUFBQ2doQUFNQUFBQUFBQUNVRUlBQkFBQUFBQUFBU2dqQUFBQUFBQUFBQUNVRVlBQUFBQUFBQUlBU0FqQUFBQUFBQUFCQUNRRVlBQUFBQUFBQW9JUUFEQUFBQUFBQUFGQkNBQVlBQUFBQUFBQW9JUUFEQUFBQUFBQUFsQkNBQVFBQUFBQUFBRW9Jd0FBQUFBQUFBQUFsQkdBQUFBQUFBQUNBRWdJd0FBQUFBQUFBUUFrQkdBQUFBQUFBQUtDRUFBd0FBQUFBQUFCUVFnQUdBQUFBQUFBQUtDRUFBd0FBQUFBQUFKUVFnQUVBQUFBQUFBQktDTUFBQUFBQUFBQUFKUVJnQUFBQUFBQUFnQklDTUFBQUFBQUFBRUFKQVJnQUFBQUFBQUNnaEFBTUFBQUFBQUFBVUVJQUJnQUFBQUFBQUNnaEFBTUFBQUFBQUFDVUVJQUJBQUFBQUFBQVNnakFBQUFBQUFBQUFDVUVZQUFBQUFBQUFJQVNBakFBQUFBQUFBQkFDUUVZQUFBQUFBQUFvSVFBREFBQUFBQUFBRkJDQUFZQUFBQUFBQUFvSVFBREFBQUFBQUFBbEJDQUFRQUFBQUFBQUVvSXdBQUFBQUFBQUFBbEJHQUFBQUFBQUFDQUVnSXdBQUFBQUFBQVFBa0JHQUFBQUFBQUFLQ0VBQXdBQUFBQUFBQlFRZ0FHQUFBQUFBQUFLQ0VBQXdBQUFBQUFBSlFRZ0FFQUFBQUFBQUJLQ01BQUFBQUFBQUFBSlFSZ0FBQUFBQUFBZ0JJQ01BQUFBQUFBQUVBSkFSZ0FBQUFBQUFDZ2hBQU1BQUFBQUFBQVVFSUFCZ0FBQUFBQUFDZ2hBQU1BQUFBQUFBQ1VFSUFCQUFBQUFBQUFTZ2pBQUFBQUFBQUFBQ1VFWUFBQUFBQUFBSUFTQWpBQUFBQUFBQUJBQ1FFWUFBQUFBQUFBb0lRQURBQUFBQUFBQUZCQ0FBWUFBQUFBQUFBb01ZM0pQLy85SzhNeTU1MWx6cEFrMjkzYTdRQUFBQUFBQUFEOGlJdzNyK1NMN1RwUHh1U3Q0L2liSkp1ejIwUURCZ0FBQUFBQUFIaHpySlBwNk52SFljeXlqTGw3ZEpUUGJsL0pwNnNQTHVmU3NNKzVlYzdxNVlPckYwT2VQL1NWYUFBQUFBQUFBSUEzd2VIN3U2emZtNzlkV0RJTVN3NjIyNXc3ODV2c3gzWHl6YXNPYnk1c3N6NjljNHNBQUFBQUFBQUFyOW42OUM2YkM5c1Q5M2E3cktkbk9SaW41T3R4eW56aTFKUWNmaXdDQXdBQUFBQUFBTHhPNjlPN0hINjhUYWFUOThjcDg1Ujh2YnAzTmZzenY4cTBMSG43eE1GMXNqay9aelVQbVovTW1XZWZoQVlBQUFBQUFBRDRvYXlQZGpuNzIyM0duN3g2WnJYUG5ldFg4bUJLa3B2M2N1ZkRkL1B1Zm41Rkw1NlN6Y1Z0TmhlVDNkTnQ4dFFsQXdBQUFBQUFBSHl2MXNtMHlTdi85WHRzTldaM0kvbEhrZ3pIaTcvNFhZN1dZejV5aXdBQUFBQUFBQUEvSXZ0Y3YvM25QRXlTMWZIYTQydDUrdk5MeVg3Sm9Sc0NBQUFBQUFBQWVQUHQxL25iVjMvS3ZlUG4xWGMzNzEvTll4RVlBQUFBQUFBQTRNMHlUSGsycnZObzJXZHp2SFpxek45di9TRjN2anUzZXZuZy9hdDVmUERMUER1MXl1R3laSFNWQUFBQUFBQUFBSy9YT0dlNHVlU3ZaNGU4TTh4WmJWZTVjZXVQdWZ2eTNPcWt3NCt2NWVtRFgrZnV1VGxMaGh3c0VZSUJBQUFBQUFBQVhwY2xHUjhPdVhQMFRSNGNQTS85ei8rU1J5Zk5EZi8xVFplek9wLzg3S2Rqeml6SlpraE83ZWRNeS93L25BVUFBQUFBQUFEZy96YU1XY1prUDgvWkxzbUxhY3IyL01WOCtjbnZzL3RQNS80Rm1MakFxMWlmY2lvQUFBQUFTVVZPUks1Q1lJST0nO1xuXG4vKipcbiAqIFBwdHhHZW5KUzogVXRpbGl0eSBNZXRob2RzXG4gKi9cbi8qKlxuICogVHJhbnNsYXRlcyBhbnkgdHlwZSBvZiBgeGAvYHlgL2B3YC9gaGAgcHJvcCB0byBFTVVcbiAqIC0gZ3VhcmFudGVlZCB0byByZXR1cm4gYSByZXN1bHQgcmVnYXJkbGVzcyBvZiB1bmRlZmluZWQsIG51bGwsIGV0Yy4gKDApXG4gKiAtIHtudW1iZXJ9IC0gMTI4MDAgKEVNVSlcbiAqIC0ge251bWJlcn0gLSAwLjUgKGluY2hlcylcbiAqIC0ge3N0cmluZ30gLSBcIjc1JVwiXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHNpemUgLSBudW1lcmljIChcIjUuNVwiKSBvciBwZXJjZW50YWdlIChcIjkwJVwiKVxuICogQHBhcmFtIHsnWCcgfCAnWSd9IHh5RGlyIC0gZGlyZWN0aW9uXG4gKiBAcGFyYW0ge1ByZXNMYXlvdXR9IGxheW91dCAtIHByZXNlbnRhdGlvbiBsYXlvdXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGNhbGN1bGF0ZWQgc2l6ZVxuICovXG5mdW5jdGlvbiBnZXRTbWFydFBhcnNlTnVtYmVyKHNpemUsIHh5RGlyLCBsYXlvdXQpIHtcbiAgICAvLyBGSVJTVDogQ29udmVydCBzdHJpbmcgbnVtZXJpYyB2YWx1ZSBpZiByZXFkXG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnc3RyaW5nJyAmJiAhaXNOYU4oTnVtYmVyKHNpemUpKSlcbiAgICAgICAgc2l6ZSA9IE51bWJlcihzaXplKTtcbiAgICAvLyBDQVNFIDE6IE51bWJlciBpbiBpbmNoZXNcbiAgICAvLyBBc3N1bWUgYW55IG51bWJlciBsZXNzIHRoYW4gMTAwIGlzIGluY2hlc1xuICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicgJiYgc2l6ZSA8IDEwMClcbiAgICAgICAgcmV0dXJuIGluY2gyRW11KHNpemUpO1xuICAgIC8vIENBU0UgMjogTnVtYmVyIGlzIGFscmVhZHkgY29udmVydGVkIHRvIHNvbWV0aGluZyBvdGhlciB0aGFuIGluY2hlc1xuICAgIC8vIEFzc3VtZSBhbnkgbnVtYmVyIGdyZWF0ZXIgdGhhbiAxMDAgc3VyZSBpc250IGluY2hlcyEgSnVzdCByZXR1cm4gaXQgKGFzc3VtZSB2YWx1ZSBpcyBFTVUgYWxyZWFkeSkuXG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJyAmJiBzaXplID49IDEwMClcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgLy8gQ0FTRSAzOiBQZXJjZW50YWdlIChleDogJzUwJScpXG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnc3RyaW5nJyAmJiBzaXplLmluY2x1ZGVzKCclJykpIHtcbiAgICAgICAgaWYgKHh5RGlyICYmIHh5RGlyID09PSAnWCcpXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgocGFyc2VGbG9hdChzaXplKSAvIDEwMCkgKiBsYXlvdXQud2lkdGgpO1xuICAgICAgICBpZiAoeHlEaXIgJiYgeHlEaXIgPT09ICdZJylcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKChwYXJzZUZsb2F0KHNpemUpIC8gMTAwKSAqIGxheW91dC5oZWlnaHQpO1xuICAgICAgICAvLyBEZWZhdWx0OiBBc3N1bWUgd2lkdGggKHgvY3gpXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKChwYXJzZUZsb2F0KHNpemUpIC8gMTAwKSAqIGxheW91dC53aWR0aCk7XG4gICAgfVxuICAgIC8vIExBU1Q6IERlZmF1bHQgdmFsdWVcbiAgICByZXR1cm4gMDtcbn1cbi8qKlxuICogQmFzaWMgVVVJRCBHZW5lcmF0b3IgQWRhcHRlZFxuICogQGxpbmsgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2NyZWF0ZS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdCNhbnN3ZXItMjExNzUyM1xuICogQHBhcmFtIHtzdHJpbmd9IHV1aWRGb3JtYXQgLSBVVUlEIGZvcm1hdFxuICogQHJldHVybnMge3N0cmluZ30gVVVJRFxuICovXG5mdW5jdGlvbiBnZXRVdWlkKHV1aWRGb3JtYXQpIHtcbiAgICByZXR1cm4gdXVpZEZvcm1hdC5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDA7XG4gICAgICAgIGNvbnN0IHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4O1xuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgfSk7XG59XG4vKipcbiAqIFJlcGxhY2Ugc3BlY2lhbCBYTUwgY2hhcmFjdGVycyB3aXRoIEhUTUwtZW5jb2RlZCBzdHJpbmdzXG4gKiBAcGFyYW0ge3N0cmluZ30geG1sIC0gWE1MIHN0cmluZyB0byBlbmNvZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGVzY2FwZWQgWE1MXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVhtbEVudGl0aWVzKHhtbCkge1xuICAgIC8vIE5PVEU6IERvbnQgdXNlIHNob3J0LWNpcmN1aXQgZXZhbCBoZXJlIGFzIHZhbHVlIGMvYiBcIjBcIiAoemVybykgZXRjLiFcbiAgICBpZiAodHlwZW9mIHhtbCA9PT0gJ3VuZGVmaW5lZCcgfHwgeG1sID09IG51bGwpXG4gICAgICAgIHJldHVybiAnJztcbiAgICByZXR1cm4geG1sLnRvU3RyaW5nKCkucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKS5yZXBsYWNlKC8nL2csICcmYXBvczsnKTtcbn1cbi8qKlxuICogQ29udmVydCBpbmNoZXMgaW50byBFTVVcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gaW5jaGVzIC0gYXMgc3RyaW5nIG9yIG51bWJlclxuICogQHJldHVybnMge251bWJlcn0gRU1VIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGluY2gyRW11KGluY2hlcykge1xuICAgIC8vIE5PVEU6IFByb3ZpZGUgQ2FsbGVyIFNhZmV0eTogTnVtYmVycyBtYXkgZ2V0IGNvbnY8LT5jb252IGR1cmluZyBmbGlnaHQsIHNvIGJlIGtpbmQgYW5kIGRvIHNvbWUgc2ltcGxlIGNoZWNrcyB0byBlbnN1cmUgaW5jaGVzIHdlcmUgcGFzc2VkXG4gICAgLy8gQW55IHZhbHVlIG92ZXIgMTAwIGRhbW4gc3VyZSBpc250IGluY2hlcywgc28gbGV0cyBhc3N1bWUgaXRzIGluIEVNVSBhbHJlYWR5LCB0aGVyZWZvcmUsIGp1c3QgcmV0dXJuIHRoZSBzYW1lIHZhbHVlXG4gICAgaWYgKHR5cGVvZiBpbmNoZXMgPT09ICdudW1iZXInICYmIGluY2hlcyA+IDEwMClcbiAgICAgICAgcmV0dXJuIGluY2hlcztcbiAgICBpZiAodHlwZW9mIGluY2hlcyA9PT0gJ3N0cmluZycpXG4gICAgICAgIGluY2hlcyA9IE51bWJlcihpbmNoZXMucmVwbGFjZSgvaW4qL2dpLCAnJykpO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKEVNVSAqIGluY2hlcyk7XG59XG4vKipcbiAqIENvbnZlcnQgYHB0YCBpbnRvIHBvaW50cyAodXNpbmcgYE9ORVBUYClcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gcHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHZhbHVlIGluIHBvaW50cyAoYE9ORVBUYClcbiAqL1xuZnVuY3Rpb24gdmFsVG9QdHMocHQpIHtcbiAgICBjb25zdCBwb2ludHMgPSBOdW1iZXIocHQpIHx8IDA7XG4gICAgcmV0dXJuIGlzTmFOKHBvaW50cykgPyAwIDogTWF0aC5yb3VuZChwb2ludHMgKiBPTkVQVCk7XG59XG4vKipcbiAqIENvbnZlcnQgZGVncmVlcyAoMC4uMzYwKSB0byBQb3dlclBvaW50IGByb3RgIHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gZCBkZWdyZWVzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBjYWxjdWxhdGVkIGByb3RgIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSb3RhdGlvbkRlZ3JlZXMoZCkge1xuICAgIGQgPSBkIHx8IDA7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoKGQgPiAzNjAgPyBkIC0gMzYwIDogZCkgKiA2MDAwMCk7XG59XG4vKipcbiAqIENvbnZlcnRzIGNvbXBvbmVudCB2YWx1ZSB0byBoZXggdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBjIC0gY29tcG9uZW50IGNvbG9yXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBoZXggc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGNvbXBvbmVudFRvSGV4KGMpIHtcbiAgICBjb25zdCBoZXggPSBjLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCA9PT0gMSA/ICcwJyArIGhleCA6IGhleDtcbn1cbi8qKlxuICogQ29udmVydHMgUkdCIGNvbG9ycyBmcm9tIGNzcyBzZWxlY3RvcnMgdG8gSGV4IGZvciBQcmVzZW50YXRpb24gY29sb3JzXG4gKiBAcGFyYW0ge251bWJlcn0gciAtIHJlZCB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGcgLSBncmVlbiB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGIgLSBibHVlIHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBYTUwgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHJnYlRvSGV4KHIsIGcsIGIpIHtcbiAgICByZXR1cm4gKGNvbXBvbmVudFRvSGV4KHIpICsgY29tcG9uZW50VG9IZXgoZykgKyBjb21wb25lbnRUb0hleChiKSkudG9VcHBlckNhc2UoKTtcbn1cbi8qKiAgVE9ETzogRlVUVVJFOiBUT0RPLTQuMDpcbiAqIEBkYXRlIDIwMjItMDQtMTBcbiAqIEB0bGRyIHRoaXMgcy9iIGEgcHJpdmF0ZSBtZXRob2Qgd2l0aCBhbGwgY3VycmVudCBjYWxscyBzd2l0Y2hlZCB0byBgZ2VuWG1sQ29sb3JTZWxlY3Rpb24oKWBcbiAqIEBkZXNjIGxvdHMgb2YgY29kZSBjYWxscyB0aGlzIG1ldGhvZFxuICogQGV4YW1wbGUgW2dlbi1jaGFydHMudHhdIGBzdHJYbWwgKz0gJzxhOnNvbGlkRmlsbD4nICsgY3JlYXRlQ29sb3JFbGVtZW50KHNlcmllc0NvbG9yLCBgPGE6YWxwaGEgdmFsPVwiJHtNYXRoLnJvdW5kKG9wdHMuY2hhcnRDb2xvcnNPcGFjaXR5ICogMTAwMCl9XCIvPmApICsgJzwvYTpzb2xpZEZpbGw+J2BcbiAqIFRoaSBzaXMgd3JvbmcuIFdlIHMvYiBjYWxsaW5nIGBnZW5YbWxDb2xvclNlbGVjdGlvbigpYCBpbnN0ZWFkIGFzIGl0IHJldHVybnMgYDxhOnNvbGlkZmlsbD5CTEFIPC9hOnNvbGlkRmlsbD5gISFcbiAqL1xuLyoqXG4gKiBDcmVhdGUgZWl0aGVyIGEgYGE6c2NoZW1lQ2xyYCAtIChzY2hlbWUgY29sb3IpIG9yIGBhOnNyZ2JDbHJgIChoZXhhIHJlcHJlc2VudGF0aW9uKS5cbiAqIEBwYXJhbSB7c3RyaW5nfFNDSEVNRV9DT0xPUlN9IGNvbG9yU3RyIC0gaGV4YSByZXByZXNlbnRhdGlvbiAoZWcuIFwiRkZGRjAwXCIpIG9yIGEgc2NoZW1lIGNvbG9yIGNvbnN0YW50IChlZy4gcHB0eC5TY2hlbWVDb2xvci5BQ0NFTlQxKVxuICogQHBhcmFtIHtzdHJpbmd9IGlubmVyRWxlbWVudHMgLSBhZGRpdGlvbmFsIGVsZW1lbnRzIHRoYXQgYWRqdXN0IHRoZSBjb2xvciBhbmQgYXJlIGVuY2xvc2VkIGJ5IHRoZSBjb2xvciBlbGVtZW50XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBYTUwgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbG9yRWxlbWVudChjb2xvclN0ciwgaW5uZXJFbGVtZW50cykge1xuICAgIGxldCBjb2xvclZhbCA9IChjb2xvclN0ciB8fCAnJykucmVwbGFjZSgnIycsICcnKTtcbiAgICBpZiAoIVJFR0VYX0hFWF9DT0xPUi50ZXN0KGNvbG9yVmFsKSAmJlxuICAgICAgICBjb2xvclZhbCAhPT0gU2NoZW1lQ29sb3IuYmFja2dyb3VuZDEgJiZcbiAgICAgICAgY29sb3JWYWwgIT09IFNjaGVtZUNvbG9yLmJhY2tncm91bmQyICYmXG4gICAgICAgIGNvbG9yVmFsICE9PSBTY2hlbWVDb2xvci50ZXh0MSAmJlxuICAgICAgICBjb2xvclZhbCAhPT0gU2NoZW1lQ29sb3IudGV4dDIgJiZcbiAgICAgICAgY29sb3JWYWwgIT09IFNjaGVtZUNvbG9yLmFjY2VudDEgJiZcbiAgICAgICAgY29sb3JWYWwgIT09IFNjaGVtZUNvbG9yLmFjY2VudDIgJiZcbiAgICAgICAgY29sb3JWYWwgIT09IFNjaGVtZUNvbG9yLmFjY2VudDMgJiZcbiAgICAgICAgY29sb3JWYWwgIT09IFNjaGVtZUNvbG9yLmFjY2VudDQgJiZcbiAgICAgICAgY29sb3JWYWwgIT09IFNjaGVtZUNvbG9yLmFjY2VudDUgJiZcbiAgICAgICAgY29sb3JWYWwgIT09IFNjaGVtZUNvbG9yLmFjY2VudDYpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBcIiR7Y29sb3JWYWx9XCIgaXMgbm90IGEgdmFsaWQgc2NoZW1lIGNvbG9yIG9yIGhleCBSR0IhIFwiJHtERUZfRk9OVF9DT0xPUn1cIiB1c2VkIGluc3RlYWQuIE9ubHkgcHJvdmlkZSA2LWRpZ2l0IFJHQiBvciAncHB0eC5TY2hlbWVDb2xvcicgdmFsdWVzIWApO1xuICAgICAgICBjb2xvclZhbCA9IERFRl9GT05UX0NPTE9SO1xuICAgIH1cbiAgICBjb25zdCB0YWdOYW1lID0gUkVHRVhfSEVYX0NPTE9SLnRlc3QoY29sb3JWYWwpID8gJ3NyZ2JDbHInIDogJ3NjaGVtZUNscic7XG4gICAgY29uc3QgY29sb3JBdHRyID0gJ3ZhbD1cIicgKyAoUkVHRVhfSEVYX0NPTE9SLnRlc3QoY29sb3JWYWwpID8gY29sb3JWYWwudG9VcHBlckNhc2UoKSA6IGNvbG9yVmFsKSArICdcIic7XG4gICAgcmV0dXJuIGlubmVyRWxlbWVudHMgPyBgPGE6JHt0YWdOYW1lfSAke2NvbG9yQXR0cn0+JHtpbm5lckVsZW1lbnRzfTwvYToke3RhZ05hbWV9PmAgOiBgPGE6JHt0YWdOYW1lfSAke2NvbG9yQXR0cn0vPmA7XG59XG4vKipcbiAqIENyZWF0ZXMgYGE6Z2xvd2AgZWxlbWVudFxuICogQHBhcmFtIHtUZXh0R2xvd1Byb3BzfSBvcHRpb25zIGdsb3cgcHJvcGVydGllc1xuICogQHBhcmFtIHtUZXh0R2xvd1Byb3BzfSBkZWZhdWx0cyBkZWZhdWx0cyBmb3IgdW5zcGVjaWZpZWQgcHJvcGVydGllcyBpbiBgb3B0c2BcbiAqIEBzZWUgaHR0cDovL29mZmljZW9wZW54bWwuY29tL2Ryd1NwLWVmZmVjdHMucGhwXG4gKiB7IHNpemU6IDgsIGNvbG9yOiAnRkZGRkZGJywgb3BhY2l0eTogMC43NSB9O1xuICovXG5mdW5jdGlvbiBjcmVhdGVHbG93RWxlbWVudChvcHRpb25zLCBkZWZhdWx0cykge1xuICAgIGxldCBzdHJYbWwgPSAnJztcbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cyksIG9wdGlvbnMpO1xuICAgIGNvbnN0IHNpemUgPSBNYXRoLnJvdW5kKG9wdHMuc2l6ZSAqIE9ORVBUKTtcbiAgICBjb25zdCBjb2xvciA9IG9wdHMuY29sb3I7XG4gICAgY29uc3Qgb3BhY2l0eSA9IE1hdGgucm91bmQob3B0cy5vcGFjaXR5ICogMTAwMDAwKTtcbiAgICBzdHJYbWwgKz0gYDxhOmdsb3cgcmFkPVwiJHtzaXplfVwiPmA7XG4gICAgc3RyWG1sICs9IGNyZWF0ZUNvbG9yRWxlbWVudChjb2xvciwgYDxhOmFscGhhIHZhbD1cIiR7b3BhY2l0eX1cIi8+YCk7XG4gICAgc3RyWG1sICs9ICc8L2E6Z2xvdz4nO1xuICAgIHJldHVybiBzdHJYbWw7XG59XG4vKipcbiAqIENyZWF0ZSBjb2xvciBzZWxlY3Rpb25cbiAqIEBwYXJhbSB7Q29sb3IgfCBTaGFwZUZpbGxQcm9wcyB8IFNoYXBlTGluZVByb3BzfSBwcm9wcyBmaWxsIHByb3BzXG4gKiBAcmV0dXJucyBYTUwgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGdlblhtbENvbG9yU2VsZWN0aW9uKHByb3BzKSB7XG4gICAgbGV0IGZpbGxUeXBlID0gJ3NvbGlkJztcbiAgICBsZXQgY29sb3JWYWwgPSAnJztcbiAgICBsZXQgaW50ZXJuYWxFbGVtZW50cyA9ICcnO1xuICAgIGxldCBvdXRUZXh0ID0gJyc7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcHMgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgY29sb3JWYWwgPSBwcm9wcztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJvcHMudHlwZSlcbiAgICAgICAgICAgICAgICBmaWxsVHlwZSA9IHByb3BzLnR5cGU7XG4gICAgICAgICAgICBpZiAocHJvcHMuY29sb3IpXG4gICAgICAgICAgICAgICAgY29sb3JWYWwgPSBwcm9wcy5jb2xvcjtcbiAgICAgICAgICAgIGlmIChwcm9wcy5hbHBoYSlcbiAgICAgICAgICAgICAgICBpbnRlcm5hbEVsZW1lbnRzICs9IGA8YTphbHBoYSB2YWw9XCIke01hdGgucm91bmQoKDEwMCAtIHByb3BzLmFscGhhKSAqIDEwMDApfVwiLz5gOyAvLyBERVBSRUNBVEVEOiBAZGVwcmVjYXRlZCB2My4zLjBcbiAgICAgICAgICAgIGlmIChwcm9wcy50cmFuc3BhcmVuY3kpXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxFbGVtZW50cyArPSBgPGE6YWxwaGEgdmFsPVwiJHtNYXRoLnJvdW5kKCgxMDAgLSBwcm9wcy50cmFuc3BhcmVuY3kpICogMTAwMCl9XCIvPmA7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChmaWxsVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgICAgICAgICAgIG91dFRleHQgKz0gYDxhOnNvbGlkRmlsbD4ke2NyZWF0ZUNvbG9yRWxlbWVudChjb2xvclZhbCwgaW50ZXJuYWxFbGVtZW50cyl9PC9hOnNvbGlkRmlsbD5gO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogLy8gQG5vdGUgbmVlZCBhIHN0YXRlbWVudCBhcyBoYXZpbmcgb25seSBcImJyZWFrXCIgaXMgcmVtb3ZlZCBieSByb2xsdXAsIHRoZW4gdGlnZ2VycyBcIm5vLWRlZmF1bHRcIiBqcy1saW50ZXJcbiAgICAgICAgICAgICAgICBvdXRUZXh0ICs9ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRUZXh0O1xufVxuLyoqXG4gKiBHZXQgYSBuZXcgcmVsIElEIChySWQpIGZvciBjaGFydHMsIG1lZGlhLCBldGMuXG4gKiBAcGFyYW0ge1ByZXNTbGlkZX0gdGFyZ2V0IC0gdGhlIHNsaWRlIHRvIHVzZVxuICogQHJldHVybnMge251bWJlcn0gY291bnQgb2YgYWxsIGN1cnJlbnQgcmVscyBwbHVzIDEgZm9yIHRoZSBjYWxsZXIgdG8gdXNlIGFzIGl0cyBcInJJZFwiXG4gKi9cbmZ1bmN0aW9uIGdldE5ld1JlbElkKHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQuX3JlbHMubGVuZ3RoICsgdGFyZ2V0Ll9yZWxzQ2hhcnQubGVuZ3RoICsgdGFyZ2V0Ll9yZWxzTWVkaWEubGVuZ3RoICsgMTtcbn1cbi8qKlxuICogQ2hlY2tzIHNoYWRvdyBvcHRpb25zIHBhc3NlZCBieSB1c2VyIGFuZCBwZXJmb3JtcyBjb3JyZWN0aW9ucyBpZiBuZWVkZWQuXG4gKiBAcGFyYW0ge1NoYWRvd1Byb3BzfSBTaGFkb3dQcm9wcyAtIHNoYWRvdyBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNvcnJlY3RTaGFkb3dPcHRpb25zKFNoYWRvd1Byb3BzKSB7XG4gICAgaWYgKCFTaGFkb3dQcm9wcyB8fCB0eXBlb2YgU2hhZG93UHJvcHMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybihcImBzaGFkb3dgIG9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuIEV4OiBge3NoYWRvdzoge3R5cGU6J25vbmUnfX1gXCIpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gT1BUOiBgdHlwZWBcbiAgICBpZiAoU2hhZG93UHJvcHMudHlwZSAhPT0gJ291dGVyJyAmJiBTaGFkb3dQcm9wcy50eXBlICE9PSAnaW5uZXInICYmIFNoYWRvd1Byb3BzLnR5cGUgIT09ICdub25lJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IHNoYWRvdy50eXBlIG9wdGlvbnMgYXJlIGBvdXRlcmAsIGBpbm5lcmAgb3IgYG5vbmVgLicpO1xuICAgICAgICBTaGFkb3dQcm9wcy50eXBlID0gJ291dGVyJztcbiAgICB9XG4gICAgLy8gT1BUOiBgYW5nbGVgXG4gICAgaWYgKFNoYWRvd1Byb3BzLmFuZ2xlKSB7XG4gICAgICAgIC8vIEE6IFJFQUxJVFktQ0hFQ0tcbiAgICAgICAgaWYgKGlzTmFOKE51bWJlcihTaGFkb3dQcm9wcy5hbmdsZSkpIHx8IFNoYWRvd1Byb3BzLmFuZ2xlIDwgMCB8fCBTaGFkb3dQcm9wcy5hbmdsZSA+IDM1OSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdXYXJuaW5nOiBzaGFkb3cuYW5nbGUgY2FuIG9ubHkgYmUgMC0zNTknKTtcbiAgICAgICAgICAgIFNoYWRvd1Byb3BzLmFuZ2xlID0gMjcwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEI6IFJPQlVTVDogQ2FzdCBhbnkgdHlwZSBvZiB2YWxpZCBhcmcgdG8gaW50OiAnMTInLCAxMi4zLCBldGMuIC0+IDEyXG4gICAgICAgIFNoYWRvd1Byb3BzLmFuZ2xlID0gTWF0aC5yb3VuZChOdW1iZXIoU2hhZG93UHJvcHMuYW5nbGUpKTtcbiAgICB9XG4gICAgLy8gT1BUOiBgb3BhY2l0eWBcbiAgICBpZiAoU2hhZG93UHJvcHMub3BhY2l0eSkge1xuICAgICAgICAvLyBBOiBSRUFMSVRZLUNIRUNLXG4gICAgICAgIGlmIChpc05hTihOdW1iZXIoU2hhZG93UHJvcHMub3BhY2l0eSkpIHx8IFNoYWRvd1Byb3BzLm9wYWNpdHkgPCAwIHx8IFNoYWRvd1Byb3BzLm9wYWNpdHkgPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IHNoYWRvdy5vcGFjaXR5IGNhbiBvbmx5IGJlIDAtMScpO1xuICAgICAgICAgICAgU2hhZG93UHJvcHMub3BhY2l0eSA9IDAuNzU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQjogUk9CVVNUOiBDYXN0IGFueSB0eXBlIG9mIHZhbGlkIGFyZyB0byBpbnQ6ICcxMicsIDEyLjMsIGV0Yy4gLT4gMTJcbiAgICAgICAgU2hhZG93UHJvcHMub3BhY2l0eSA9IE51bWJlcihTaGFkb3dQcm9wcy5vcGFjaXR5KTtcbiAgICB9XG4gICAgLy8gT1BUOiBgY29sb3JgXG4gICAgaWYgKFNoYWRvd1Byb3BzLmNvbG9yKSB7XG4gICAgICAgIC8vIElOQ09SUkVDVCBGT1JNQVRcbiAgICAgICAgaWYgKFNoYWRvd1Byb3BzLmNvbG9yLnN0YXJ0c1dpdGgoJyMnKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdXYXJuaW5nOiBzaGFkb3cuY29sb3Igc2hvdWxkIG5vdCBpbmNsdWRlIGhhc2ggKCMpIGNoYXJhY3RlciwgLCBlLmcuIFwiRkYwMDAwXCInKTtcbiAgICAgICAgICAgIFNoYWRvd1Byb3BzLmNvbG9yID0gU2hhZG93UHJvcHMuY29sb3IucmVwbGFjZSgnIycsICcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gU2hhZG93UHJvcHM7XG59XG5cbi8qKlxuICogUHB0eEdlbkpTOiBUYWJsZSBHZW5lcmF0aW9uXG4gKi9cbi8qKlxuICogQnJlYWsgY2VsbCB0ZXh0IGludG8gbGluZXMgYmFzZWQgdXBvbiB0YWJsZSBjb2x1bW4gd2lkdGggKGUuZy46IE1hZ2ljIEhhcHBlbnMgSGVyZSh0bSkpXG4gKiBAcGFyYW0ge1RhYmxlQ2VsbH0gY2VsbCAtIHRhYmxlIGNlbGxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2xXaWR0aCAtIHRhYmxlIGNvbHVtbiB3aWR0aCAoaW5jaGVzKVxuICogQHJldHVybiB7VGFibGVSb3dbXX0gLSBjZWxsJ3MgdGV4dCBvYmplY3RzIGdyb3VwZWQgaW50byBsaW5lc1xuICovXG5mdW5jdGlvbiBwYXJzZVRleHRUb0xpbmVzKGNlbGwsIGNvbFdpZHRoLCB2ZXJib3NlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICAvLyBGWUk6IENQTCA9IFdpZHRoIC8gKGZvbnQtc2l6ZSAvIGZvbnQtY29uc3RhbnQpXG4gICAgLy8gRllJOiBDSEFSOjIuMywgY29sV2lkdGg6MTAsIGZvbnRTaXplOjEyID0+IENQTD0xMzgsIChhY3R1YWwgY2hhcnMgcGVyIGxpbmUgaW4gUFBUKT0xNDUgWzE0LjUgQ1BJXVxuICAgIC8vIEZZSTogQ0hBUjoyLjMsIGNvbFdpZHRoOjcgLCBmb250U2l6ZToxMiA9PiBDUEw9IDk3LCAoYWN0dWFsIGNoYXJzIHBlciBsaW5lIGluIFBQVCk9MTAwIFsxNC4zIENQSV1cbiAgICAvLyBGWUk6IENIQVI6Mi4zLCBjb2xXaWR0aDo5ICwgZm9udFNpemU6MTYgPT4gQ1BMPSA5NiwgKGFjdHVhbCBjaGFycyBwZXIgbGluZSBpbiBQUFQpPTg0ICBbIDkuMyBDUEldXG4gICAgY29uc3QgRk9DTyA9IDIuMyArICgoKF9hID0gY2VsbC5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXV0b1BhZ2VDaGFyV2VpZ2h0KSA/IGNlbGwub3B0aW9ucy5hdXRvUGFnZUNoYXJXZWlnaHQgOiAwKTsgLy8gQ2hhcmFjdGVyIENvbnN0YW50XG4gICAgY29uc3QgQ1BMID0gTWF0aC5mbG9vcigoY29sV2lkdGggLyBPTkVQVCkgKiBFTVUpIC8gKCgoKF9iID0gY2VsbC5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZm9udFNpemUpID8gY2VsbC5vcHRpb25zLmZvbnRTaXplIDogREVGX0ZPTlRfU0laRSkgLyBGT0NPKTsgLy8gQ2hhcnMtUGVyLUxpbmVcbiAgICBjb25zdCBwYXJzZWRMaW5lcyA9IFtdO1xuICAgIGxldCBpbnB1dENlbGxzID0gW107XG4gICAgY29uc3QgaW5wdXRMaW5lczEgPSBbXTtcbiAgICBjb25zdCBpbnB1dExpbmVzMiA9IFtdO1xuICAgIC8qXG4gICAgICAgIGlmIChjZWxsLm9wdGlvbnMgJiYgY2VsbC5vcHRpb25zLmF1dG9QYWdlQ2hhcldlaWdodCkge1xuICAgICAgICAgICAgbGV0IENIUjEgPSAyLjMgKyAoY2VsbC5vcHRpb25zICYmIGNlbGwub3B0aW9ucy5hdXRvUGFnZUNoYXJXZWlnaHQgPyBjZWxsLm9wdGlvbnMuYXV0b1BhZ2VDaGFyV2VpZ2h0IDogMCkgLy8gQ2hhcmFjdGVyIENvbnN0YW50XG4gICAgICAgICAgICBsZXQgQ1BMMSA9ICgoY29sV2lkdGggLyBPTkVQVCkgKiBFTVUpIC8gKChjZWxsLm9wdGlvbnMgJiYgY2VsbC5vcHRpb25zLmZvbnRTaXplID8gY2VsbC5vcHRpb25zLmZvbnRTaXplIDogREVGX0ZPTlRfU0laRSkgLyBDSFIxKSAvLyBDaGFycy1QZXItTGluZVxuICAgICAgICAgICAgY29uc29sZS5sb2coYGNlbGwub3B0aW9ucy5hdXRvUGFnZUNoYXJXZWlnaHQ6ICcke2NlbGwub3B0aW9ucy5hdXRvUGFnZUNoYXJXZWlnaHR9JyA9PiBDUEw6ICR7Q1BMMX1gKVxuICAgICAgICAgICAgbGV0IENIUjIgPSAyLjMgKyAwXG4gICAgICAgICAgICBsZXQgQ1BMMiA9ICgoY29sV2lkdGggLyBPTkVQVCkgKiBFTVUpIC8gKChjZWxsLm9wdGlvbnMgJiYgY2VsbC5vcHRpb25zLmZvbnRTaXplID8gY2VsbC5vcHRpb25zLmZvbnRTaXplIDogREVGX0ZPTlRfU0laRSkgLyBDSFIyKSAvLyBDaGFycy1QZXItTGluZVxuICAgICAgICAgICAgY29uc29sZS5sb2coYGNlbGwub3B0aW9ucy5hdXRvUGFnZUNoYXJXZWlnaHQ6ICcwJyA9PiBDUEw6ICR7Q1BMMn1gKVxuICAgICAgICB9XG4gICAgKi9cbiAgICAvKipcbiAgICAgKiBFWCBJTlBVVFM6IGBjZWxsLnRleHRgXG4gICAgICogLSBzdHJpbmcuLi4uOiBcIkFjY291bnQgTmFtZSBDb2x1bW5cIlxuICAgICAqIC0gb2JqZWN0Li4uLjogeyB0ZXh0OlwiQWNjb3VudCBOYW1lIENvbHVtblwiIH1cbiAgICAgKiAtIG9iamVjdFtdLi46IFt7IHRleHQ6XCJBY2NvdW50IE5hbWVcIiwgb3B0aW9uczp7IGJvbGQ6dHJ1ZSB9IH0sIHsgdGV4dDpcIiBDb2x1bW5cIiB9XVxuICAgICAqIC0gb2JqZWN0W10uLjogW3sgdGV4dDpcIkFjY291bnQgTmFtZVwiLCBvcHRpb25zOnsgYnJlYWtMaW5lOnRydWUgfSB9LCB7IHRleHQ6XCJJbnB1dFwiIH1dXG4gICAgICovXG4gICAgLyoqXG4gICAgICogRVggT1VUUFVUUzpcbiAgICAgKiAtIHN0cmluZy4uLi46IFt7IHRleHQ6XCJBY2NvdW50IE5hbWUgQ29sdW1uXCIgfV1cbiAgICAgKiAtIG9iamVjdC4uLi46IFt7IHRleHQ6XCJBY2NvdW50IE5hbWUgQ29sdW1uXCIgfV1cbiAgICAgKiAtIG9iamVjdFtdLi46IFt7IHRleHQ6XCJBY2NvdW50IE5hbWVcIiwgb3B0aW9uczp7IGJyZWFrTGluZTp0cnVlIH0gfSwgeyB0ZXh0OlwiSW5wdXRcIiB9XVxuICAgICAqIC0gb2JqZWN0W10uLjogW3sgdGV4dDpcIkFjY291bnQgTmFtZVwiLCBvcHRpb25zOnsgYnJlYWtMaW5lOnRydWUgfSB9LCB7IHRleHQ6XCJJbnB1dFwiIH1dXG4gICAgICovXG4gICAgLy8gU1RFUCAxOiBFbnN1cmUgaW5wdXRDZWxscyBpcyBhbiBhcnJheSBvZiBUYWJsZUNlbGxzXG4gICAgaWYgKGNlbGwudGV4dCAmJiBjZWxsLnRleHQudG9TdHJpbmcoKS50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIEFsbG93IGEgc2luZ2xlIHNwYWNlL3doaXRlc3BhY2UgYXMgY2VsbCB0ZXh0ICh1c2VyLXJlcXVlc3RlZCBmZWF0dXJlKVxuICAgICAgICBpbnB1dENlbGxzLnB1c2goeyBfdHlwZTogU0xJREVfT0JKRUNUX1RZUEVTLnRhYmxlY2VsbCwgdGV4dDogJyAnIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgY2VsbC50ZXh0ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgY2VsbC50ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpbnB1dENlbGxzLnB1c2goeyBfdHlwZTogU0xJREVfT0JKRUNUX1RZUEVTLnRhYmxlY2VsbCwgdGV4dDogKGNlbGwudGV4dCB8fCAnJykudG9TdHJpbmcoKS50cmltKCkgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2VsbC50ZXh0KSkge1xuICAgICAgICBpbnB1dENlbGxzID0gY2VsbC50ZXh0O1xuICAgIH1cbiAgICAvLyBTVEVQIDI6IEdyb3VwIHRhYmxlIGNlbGxzIGludG8gbGluZXMgYmFzZWQgb24gXCJcXG5cIiBvciBgYnJlYWtMaW5lYCBwcm9wXG4gICAgLyoqXG4gICAgICogLSBFWDogYFt7IHRleHQ6XCJJbnB1dCBPdXRwdXRcIiB9LCB7IHRleHQ6XCJFeHRyYVwiIH1dYCAgICAgICAgICAgICAgICAgICAgICAgPT0gMSBsaW5lXG4gICAgICogLSBFWDogYFt7IHRleHQ6XCJJbnB1dFwiIH0sIHsgdGV4dDpcIk91dHB1dFwiLCBvcHRpb25zOnsgYnJlYWtMaW5lOnRydWUgfSB9XWAgPT0gMSBsaW5lXG4gICAgICogLSBFWDogYFt7IHRleHQ6XCJJbnB1dFxcbk91dHB1dFwiIH1dYCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9PSAyIGxpbmVzXG4gICAgICogLSBFWDogYFt7IHRleHQ6XCJJbnB1dFwiLCBvcHRpb25zOnsgYnJlYWtMaW5lOnRydWUgfSB9LCB7IHRleHQ6XCJPdXRwdXRcIiB9XWAgPT0gMiBsaW5lc1xuICAgICAqL1xuICAgIGxldCBuZXdMaW5lID0gW107XG4gICAgaW5wdXRDZWxscy5mb3JFYWNoKGNlbGwgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vICh0aGlzIGlzIGFsd2F5cyB0cnVlLCB3ZSBqdXN0IGNvbnN0cnVjdGVkIHRoZW0gYWJvdmUsIGJ1dCB3ZSBuZWVkIHRvIHRlbGwgdHlwZXNjcmlwdCBiL2MgdHlwZSBpcyBzdGlsbCBzdHJpbmd8fENlbGxbXSlcbiAgICAgICAgaWYgKHR5cGVvZiBjZWxsLnRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoY2VsbC50ZXh0LnNwbGl0KCdcXG4nKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgY2VsbC50ZXh0LnNwbGl0KCdcXG4nKS5mb3JFYWNoKHRleHRMaW5lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbmV3TGluZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90eXBlOiBTTElERV9PQkpFQ1RfVFlQRVMudGFibGVjZWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dExpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNlbGwub3B0aW9ucyksIHsgYnJlYWtMaW5lOiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0xpbmUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIF90eXBlOiBTTElERV9PQkpFQ1RfVFlQRVMudGFibGVjZWxsLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjZWxsLnRleHQudHJpbSgpLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBjZWxsLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKF9hID0gY2VsbC5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYnJlYWtMaW5lKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRMaW5lczEucHVzaChuZXdMaW5lKTtcbiAgICAgICAgICAgICAgICBuZXdMaW5lID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmx1c2ggYnVmZmVyXG4gICAgICAgIGlmIChuZXdMaW5lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlucHV0TGluZXMxLnB1c2gobmV3TGluZSk7XG4gICAgICAgICAgICBuZXdMaW5lID0gW107XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBTVEVQIDM6IFRva2VuaXplIGV2ZXJ5IHRleHQgb2JqZWN0IGludG8gd29yZHMgKHRoZW4gaXQncyByZWFsbHkgZWFzeSB0byBhc3NlbWJsZSBsaW5lcyBiZWxvdyB3aXRob3V0IGhhdmluZyB0byBicmVhayB0ZXh0LCBhZGQgaXRzIGBvcHRpb25zYCwgZXRjLilcbiAgICBpbnB1dExpbmVzMS5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICBsaW5lLmZvckVhY2goY2VsbCA9PiB7XG4gICAgICAgICAgICBjb25zdCBsaW5lQ2VsbHMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGNlbGxUZXh0U3RyID0gU3RyaW5nKGNlbGwudGV4dCk7IC8vIGZvcmNlIGNvbnZlcnQgdG8gc3RyaW5nIChjb21waWxlZCBKUyBpcyBiZXR0ZXIgd2l0aCB0aGlzIHRoYW4gYSBjYXN0KVxuICAgICAgICAgICAgY29uc3QgbGluZVdvcmRzID0gY2VsbFRleHRTdHIuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGxpbmVXb3Jkcy5mb3JFYWNoKCh3b3JkLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBjZWxsLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIC8vIElNUE9SVEFOVDogSGFuZGxlIGBicmVha0xpbmVgIHByb3AgLSB3ZSBjYW5ub3QgYXBwbHkgdG8gZWFjaCB3b3JkIC0gb25seSBhcHBseSB0byB2ZXJ5IGxhc3Qgd29yZCFcbiAgICAgICAgICAgICAgICBpZiAoY2VsbFByb3BzID09PSBudWxsIHx8IGNlbGxQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2VsbFByb3BzLmJyZWFrTGluZSlcbiAgICAgICAgICAgICAgICAgICAgY2VsbFByb3BzLmJyZWFrTGluZSA9IGlkeCArIDEgPT09IGxpbmVXb3Jkcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGluZUNlbGxzLnB1c2goeyBfdHlwZTogU0xJREVfT0JKRUNUX1RZUEVTLnRhYmxlY2VsbCwgdGV4dDogd29yZCArIChpZHggKyAxIDwgbGluZVdvcmRzLmxlbmd0aCA/ICcgJyA6ICcnKSwgb3B0aW9uczogY2VsbFByb3BzIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbnB1dExpbmVzMi5wdXNoKGxpbmVDZWxscyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIFNURVAgNDogR3JvdXAgY2VsbHMvd29yZHMgaW50byBsaW5lcyBiYXNlZCB1cG9uIHNwYWNlIGNvbnN1bWVkIGJ5IHdvcmQgbGV0dGVyc1xuICAgIGlucHV0TGluZXMyLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgIGxldCBsaW5lQ2VsbHMgPSBbXTtcbiAgICAgICAgbGV0IHN0ckN1cnJMaW5lID0gJyc7XG4gICAgICAgIGxpbmUuZm9yRWFjaCh3b3JkID0+IHtcbiAgICAgICAgICAgIC8vIEE6IGNyZWF0ZSBuZXcgbGluZSB3aGVuIGhvcml6b250YWwgc3BhY2UgaXMgZXhoYXVzdGVkXG4gICAgICAgICAgICBpZiAoc3RyQ3VyckxpbmUubGVuZ3RoICsgd29yZC50ZXh0Lmxlbmd0aCA+IENQTCkge1xuICAgICAgICAgICAgICAgIC8vIGlmICh2ZXJib3NlKSBjb25zb2xlLmxvZyhgU1RFUCA0OiBOZXcgbGluZSBhZGRlZDogKCR7c3RyQ3VyckxpbmUubGVuZ3RofSArICR7d29yZC50ZXh0Lmxlbmd0aH0gPiAke0NQTH0pYCk7XG4gICAgICAgICAgICAgICAgcGFyc2VkTGluZXMucHVzaChsaW5lQ2VsbHMpO1xuICAgICAgICAgICAgICAgIGxpbmVDZWxscyA9IFtdO1xuICAgICAgICAgICAgICAgIHN0ckN1cnJMaW5lID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCOiBhZGQgY3VycmVudCB3b3JkIHRvIGxpbmUgY2VsbHNcbiAgICAgICAgICAgIGxpbmVDZWxscy5wdXNoKHdvcmQpO1xuICAgICAgICAgICAgLy8gQzogYWRkIGN1cnJlbnQgd29yZCB0byBgc3RyQ3VyckxpbmVgIHdoaWNoIHdlIHVzZSB0byBrZWVwIHRyYWNrIG9mIGxpbmUncyBjaGFyIGxlbmd0aFxuICAgICAgICAgICAgc3RyQ3VyckxpbmUgKz0gd29yZC50ZXh0LnRvU3RyaW5nKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBGbHVzaCBidWZmZXI6IE9ubHkgY3JlYXRlIGEgbGluZSB3aGVuIHRoZXJlJ3MgdGV4dCB0byBhdm9pZCBlbXB0eSByb3dcbiAgICAgICAgaWYgKGxpbmVDZWxscy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgcGFyc2VkTGluZXMucHVzaChsaW5lQ2VsbHMpO1xuICAgIH0pO1xuICAgIC8vIERvbmU6XG4gICAgcmV0dXJuIHBhcnNlZExpbmVzO1xufVxuLyoqXG4gKiBUYWtlcyBhbiBhcnJheSBvZiB0YWJsZSByb3dzIGFuZCBicmVha3MgaW50byBhbiBhcnJheSBvZiBzbGlkZXMsIHdoaWNoIGNvbnRhaW4gdGhlIGNhbGN1bGF0ZWQgYW1vdW50IG9mIHRhYmxlIHJvd3MgdGhhdCBmaXQgb24gdGhhdCBzbGlkZVxuICogQHBhcmFtIHtUYWJsZUNlbGxbXVtdfSB0YWJsZVJvd3MgLSB0YWJsZSByb3dzXG4gKiBAcGFyYW0ge1RhYmxlVG9TbGlkZXNQcm9wc30gdGFibGVQcm9wcyAtIHRhYmxlMnNsaWRlcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge1ByZXNMYXlvdXR9IHByZXNMYXlvdXQgLSBwcmVzZW50YXRpb24gbGF5b3V0XG4gKiBAcGFyYW0ge1NsaWRlTGF5b3V0fSBtYXN0ZXJTbGlkZSAtIG1hc3RlciBzbGlkZVxuICogQHJldHVybiB7VGFibGVSb3dTbGlkZVtdfSBhcnJheSBvZiB0YWJsZSByb3dzXG4gKi9cbmZ1bmN0aW9uIGdldFNsaWRlc0ZvclRhYmxlUm93cyh0YWJsZVJvd3MgPSBbXSwgdGFibGVQcm9wcyA9IHt9LCBwcmVzTGF5b3V0LCBtYXN0ZXJTbGlkZSkge1xuICAgIGxldCBhcnJJbmNoTWFyZ2lucyA9IERFRl9TTElERV9NQVJHSU5fSU47XG4gICAgbGV0IGVtdVNsaWRlVGFiVyA9IEVNVSAqIDE7XG4gICAgbGV0IGVtdVNsaWRlVGFiSCA9IEVNVSAqIDE7XG4gICAgbGV0IGVtdVRhYkN1cnJIID0gMDtcbiAgICBsZXQgbnVtQ29scyA9IDA7XG4gICAgY29uc3QgdGFibGVSb3dTbGlkZXMgPSBbXTtcbiAgICBjb25zdCB0YWJsZVByb3BYID0gZ2V0U21hcnRQYXJzZU51bWJlcih0YWJsZVByb3BzLngsICdYJywgcHJlc0xheW91dCk7XG4gICAgY29uc3QgdGFibGVQcm9wWSA9IGdldFNtYXJ0UGFyc2VOdW1iZXIodGFibGVQcm9wcy55LCAnWScsIHByZXNMYXlvdXQpO1xuICAgIGNvbnN0IHRhYmxlUHJvcFcgPSBnZXRTbWFydFBhcnNlTnVtYmVyKHRhYmxlUHJvcHMudywgJ1gnLCBwcmVzTGF5b3V0KTtcbiAgICBjb25zdCB0YWJsZVByb3BIID0gZ2V0U21hcnRQYXJzZU51bWJlcih0YWJsZVByb3BzLmgsICdZJywgcHJlc0xheW91dCk7XG4gICAgbGV0IHRhYmxlQ2FsY1cgPSB0YWJsZVByb3BXO1xuICAgIGZ1bmN0aW9uIGNhbGNTbGlkZVRhYkgoKSB7XG4gICAgICAgIGxldCBlbXVTdGFydFkgPSAwO1xuICAgICAgICBpZiAodGFibGVSb3dTbGlkZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgZW11U3RhcnRZID0gdGFibGVQcm9wWSB8fCBpbmNoMkVtdShhcnJJbmNoTWFyZ2luc1swXSk7XG4gICAgICAgIGlmICh0YWJsZVJvd1NsaWRlcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgZW11U3RhcnRZID0gaW5jaDJFbXUodGFibGVQcm9wcy5hdXRvUGFnZVNsaWRlU3RhcnRZIHx8IHRhYmxlUHJvcHMubmV3U2xpZGVTdGFydFkgfHwgYXJySW5jaE1hcmdpbnNbMF0pO1xuICAgICAgICBlbXVTbGlkZVRhYkggPSAodGFibGVQcm9wSCB8fCBwcmVzTGF5b3V0LmhlaWdodCkgLSBlbXVTdGFydFkgLSBpbmNoMkVtdShhcnJJbmNoTWFyZ2luc1syXSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGB8IHN0YXJ0WSAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gPSAkeyhlbXVTdGFydFkgLyBFTVUpLnRvRml4ZWQoMSl9YClcbiAgICAgICAgLy8gY29uc29sZS5sb2coYHwgZW11U2xpZGVUYWJIIC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiA9ICR7KGVtdVNsaWRlVGFiSCAvIEVNVSkudG9GaXhlZCgxKX1gKVxuICAgICAgICBpZiAodGFibGVSb3dTbGlkZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgLy8gRDogUlVMRTogVXNlIG1hcmdpbnMgZm9yIHN0YXJ0aW5nIHBvaW50IGFmdGVyIHRoZSBpbml0aWFsIFNsaWRlLCBub3QgYG9wdC55YCAoSVNTVUUgIzQzLCBJU1NVRSAjNDcsIElTU1VFICM0OClcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFibGVQcm9wcy5hdXRvUGFnZVNsaWRlU3RhcnRZID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGVtdVNsaWRlVGFiSCA9ICh0YWJsZVByb3BIIHx8IHByZXNMYXlvdXQuaGVpZ2h0KSAtIGluY2gyRW11KHRhYmxlUHJvcHMuYXV0b1BhZ2VTbGlkZVN0YXJ0WSArIGFyckluY2hNYXJnaW5zWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0YWJsZVByb3BzLm5ld1NsaWRlU3RhcnRZID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIEBkZXByZWNhdGVkIHYzLjMuMFxuICAgICAgICAgICAgICAgIGVtdVNsaWRlVGFiSCA9ICh0YWJsZVByb3BIIHx8IHByZXNMYXlvdXQuaGVpZ2h0KSAtIGluY2gyRW11KHRhYmxlUHJvcHMubmV3U2xpZGVTdGFydFkgKyBhcnJJbmNoTWFyZ2luc1syXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0YWJsZVByb3BZKSB7XG4gICAgICAgICAgICAgICAgZW11U2xpZGVUYWJIID0gKHRhYmxlUHJvcEggfHwgcHJlc0xheW91dC5oZWlnaHQpIC0gaW5jaDJFbXUoKHRhYmxlUHJvcFkgLyBFTVUgPCBhcnJJbmNoTWFyZ2luc1swXSA/IHRhYmxlUHJvcFkgLyBFTVUgOiBhcnJJbmNoTWFyZ2luc1swXSkgKyBhcnJJbmNoTWFyZ2luc1syXSk7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHdoaWNoZXZlciBpcyBncmVhdGVyOiBhcmVhIGJldHdlZW4gbWFyZ2lucyBvciB0aGUgdGFibGUgSCBwcm92aWRlZCAoZG9udCBzaHJpbmsgdXNhYmxlIGFyZWEgLSB0aGUgd2hvbGUgcG9pbnQgb2Ygb3Zlci1yaWRpbmcgWSBvbiBwYWdpbmcgaXMgdG8gKmluY3JlYXNlKiB1c2FibGUgc3BhY2UpXG4gICAgICAgICAgICAgICAgaWYgKGVtdVNsaWRlVGFiSCA8IHRhYmxlUHJvcEgpXG4gICAgICAgICAgICAgICAgICAgIGVtdVNsaWRlVGFiSCA9IHRhYmxlUHJvcEg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhYmxlUHJvcHMudmVyYm9zZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnW1tWRVJCT1NFIE1PREVdXScpO1xuICAgICAgICBjb25zb2xlLmxvZygnfC0tIFRBQkxFIFBST1BTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfCcpO1xuICAgICAgICBjb25zb2xlLmxvZyhgfCBwcmVzTGF5b3V0LndpZHRoIC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uID0gJHsocHJlc0xheW91dC53aWR0aCAvIEVNVSkudG9GaXhlZCgxKX1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYHwgcHJlc0xheW91dC5oZWlnaHQgLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiA9ICR7KHByZXNMYXlvdXQuaGVpZ2h0IC8gRU1VKS50b0ZpeGVkKDEpfWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgfCB0YWJsZVByb3BzLnggLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uID0gJHt0eXBlb2YgdGFibGVQcm9wcy54ID09PSAnbnVtYmVyJyA/ICh0YWJsZVByb3BzLnggLyBFTVUpLnRvRml4ZWQoMSkgOiB0YWJsZVByb3BzLnh9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGB8IHRhYmxlUHJvcHMueSAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gPSAke3R5cGVvZiB0YWJsZVByb3BzLnkgPT09ICdudW1iZXInID8gKHRhYmxlUHJvcHMueSAvIEVNVSkudG9GaXhlZCgxKSA6IHRhYmxlUHJvcHMueX1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYHwgdGFibGVQcm9wcy53IC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiA9ICR7dHlwZW9mIHRhYmxlUHJvcHMudyA9PT0gJ251bWJlcicgPyAodGFibGVQcm9wcy53IC8gRU1VKS50b0ZpeGVkKDEpIDogdGFibGVQcm9wcy53fWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgfCB0YWJsZVByb3BzLmggLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uID0gJHt0eXBlb2YgdGFibGVQcm9wcy5oID09PSAnbnVtYmVyJyA/ICh0YWJsZVByb3BzLmggLyBFTVUpLnRvRml4ZWQoMSkgOiB0YWJsZVByb3BzLmh9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGB8IHRhYmxlUHJvcHMuc2xpZGVNYXJnaW4gLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gPSAke3RhYmxlUHJvcHMuc2xpZGVNYXJnaW4gPyBTdHJpbmcodGFibGVQcm9wcy5zbGlkZU1hcmdpbikgOiAnJ31gKTtcbiAgICAgICAgY29uc29sZS5sb2coYHwgdGFibGVQcm9wcy5tYXJnaW4gLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiA9ICR7U3RyaW5nKHRhYmxlUHJvcHMubWFyZ2luKX1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYHwgdGFibGVQcm9wcy5jb2xXIC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiA9ICR7U3RyaW5nKHRhYmxlUHJvcHMuY29sVyl9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGB8IHRhYmxlUHJvcHMuYXV0b1BhZ2VTbGlkZVN0YXJ0WSAuLi4uLi4uLi4uLi4uLi4uLi4gPSAke3RhYmxlUHJvcHMuYXV0b1BhZ2VTbGlkZVN0YXJ0WX1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYHwgdGFibGVQcm9wcy5hdXRvUGFnZUNoYXJXZWlnaHQgLi4uLi4uLi4uLi4uLi4uLi4uLiA9ICR7dGFibGVQcm9wcy5hdXRvUGFnZUNoYXJXZWlnaHR9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCd8LS0gQ0FMQ1VMQVRJT05TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18Jyk7XG4gICAgICAgIGNvbnNvbGUubG9nKGB8IHRhYmxlUHJvcFggLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gPSAke3RhYmxlUHJvcFggLyBFTVV9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGB8IHRhYmxlUHJvcFkgLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gPSAke3RhYmxlUHJvcFkgLyBFTVV9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGB8IHRhYmxlUHJvcFcgLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gPSAke3RhYmxlUHJvcFcgLyBFTVV9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGB8IHRhYmxlUHJvcEggLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gPSAke3RhYmxlUHJvcEggLyBFTVV9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGB8IHRhYmxlQ2FsY1cgLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gPSAke3RhYmxlQ2FsY1cgLyBFTVV9YCk7XG4gICAgfVxuICAgIC8vIFNURVAgMTogQ2FsY3VsYXRlIG1hcmdpbnNcbiAgICB7XG4gICAgICAgIC8vIEltcG9ydGFudDogVXNlIGRlZmF1bHQgc2l6ZSBhcyB6ZXJvIGNlbGwgbWFyZ2luIGlzIGNhdXNpbmcgb3VyIHRhYmxlcyB0byBiZSB0b28gbGFyZ2UgYW5kIHRvdWNoIGJvdHRvbSBvZiBzbGlkZSFcbiAgICAgICAgaWYgKCF0YWJsZVByb3BzLnNsaWRlTWFyZ2luICYmIHRhYmxlUHJvcHMuc2xpZGVNYXJnaW4gIT09IDApXG4gICAgICAgICAgICB0YWJsZVByb3BzLnNsaWRlTWFyZ2luID0gREVGX1NMSURFX01BUkdJTl9JTlswXTtcbiAgICAgICAgaWYgKG1hc3RlclNsaWRlICYmIHR5cGVvZiBtYXN0ZXJTbGlkZS5fbWFyZ2luICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWFzdGVyU2xpZGUuX21hcmdpbikpXG4gICAgICAgICAgICAgICAgYXJySW5jaE1hcmdpbnMgPSBtYXN0ZXJTbGlkZS5fbWFyZ2luO1xuICAgICAgICAgICAgZWxzZSBpZiAoIWlzTmFOKE51bWJlcihtYXN0ZXJTbGlkZS5fbWFyZ2luKSkpIHtcbiAgICAgICAgICAgICAgICBhcnJJbmNoTWFyZ2lucyA9IFtOdW1iZXIobWFzdGVyU2xpZGUuX21hcmdpbiksIE51bWJlcihtYXN0ZXJTbGlkZS5fbWFyZ2luKSwgTnVtYmVyKG1hc3RlclNsaWRlLl9tYXJnaW4pLCBOdW1iZXIobWFzdGVyU2xpZGUuX21hcmdpbildO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRhYmxlUHJvcHMuc2xpZGVNYXJnaW4gfHwgdGFibGVQcm9wcy5zbGlkZU1hcmdpbiA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFibGVQcm9wcy5zbGlkZU1hcmdpbikpXG4gICAgICAgICAgICAgICAgYXJySW5jaE1hcmdpbnMgPSB0YWJsZVByb3BzLnNsaWRlTWFyZ2luO1xuICAgICAgICAgICAgZWxzZSBpZiAoIWlzTmFOKHRhYmxlUHJvcHMuc2xpZGVNYXJnaW4pKVxuICAgICAgICAgICAgICAgIGFyckluY2hNYXJnaW5zID0gW3RhYmxlUHJvcHMuc2xpZGVNYXJnaW4sIHRhYmxlUHJvcHMuc2xpZGVNYXJnaW4sIHRhYmxlUHJvcHMuc2xpZGVNYXJnaW4sIHRhYmxlUHJvcHMuc2xpZGVNYXJnaW5dO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWJsZVByb3BzLnZlcmJvc2UpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgfCBhcnJJbmNoTWFyZ2lucyAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uID0gWyR7YXJySW5jaE1hcmdpbnMuam9pbignLCAnKX1dYCk7XG4gICAgfVxuICAgIC8vIFNURVAgMjogQ2FsY3VsYXRlIG51bWJlciBvZiBjb2x1bW5zXG4gICAge1xuICAgICAgICAvLyBOT1RFOiBDZWxscyBtYXkgaGF2ZSBhIGNvbHNwYW4sIHNvIG1lcmVseSB0YWtpbmcgdGhlIGxlbmd0aCBvZiB0aGUgWzBdIChvciBhbnkgb3RoZXIpIHJvdyBpcyBub3RcbiAgICAgICAgLy8gLi4uLjogc3VmZmljaWVudCB0byBkZXRlcm1pbmUgY29sdW1uIGNvdW50LiBUaGVyZWZvcmUsIGNoZWNrIGVhY2ggY2VsbCBmb3IgYSBjb2xzcGFuIGFuZCB0b3RhbCBjb2xzIGFzIHJlcWRcbiAgICAgICAgY29uc3QgZmlyc3RSb3cgPSB0YWJsZVJvd3NbMF0gfHwgW107XG4gICAgICAgIGZpcnN0Um93LmZvckVhY2goY2VsbCA9PiB7XG4gICAgICAgICAgICBpZiAoIWNlbGwpXG4gICAgICAgICAgICAgICAgY2VsbCA9IHsgX3R5cGU6IFNMSURFX09CSkVDVF9UWVBFUy50YWJsZWNlbGwgfTtcbiAgICAgICAgICAgIGNvbnN0IGNlbGxPcHRzID0gY2VsbC5vcHRpb25zIHx8IG51bGw7XG4gICAgICAgICAgICBudW1Db2xzICs9IE51bWJlcigoY2VsbE9wdHMgPT09IG51bGwgfHwgY2VsbE9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNlbGxPcHRzLmNvbHNwYW4pID8gY2VsbE9wdHMuY29sc3BhbiA6IDEpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRhYmxlUHJvcHMudmVyYm9zZSlcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGB8IG51bUNvbHMgLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gPSAke251bUNvbHN9YCk7XG4gICAgfVxuICAgIC8vIFNURVAgMzogQ2FsY3VsYXRlIHdpZHRoIHVzaW5nIHRhYmxlUHJvcHMuY29sVyBpZiBwb3NzaWJsZVxuICAgIGlmICghdGFibGVQcm9wVyAmJiB0YWJsZVByb3BzLmNvbFcpIHtcbiAgICAgICAgdGFibGVDYWxjVyA9IEFycmF5LmlzQXJyYXkodGFibGVQcm9wcy5jb2xXKSA/IHRhYmxlUHJvcHMuY29sVy5yZWR1Y2UoKHAsIG4pID0+IHAgKyBuKSAqIEVNVSA6IHRhYmxlUHJvcHMuY29sVyAqIG51bUNvbHMgfHwgMDtcbiAgICAgICAgaWYgKHRhYmxlUHJvcHMudmVyYm9zZSlcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGB8IHRhYmxlQ2FsY1cgLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gPSAke3RhYmxlQ2FsY1cgLyBFTVV9YCk7XG4gICAgfVxuICAgIC8vIFNURVAgNDogQ2FsY3VsYXRlIHVzYWJsZSB3aWR0aCBub3cgdGhhdCB0b3RhbCB1c2FibGUgc3BhY2UgaXMga25vd24gKGBlbXVTbGlkZVRhYldgKVxuICAgIHtcbiAgICAgICAgZW11U2xpZGVUYWJXID0gdGFibGVDYWxjVyB8fCBpbmNoMkVtdSgodGFibGVQcm9wWCA/IHRhYmxlUHJvcFggLyBFTVUgOiBhcnJJbmNoTWFyZ2luc1sxXSkgKyBhcnJJbmNoTWFyZ2luc1szXSk7XG4gICAgICAgIGlmICh0YWJsZVByb3BzLnZlcmJvc2UpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgfCBlbXVTbGlkZVRhYlcgLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uID0gJHsoZW11U2xpZGVUYWJXIC8gRU1VKS50b0ZpeGVkKDEpfWApO1xuICAgIH1cbiAgICAvLyBTVEVQIDU6IENhbGN1bGF0ZSBjb2x1bW4gd2lkdGhzIGlmIG5vdCBwcm92aWRlZCAoZW11U2xpZGVUYWJXIHdpbGwgYmUgdXNlZCBiZWxvdyB0byBkZXRlcm1pbmUgbGluZXMtcGVyLWNvbClcbiAgICBpZiAoIXRhYmxlUHJvcHMuY29sVyB8fCAhQXJyYXkuaXNBcnJheSh0YWJsZVByb3BzLmNvbFcpKSB7XG4gICAgICAgIGlmICh0YWJsZVByb3BzLmNvbFcgJiYgIWlzTmFOKE51bWJlcih0YWJsZVByb3BzLmNvbFcpKSkge1xuICAgICAgICAgICAgY29uc3QgYXJyQ29sVyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgZmlyc3RSb3cgPSB0YWJsZVJvd3NbMF0gfHwgW107XG4gICAgICAgICAgICBmaXJzdFJvdy5mb3JFYWNoKCgpID0+IGFyckNvbFcucHVzaCh0YWJsZVByb3BzLmNvbFcpKTtcbiAgICAgICAgICAgIHRhYmxlUHJvcHMuY29sVyA9IFtdO1xuICAgICAgICAgICAgYXJyQ29sVy5mb3JFYWNoKHZhbCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFibGVQcm9wcy5jb2xXKSlcbiAgICAgICAgICAgICAgICAgICAgdGFibGVQcm9wcy5jb2xXLnB1c2godmFsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gY29sdW1uIHdpZHRocyBwcm92aWRlZD8gVGhlbiBkaXN0cmlidXRlIGNvbHMuXG4gICAgICAgICAgICB0YWJsZVByb3BzLmNvbFcgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGlDb2wgPSAwOyBpQ29sIDwgbnVtQ29sczsgaUNvbCsrKSB7XG4gICAgICAgICAgICAgICAgdGFibGVQcm9wcy5jb2xXLnB1c2goZW11U2xpZGVUYWJXIC8gRU1VIC8gbnVtQ29scyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU1RFUCA2OiAqKk1BSU4qKiBJdGVyYXRlIG92ZXIgcm93cywgYWRkIHRhYmxlIGNvbnRlbnQsIGNyZWF0ZSBuZXcgc2xpZGVzIGFzIHJvd3Mgb3ZlcmZsb3dcbiAgICBsZXQgbmV3VGFibGVSb3dTbGlkZSA9IHsgcm93czogW10gfTtcbiAgICB0YWJsZVJvd3MuZm9yRWFjaCgocm93LCBpUm93KSA9PiB7XG4gICAgICAgIC8vIEE6IFJvdyB2YXJpYWJsZXNcbiAgICAgICAgY29uc3Qgcm93Q2VsbExpbmVzID0gW107XG4gICAgICAgIGxldCBtYXhDZWxsTWFyVG9wRW11ID0gMDtcbiAgICAgICAgbGV0IG1heENlbGxNYXJCdG1FbXUgPSAwO1xuICAgICAgICAvLyBCOiBDcmVhdGUgbmV3IHJvdyBpbiBkYXRhIG1vZGVsLCBjYWxjIGBtYXhDZWxsTWFyKmBcbiAgICAgICAgbGV0IGN1cnJUYWJsZVJvdyA9IFtdO1xuICAgICAgICByb3cuZm9yRWFjaChjZWxsID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgIGN1cnJUYWJsZVJvdy5wdXNoKHtcbiAgICAgICAgICAgICAgICBfdHlwZTogU0xJREVfT0JKRUNUX1RZUEVTLnRhYmxlY2VsbCxcbiAgICAgICAgICAgICAgICB0ZXh0OiBbXSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBjZWxsLm9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8qKiBGVVRVUkU6IERFUFJFQ0FURUQ6XG4gICAgICAgICAgICAgKiAtIEJhY2t3YXJkcy1Db21wYXQ6IE9vcHMhIERpc2NvdmVyZWQgd2Ugd2VyZSBzdGlsbCB1c2luZyBwb2ludHMgZm9yIGNlbGwgbWFyZ2luIGJlZm9yZSB2My44LjAgKFVHSCEpXG4gICAgICAgICAgICAgKiAtIFdlIGNhbnQgaW50cm9kdWNlIGEgYnJlYWtpbmcgY2hhbmdlIGJlZm9yZSB2NC4wLCBzby4uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoY2VsbC5vcHRpb25zLm1hcmdpbiAmJiBjZWxsLm9wdGlvbnMubWFyZ2luWzBdID49IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IGNlbGwub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcmdpbikgJiYgY2VsbC5vcHRpb25zLm1hcmdpblswXSAmJiB2YWxUb1B0cyhjZWxsLm9wdGlvbnMubWFyZ2luWzBdKSA+IG1heENlbGxNYXJUb3BFbXUpXG4gICAgICAgICAgICAgICAgICAgIG1heENlbGxNYXJUb3BFbXUgPSB2YWxUb1B0cyhjZWxsLm9wdGlvbnMubWFyZ2luWzBdKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgodGFibGVQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZVByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWJsZVByb3BzLm1hcmdpbikgJiYgdGFibGVQcm9wcy5tYXJnaW5bMF0gJiYgdmFsVG9QdHModGFibGVQcm9wcy5tYXJnaW5bMF0pID4gbWF4Q2VsbE1hclRvcEVtdSlcbiAgICAgICAgICAgICAgICAgICAgbWF4Q2VsbE1hclRvcEVtdSA9IHZhbFRvUHRzKHRhYmxlUHJvcHMubWFyZ2luWzBdKTtcbiAgICAgICAgICAgICAgICBpZiAoKChfYiA9IGNlbGwub3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1hcmdpbikgJiYgY2VsbC5vcHRpb25zLm1hcmdpblsyXSAmJiB2YWxUb1B0cyhjZWxsLm9wdGlvbnMubWFyZ2luWzJdKSA+IG1heENlbGxNYXJCdG1FbXUpXG4gICAgICAgICAgICAgICAgICAgIG1heENlbGxNYXJCdG1FbXUgPSB2YWxUb1B0cyhjZWxsLm9wdGlvbnMubWFyZ2luWzJdKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgodGFibGVQcm9wcyA9PT0gbnVsbCB8fCB0YWJsZVByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWJsZVByb3BzLm1hcmdpbikgJiYgdGFibGVQcm9wcy5tYXJnaW5bMl0gJiYgdmFsVG9QdHModGFibGVQcm9wcy5tYXJnaW5bMl0pID4gbWF4Q2VsbE1hckJ0bUVtdSlcbiAgICAgICAgICAgICAgICAgICAgbWF4Q2VsbE1hckJ0bUVtdSA9IHZhbFRvUHRzKHRhYmxlUHJvcHMubWFyZ2luWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgoKF9jID0gY2VsbC5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubWFyZ2luKSAmJiBjZWxsLm9wdGlvbnMubWFyZ2luWzBdICYmIGluY2gyRW11KGNlbGwub3B0aW9ucy5tYXJnaW5bMF0pID4gbWF4Q2VsbE1hclRvcEVtdSlcbiAgICAgICAgICAgICAgICAgICAgbWF4Q2VsbE1hclRvcEVtdSA9IGluY2gyRW11KGNlbGwub3B0aW9ucy5tYXJnaW5bMF0pO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCh0YWJsZVByb3BzID09PSBudWxsIHx8IHRhYmxlUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlUHJvcHMubWFyZ2luKSAmJiB0YWJsZVByb3BzLm1hcmdpblswXSAmJiBpbmNoMkVtdSh0YWJsZVByb3BzLm1hcmdpblswXSkgPiBtYXhDZWxsTWFyVG9wRW11KVxuICAgICAgICAgICAgICAgICAgICBtYXhDZWxsTWFyVG9wRW11ID0gaW5jaDJFbXUodGFibGVQcm9wcy5tYXJnaW5bMF0pO1xuICAgICAgICAgICAgICAgIGlmICgoKF9kID0gY2VsbC5vcHRpb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubWFyZ2luKSAmJiBjZWxsLm9wdGlvbnMubWFyZ2luWzJdICYmIGluY2gyRW11KGNlbGwub3B0aW9ucy5tYXJnaW5bMl0pID4gbWF4Q2VsbE1hckJ0bUVtdSlcbiAgICAgICAgICAgICAgICAgICAgbWF4Q2VsbE1hckJ0bUVtdSA9IGluY2gyRW11KGNlbGwub3B0aW9ucy5tYXJnaW5bMl0pO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCh0YWJsZVByb3BzID09PSBudWxsIHx8IHRhYmxlUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYmxlUHJvcHMubWFyZ2luKSAmJiB0YWJsZVByb3BzLm1hcmdpblsyXSAmJiBpbmNoMkVtdSh0YWJsZVByb3BzLm1hcmdpblsyXSkgPiBtYXhDZWxsTWFyQnRtRW11KVxuICAgICAgICAgICAgICAgICAgICBtYXhDZWxsTWFyQnRtRW11ID0gaW5jaDJFbXUodGFibGVQcm9wcy5tYXJnaW5bMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQzogQ2FsYyB1c2FibGUgdmVydGljYWwgc3BhY2UvdGFibGUgaGVpZ2h0LiBTZXQgZGVmYXVsdCB2YWx1ZSBmaXJzdCwgYWRqdXN0IGJlbG93IHdoZW4gbmVjZXNzYXJ5LlxuICAgICAgICBjYWxjU2xpZGVUYWJIKCk7XG4gICAgICAgIGVtdVRhYkN1cnJIICs9IG1heENlbGxNYXJUb3BFbXUgKyBtYXhDZWxsTWFyQnRtRW11OyAvLyBTdGFydCByb3cgaGVpZ2h0IHdpdGggbWFyZ2luc1xuICAgICAgICBpZiAodGFibGVQcm9wcy52ZXJib3NlICYmIGlSb3cgPT09IDApXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgfCBTTElERSBbJHt0YWJsZVJvd1NsaWRlcy5sZW5ndGh9XTogZW11U2xpZGVUYWJIIC4uLi4uLiA9ICR7KGVtdVNsaWRlVGFiSCAvIEVNVSkudG9GaXhlZCgxKX0gYCk7XG4gICAgICAgIC8vIEQ6IC0tPT1bWyBCVUlMRCBEQVRBIFNFVCBdXT09LS0gKGl0ZXJhdGUgb3ZlciBjZWxsczogc3BsaXQgdGV4dCBpbnRvIGxpbmVzW10sIHNldCBgbGluZUhlaWdodGApXG4gICAgICAgIHJvdy5mb3JFYWNoKChjZWxsLCBpQ2VsbCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2VsbCA9IHtcbiAgICAgICAgICAgICAgICBfdHlwZTogU0xJREVfT0JKRUNUX1RZUEVTLnRhYmxlY2VsbCxcbiAgICAgICAgICAgICAgICBfbGluZXM6IG51bGwsXG4gICAgICAgICAgICAgICAgX2xpbmVIZWlnaHQ6IGluY2gyRW11KCgoKChfYSA9IGNlbGwub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvbnRTaXplKSA/IGNlbGwub3B0aW9ucy5mb250U2l6ZSA6IHRhYmxlUHJvcHMuZm9udFNpemUgPyB0YWJsZVByb3BzLmZvbnRTaXplIDogREVGX0ZPTlRfU0laRSkgKlxuICAgICAgICAgICAgICAgICAgICAoTElORUhfTU9ESUZJRVIgKyAodGFibGVQcm9wcy5hdXRvUGFnZUxpbmVXZWlnaHQgPyB0YWJsZVByb3BzLmF1dG9QYWdlTGluZVdlaWdodCA6IDApKSkgL1xuICAgICAgICAgICAgICAgICAgICAxMDApLFxuICAgICAgICAgICAgICAgIHRleHQ6IFtdLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGNlbGwub3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBFLTE6IEV4ZW1wdCBjZWxscyB3aXRoIGByb3dzcGFuYCBmcm9tIGluY3JlYXNpbmcgbGluZUhlaWdodCAob3Igd2UgY291bGQgY3JlYXRlIGEgbmV3IHNsaWRlIHdoZW4gdW5lY2Vzc2FyeSEpXG4gICAgICAgICAgICBpZiAobmV3Q2VsbC5vcHRpb25zLnJvd3NwYW4pXG4gICAgICAgICAgICAgICAgbmV3Q2VsbC5fbGluZUhlaWdodCA9IDA7XG4gICAgICAgICAgICAvLyBFLTI6IFRoZSBwYXJzZVRleHRUb0xpbmVzIG1ldGhvZCB1c2VzIGBhdXRvUGFnZUNoYXJXZWlnaHRgLCBzbyBpbmhlcml0IGZyb20gdGFibGUgb3B0aW9uc1xuICAgICAgICAgICAgbmV3Q2VsbC5vcHRpb25zLmF1dG9QYWdlQ2hhcldlaWdodCA9IHRhYmxlUHJvcHMuYXV0b1BhZ2VDaGFyV2VpZ2h0ID8gdGFibGVQcm9wcy5hdXRvUGFnZUNoYXJXZWlnaHQgOiBudWxsO1xuICAgICAgICAgICAgLy8gRS0zOiAqKk1BSU4qKiBQYXJzZSBjZWxsIGNvbnRlbnRzIGludG8gbGluZXMgYmFzZWQgdXBvbiBjb2wgd2lkdGgsIGZvbnQsIGV0Y1xuICAgICAgICAgICAgbGV0IHRvdGFsQ29sVyA9IHRhYmxlUHJvcHMuY29sV1tpQ2VsbF07XG4gICAgICAgICAgICBpZiAoY2VsbC5vcHRpb25zLmNvbHNwYW4gJiYgQXJyYXkuaXNBcnJheSh0YWJsZVByb3BzLmNvbFcpKSB7XG4gICAgICAgICAgICAgICAgdG90YWxDb2xXID0gdGFibGVQcm9wcy5jb2xXLmZpbHRlcigoX2NlbGwsIGlkeCkgPT4gaWR4ID49IGlDZWxsICYmIGlkeCA8IGlkeCArIGNlbGwub3B0aW9ucy5jb2xzcGFuKS5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHByZXYgKyBjdXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEUtNDogQ3JlYXRlIGxpbmVzIGJhc2VkIHVwb24gYXZhaWxhYmxlIGNvbHVtbiB3aWR0aFxuICAgICAgICAgICAgbmV3Q2VsbC5fbGluZXMgPSBwYXJzZVRleHRUb0xpbmVzKGNlbGwsIHRvdGFsQ29sVyk7XG4gICAgICAgICAgICAvLyBFLTU6IEFkZCBjZWxsIHRvIGFycmF5XG4gICAgICAgICAgICByb3dDZWxsTGluZXMucHVzaChuZXdDZWxsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBFOiAtLT09W1sgUEFHRSBEQVRBIFNFVCBdXT09LS1cbiAgICAgICAgICogQWRkIHRleHQgb25lLWxpbmUtYS10aW1lIHRvIHRoaXMgcm93J3MgY2VsbHMgdW50aWw6IGxpbmVzIGFyZSBleGhhdXN0ZWQgT1IgdGFibGUgaGVpZ2h0IGxpbWl0IGlzIGhpdFxuICAgICAgICAgKlxuICAgICAgICAgKiBEZXNpZ246XG4gICAgICAgICAqIC0gQnVpbGRpbmcgY2VsbHMgTC10by1SL2xvb3Agc3R5bGUgd29udCB3b3JrIGFzIG9uZSBjb3VsZCBiZSAxMDAgbGluZXMgYW5kIGFub3RoZXIgMSBsaW5lXG4gICAgICAgICAqIC0gVGhlcmVmb3JlLCBidWlsZCB0aGUgd2hvbGUgcm93LCBvbmUtbGluZS1hdC1hLXRpbWUsIGFjcm9zcyBlYWNoIHRhYmxlIGNvbHVtbnNcbiAgICAgICAgICogLSBUaGVuLCB3aGVuIHRoZSB2ZXJ0aWNhbCBzaXplIGxpbWl0IGlzIGhpdCBpcyBieSBhbnkgb2YgdGhlIGNlbGxzLCBtYWtlIGEgbmV3IHNsaWRlIGFuZCBjb250aW51ZSBhZGRpbmcgYW55IHJlbWFpbmluZyBsaW5lc1xuICAgICAgICAgKlxuICAgICAgICAgKiBJbXBsZW1lbnRhdGlvbjpcbiAgICAgICAgICogLSBgcm93Q2VsbExpbmVzYCBpcyBhbiBhcnJheSBvZiBjZWxscywgb25lIGZvciBlYWNoIGNvbHVtbiBpbiB0aGUgdGFibGUsIHdpdGggZWFjaCBjZWxsIGNvbnRhaW5pbmcgYW4gYXJyYXkgb2YgbGluZXNcbiAgICAgICAgICpcbiAgICAgICAgICogU2FtcGxlIERhdGE6XG4gICAgICAgICAqIC0gYHJvd0NlbGxMaW5lc2AgLi46IFsgVGFibGVDZWxsLCBUYWJsZUNlbGwsIFRhYmxlQ2VsbCBdXG4gICAgICAgICAqIC0gYFRhYmxlQ2VsbGAgLi4uLi46IHsgX3R5cGU6ICd0YWJsZWNlbGwnLCBfbGluZXM6IFRhYmxlQ2VsbFtdLCBfbGluZUhlaWdodDogMTAgfVxuICAgICAgICAgKiAtIGBfbGluZXNgIC4uLi4uLi4uOiBbIHtfdHlwZTogJ3RhYmxlY2VsbCcsIHRleHQ6ICdjZWxsLTEsbGluZS0xJywgb3B0aW9uczoge+KApn19LCB7X3R5cGU6ICd0YWJsZWNlbGwnLCB0ZXh0OiAnY2VsbC0xLGxpbmUtMicsIG9wdGlvbnM6IHvigKZ9fSB9XG4gICAgICAgICAqIC0gYF9saW5lc2AgaXMgVGFibGVDZWxsW10gKHRoZSAxLU4gd29yZHMgaW4gdGhlIGxpbmUpXG4gICAgICAgICAqIHtcbiAgICAgICAgICogICAgX2xpbmVzOiBbeyB0ZXh0OidjZWxsLTEsbGluZS0xJyB9LCB7IHRleHQ6J2NlbGwtMSxsaW5lLTInIH1dLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9UQUwtQ0VMTC1IRUlHSFQgPSAyXG4gICAgICAgICAqICAgIF9saW5lczogW3sgdGV4dDonY2VsbC0yLGxpbmUtMScgfSwgeyB0ZXh0OidjZWxsLTIsbGluZS0yJyB9XSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPVEFMLUNFTEwtSEVJR0hUID0gMlxuICAgICAgICAgKiAgICBfbGluZXM6IFt7IHRleHQ6J2NlbGwtMyxsaW5lLTEnIH0sIHsgdGV4dDonY2VsbC0zLGxpbmUtMicgfSwgeyB0ZXh0OidjZWxsLTMsbGluZS0zJyB9LCB7IHRleHQ6J2NlbGwtMyxsaW5lLTQnIH1dLCAvLyBUT1RBTC1DRUxMLUhFSUdIVCA9IDRcbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiBFeGFtcGxlOiAyIHJvd3MsIHdpdGggdGhlIGZpcnN0cm93IG92ZXJmbG93aW5nIG9udG8gYSBuZXcgc2xpZGVcbiAgICAgICAgICogU0xJREUgMTpcbiAgICAgICAgICogIHwtLS0tLS0tLXwtLS0tLS0tLXwtLS0tLS0tLXwtLS0tLS0tLXxcbiAgICAgICAgICogIHwgbGluZS0xIHwgbGluZS0xIHwgbGluZS0xIHwgbGluZS0xIHxcbiAgICAgICAgICogIHwgICAgICAgIHwgICAgICAgIHwgbGluZS0yIHwgICAgICAgIHxcbiAgICAgICAgICogIHwgICAgICAgIHwgICAgICAgIHwgbGluZS0zIHwgICAgICAgIHxcbiAgICAgICAgICogIHwtLS0tLS0tLXwtLS0tLS0tLXwtLS0tLS0tLXwtLS0tLS0tLXxcbiAgICAgICAgICpcbiAgICAgICAgICogU0xJREUgMjpcbiAgICAgICAgICogIHwtLS0tLS0tLXwtLS0tLS0tLXwtLS0tLS0tLXwtLS0tLS0tLXxcbiAgICAgICAgICogIHwgICAgICAgIHwgICAgICAgIHwgbGluZS00IHwgICAgICAgIHxcbiAgICAgICAgICogIHwtLS0tLS0tLXwtLS0tLS0tLXwtLS0tLS0tLXwtLS0tLS0tLXxcbiAgICAgICAgICogIHwgbGluZS0xIHwgbGluZS0xIHwgbGluZS0xIHwgbGluZS0xIHxcbiAgICAgICAgICogIHwtLS0tLS0tLXwtLS0tLS0tLXwtLS0tLS0tLXwtLS0tLS0tLXxcbiAgICAgICAgICovXG4gICAgICAgIGlmICh0YWJsZVByb3BzLnZlcmJvc2UpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgXFxufCBTTElERSBbJHt0YWJsZVJvd1NsaWRlcy5sZW5ndGh9XTogUk9XIFske2lSb3d9XTogU1RBUlQuLi5gKTtcbiAgICAgICAgbGV0IGN1cnJDZWxsSWR4ID0gMDtcbiAgICAgICAgbGV0IGVtdUxpbmVNYXhIID0gMDtcbiAgICAgICAgbGV0IGlzRG9uZSA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoIWlzRG9uZSkge1xuICAgICAgICAgICAgY29uc3Qgc3JjQ2VsbCA9IHJvd0NlbGxMaW5lc1tjdXJyQ2VsbElkeF07XG4gICAgICAgICAgICBsZXQgdGd0Q2VsbCA9IGN1cnJUYWJsZVJvd1tjdXJyQ2VsbElkeF07IC8vIE5PVEU6IG1heSBiZSByZWRlZmluZWQgYmVsb3cgKGEgbmV3IHJvdyBtYXkgYmUgY3JlYXRlZCwgdGh1cyBjaGFuZ2luZyB0aGlzIHZhbHVlKVxuICAgICAgICAgICAgLy8gMTogY2FsYyBlbXVMaW5lTWF4SFxuICAgICAgICAgICAgcm93Q2VsbExpbmVzLmZvckVhY2goY2VsbCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGwuX2xpbmVIZWlnaHQgPj0gZW11TGluZU1heEgpXG4gICAgICAgICAgICAgICAgICAgIGVtdUxpbmVNYXhIID0gY2VsbC5fbGluZUhlaWdodDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gMjogY3JlYXRlIGEgbmV3IHNsaWRlIGlmIHRoZXJlIGlzIGluc3VmZmljaWVudCByb29tIGZvciB0aGUgY3VycmVudCByb3dcbiAgICAgICAgICAgIGlmIChlbXVUYWJDdXJySCArIGVtdUxpbmVNYXhIID4gZW11U2xpZGVUYWJIKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhYmxlUHJvcHMudmVyYm9zZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnXFxufC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfCcpO1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYHwtLSBORVcgU0xJREUgQ1JFQVRFRCAoY3VyclRhYkgrY3VyckxpbmVIID4gbWF4SCkgPT4gJHsoZW11VGFiQ3VyckggLyBFTVUpLnRvRml4ZWQoMil9ICsgJHsoc3JjQ2VsbC5fbGluZUhlaWdodCAvIEVNVSkudG9GaXhlZCgyKX0gPiAke2VtdVNsaWRlVGFiSCAvIEVNVX1gKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3wtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcXG5cXG4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQTogYWRkIGN1cnJlbnQgcm93IHNsaWRlIG9yIGl0IHdpbGwgYmUgbG9zdCAob25seSBpZiBpdCBoYXMgcm93cyBhbmQgdGV4dClcbiAgICAgICAgICAgICAgICBpZiAoY3VyclRhYmxlUm93Lmxlbmd0aCA+IDAgJiYgY3VyclRhYmxlUm93Lm1hcChjZWxsID0+IGNlbGwudGV4dC5sZW5ndGgpLnJlZHVjZSgocCwgbikgPT4gcCArIG4pID4gMClcbiAgICAgICAgICAgICAgICAgICAgbmV3VGFibGVSb3dTbGlkZS5yb3dzLnB1c2goY3VyclRhYmxlUm93KTtcbiAgICAgICAgICAgICAgICAvLyBCOiBhZGQgY3VycmVudCBzbGlkZSB0byBTbGlkZXMgYXJyYXlcbiAgICAgICAgICAgICAgICB0YWJsZVJvd1NsaWRlcy5wdXNoKG5ld1RhYmxlUm93U2xpZGUpO1xuICAgICAgICAgICAgICAgIC8vIEM6IHJlc2V0IHdvcmtpbmcvY3VyciBzbGlkZSB0byBob2xkIHJvd3MgYXMgdGhleSdyZSBjcmVhdGVkXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Um93cyA9IFtdO1xuICAgICAgICAgICAgICAgIG5ld1RhYmxlUm93U2xpZGUgPSB7IHJvd3M6IG5ld1Jvd3MgfTtcbiAgICAgICAgICAgICAgICAvLyBEOiByZXNldCB3b3JraW5nL2N1cnIgcm93XG4gICAgICAgICAgICAgICAgY3VyclRhYmxlUm93ID0gW107XG4gICAgICAgICAgICAgICAgcm93LmZvckVhY2goY2VsbCA9PiBjdXJyVGFibGVSb3cucHVzaCh7IF90eXBlOiBTTElERV9PQkpFQ1RfVFlQRVMudGFibGVjZWxsLCB0ZXh0OiBbXSwgb3B0aW9uczogY2VsbC5vcHRpb25zIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBFOiBDYWxjIHVzYWJsZSB2ZXJ0aWNhbCBzcGFjZS90YWJsZSBoZWlnaHQgbm93IGFzIHdlIG1heSBzdGlsbCBiZSBpbiB0aGUgc2FtZSByb3cgYW5kIGNvZGUgYWJvdmUgKFwiQzogQ2FsYyB1c2FibGUgdmVydGljYWwgc3BhY2UvdGFibGUgaGVpZ2h0LlwiKSBjYWxjIG1heSBub3cgYmUgaW52YWxpZFxuICAgICAgICAgICAgICAgIGNhbGNTbGlkZVRhYkgoKTtcbiAgICAgICAgICAgICAgICBlbXVUYWJDdXJySCArPSBtYXhDZWxsTWFyVG9wRW11ICsgbWF4Q2VsbE1hckJ0bUVtdTsgLy8gU3RhcnQgcm93IGhlaWdodCB3aXRoIG1hcmdpbnNcbiAgICAgICAgICAgICAgICBpZiAodGFibGVQcm9wcy52ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgfCBTTElERSBbJHt0YWJsZVJvd1NsaWRlcy5sZW5ndGh9XTogZW11U2xpZGVUYWJIIC4uLi4uLiA9ICR7KGVtdVNsaWRlVGFiSCAvIEVNVSkudG9GaXhlZCgxKX0gYCk7XG4gICAgICAgICAgICAgICAgLy8gRjogcmVzZXQgY3VycmVudCB0YWJsZSBoZWlnaHQgZm9yIHRoaXMgbmV3IFNsaWRlXG4gICAgICAgICAgICAgICAgZW11VGFiQ3VyckggPSAwO1xuICAgICAgICAgICAgICAgIC8vIEc6IGhhbmRsZSByZXBlYXQgaGVhZGVycyBvcHRpb24gL29yLyBBZGQgbmV3IGVtcHR5IHJvdyB0byBjb250aW51ZSBjdXJyZW50IGxpbmVzIGludG9cbiAgICAgICAgICAgICAgICBpZiAoKHRhYmxlUHJvcHMuYWRkSGVhZGVyVG9FYWNoIHx8IHRhYmxlUHJvcHMuYXV0b1BhZ2VSZXBlYXRIZWFkZXIpICYmIHRhYmxlUHJvcHMuX2Fyck9ialRhYkhlYWRSb3dzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlUHJvcHMuX2Fyck9ialRhYkhlYWRSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0hlYWRSb3cgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtYXhMaW5lSGVpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5mb3JFYWNoKGNlbGwgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0hlYWRSb3cucHVzaChjZWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbC5fbGluZUhlaWdodCA+IG1heExpbmVIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heExpbmVIZWlnaHQgPSBjZWxsLl9saW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdUYWJsZVJvd1NsaWRlLnJvd3MucHVzaChuZXdIZWFkUm93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtdVRhYkN1cnJIICs9IG1heExpbmVIZWlnaHQ7IC8vIFRPRE86IHdoYXQgYWJvdXQgbWFyZ2lucz8gZG9udCB3ZSBuZWVkIHRvIGluY2x1ZGUgY2VsbCBtYXJnaW4gaW4gbGluZSBoZWlnaHQ/XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXSVA6IE5FVzogVEVTVCBUSElTISFcbiAgICAgICAgICAgICAgICB0Z3RDZWxsID0gY3VyclRhYmxlUm93W2N1cnJDZWxsSWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDM6IHNldCBhcnJheSBvZiB3b3JkcyB0aGF0IGNvbXByaXNlIHRoaXMgbGluZVxuICAgICAgICAgICAgY29uc3QgY3VyckxpbmUgPSBzcmNDZWxsLl9saW5lcy5zaGlmdCgpO1xuICAgICAgICAgICAgLy8gNDogY3JlYXRlIG5ldyBsaW5lIGJ5IGFkZGluZyBhbGwgd29yZHMgZnJvbSBjdXJyIGxpbmUgKG9yIGFkZCBlbXB0eSBpZiB0aGVyZSBhcmUgbm8gd29yZHMgdG8gYXZvaWQgXCJuZWVkcyByZXBhaXJcIiBpc3N1ZSB0cmlnZ2VyZWQgd2hlbiBjZWxscyBoYXZlIG51bGwgY29udGVudClcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRndENlbGwudGV4dCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyckxpbmUpXG4gICAgICAgICAgICAgICAgICAgIHRndENlbGwudGV4dCA9IHRndENlbGwudGV4dC5jb25jYXQoY3VyckxpbmUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRndENlbGwudGV4dC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRndENlbGwudGV4dCA9IHRndENlbGwudGV4dC5jb25jYXQoeyBfdHlwZTogU0xJREVfT0JKRUNUX1RZUEVTLnRhYmxlY2VsbCwgdGV4dDogJycgfSk7XG4gICAgICAgICAgICAgICAgLy8gSU1QT1JUQU5UOiBeXl4gYWRkIGVtcHR5IGlmIHRoZXJlIGFyZSBubyB3b3JkcyB0byBhdm9pZCBcIm5lZWRzIHJlcGFpclwiIGlzc3VlIHRyaWdnZXJlZCB3aGVuIGNlbGxzIGhhdmUgbnVsbCBjb250ZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA1OiBpbmNyZWFzZSB0YWJsZSBoZWlnaHQgYnkgdGhlIGN1cnIgbGluZSBoZWlnaHQgKGlmIHdlJ3JlIG9uIHRoZSBsYXN0IGNvbHVtbilcbiAgICAgICAgICAgIGlmIChjdXJyQ2VsbElkeCA9PT0gcm93Q2VsbExpbmVzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgZW11VGFiQ3VyckggKz0gZW11TGluZU1heEg7XG4gICAgICAgICAgICAvLyA2OiBhZHZhbmNlIGNvbHVtbi9jZWxsIGluZGV4IChvciBjaXJjbGUgYmFjayB0byBmaXJzdCBvbmUgdG8gY29udGludWUgYWRkaW5nIGxpbmVzKVxuICAgICAgICAgICAgY3VyckNlbGxJZHggPSBjdXJyQ2VsbElkeCA8IHJvd0NlbGxMaW5lcy5sZW5ndGggLSAxID8gY3VyckNlbGxJZHggKyAxIDogMDtcbiAgICAgICAgICAgIC8vIDc6IFdJUDogZG9uZT9cbiAgICAgICAgICAgIGNvbnN0IGJyZW50ID0gcm93Q2VsbExpbmVzLm1hcChjZWxsID0+IGNlbGwuX2xpbmVzLmxlbmd0aCkucmVkdWNlKChwcmV2LCBuZXh0KSA9PiBwcmV2ICsgbmV4dCk7XG4gICAgICAgICAgICBpZiAoYnJlbnQgPT09IDApXG4gICAgICAgICAgICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGOiBGbHVzaC9jYXB0dXJlIHJvdyBidWZmZXIgYmVmb3JlIGl0IHJlc2V0cyBhdCB0aGUgdG9wIG9mIHRoaXMgbG9vcFxuICAgICAgICBpZiAoY3VyclRhYmxlUm93Lmxlbmd0aCA+IDApXG4gICAgICAgICAgICBuZXdUYWJsZVJvd1NsaWRlLnJvd3MucHVzaChjdXJyVGFibGVSb3cpO1xuICAgICAgICBpZiAodGFibGVQcm9wcy52ZXJib3NlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgLSBTTElERSBbJHt0YWJsZVJvd1NsaWRlcy5sZW5ndGh9XTogUk9XIFske2lSb3d9XTogLi4uQ09NUExFVEUgLi4uLi4uIGVtdVRhYkN1cnJIID0gJHsoZW11VGFiQ3VyckggLyBFTVUpLnRvRml4ZWQoMil9ICggZW11U2xpZGVUYWJIID0gJHsoZW11U2xpZGVUYWJIIC8gRU1VKS50b0ZpeGVkKDIpfSApYCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBTVEVQIDc6IEZsdXNoIGJ1ZmZlciAvIGFkZCBmaW5hbCBzbGlkZVxuICAgIHRhYmxlUm93U2xpZGVzLnB1c2gobmV3VGFibGVSb3dTbGlkZSk7XG4gICAgaWYgKHRhYmxlUHJvcHMudmVyYm9zZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnXFxufD09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PXwnKTtcbiAgICAgICAgY29uc29sZS5sb2coYHwgRklOQUw6IHRhYmxlUm93U2xpZGVzLmxlbmd0aCA9ICR7dGFibGVSb3dTbGlkZXMubGVuZ3RofWApO1xuICAgICAgICB0YWJsZVJvd1NsaWRlcy5mb3JFYWNoKHNsaWRlID0+IGNvbnNvbGUubG9nKHNsaWRlKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCd8PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09fFxcblxcbicpO1xuICAgIH1cbiAgICAvLyBMQVNUOlxuICAgIHJldHVybiB0YWJsZVJvd1NsaWRlcztcbn1cbi8qKlxuICogUmVwcm9kdWNlcyBhbiBIVE1MIHRhYmxlIGFzIGEgUG93ZXJQb2ludCB0YWJsZSAtIGluY2x1ZGluZyBjb2x1bW4gd2lkdGhzLCBzdHlsZSwgZXRjLiAtIGNyZWF0ZXMgMSBvciBtb3JlIHNsaWRlcyBhcyBuZWVkZWRcbiAqIEBwYXJhbSB7UHB0eEdlbkpTfSBwcHR4IC0gcHB0eGdlbmpzIGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFiRWxlSWQgLSBIVE1MRWxlbWVudElEIG9mIHRoZSB0YWJsZVxuICogQHBhcmFtIHtJVGFibGVUb1NsaWRlc09wdHN9IG9wdGlvbnMgLSBhcnJheSBvZiBvcHRpb25zIChlLmcuOiB0YWJzaXplKVxuICogQHBhcmFtIHtTbGlkZUxheW91dH0gbWFzdGVyU2xpZGUgLSBtYXN0ZXJTbGlkZVxuICovXG5mdW5jdGlvbiBnZW5UYWJsZVRvU2xpZGVzKHBwdHgsIHRhYkVsZUlkLCBvcHRpb25zID0ge30sIG1hc3RlclNsaWRlKSB7XG4gICAgY29uc3Qgb3B0cyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0cy5zbGlkZU1hcmdpbiA9IG9wdHMuc2xpZGVNYXJnaW4gfHwgb3B0cy5zbGlkZU1hcmdpbiA9PT0gMCA/IG9wdHMuc2xpZGVNYXJnaW4gOiAwLjU7XG4gICAgbGV0IGVtdVNsaWRlVGFiVyA9IG9wdHMudyB8fCBwcHR4LnByZXNMYXlvdXQud2lkdGg7XG4gICAgY29uc3QgYXJyT2JqVGFiSGVhZFJvd3MgPSBbXTtcbiAgICBjb25zdCBhcnJPYmpUYWJCb2R5Um93cyA9IFtdO1xuICAgIGNvbnN0IGFyck9ialRhYkZvb3RSb3dzID0gW107XG4gICAgY29uc3QgYXJyQ29sVyA9IFtdO1xuICAgIGNvbnN0IGFyclRhYkNvbFcgPSBbXTtcbiAgICBsZXQgYXJySW5jaE1hcmdpbnMgPSBbMC41LCAwLjUsIDAuNSwgMC41XTsgLy8gVFJCTC1zdHlsZVxuICAgIGxldCBpbnRUYWJXID0gMDtcbiAgICAvLyBSRUFMSVRZLUNIRUNLOlxuICAgIGlmICghZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFiRWxlSWQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhYmxlVG9TbGlkZXM6IFRhYmxlIElEIFwiJyArIHRhYkVsZUlkICsgJ1wiIGRvZXMgbm90IGV4aXN0IScpO1xuICAgIC8vIFNURVAgMTogU2V0IG1hcmdpbnNcbiAgICBpZiAobWFzdGVyU2xpZGUgPT09IG51bGwgfHwgbWFzdGVyU2xpZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hc3RlclNsaWRlLl9tYXJnaW4pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWFzdGVyU2xpZGUuX21hcmdpbikpXG4gICAgICAgICAgICBhcnJJbmNoTWFyZ2lucyA9IG1hc3RlclNsaWRlLl9tYXJnaW47XG4gICAgICAgIGVsc2UgaWYgKCFpc05hTihtYXN0ZXJTbGlkZS5fbWFyZ2luKSlcbiAgICAgICAgICAgIGFyckluY2hNYXJnaW5zID0gW21hc3RlclNsaWRlLl9tYXJnaW4sIG1hc3RlclNsaWRlLl9tYXJnaW4sIG1hc3RlclNsaWRlLl9tYXJnaW4sIG1hc3RlclNsaWRlLl9tYXJnaW5dO1xuICAgICAgICBvcHRzLnNsaWRlTWFyZ2luID0gYXJySW5jaE1hcmdpbnM7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zbGlkZU1hcmdpbikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRzLnNsaWRlTWFyZ2luKSlcbiAgICAgICAgICAgIGFyckluY2hNYXJnaW5zID0gb3B0cy5zbGlkZU1hcmdpbjtcbiAgICAgICAgZWxzZSBpZiAoIWlzTmFOKG9wdHMuc2xpZGVNYXJnaW4pKVxuICAgICAgICAgICAgYXJySW5jaE1hcmdpbnMgPSBbb3B0cy5zbGlkZU1hcmdpbiwgb3B0cy5zbGlkZU1hcmdpbiwgb3B0cy5zbGlkZU1hcmdpbiwgb3B0cy5zbGlkZU1hcmdpbl07XG4gICAgfVxuICAgIGVtdVNsaWRlVGFiVyA9IChvcHRzLncgPyBpbmNoMkVtdShvcHRzLncpIDogcHB0eC5wcmVzTGF5b3V0LndpZHRoKSAtIGluY2gyRW11KGFyckluY2hNYXJnaW5zWzFdICsgYXJySW5jaE1hcmdpbnNbM10pO1xuICAgIGlmIChvcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tbVkVSQk9TRSBNT0RFXV0nKTtcbiAgICAgICAgY29uc29sZS5sb2coJ3wtLSBgdGFibGVUb1NsaWRlc2AgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwnKTtcbiAgICAgICAgY29uc29sZS5sb2coYHwgdGFibGVQcm9wcy5oIC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiA9ICR7b3B0cy5ofWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgfCB0YWJsZVByb3BzLncgLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uID0gJHtvcHRzLnd9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGB8IHBwdHgucHJlc0xheW91dC53aWR0aCAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gPSAkeyhwcHR4LnByZXNMYXlvdXQud2lkdGggLyBFTVUpLnRvRml4ZWQoMSl9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGB8IHBwdHgucHJlc0xheW91dC5oZWlnaHQgLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gPSAkeyhwcHR4LnByZXNMYXlvdXQuaGVpZ2h0IC8gRU1VKS50b0ZpeGVkKDEpfWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgfCBlbXVTbGlkZVRhYlcgLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uID0gJHsoZW11U2xpZGVUYWJXIC8gRU1VKS50b0ZpeGVkKDEpfWApO1xuICAgIH1cbiAgICAvLyBTVEVQIDI6IEdyYWIgdGFibGUgY29sIHdpZHRocyAtIGp1c3QgZmluZCB0aGUgZmlyc3QgYXZhaWxibGUgcm93LCBlaXRoZXIgdGhlYWQvdGJvZHkvdGZvb3QsIG90aGVycyBtYXkgaGF2ZSBjb2xzcGFucywgd2hvIGNhcmVzLCB3ZSBvbmx5IG5lZWQgY29sIHdpZHRocyBmcm9tIDFcbiAgICBsZXQgZmlyc3RSb3dDZWxscyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYCMke3RhYkVsZUlkfSB0cjpmaXJzdC1jaGlsZCB0aGApO1xuICAgIGlmIChmaXJzdFJvd0NlbGxzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgZmlyc3RSb3dDZWxscyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYCMke3RhYkVsZUlkfSB0cjpmaXJzdC1jaGlsZCB0ZGApO1xuICAgIGZpcnN0Um93Q2VsbHMuZm9yRWFjaCgoY2VsbEVsZSkgPT4ge1xuICAgICAgICBjb25zdCBjZWxsID0gY2VsbEVsZTtcbiAgICAgICAgaWYgKGNlbGwuZ2V0QXR0cmlidXRlKCdjb2xzcGFuJykpIHtcbiAgICAgICAgICAgIC8vIEd1ZXNzdGltYXRlIChkaXZpZGUgZXZlbmx5KSBjb2wgd2lkdGhzXG4gICAgICAgICAgICAvLyBOT1RFOiBib3RoIGokcXVlcnkgYW5kIHZhbmlsbGEgc2VsZWN0b3JzIHJldHVybiB7MH0gd2hlbiB0YWJsZSBpcyBub3QgdmlzaWJsZSlcbiAgICAgICAgICAgIGZvciAobGV0IGlkeGMgPSAwOyBpZHhjIDwgTnVtYmVyKGNlbGwuZ2V0QXR0cmlidXRlKCdjb2xzcGFuJykpOyBpZHhjKyspIHtcbiAgICAgICAgICAgICAgICBhcnJUYWJDb2xXLnB1c2goTWF0aC5yb3VuZChjZWxsLm9mZnNldFdpZHRoIC8gTnVtYmVyKGNlbGwuZ2V0QXR0cmlidXRlKCdjb2xzcGFuJykpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhcnJUYWJDb2xXLnB1c2goY2VsbC5vZmZzZXRXaWR0aCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBhcnJUYWJDb2xXLmZvckVhY2goY29sVyA9PiB7XG4gICAgICAgIGludFRhYlcgKz0gY29sVztcbiAgICB9KTtcbiAgICAvLyBTVEVQIDM6IENhbGMvU2V0IGNvbHVtbiB3aWR0aHMgYnkgdXNpbmcgc2FtZSBjb2x1bW4gd2lkdGggcGVyY2VudCBmcm9tIEhUTUwgdGFibGVcbiAgICBhcnJUYWJDb2xXLmZvckVhY2goKGNvbFcsIGlkeFcpID0+IHtcbiAgICAgICAgY29uc3QgaW50Q2FsY1dpZHRoID0gTnVtYmVyKCgoTnVtYmVyKGVtdVNsaWRlVGFiVykgKiAoKGNvbFcgLyBpbnRUYWJXKSAqIDEwMCkpIC8gMTAwIC8gRU1VKS50b0ZpeGVkKDIpKTtcbiAgICAgICAgbGV0IGludE1pbldpZHRoID0gMDtcbiAgICAgICAgY29uc3QgY29sU2VsZWN0b3JNaW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAjJHt0YWJFbGVJZH0gdGhlYWQgdHI6Zmlyc3QtY2hpbGQgdGg6bnRoLWNoaWxkKCR7aWR4VyArIDF9KWApO1xuICAgICAgICBpZiAoY29sU2VsZWN0b3JNaW4pXG4gICAgICAgICAgICBpbnRNaW5XaWR0aCA9IE51bWJlcihjb2xTZWxlY3Rvck1pbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtcHB0eC1taW4td2lkdGgnKSk7XG4gICAgICAgIGNvbnN0IGNvbFNlbGVjdG9yU2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgIyR7dGFiRWxlSWR9IHRoZWFkIHRyOmZpcnN0LWNoaWxkIHRoOm50aC1jaGlsZCgke2lkeFcgKyAxfSlgKTtcbiAgICAgICAgaWYgKGNvbFNlbGVjdG9yU2V0KVxuICAgICAgICAgICAgaW50TWluV2lkdGggPSBOdW1iZXIoY29sU2VsZWN0b3JTZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXBwdHgtd2lkdGgnKSk7XG4gICAgICAgIGFyckNvbFcucHVzaCgoaW50TWluV2lkdGggPiBpbnRDYWxjV2lkdGggPyBpbnRNaW5XaWR0aCA6IGludENhbGNXaWR0aCkpO1xuICAgIH0pO1xuICAgIGlmIChvcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coYHwgYXJyQ29sVyAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiA9IFske2FyckNvbFcuam9pbignLCAnKX1dYCk7XG4gICAgfVxuICAgIC8vIFNURVAgNDogSXRlcmF0ZSBvdmVyIGVhY2ggdGFibGUgZWxlbWVudCBhbmQgY3JlYXRlIGRhdGEgYXJyYXlzICh0ZXh0IGFuZCBvcHRzKVxuICAgIC8vIE5PVEU6IFdlIGNyZWF0ZSAzIGFycmF5cyBpbnN0ZWFkIG9mIG9uZSBzbyB3ZSBjYW4gbG9vcCBvdmVyIGJvZHkgdGhlbiBzaG93IGhlYWRlci9mb290ZXIgcm93cyBvbiBmaXJzdCBhbmQgbGFzdCBwYWdlXG4gICAgY29uc3QgdGFibGVQYXJ0cyA9IFsndGhlYWQnLCAndGJvZHknLCAndGZvb3QnXTtcbiAgICB0YWJsZVBhcnRzLmZvckVhY2gocGFydCA9PiB7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYCMke3RhYkVsZUlkfSAke3BhcnR9IHRyYCkuZm9yRWFjaCgocm93KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBodG1sUm93ID0gcm93O1xuICAgICAgICAgICAgY29uc3QgYXJyT2JqVGFiQ2VsbHMgPSBbXTtcbiAgICAgICAgICAgIEFycmF5LmZyb20oaHRtbFJvdy5jZWxscykuZm9yRWFjaChjZWxsID0+IHtcbiAgICAgICAgICAgICAgICAvLyBBOiBHZXQgUkdCIHRleHQvYmtnZCBjb2xvcnNcbiAgICAgICAgICAgICAgICBjb25zdCBhcnJSR0IxID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoY2VsbCkuZ2V0UHJvcGVydHlWYWx1ZSgnY29sb3InKS5yZXBsYWNlKC9cXHMrL2dpLCAnJykucmVwbGFjZSgncmdiYSgnLCAnJykucmVwbGFjZSgncmdiKCcsICcnKS5yZXBsYWNlKCcpJywgJycpLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgbGV0IGFyclJHQjIgPSB3aW5kb3dcbiAgICAgICAgICAgICAgICAgICAgLmdldENvbXB1dGVkU3R5bGUoY2VsbClcbiAgICAgICAgICAgICAgICAgICAgLmdldFByb3BlcnR5VmFsdWUoJ2JhY2tncm91bmQtY29sb3InKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxzKy9naSwgJycpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdyZ2JhKCcsICcnKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgncmdiKCcsICcnKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnKScsICcnKVxuICAgICAgICAgICAgICAgICAgICAuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gTk9URTogKElTU1VFIzU3KTogRGVmYXVsdCBmb3IgdW5zdHlsZWQgdGFibGVzIGlzIGJsYWNrIGJrZ2QsIHNvIHVzZSB3aGl0ZSBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUoY2VsbCkuZ2V0UHJvcGVydHlWYWx1ZSgnYmFja2dyb3VuZC1jb2xvcicpID09PSAncmdiYSgwLCAwLCAwLCAwKScgfHxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUoY2VsbCkuZ2V0UHJvcGVydHlWYWx1ZSgndHJhbnNwYXJlbnQnKSkge1xuICAgICAgICAgICAgICAgICAgICBhcnJSR0IyID0gWycyNTUnLCAnMjU1JywgJzI1NSddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBCOiBDcmVhdGUgb3B0aW9uIG9iamVjdFxuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxPcHRzID0ge1xuICAgICAgICAgICAgICAgICAgICBhbGlnbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgYm9sZDogISEod2luZG93LmdldENvbXB1dGVkU3R5bGUoY2VsbCkuZ2V0UHJvcGVydHlWYWx1ZSgnZm9udC13ZWlnaHQnKSA9PT0gJ2JvbGQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIod2luZG93LmdldENvbXB1dGVkU3R5bGUoY2VsbCkuZ2V0UHJvcGVydHlWYWx1ZSgnZm9udC13ZWlnaHQnKSkgPj0gNTAwKSxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogcmdiVG9IZXgoTnVtYmVyKGFyclJHQjFbMF0pLCBOdW1iZXIoYXJyUkdCMVsxXSksIE51bWJlcihhcnJSR0IxWzJdKSksXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IHsgY29sb3I6IHJnYlRvSGV4KE51bWJlcihhcnJSR0IyWzBdKSwgTnVtYmVyKGFyclJHQjJbMV0pLCBOdW1iZXIoYXJyUkdCMlsyXSkpIH0sXG4gICAgICAgICAgICAgICAgICAgIGZvbnRGYWNlOiAod2luZG93LmdldENvbXB1dGVkU3R5bGUoY2VsbCkuZ2V0UHJvcGVydHlWYWx1ZSgnZm9udC1mYW1pbHknKSB8fCAnJykuc3BsaXQoJywnKVswXS5yZXBsYWNlKC9cIi9nLCAnJykucmVwbGFjZSgnaW5oZXJpdCcsICcnKS5yZXBsYWNlKCdpbml0aWFsJywgJycpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogTnVtYmVyKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGNlbGwpLmdldFByb3BlcnR5VmFsdWUoJ2ZvbnQtc2l6ZScpLnJlcGxhY2UoL1thLXpdL2dpLCAnJykpLFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNvbHNwYW46IE51bWJlcihjZWxsLmdldEF0dHJpYnV0ZSgnY29sc3BhbicpKSB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICByb3dzcGFuOiBOdW1iZXIoY2VsbC5nZXRBdHRyaWJ1dGUoJ3Jvd3NwYW4nKSkgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWduOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnLCAnc3RhcnQnLCAnZW5kJ10uaW5jbHVkZXMod2luZG93LmdldENvbXB1dGVkU3R5bGUoY2VsbCkuZ2V0UHJvcGVydHlWYWx1ZSgndGV4dC1hbGlnbicpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGlnbiA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGNlbGwpLmdldFByb3BlcnR5VmFsdWUoJ3RleHQtYWxpZ24nKS5yZXBsYWNlKCdzdGFydCcsICdsZWZ0JykucmVwbGFjZSgnZW5kJywgJ3JpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxPcHRzLmFsaWduID0gYWxpZ24gPT09ICdjZW50ZXInID8gJ2NlbnRlcicgOiBhbGlnbiA9PT0gJ2xlZnQnID8gJ2xlZnQnIDogYWxpZ24gPT09ICdyaWdodCcgPyAncmlnaHQnIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFsndG9wJywgJ21pZGRsZScsICdib3R0b20nXS5pbmNsdWRlcyh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjZWxsKS5nZXRQcm9wZXJ0eVZhbHVlKCd2ZXJ0aWNhbC1hbGlnbicpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWxpZ24gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjZWxsKS5nZXRQcm9wZXJ0eVZhbHVlKCd2ZXJ0aWNhbC1hbGlnbicpO1xuICAgICAgICAgICAgICAgICAgICBjZWxsT3B0cy52YWxpZ24gPSB2YWxpZ24gPT09ICd0b3AnID8gJ3RvcCcgOiB2YWxpZ24gPT09ICdtaWRkbGUnID8gJ21pZGRsZScgOiB2YWxpZ24gPT09ICdib3R0b20nID8gJ2JvdHRvbScgOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDOiBBZGQgcGFkZGluZyBbbWFyZ2luXSAoaWYgYW55KVxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IE1hcmdpbnMgdHJhbnNsYXRlOiBweC0+cHQgMToxIChlLmcuOiBhIDIwcHggcGFkZGVkIGNlbGwgbG9va3MgdGhlIHNhbWUgaW4gUFBUWCBhcyAyMHB0IFRleHQgSW5zZXQvUGFkZGluZylcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUoY2VsbCkuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy1sZWZ0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbE9wdHMubWFyZ2luID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWRlc1BhZCA9IFsncGFkZGluZy10b3AnLCAncGFkZGluZy1yaWdodCcsICdwYWRkaW5nLWJvdHRvbScsICdwYWRkaW5nLWxlZnQnXTtcbiAgICAgICAgICAgICAgICAgICAgc2lkZXNQYWQuZm9yRWFjaCgodmFsLCBpZHhzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsT3B0cy5tYXJnaW5baWR4c10gPSBNYXRoLnJvdW5kKE51bWJlcih3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjZWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHZhbCkucmVwbGFjZSgvXFxEL2dpLCAnJykpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEQ6IEFkZCBib3JkZXIgKGlmIGFueSlcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUoY2VsbCkuZ2V0UHJvcGVydHlWYWx1ZSgnYm9yZGVyLXRvcC13aWR0aCcpIHx8XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGNlbGwpLmdldFByb3BlcnR5VmFsdWUoJ2JvcmRlci1yaWdodC13aWR0aCcpIHx8XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGNlbGwpLmdldFByb3BlcnR5VmFsdWUoJ2JvcmRlci1ib3R0b20td2lkdGgnKSB8fFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjZWxsKS5nZXRQcm9wZXJ0eVZhbHVlKCdib3JkZXItbGVmdC13aWR0aCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxPcHRzLmJvcmRlciA9IFtudWxsLCBudWxsLCBudWxsLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lkZXNCb3IgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuICAgICAgICAgICAgICAgICAgICBzaWRlc0Jvci5mb3JFYWNoKCh2YWwsIGlkeGIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGludEJvcmRlclcgPSBNYXRoLnJvdW5kKE51bWJlcih3aW5kb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0Q29tcHV0ZWRTdHlsZShjZWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRQcm9wZXJ0eVZhbHVlKCdib3JkZXItJyArIHZhbCArICctd2lkdGgnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdweCcsICcnKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFyclJHQiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyUkdCID0gd2luZG93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldENvbXB1dGVkU3R5bGUoY2VsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0UHJvcGVydHlWYWx1ZSgnYm9yZGVyLScgKyB2YWwgKyAnLWNvbG9yJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxzKy9naSwgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3JnYmEoJywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3JnYignLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnKScsICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyQm9yZGVyQyA9IHJnYlRvSGV4KE51bWJlcihhcnJSR0JbMF0pLCBOdW1iZXIoYXJyUkdCWzFdKSwgTnVtYmVyKGFyclJHQlsyXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbE9wdHMuYm9yZGVyW2lkeGJdID0geyBwdDogaW50Qm9yZGVyVywgY29sb3I6IHN0ckJvcmRlckMgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIExBU1Q6IEFkZCBjZWxsXG4gICAgICAgICAgICAgICAgYXJyT2JqVGFiQ2VsbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIF90eXBlOiBTTElERV9PQkpFQ1RfVFlQRVMudGFibGVjZWxsLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjZWxsLmlubmVyVGV4dCwgLy8gYGlubmVyVGV4dGAgcmV0dXJucyA8YnI+IGFzIFwiXFxuXCIsIHNvIGxpbmVicmVhayBldGMuIHdvcmsgbGF0ZXIhXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IGNlbGxPcHRzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd0aGVhZCc6XG4gICAgICAgICAgICAgICAgICAgIGFyck9ialRhYkhlYWRSb3dzLnB1c2goYXJyT2JqVGFiQ2VsbHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd0Ym9keSc6XG4gICAgICAgICAgICAgICAgICAgIGFyck9ialRhYkJvZHlSb3dzLnB1c2goYXJyT2JqVGFiQ2VsbHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICAgICAgICAgICAgICAgIGFyck9ialRhYkZvb3RSb3dzLnB1c2goYXJyT2JqVGFiQ2VsbHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgdGFibGUgcGFyc2luZzogdW5leHBlY3RlZCB0YWJsZSBwYXJ0OiAke3BhcnR9YCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBTVEVQIDU6IEJyZWFrIHRhYmxlIGludG8gU2xpZGVzIGFzIG5lZWRlZFxuICAgIC8vIFBhc3MgaGVhZC1yb3dzIGFzIHRoZXJlIGlzIGFuIG9wdGlvbiB0byBhZGQgdG8gZWFjaCB0YWJsZSBhbmQgdGhlIHBhcnNlIGZ1bmMgbmVlZHMgdGhpcyBkYXRhIHRvIGZ1bGZpbGwgdGhhdCBvcHRpb25cbiAgICBvcHRzLl9hcnJPYmpUYWJIZWFkUm93cyA9IGFyck9ialRhYkhlYWRSb3dzIHx8IG51bGw7XG4gICAgb3B0cy5jb2xXID0gYXJyQ29sVztcbiAgICBnZXRTbGlkZXNGb3JUYWJsZVJvd3MoWy4uLmFyck9ialRhYkhlYWRSb3dzLCAuLi5hcnJPYmpUYWJCb2R5Um93cywgLi4uYXJyT2JqVGFiRm9vdFJvd3NdLCBvcHRzLCBwcHR4LnByZXNMYXlvdXQsIG1hc3RlclNsaWRlKS5mb3JFYWNoKChzbGlkZSwgaWR4VHIpID0+IHtcbiAgICAgICAgLy8gQTogQ3JlYXRlIG5ldyBTbGlkZVxuICAgICAgICBjb25zdCBuZXdTbGlkZSA9IHBwdHguYWRkU2xpZGUoeyBtYXN0ZXJOYW1lOiBvcHRzLm1hc3RlclNsaWRlTmFtZSB8fCBudWxsIH0pO1xuICAgICAgICAvLyBCOiBERVNJR046IFJlc2V0IGB5YCB0byBzdGFydFkgb3IgbWFyZ2luIGFmdGVyIGZpcnN0IFNsaWRlIChJU1NVRSM0MywgSVNTVUUjNDcsIElTU1VFIzQ4KVxuICAgICAgICBpZiAoaWR4VHIgPT09IDApXG4gICAgICAgICAgICBvcHRzLnkgPSBvcHRzLnkgfHwgYXJySW5jaE1hcmdpbnNbMF07XG4gICAgICAgIGlmIChpZHhUciA+IDApXG4gICAgICAgICAgICBvcHRzLnkgPSBvcHRzLmF1dG9QYWdlU2xpZGVTdGFydFkgfHwgb3B0cy5uZXdTbGlkZVN0YXJ0WSB8fCBhcnJJbmNoTWFyZ2luc1swXTtcbiAgICAgICAgaWYgKG9wdHMudmVyYm9zZSlcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGB8IG9wdHMuYXV0b1BhZ2VTbGlkZVN0YXJ0WTogJHtvcHRzLmF1dG9QYWdlU2xpZGVTdGFydFl9IC8gYXJySW5jaE1hcmdpbnNbMF06ICR7YXJySW5jaE1hcmdpbnNbMF19ID0+IG9wdHMueSA9ICR7b3B0cy55fWApO1xuICAgICAgICAvLyBDOiBBZGQgdGFibGUgdG8gU2xpZGVcbiAgICAgICAgbmV3U2xpZGUuYWRkVGFibGUoc2xpZGUucm93cywgeyB4OiBvcHRzLnggfHwgYXJySW5jaE1hcmdpbnNbM10sIHk6IG9wdHMueSwgdzogTnVtYmVyKGVtdVNsaWRlVGFiVykgLyBFTVUsIGNvbFc6IGFyckNvbFcsIGF1dG9QYWdlOiBmYWxzZSB9KTtcbiAgICAgICAgLy8gRDogQWRkIGFueSBhZGRpdGlvbmFsIG9iamVjdHNcbiAgICAgICAgaWYgKG9wdHMuYWRkSW1hZ2UpIHtcbiAgICAgICAgICAgIG9wdHMuYWRkSW1hZ2Uub3B0aW9ucyA9IG9wdHMuYWRkSW1hZ2Uub3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIGlmICghb3B0cy5hZGRJbWFnZS5pbWFnZSB8fCAoIW9wdHMuYWRkSW1hZ2UuaW1hZ2UucGF0aCAmJiAhb3B0cy5hZGRJbWFnZS5pbWFnZS5kYXRhKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignV2FybmluZzogdGFibGVUb1NsaWRlcy5hZGRJbWFnZSByZXF1aXJlcyBlaXRoZXIgYHBhdGhgIG9yIGBkYXRhYCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U2xpZGUuYWRkSW1hZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBwYXRoOiBvcHRzLmFkZEltYWdlLmltYWdlLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG9wdHMuYWRkSW1hZ2UuaW1hZ2UuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgeDogb3B0cy5hZGRJbWFnZS5vcHRpb25zLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IG9wdHMuYWRkSW1hZ2Uub3B0aW9ucy55LFxuICAgICAgICAgICAgICAgICAgICB3OiBvcHRzLmFkZEltYWdlLm9wdGlvbnMudyxcbiAgICAgICAgICAgICAgICAgICAgaDogb3B0cy5hZGRJbWFnZS5vcHRpb25zLmgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuYWRkU2hhcGUpXG4gICAgICAgICAgICBuZXdTbGlkZS5hZGRTaGFwZShvcHRzLmFkZFNoYXBlLnNoYXBlTmFtZSwgb3B0cy5hZGRTaGFwZS5vcHRpb25zIHx8IHt9KTtcbiAgICAgICAgaWYgKG9wdHMuYWRkVGFibGUpXG4gICAgICAgICAgICBuZXdTbGlkZS5hZGRUYWJsZShvcHRzLmFkZFRhYmxlLnJvd3MsIG9wdHMuYWRkVGFibGUub3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIGlmIChvcHRzLmFkZFRleHQpXG4gICAgICAgICAgICBuZXdTbGlkZS5hZGRUZXh0KG9wdHMuYWRkVGV4dC50ZXh0LCBvcHRzLmFkZFRleHQub3B0aW9ucyB8fCB7fSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogUHB0eEdlbkpTOiBTbGlkZSBPYmplY3QgR2VuZXJhdG9yc1xuICovXG4vKiogY291bnRlciBmb3IgaW5jbHVkZWQgY2hhcnRzICh1c2VkIGZvciBpbmRleCBpbiB0aGVpciBmaWxlbmFtZXMpICovXG5sZXQgX2NoYXJ0Q291bnRlciA9IDA7XG4vKipcbiAqIFRyYW5zZm9ybXMgYSBzbGlkZSBkZWZpbml0aW9uIHRvIGEgc2xpZGUgb2JqZWN0IHRoYXQgaXMgdGhlbiBwYXNzZWQgdG8gdGhlIFhNTCB0cmFuc2Zvcm1hdGlvbiBwcm9jZXNzLlxuICogQHBhcmFtIHtTbGlkZU1hc3RlclByb3BzfSBwcm9wcyAtIHNsaWRlIGRlZmluaXRpb25cbiAqIEBwYXJhbSB7UHJlc1NsaWRlfFNsaWRlTGF5b3V0fSB0YXJnZXQgLSBlbXB0eSBzbGlkZSBvYmplY3QgdGhhdCBzaG91bGQgYmUgdXBkYXRlZCBieSB0aGUgcGFzc2VkIGRlZmluaXRpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2xpZGVNYXN0ZXIocHJvcHMsIHRhcmdldCkge1xuICAgIC8vIFNURVAgMTogQWRkIGJhY2tncm91bmQgaWYgZWl0aGVyIHRoZSBzbGlkZSBvciBsYXlvdXQgaGFzIGJhY2tncm91bmQgcHJvcHNcbiAgICAvLyBpZiAocHJvcHMuYmFja2dyb3VuZCB8fCB0YXJnZXQuYmFja2dyb3VuZCkgYWRkQmFja2dyb3VuZERlZmluaXRpb24ocHJvcHMuYmFja2dyb3VuZCwgdGFyZ2V0KVxuICAgIGlmIChwcm9wcy5ia2dkKVxuICAgICAgICB0YXJnZXQuYmtnZCA9IHByb3BzLmJrZ2Q7IC8vIERFUFJFQ0FURUQ6IChyZW1vdmUgaW4gdjQuMC4wKVxuICAgIC8vIFNURVAgMjogQWRkIGFsbCBTbGlkZSBNYXN0ZXIgb2JqZWN0cyBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIGdpdmVuXG4gICAgaWYgKHByb3BzLm9iamVjdHMgJiYgQXJyYXkuaXNBcnJheShwcm9wcy5vYmplY3RzKSAmJiBwcm9wcy5vYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcHJvcHMub2JqZWN0cy5mb3JFYWNoKChvYmplY3QsIGlkeCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gT2JqZWN0LmtleXMob2JqZWN0KVswXTtcbiAgICAgICAgICAgIGNvbnN0IHRndCA9IHRhcmdldDtcbiAgICAgICAgICAgIGlmIChNQVNURVJfT0JKRUNUU1trZXldICYmIGtleSA9PT0gJ2NoYXJ0JylcbiAgICAgICAgICAgICAgICBhZGRDaGFydERlZmluaXRpb24odGd0LCBvYmplY3Rba2V5XS50eXBlLCBvYmplY3Rba2V5XS5kYXRhLCBvYmplY3Rba2V5XS5vcHRzKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKE1BU1RFUl9PQkpFQ1RTW2tleV0gJiYga2V5ID09PSAnaW1hZ2UnKVxuICAgICAgICAgICAgICAgIGFkZEltYWdlRGVmaW5pdGlvbih0Z3QsIG9iamVjdFtrZXldKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKE1BU1RFUl9PQkpFQ1RTW2tleV0gJiYga2V5ID09PSAnbGluZScpXG4gICAgICAgICAgICAgICAgYWRkU2hhcGVEZWZpbml0aW9uKHRndCwgU0hBUEVfVFlQRS5MSU5FLCBvYmplY3Rba2V5XSk7XG4gICAgICAgICAgICBlbHNlIGlmIChNQVNURVJfT0JKRUNUU1trZXldICYmIGtleSA9PT0gJ3JlY3QnKVxuICAgICAgICAgICAgICAgIGFkZFNoYXBlRGVmaW5pdGlvbih0Z3QsIFNIQVBFX1RZUEUuUkVDVEFOR0xFLCBvYmplY3Rba2V5XSk7XG4gICAgICAgICAgICBlbHNlIGlmIChNQVNURVJfT0JKRUNUU1trZXldICYmIGtleSA9PT0gJ3RleHQnKVxuICAgICAgICAgICAgICAgIGFkZFRleHREZWZpbml0aW9uKHRndCwgW3sgdGV4dDogb2JqZWN0W2tleV0udGV4dCB9XSwgb2JqZWN0W2tleV0ub3B0aW9ucywgZmFsc2UpO1xuICAgICAgICAgICAgZWxzZSBpZiAoTUFTVEVSX09CSkVDVFNba2V5XSAmJiBrZXkgPT09ICdwbGFjZWhvbGRlcicpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiAyMDE4MDgyMDogQ2hlY2sgZm9yIGV4aXN0aW5nIGBuYW1lYD9cbiAgICAgICAgICAgICAgICBvYmplY3Rba2V5XS5vcHRpb25zLnBsYWNlaG9sZGVyID0gb2JqZWN0W2tleV0ub3B0aW9ucy5uYW1lO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmplY3Rba2V5XS5vcHRpb25zLm5hbWU7IC8vIHJlbWFwIG5hbWUgZm9yIGVhcmllciBoYW5kbGluZyBpbnRlcm5hbGx5XG4gICAgICAgICAgICAgICAgb2JqZWN0W2tleV0ub3B0aW9ucy5fcGxhY2Vob2xkZXJUeXBlID0gb2JqZWN0W2tleV0ub3B0aW9ucy50eXBlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmplY3Rba2V5XS5vcHRpb25zLnR5cGU7IC8vIHJlbWFwIG5hbWUgZm9yIGVhcmllciBoYW5kbGluZyBpbnRlcm5hbGx5XG4gICAgICAgICAgICAgICAgb2JqZWN0W2tleV0ub3B0aW9ucy5fcGxhY2Vob2xkZXJJZHggPSAxMDAgKyBpZHg7XG4gICAgICAgICAgICAgICAgYWRkVGV4dERlZmluaXRpb24odGd0LCBbeyB0ZXh0OiBvYmplY3Rba2V5XS50ZXh0IH1dLCBvYmplY3Rba2V5XS5vcHRpb25zLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBJU1NVRSM1OTkgLSBvbmx5IHRleHQgaXMgc3Vwb3J0ZWQgbm93IChhZGQgbW9yZSBiZWxvdylcbiAgICAgICAgICAgICAgICAvLyBlbHNlIGlmIChvYmplY3Rba2V5XS5pbWFnZSkgYWRkSW1hZ2VEZWZpbml0aW9uKHRndCwgb2JqZWN0W2tleV0uaW1hZ2UpXG4gICAgICAgICAgICAgICAgLyogMjAyMDAxMjA6IFNvLi4uIGltYWdlIHBsYWNlaG9sZGVycyBnbyBpbnRvIHRoZSBcInNsaWRlTGF5b3V0Ti54bWxcIiBmaWxlIGFuZCBhZGRJbWFnZSBkb2VzbnQgZG8gdGhpcyB5ZXQuLi5cbiAgICAgICAgICAgICAgICAgICAgPHA6c3A+XG4gICAgICAgICAgICAgICAgICA8cDpudlNwUHI+XG4gICAgICAgICAgICAgICAgICAgIDxwOmNOdlByIGlkPVwiN1wiIG5hbWU9XCJQaWN0dXJlIFBsYWNlaG9sZGVyIDZcIj5cbiAgICAgICAgICAgICAgICAgICAgICA8YTpleHRMc3Q+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YTpleHQgdXJpPVwie0ZGMkI1RUY0LUZGRjItNDBCNC1CRTQ5LUYyMzhFMjdGQzIzNn1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPGExNjpjcmVhdGlvbklkIHhtbG5zOmExNj1cImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL2RyYXdpbmcvMjAxNC9tYWluXCIgaWQ9XCJ7Q0UxQUU0NUQtODY0MS0wRjRGLUJEQjUtMDgwRTY5Q0NCMDM0fVwiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYTpleHQ+XG4gICAgICAgICAgICAgICAgICAgICAgPC9hOmV4dExzdD5cbiAgICAgICAgICAgICAgICAgICAgPC9wOmNOdlByPlxuICAgICAgICAgICAgICAgICAgICA8cDpjTnZTcFByPlxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBTVEVQIDM6IEFkZCBTbGlkZSBOdW1iZXJzIChOT1RFOiBEbyB0aGlzIGxhc3Qgc28gbnVtYmVycyBhcmUgbm90IGNvdmVyZWQgYnkgb2JqZWN0cyEpXG4gICAgaWYgKHByb3BzLnNsaWRlTnVtYmVyICYmIHR5cGVvZiBwcm9wcy5zbGlkZU51bWJlciA9PT0gJ29iamVjdCcpXG4gICAgICAgIHRhcmdldC5fc2xpZGVOdW1iZXJQcm9wcyA9IHByb3BzLnNsaWRlTnVtYmVyO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgY2hhcnQgYmFzZWQgb24gaW5wdXQgZGF0YS5cbiAqIE9PWE1MIENoYXJ0IFNwZWM6IElTTy9JRUMgMjk1MDAtMToyMDE2KEUpXG4gKlxuICogQHBhcmFtIHtDSEFSVF9OQU1FIHwgSUNoYXJ0TXVsdGlbXX0gYHR5cGVgIHNob3VsZCBiZWxvbmcgdG86ICdjb2x1bW4nLCAncGllJ1xuICogQHBhcmFtIHtbXX0gYGRhdGFgIGEgSlNPTiBvYmplY3Qgd2l0aCBmb2xsb3cgdGhlIGZvbGxvd2luZyBmb3JtYXRcbiAqIEBwYXJhbSB7SUNoYXJ0T3B0c0xpYn0gYG9wdGAgY2hhcnQgb3B0aW9uc1xuICogQHBhcmFtIHtQcmVzU2xpZGV9IGB0YXJnZXRgIHNsaWRlIG9iamVjdCB0aGF0IHRoZSBjaGFydCB3aWxsIGJlIGFkZGVkIHRvXG4gKiBAcmV0dXJuIHtvYmplY3R9IGNoYXJ0IG9iamVjdFxuICoge1xuICogICAgdGl0bGU6ICdlU3VydmV5IGNoYXJ0JyxcbiAqICAgIGRhdGE6IFtcbiAqICAgICAgICB7XG4gKiAgICAgICAgICAgIG5hbWU6ICdJbmNvbWUnLFxuICogICAgICAgICAgICBsYWJlbHM6IFsnMjAwNScsICcyMDA2JywgJzIwMDcnLCAnMjAwOCcsICcyMDA5J10sXG4gKiAgICAgICAgICAgIHZhbHVlczogWzIzLjUsIDI2LjIsIDMwLjEsIDI5LjUsIDI0LjZdXG4gKiAgICAgICAgfSxcbiAqICAgICAgICB7XG4gKiAgICAgICAgICAgIG5hbWU6ICdFeHBlbnNlJyxcbiAqICAgICAgICAgICAgbGFiZWxzOiBbJzIwMDUnLCAnMjAwNicsICcyMDA3JywgJzIwMDgnLCAnMjAwOSddLFxuICogICAgICAgICAgICB2YWx1ZXM6IFsxOC4xLCAyMi44LCAyMy45LCAyNS4xLCAyNV1cbiAqICAgICAgICB9XG4gKiAgICBdXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGFkZENoYXJ0RGVmaW5pdGlvbih0YXJnZXQsIHR5cGUsIGRhdGEsIG9wdCkge1xuICAgIHZhciBfYTtcbiAgICBmdW5jdGlvbiBjb3JyZWN0R3JpZExpbmVPcHRpb25zKGdsT3B0cykge1xuICAgICAgICBpZiAoIWdsT3B0cyB8fCBnbE9wdHMuc3R5bGUgPT09ICdub25lJylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGdsT3B0cy5zaXplICE9PSB1bmRlZmluZWQgJiYgKGlzTmFOKE51bWJlcihnbE9wdHMuc2l6ZSkpIHx8IGdsT3B0cy5zaXplIDw9IDApKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IGNoYXJ0LmdyaWRMaW5lLnNpemUgbXVzdCBiZSBncmVhdGVyIHRoYW4gMC4nKTtcbiAgICAgICAgICAgIGRlbGV0ZSBnbE9wdHMuc2l6ZTsgLy8gZGVsZXRlIHByb3AgdG8gdXNlZCBkZWZhdWx0c1xuICAgICAgICB9XG4gICAgICAgIGlmIChnbE9wdHMuc3R5bGUgJiYgIVsnc29saWQnLCAnZGFzaCcsICdkb3QnXS5pbmNsdWRlcyhnbE9wdHMuc3R5bGUpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IGNoYXJ0LmdyaWRMaW5lLnN0eWxlIG9wdGlvbnM6IGBzb2xpZGAsIGBkYXNoYCwgYGRvdGAuJyk7XG4gICAgICAgICAgICBkZWxldGUgZ2xPcHRzLnN0eWxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnbE9wdHMuY2FwICYmICFbJ2ZsYXQnLCAnc3F1YXJlJywgJ3JvdW5kJ10uaW5jbHVkZXMoZ2xPcHRzLmNhcCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignV2FybmluZzogY2hhcnQuZ3JpZExpbmUuY2FwIG9wdGlvbnM6IGBmbGF0YCwgYHNxdWFyZWAsIGByb3VuZGAuJyk7XG4gICAgICAgICAgICBkZWxldGUgZ2xPcHRzLmNhcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjaGFydElkID0gKytfY2hhcnRDb3VudGVyO1xuICAgIGNvbnN0IHJlc3VsdE9iamVjdCA9IHtcbiAgICAgICAgX3R5cGU6IG51bGwsXG4gICAgICAgIHRleHQ6IG51bGwsXG4gICAgICAgIG9wdGlvbnM6IG51bGwsXG4gICAgICAgIGNoYXJ0UmlkOiBudWxsLFxuICAgIH07XG4gICAgLy8gREVTSUdOOiBgdHlwZWAgY2FuIGFuIG9iamVjdCAoZXg6IGBwcHR4LmNoYXJ0cy5ET1VHSE5VVGApIG9yIGFuIGFycmF5IG9mIGNoYXJ0IG9iamVjdHNcbiAgICAvLyBFWDogYWRkQ2hhcnREZWZpbml0aW9uKFsgeyB0eXBlOnBwdHguY2hhcnRzLkJBUiwgZGF0YTp7bmFtZTonJywgbGFiZWxzOltdLCB2YWx1ZXNbXX0gfSwgezxldGM+fSBdKVxuICAgIC8vIE11bHRpLVR5cGUgQ2hhcnRzXG4gICAgbGV0IHRtcE9wdCA9IG51bGw7XG4gICAgbGV0IHRtcERhdGEgPSBbXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgICAvLyBGb3IgbXVsdGktdHlwZSBjaGFydHMgdGhlcmUgbmVlZHMgdG8gYmUgZGF0YSBmb3IgZWFjaCB0eXBlLFxuICAgICAgICAvLyBhcyB3ZWxsIGFzIGEgc2luZ2xlIGRhdGEgc291cmNlIGZvciBub24tc2VyaWVzIG9wZXJhdGlvbnMuXG4gICAgICAgIC8vIFRoZSBkYXRhIGlzIGluZGV4ZWQgYmVsb3cgdG8ga2VlcCB0aGUgZGF0YSBpbiBvcmRlciB3aGVuIHNlZ21lbnRlZFxuICAgICAgICAvLyBpbnRvIHR5cGVzLlxuICAgICAgICB0eXBlLmZvckVhY2gob2JqID0+IHtcbiAgICAgICAgICAgIHRtcERhdGEgPSB0bXBEYXRhLmNvbmNhdChvYmouZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0bXBPcHQgPSBkYXRhIHx8IG9wdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRtcERhdGEgPSBkYXRhO1xuICAgICAgICB0bXBPcHQgPSBvcHQ7XG4gICAgfVxuICAgIHRtcERhdGEuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICBpdGVtLl9kYXRhSW5kZXggPSBpO1xuICAgICAgICAvLyBDb252ZXJ0cyB0aGUgJ2xhYmVscycgYXJyYXkgZnJvbSBzdHJpbmdbXSB0byBzdHJpbmdbXVtdIChvciB0aGUgcmVzcGVjdGl2ZSBwcmltaXRpdmUgdHlwZSksIGlmIG5lZWRlZFxuICAgICAgICBpZiAoaXRlbS5sYWJlbHMgIT09IHVuZGVmaW5lZCAmJiAhQXJyYXkuaXNBcnJheShpdGVtLmxhYmVsc1swXSkpIHtcbiAgICAgICAgICAgIGl0ZW0ubGFiZWxzID0gW2l0ZW0ubGFiZWxzXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0bXBPcHQgJiYgdHlwZW9mIHRtcE9wdCA9PT0gJ29iamVjdCcgPyB0bXBPcHQgOiB7fTtcbiAgICAvLyBTVEVQIDE6IFRPRE86IGNoZWNrIGZvciByZXFkIGZpZWxkcywgY29ycmVjdCB0eXBlLCBldGNcbiAgICAvLyBgdHlwZWAgZXhpc3RzIGluIENIQVJUX1RZUEVcbiAgICAvLyBBcnJheS5pc0FycmF5KGRhdGEpXG4gICAgLypcbiAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KHJlbC5kYXRhKSAmJiByZWwuZGF0YS5sZW5ndGggPiAwICYmIHR5cGVvZiByZWwuZGF0YVswXSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICYmIHJlbC5kYXRhWzBdLmxhYmVscyAmJiBBcnJheS5pc0FycmF5KHJlbC5kYXRhWzBdLmxhYmVscylcbiAgICAgICAgICAgICYmIHJlbC5kYXRhWzBdLnZhbHVlcyAmJiBBcnJheS5pc0FycmF5KHJlbC5kYXRhWzBdLnZhbHVlcykgKSB7XG4gICAgICAgICAgICBvYmogPSByZWwuZGF0YVswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVTQUdFOiBhZGRDaGFydCggJ3BpZScsIFsge25hbWU6J1NhbGVzJywgbGFiZWxzOlsnSmFuJywnRmViJ10sIHZhbHVlczpbMTAsMjBdfSBdLCB7eDoxLCB5OjF9IClcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAvLyBTVEVQIDI6IFNldCBkZWZhdWx0IG9wdGlvbnMvZGVjb2RlIHVzZXIgb3B0aW9uc1xuICAgIC8vIEE6IENvcmVcbiAgICBvcHRpb25zLl90eXBlID0gdHlwZTtcbiAgICBvcHRpb25zLnggPSB0eXBlb2Ygb3B0aW9ucy54ICE9PSAndW5kZWZpbmVkJyAmJiBvcHRpb25zLnggIT0gbnVsbCAmJiAhaXNOYU4oTnVtYmVyKG9wdGlvbnMueCkpID8gb3B0aW9ucy54IDogMTtcbiAgICBvcHRpb25zLnkgPSB0eXBlb2Ygb3B0aW9ucy55ICE9PSAndW5kZWZpbmVkJyAmJiBvcHRpb25zLnkgIT0gbnVsbCAmJiAhaXNOYU4oTnVtYmVyKG9wdGlvbnMueSkpID8gb3B0aW9ucy55IDogMTtcbiAgICBvcHRpb25zLncgPSBvcHRpb25zLncgfHwgJzUwJSc7XG4gICAgb3B0aW9ucy5oID0gb3B0aW9ucy5oIHx8ICc1MCUnO1xuICAgIG9wdGlvbnMub2JqZWN0TmFtZSA9IG9wdGlvbnMub2JqZWN0TmFtZVxuICAgICAgICA/IGVuY29kZVhtbEVudGl0aWVzKG9wdGlvbnMub2JqZWN0TmFtZSlcbiAgICAgICAgOiBgQ2hhcnQgJHt0YXJnZXQuX3NsaWRlT2JqZWN0cy5maWx0ZXIob2JqID0+IG9iai5fdHlwZSA9PT0gU0xJREVfT0JKRUNUX1RZUEVTLmNoYXJ0KS5sZW5ndGh9YDtcbiAgICAvLyBCOiBPcHRpb25zOiBtaXNjXG4gICAgaWYgKCFbJ2JhcicsICdjb2wnXS5pbmNsdWRlcyhvcHRpb25zLmJhckRpciB8fCAnJykpXG4gICAgICAgIG9wdGlvbnMuYmFyRGlyID0gJ2NvbCc7XG4gICAgLy8gYmFyR3JvdXBpbmc6IFwiMjEuMi4zLjE3IFNUX0dyb3VwaW5nIChHcm91cGluZylcIlxuICAgIC8vIGJhckdyb3VwaW5nIG11c3QgYmUgaGFuZGxlZCBiZWZvcmUgZGF0YSBsYWJlbCB2YWxpZGF0aW9uIGFzIGl0IGNhbiBhZmZlY3QgdmFsaWQgbGFiZWwgcG9zaXRpb25pbmdcbiAgICBpZiAob3B0aW9ucy5fdHlwZSA9PT0gQ0hBUlRfVFlQRS5BUkVBKSB7XG4gICAgICAgIGlmICghWydzdGFja2VkJywgJ3N0YW5kYXJkJywgJ3BlcmNlbnRTdGFja2VkJ10uaW5jbHVkZXMob3B0aW9ucy5iYXJHcm91cGluZyB8fCAnJykpXG4gICAgICAgICAgICBvcHRpb25zLmJhckdyb3VwaW5nID0gJ3N0YW5kYXJkJztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuX3R5cGUgPT09IENIQVJUX1RZUEUuQkFSKSB7XG4gICAgICAgIGlmICghWydjbHVzdGVyZWQnLCAnc3RhY2tlZCcsICdwZXJjZW50U3RhY2tlZCddLmluY2x1ZGVzKG9wdGlvbnMuYmFyR3JvdXBpbmcgfHwgJycpKVxuICAgICAgICAgICAgb3B0aW9ucy5iYXJHcm91cGluZyA9ICdjbHVzdGVyZWQnO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5fdHlwZSA9PT0gQ0hBUlRfVFlQRS5CQVIzRCkge1xuICAgICAgICBpZiAoIVsnY2x1c3RlcmVkJywgJ3N0YWNrZWQnLCAnc3RhbmRhcmQnLCAncGVyY2VudFN0YWNrZWQnXS5pbmNsdWRlcyhvcHRpb25zLmJhckdyb3VwaW5nIHx8ICcnKSlcbiAgICAgICAgICAgIG9wdGlvbnMuYmFyR3JvdXBpbmcgPSAnc3RhbmRhcmQnO1xuICAgIH1cbiAgICBpZiAoKF9hID0gb3B0aW9ucy5iYXJHcm91cGluZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKCd0YWNrZWQnKSkge1xuICAgICAgICBpZiAoIW9wdGlvbnMuYmFyR2FwV2lkdGhQY3QpXG4gICAgICAgICAgICBvcHRpb25zLmJhckdhcFdpZHRoUGN0ID0gNTA7XG4gICAgfVxuICAgIC8vIENsZWFuIHVwIGFuZCB2YWxpZGF0ZSBkYXRhIGxhYmVsIHBvc2l0aW9uc1xuICAgIC8vIFJFRkVSRU5DRTogaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvb3BlbnNwZWNzL29mZmljZV9zdGFuZGFyZHMvbXMtb2kyOTUwMC9lMmIxNjk3Yy03YWRjLTQ2M2QtOTA4MS0zZGFlZjcyZjY1NmY/cmVkaXJlY3RlZGZyb209TVNETlxuICAgIGlmIChvcHRpb25zLmRhdGFMYWJlbFBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChvcHRpb25zLl90eXBlID09PSBDSEFSVF9UWVBFLkFSRUEgfHwgb3B0aW9ucy5fdHlwZSA9PT0gQ0hBUlRfVFlQRS5CQVIzRCB8fCBvcHRpb25zLl90eXBlID09PSBDSEFSVF9UWVBFLkRPVUdITlVUIHx8IG9wdGlvbnMuX3R5cGUgPT09IENIQVJUX1RZUEUuUkFEQVIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGFMYWJlbFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLl90eXBlID09PSBDSEFSVF9UWVBFLlBJRSkge1xuICAgICAgICAgICAgaWYgKCFbJ2Jlc3RGaXQnLCAnY3RyJywgJ2luRW5kJywgJ291dEVuZCddLmluY2x1ZGVzKG9wdGlvbnMuZGF0YUxhYmVsUG9zaXRpb24pKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGFMYWJlbFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLl90eXBlID09PSBDSEFSVF9UWVBFLkJVQkJMRSB8fCBvcHRpb25zLl90eXBlID09PSBDSEFSVF9UWVBFLkJVQkJMRTNEIHx8IG9wdGlvbnMuX3R5cGUgPT09IENIQVJUX1RZUEUuTElORSB8fCBvcHRpb25zLl90eXBlID09PSBDSEFSVF9UWVBFLlNDQVRURVIpIHtcbiAgICAgICAgICAgIGlmICghWydiJywgJ2N0cicsICdsJywgJ3InLCAndCddLmluY2x1ZGVzKG9wdGlvbnMuZGF0YUxhYmVsUG9zaXRpb24pKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGFMYWJlbFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLl90eXBlID09PSBDSEFSVF9UWVBFLkJBUikge1xuICAgICAgICAgICAgaWYgKCFbJ3N0YWNrZWQnLCAncGVyY2VudFN0YWNrZWQnXS5pbmNsdWRlcyhvcHRpb25zLmJhckdyb3VwaW5nIHx8ICcnKSkge1xuICAgICAgICAgICAgICAgIGlmICghWydjdHInLCAnaW5CYXNlJywgJ2luRW5kJ10uaW5jbHVkZXMob3B0aW9ucy5kYXRhTGFiZWxQb3NpdGlvbikpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGFMYWJlbFBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFbJ2NsdXN0ZXJlZCddLmluY2x1ZGVzKG9wdGlvbnMuYmFyR3JvdXBpbmcgfHwgJycpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFbJ2N0cicsICdpbkJhc2UnLCAnaW5FbmQnLCAnb3V0RW5kJ10uaW5jbHVkZXMob3B0aW9ucy5kYXRhTGFiZWxQb3NpdGlvbikpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGFMYWJlbFBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG9wdGlvbnMuZGF0YUxhYmVsQmtncmRDb2xvcnMgPSBvcHRpb25zLmRhdGFMYWJlbEJrZ3JkQ29sb3JzIHx8ICFvcHRpb25zLmRhdGFMYWJlbEJrZ3JkQ29sb3JzID8gb3B0aW9ucy5kYXRhTGFiZWxCa2dyZENvbG9ycyA6IGZhbHNlO1xuICAgIGlmICghWydiJywgJ2wnLCAncicsICd0JywgJ3RyJ10uaW5jbHVkZXMob3B0aW9ucy5sZWdlbmRQb3MgfHwgJycpKVxuICAgICAgICBvcHRpb25zLmxlZ2VuZFBvcyA9ICdyJztcbiAgICAvLyAzRCBiYXI6IFNUX1NoYXBlXG4gICAgaWYgKCFbJ2NvbmUnLCAnY29uZVRvTWF4JywgJ2JveCcsICdjeWxpbmRlcicsICdweXJhbWlkJywgJ3B5cmFtaWRUb01heCddLmluY2x1ZGVzKG9wdGlvbnMuYmFyM0RTaGFwZSB8fCAnJykpXG4gICAgICAgIG9wdGlvbnMuYmFyM0RTaGFwZSA9ICdib3gnO1xuICAgIC8vIGxpbmVEYXRhU3ltYm9sOiBodHRwOi8vd3d3LmRhdHlwaWMuY29tL3NjL29veG1sL2EtdmFsLTMyLmh0bWxcbiAgICAvLyBTcGVjIGhhcyBbcGx1cyxzdGFyLHhdIGhvd2V2ZXIgbmVpdGhlciBQUFQyMDEzIG5vciBQUFQtT25saW5lIHN1cHBvcnQgdGhlbVxuICAgIGlmICghWydjaXJjbGUnLCAnZGFzaCcsICdkaWFtb25kJywgJ2RvdCcsICdub25lJywgJ3NxdWFyZScsICd0cmlhbmdsZSddLmluY2x1ZGVzKG9wdGlvbnMubGluZURhdGFTeW1ib2wgfHwgJycpKVxuICAgICAgICBvcHRpb25zLmxpbmVEYXRhU3ltYm9sID0gJ2NpcmNsZSc7XG4gICAgaWYgKCFbJ2dhcCcsICdzcGFuJ10uaW5jbHVkZXMob3B0aW9ucy5kaXNwbGF5QmxhbmtzQXMgfHwgJycpKVxuICAgICAgICBvcHRpb25zLmRpc3BsYXlCbGFua3NBcyA9ICdzcGFuJztcbiAgICBpZiAoIVsnc3RhbmRhcmQnLCAnbWFya2VyJywgJ2ZpbGxlZCddLmluY2x1ZGVzKG9wdGlvbnMucmFkYXJTdHlsZSB8fCAnJykpXG4gICAgICAgIG9wdGlvbnMucmFkYXJTdHlsZSA9ICdzdGFuZGFyZCc7XG4gICAgb3B0aW9ucy5saW5lRGF0YVN5bWJvbFNpemUgPSBvcHRpb25zLmxpbmVEYXRhU3ltYm9sU2l6ZSAmJiAhaXNOYU4ob3B0aW9ucy5saW5lRGF0YVN5bWJvbFNpemUpID8gb3B0aW9ucy5saW5lRGF0YVN5bWJvbFNpemUgOiA2O1xuICAgIG9wdGlvbnMubGluZURhdGFTeW1ib2xMaW5lU2l6ZSA9IG9wdGlvbnMubGluZURhdGFTeW1ib2xMaW5lU2l6ZSAmJiAhaXNOYU4ob3B0aW9ucy5saW5lRGF0YVN5bWJvbExpbmVTaXplKSA/IHZhbFRvUHRzKG9wdGlvbnMubGluZURhdGFTeW1ib2xMaW5lU2l6ZSkgOiB2YWxUb1B0cygwLjc1KTtcbiAgICAvLyBgbGF5b3V0YCBhbGxvd3MgdGhlIG92ZXJyaWRlIG9mIFBQVCBkZWZhdWx0cyB0byBtYXhpbWl6ZSBzcGFjZVxuICAgIGlmIChvcHRpb25zLmxheW91dCkge1xuICAgICAgICBbJ3gnLCAneScsICd3JywgJ2gnXS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBvcHRpb25zLmxheW91dFtrZXldO1xuICAgICAgICAgICAgaWYgKGlzTmFOKE51bWJlcih2YWwpKSB8fCB2YWwgPCAwIHx8IHZhbCA+IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IGNoYXJ0LmxheW91dC4nICsga2V5ICsgJyBjYW4gb25seSBiZSAwLTEnKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5sYXlvdXRba2V5XTsgLy8gcmVtb3ZlIGludmFsaWQgdmFsdWUgc28gdGhhdCBkZWZhdWx0IHdpbGwgYmUgdXNlZFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gU2V0IGdyaWRsaW5lIGRlZmF1bHRzXG4gICAgb3B0aW9ucy5jYXRHcmlkTGluZSA9IG9wdGlvbnMuY2F0R3JpZExpbmUgfHwgKG9wdGlvbnMuX3R5cGUgPT09IENIQVJUX1RZUEUuU0NBVFRFUiA/IHsgY29sb3I6ICdEOUQ5RDknLCBzaXplOiAxIH0gOiB7IHN0eWxlOiAnbm9uZScgfSk7XG4gICAgb3B0aW9ucy52YWxHcmlkTGluZSA9IG9wdGlvbnMudmFsR3JpZExpbmUgfHwgKG9wdGlvbnMuX3R5cGUgPT09IENIQVJUX1RZUEUuU0NBVFRFUiA/IHsgY29sb3I6ICdEOUQ5RDknLCBzaXplOiAxIH0gOiB7fSk7XG4gICAgb3B0aW9ucy5zZXJHcmlkTGluZSA9IG9wdGlvbnMuc2VyR3JpZExpbmUgfHwgKG9wdGlvbnMuX3R5cGUgPT09IENIQVJUX1RZUEUuU0NBVFRFUiA/IHsgY29sb3I6ICdEOUQ5RDknLCBzaXplOiAxIH0gOiB7IHN0eWxlOiAnbm9uZScgfSk7XG4gICAgY29ycmVjdEdyaWRMaW5lT3B0aW9ucyhvcHRpb25zLmNhdEdyaWRMaW5lKTtcbiAgICBjb3JyZWN0R3JpZExpbmVPcHRpb25zKG9wdGlvbnMudmFsR3JpZExpbmUpO1xuICAgIGNvcnJlY3RHcmlkTGluZU9wdGlvbnMob3B0aW9ucy5zZXJHcmlkTGluZSk7XG4gICAgY29ycmVjdFNoYWRvd09wdGlvbnMob3B0aW9ucy5zaGFkb3cpO1xuICAgIC8vIEM6IE9wdGlvbnM6IHBsb3RBcmVhXG4gICAgb3B0aW9ucy5zaG93RGF0YVRhYmxlID0gb3B0aW9ucy5zaG93RGF0YVRhYmxlIHx8ICFvcHRpb25zLnNob3dEYXRhVGFibGUgPyBvcHRpb25zLnNob3dEYXRhVGFibGUgOiBmYWxzZTtcbiAgICBvcHRpb25zLnNob3dEYXRhVGFibGVIb3J6Qm9yZGVyID0gb3B0aW9ucy5zaG93RGF0YVRhYmxlSG9yekJvcmRlciB8fCAhb3B0aW9ucy5zaG93RGF0YVRhYmxlSG9yekJvcmRlciA/IG9wdGlvbnMuc2hvd0RhdGFUYWJsZUhvcnpCb3JkZXIgOiB0cnVlO1xuICAgIG9wdGlvbnMuc2hvd0RhdGFUYWJsZVZlcnRCb3JkZXIgPSBvcHRpb25zLnNob3dEYXRhVGFibGVWZXJ0Qm9yZGVyIHx8ICFvcHRpb25zLnNob3dEYXRhVGFibGVWZXJ0Qm9yZGVyID8gb3B0aW9ucy5zaG93RGF0YVRhYmxlVmVydEJvcmRlciA6IHRydWU7XG4gICAgb3B0aW9ucy5zaG93RGF0YVRhYmxlT3V0bGluZSA9IG9wdGlvbnMuc2hvd0RhdGFUYWJsZU91dGxpbmUgfHwgIW9wdGlvbnMuc2hvd0RhdGFUYWJsZU91dGxpbmUgPyBvcHRpb25zLnNob3dEYXRhVGFibGVPdXRsaW5lIDogdHJ1ZTtcbiAgICBvcHRpb25zLnNob3dEYXRhVGFibGVLZXlzID0gb3B0aW9ucy5zaG93RGF0YVRhYmxlS2V5cyB8fCAhb3B0aW9ucy5zaG93RGF0YVRhYmxlS2V5cyA/IG9wdGlvbnMuc2hvd0RhdGFUYWJsZUtleXMgOiB0cnVlO1xuICAgIG9wdGlvbnMuc2hvd0xhYmVsID0gb3B0aW9ucy5zaG93TGFiZWwgfHwgIW9wdGlvbnMuc2hvd0xhYmVsID8gb3B0aW9ucy5zaG93TGFiZWwgOiBmYWxzZTtcbiAgICBvcHRpb25zLnNob3dMZWdlbmQgPSBvcHRpb25zLnNob3dMZWdlbmQgfHwgIW9wdGlvbnMuc2hvd0xlZ2VuZCA/IG9wdGlvbnMuc2hvd0xlZ2VuZCA6IGZhbHNlO1xuICAgIG9wdGlvbnMuc2hvd1BlcmNlbnQgPSBvcHRpb25zLnNob3dQZXJjZW50IHx8ICFvcHRpb25zLnNob3dQZXJjZW50ID8gb3B0aW9ucy5zaG93UGVyY2VudCA6IHRydWU7XG4gICAgb3B0aW9ucy5zaG93VGl0bGUgPSBvcHRpb25zLnNob3dUaXRsZSB8fCAhb3B0aW9ucy5zaG93VGl0bGUgPyBvcHRpb25zLnNob3dUaXRsZSA6IGZhbHNlO1xuICAgIG9wdGlvbnMuc2hvd1ZhbHVlID0gb3B0aW9ucy5zaG93VmFsdWUgfHwgIW9wdGlvbnMuc2hvd1ZhbHVlID8gb3B0aW9ucy5zaG93VmFsdWUgOiBmYWxzZTtcbiAgICBvcHRpb25zLnNob3dMZWFkZXJMaW5lcyA9IG9wdGlvbnMuc2hvd0xlYWRlckxpbmVzIHx8ICFvcHRpb25zLnNob3dMZWFkZXJMaW5lcyA/IG9wdGlvbnMuc2hvd0xlYWRlckxpbmVzIDogZmFsc2U7XG4gICAgb3B0aW9ucy5jYXRBeGlzTGluZVNob3cgPSB0eXBlb2Ygb3B0aW9ucy5jYXRBeGlzTGluZVNob3cgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5jYXRBeGlzTGluZVNob3cgOiB0cnVlO1xuICAgIG9wdGlvbnMudmFsQXhpc0xpbmVTaG93ID0gdHlwZW9mIG9wdGlvbnMudmFsQXhpc0xpbmVTaG93ICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMudmFsQXhpc0xpbmVTaG93IDogdHJ1ZTtcbiAgICBvcHRpb25zLnNlckF4aXNMaW5lU2hvdyA9IHR5cGVvZiBvcHRpb25zLnNlckF4aXNMaW5lU2hvdyAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnNlckF4aXNMaW5lU2hvdyA6IHRydWU7XG4gICAgb3B0aW9ucy52M0RSb3RYID0gIWlzTmFOKG9wdGlvbnMudjNEUm90WCkgJiYgb3B0aW9ucy52M0RSb3RYID49IC05MCAmJiBvcHRpb25zLnYzRFJvdFggPD0gOTAgPyBvcHRpb25zLnYzRFJvdFggOiAzMDtcbiAgICBvcHRpb25zLnYzRFJvdFkgPSAhaXNOYU4ob3B0aW9ucy52M0RSb3RZKSAmJiBvcHRpb25zLnYzRFJvdFkgPj0gMCAmJiBvcHRpb25zLnYzRFJvdFkgPD0gMzYwID8gb3B0aW9ucy52M0RSb3RZIDogMzA7XG4gICAgb3B0aW9ucy52M0RSQW5nQXggPSBvcHRpb25zLnYzRFJBbmdBeCB8fCAhb3B0aW9ucy52M0RSQW5nQXggPyBvcHRpb25zLnYzRFJBbmdBeCA6IHRydWU7XG4gICAgb3B0aW9ucy52M0RQZXJzcGVjdGl2ZSA9ICFpc05hTihvcHRpb25zLnYzRFBlcnNwZWN0aXZlKSAmJiBvcHRpb25zLnYzRFBlcnNwZWN0aXZlID49IDAgJiYgb3B0aW9ucy52M0RQZXJzcGVjdGl2ZSA8PSAyNDAgPyBvcHRpb25zLnYzRFBlcnNwZWN0aXZlIDogMzA7XG4gICAgLy8gRDogT3B0aW9uczogY2hhcnRcbiAgICBvcHRpb25zLmJhckdhcFdpZHRoUGN0ID0gIWlzTmFOKG9wdGlvbnMuYmFyR2FwV2lkdGhQY3QpICYmIG9wdGlvbnMuYmFyR2FwV2lkdGhQY3QgPj0gMCAmJiBvcHRpb25zLmJhckdhcFdpZHRoUGN0IDw9IDEwMDAgPyBvcHRpb25zLmJhckdhcFdpZHRoUGN0IDogMTUwO1xuICAgIG9wdGlvbnMuYmFyR2FwRGVwdGhQY3QgPSAhaXNOYU4ob3B0aW9ucy5iYXJHYXBEZXB0aFBjdCkgJiYgb3B0aW9ucy5iYXJHYXBEZXB0aFBjdCA+PSAwICYmIG9wdGlvbnMuYmFyR2FwRGVwdGhQY3QgPD0gMTAwMCA/IG9wdGlvbnMuYmFyR2FwRGVwdGhQY3QgOiAxNTA7XG4gICAgb3B0aW9ucy5jaGFydENvbG9ycyA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5jaGFydENvbG9ycylcbiAgICAgICAgPyBvcHRpb25zLmNoYXJ0Q29sb3JzXG4gICAgICAgIDogb3B0aW9ucy5fdHlwZSA9PT0gQ0hBUlRfVFlQRS5QSUUgfHwgb3B0aW9ucy5fdHlwZSA9PT0gQ0hBUlRfVFlQRS5ET1VHSE5VVFxuICAgICAgICAgICAgPyBQSUVDSEFSVF9DT0xPUlNcbiAgICAgICAgICAgIDogQkFSQ0hBUlRfQ09MT1JTO1xuICAgIG9wdGlvbnMuY2hhcnRDb2xvcnNPcGFjaXR5ID0gb3B0aW9ucy5jaGFydENvbG9yc09wYWNpdHkgJiYgIWlzTmFOKG9wdGlvbnMuY2hhcnRDb2xvcnNPcGFjaXR5KSA/IG9wdGlvbnMuY2hhcnRDb2xvcnNPcGFjaXR5IDogbnVsbDtcbiAgICAvLyBERVBSRUNBVEVEOiB2My4xMS4wIC0gdXNlIGBwbG90QXJlYS5ib3JkZXJgIHZ2dlxuICAgIG9wdGlvbnMuYm9yZGVyID0gb3B0aW9ucy5ib3JkZXIgJiYgdHlwZW9mIG9wdGlvbnMuYm9yZGVyID09PSAnb2JqZWN0JyA/IG9wdGlvbnMuYm9yZGVyIDogbnVsbDtcbiAgICBpZiAob3B0aW9ucy5ib3JkZXIgJiYgKCFvcHRpb25zLmJvcmRlci5wdCB8fCBpc05hTihvcHRpb25zLmJvcmRlci5wdCkpKVxuICAgICAgICBvcHRpb25zLmJvcmRlci5wdCA9IERFRl9DSEFSVF9CT1JERVIucHQ7XG4gICAgaWYgKG9wdGlvbnMuYm9yZGVyICYmICghb3B0aW9ucy5ib3JkZXIuY29sb3IgfHwgdHlwZW9mIG9wdGlvbnMuYm9yZGVyLmNvbG9yICE9PSAnc3RyaW5nJykpXG4gICAgICAgIG9wdGlvbnMuYm9yZGVyLmNvbG9yID0gREVGX0NIQVJUX0JPUkRFUi5jb2xvcjtcbiAgICAvLyBERVBSRUNBVEVEOiAocmVtb3ZlIGFib3ZlIGluIHY0LjApIF5eXlxuICAgIG9wdGlvbnMucGxvdEFyZWEgPSBvcHRpb25zLnBsb3RBcmVhIHx8IHt9O1xuICAgIG9wdGlvbnMucGxvdEFyZWEuYm9yZGVyID0gb3B0aW9ucy5wbG90QXJlYS5ib3JkZXIgJiYgdHlwZW9mIG9wdGlvbnMucGxvdEFyZWEuYm9yZGVyID09PSAnb2JqZWN0JyA/IG9wdGlvbnMucGxvdEFyZWEuYm9yZGVyIDogbnVsbDtcbiAgICBpZiAob3B0aW9ucy5wbG90QXJlYS5ib3JkZXIgJiYgKCFvcHRpb25zLnBsb3RBcmVhLmJvcmRlci5wdCB8fCBpc05hTihvcHRpb25zLnBsb3RBcmVhLmJvcmRlci5wdCkpKVxuICAgICAgICBvcHRpb25zLnBsb3RBcmVhLmJvcmRlci5wdCA9IERFRl9DSEFSVF9CT1JERVIucHQ7XG4gICAgaWYgKG9wdGlvbnMucGxvdEFyZWEuYm9yZGVyICYmICghb3B0aW9ucy5wbG90QXJlYS5ib3JkZXIuY29sb3IgfHwgdHlwZW9mIG9wdGlvbnMucGxvdEFyZWEuYm9yZGVyLmNvbG9yICE9PSAnc3RyaW5nJykpIHtcbiAgICAgICAgb3B0aW9ucy5wbG90QXJlYS5ib3JkZXIuY29sb3IgPSBERUZfQ0hBUlRfQk9SREVSLmNvbG9yO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ib3JkZXIpXG4gICAgICAgIG9wdGlvbnMucGxvdEFyZWEuYm9yZGVyID0gb3B0aW9ucy5ib3JkZXI7IC8vIEBkZXByZWNhdGVkIFtbcmVtb3ZlIGluIHY0LjBdXVxuICAgIG9wdGlvbnMucGxvdEFyZWEuZmlsbCA9IG9wdGlvbnMucGxvdEFyZWEuZmlsbCB8fCB7IGNvbG9yOiBudWxsLCB0cmFuc3BhcmVuY3k6IG51bGwgfTtcbiAgICBpZiAob3B0aW9ucy5maWxsKVxuICAgICAgICBvcHRpb25zLnBsb3RBcmVhLmZpbGwuY29sb3IgPSBvcHRpb25zLmZpbGw7IC8vIEBkZXByZWNhdGVkIFtbcmVtb3ZlIGluIHY0LjBdXVxuICAgIC8vXG4gICAgb3B0aW9ucy5jaGFydEFyZWEgPSBvcHRpb25zLmNoYXJ0QXJlYSB8fCB7fTtcbiAgICBvcHRpb25zLmNoYXJ0QXJlYS5ib3JkZXIgPSBvcHRpb25zLmNoYXJ0QXJlYS5ib3JkZXIgJiYgdHlwZW9mIG9wdGlvbnMuY2hhcnRBcmVhLmJvcmRlciA9PT0gJ29iamVjdCcgPyBvcHRpb25zLmNoYXJ0QXJlYS5ib3JkZXIgOiBudWxsO1xuICAgIGlmIChvcHRpb25zLmNoYXJ0QXJlYS5ib3JkZXIpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFydEFyZWEuYm9yZGVyID0ge1xuICAgICAgICAgICAgY29sb3I6IG9wdGlvbnMuY2hhcnRBcmVhLmJvcmRlci5jb2xvciB8fCBERUZfQ0hBUlRfQk9SREVSLmNvbG9yLFxuICAgICAgICAgICAgcHQ6IG9wdGlvbnMuY2hhcnRBcmVhLmJvcmRlci5wdCB8fCBERUZfQ0hBUlRfQk9SREVSLnB0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBvcHRpb25zLmNoYXJ0QXJlYS5yb3VuZGVkQ29ybmVycyA9IHR5cGVvZiBvcHRpb25zLmNoYXJ0QXJlYS5yb3VuZGVkQ29ybmVycyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5jaGFydEFyZWEucm91bmRlZENvcm5lcnMgOiB0cnVlO1xuICAgIC8vXG4gICAgb3B0aW9ucy5kYXRhQm9yZGVyID0gb3B0aW9ucy5kYXRhQm9yZGVyICYmIHR5cGVvZiBvcHRpb25zLmRhdGFCb3JkZXIgPT09ICdvYmplY3QnID8gb3B0aW9ucy5kYXRhQm9yZGVyIDogbnVsbDtcbiAgICBpZiAob3B0aW9ucy5kYXRhQm9yZGVyICYmICghb3B0aW9ucy5kYXRhQm9yZGVyLnB0IHx8IGlzTmFOKG9wdGlvbnMuZGF0YUJvcmRlci5wdCkpKVxuICAgICAgICBvcHRpb25zLmRhdGFCb3JkZXIucHQgPSAwLjc1O1xuICAgIGlmIChvcHRpb25zLmRhdGFCb3JkZXIgJiYgb3B0aW9ucy5kYXRhQm9yZGVyLmNvbG9yKSB7XG4gICAgICAgIGNvbnN0IGlzSGV4Q29sb3IgPSB0eXBlb2Ygb3B0aW9ucy5kYXRhQm9yZGVyLmNvbG9yID09PSAnc3RyaW5nJyAmJiBvcHRpb25zLmRhdGFCb3JkZXIuY29sb3IubGVuZ3RoID09PSA2ICYmIC9eWzAtOUEtRmEtZl17Nn0kLy50ZXN0KG9wdGlvbnMuZGF0YUJvcmRlci5jb2xvcik7XG4gICAgICAgIGNvbnN0IGlzU2NoZW1lQ29sb3IgPSBPYmplY3QudmFsdWVzKFNDSEVNRV9DT0xPUl9OQU1FUykuaW5jbHVkZXMob3B0aW9ucy5kYXRhQm9yZGVyLmNvbG9yKTtcbiAgICAgICAgaWYgKCFpc0hleENvbG9yICYmICFpc1NjaGVtZUNvbG9yKSB7XG4gICAgICAgICAgICBvcHRpb25zLmRhdGFCb3JkZXIuY29sb3IgPSAnRjlGOUY5JzsgLy8gRmFsbGJhY2sgaWYgbmVpdGhlciBoZXggbm9yIHNjaGVtZSBjb2xvclxuICAgICAgICB9XG4gICAgfVxuICAgIC8vXG4gICAgaWYgKCFvcHRpb25zLmRhdGFMYWJlbEZvcm1hdENvZGUgJiYgb3B0aW9ucy5fdHlwZSA9PT0gQ0hBUlRfVFlQRS5TQ0FUVEVSKVxuICAgICAgICBvcHRpb25zLmRhdGFMYWJlbEZvcm1hdENvZGUgPSAnR2VuZXJhbCc7XG4gICAgaWYgKCFvcHRpb25zLmRhdGFMYWJlbEZvcm1hdENvZGUgJiYgKG9wdGlvbnMuX3R5cGUgPT09IENIQVJUX1RZUEUuUElFIHx8IG9wdGlvbnMuX3R5cGUgPT09IENIQVJUX1RZUEUuRE9VR0hOVVQpKSB7XG4gICAgICAgIG9wdGlvbnMuZGF0YUxhYmVsRm9ybWF0Q29kZSA9IG9wdGlvbnMuc2hvd1BlcmNlbnQgPyAnMCUnIDogJ0dlbmVyYWwnO1xuICAgIH1cbiAgICBvcHRpb25zLmRhdGFMYWJlbEZvcm1hdENvZGUgPSBvcHRpb25zLmRhdGFMYWJlbEZvcm1hdENvZGUgJiYgdHlwZW9mIG9wdGlvbnMuZGF0YUxhYmVsRm9ybWF0Q29kZSA9PT0gJ3N0cmluZycgPyBvcHRpb25zLmRhdGFMYWJlbEZvcm1hdENvZGUgOiAnIywjIzAnO1xuICAgIC8vXG4gICAgLy8gU2V0IGRlZmF1bHQgZm9ybWF0IGZvciBTY2F0dGVyIGNoYXJ0IGxhYmVscyB0byBjdXN0b20gc3RyaW5nIGlmIG5vdCBkZWZpbmVkXG4gICAgaWYgKCFvcHRpb25zLmRhdGFMYWJlbEZvcm1hdFNjYXR0ZXIgJiYgb3B0aW9ucy5fdHlwZSA9PT0gQ0hBUlRfVFlQRS5TQ0FUVEVSKVxuICAgICAgICBvcHRpb25zLmRhdGFMYWJlbEZvcm1hdFNjYXR0ZXIgPSAnY3VzdG9tJztcbiAgICAvL1xuICAgIG9wdGlvbnMubGluZVNpemUgPSB0eXBlb2Ygb3B0aW9ucy5saW5lU2l6ZSA9PT0gJ251bWJlcicgPyBvcHRpb25zLmxpbmVTaXplIDogMjtcbiAgICBvcHRpb25zLnZhbEF4aXNNYWpvclVuaXQgPSB0eXBlb2Ygb3B0aW9ucy52YWxBeGlzTWFqb3JVbml0ID09PSAnbnVtYmVyJyA/IG9wdGlvbnMudmFsQXhpc01ham9yVW5pdCA6IG51bGw7XG4gICAgaWYgKG9wdGlvbnMuX3R5cGUgPT09IENIQVJUX1RZUEUuQVJFQSB8fCBvcHRpb25zLl90eXBlID09PSBDSEFSVF9UWVBFLkJBUiB8fCBvcHRpb25zLl90eXBlID09PSBDSEFSVF9UWVBFLkJBUjNEIHx8IG9wdGlvbnMuX3R5cGUgPT09IENIQVJUX1RZUEUuTElORSkge1xuICAgICAgICBvcHRpb25zLmNhdEF4aXNNdWx0aUxldmVsTGFiZWxzID0gISFvcHRpb25zLmNhdEF4aXNNdWx0aUxldmVsTGFiZWxzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuY2F0QXhpc011bHRpTGV2ZWxMYWJlbHM7XG4gICAgfVxuICAgIC8vIFNURVAgNDogU2V0IHByb3BzXG4gICAgcmVzdWx0T2JqZWN0Ll90eXBlID0gJ2NoYXJ0JztcbiAgICByZXN1bHRPYmplY3Qub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgcmVzdWx0T2JqZWN0LmNoYXJ0UmlkID0gZ2V0TmV3UmVsSWQodGFyZ2V0KTtcbiAgICAvLyBTVEVQIDU6IEFkZCB0aGlzIGNoYXJ0IHRvIHRoaXMgU2xpZGUgUmVscyAocklkL3JlbHMgY291bnQgc3BhbnMgYWxsIHNsaWRlcyEgQ291bnQgYWxsIGltYWdlcyB0byBnZXQgbmV4dCBySWQpXG4gICAgdGFyZ2V0Ll9yZWxzQ2hhcnQucHVzaCh7XG4gICAgICAgIHJJZDogZ2V0TmV3UmVsSWQodGFyZ2V0KSxcbiAgICAgICAgZGF0YTogdG1wRGF0YSxcbiAgICAgICAgb3B0czogb3B0aW9ucyxcbiAgICAgICAgdHlwZTogb3B0aW9ucy5fdHlwZSxcbiAgICAgICAgZ2xvYmFsSWQ6IGNoYXJ0SWQsXG4gICAgICAgIGZpbGVOYW1lOiBgY2hhcnQke2NoYXJ0SWR9LnhtbGAsXG4gICAgICAgIFRhcmdldDogYC9wcHQvY2hhcnRzL2NoYXJ0JHtjaGFydElkfS54bWxgLFxuICAgIH0pO1xuICAgIHRhcmdldC5fc2xpZGVPYmplY3RzLnB1c2gocmVzdWx0T2JqZWN0KTtcbiAgICByZXR1cm4gcmVzdWx0T2JqZWN0O1xufVxuLyoqXG4gKiBBZGRzIGFuIGltYWdlIG9iamVjdCB0byBhIHNsaWRlIGRlZmluaXRpb24uXG4gKiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIHdpdGggb25seSB0d28gYXJncyAob3B0LCB0YXJnZXQpIC0gdGhpcyBpcyBzdXBwb3NlZCB0byBiZSB0aGUgb25seSB3YXkgaW4gZnV0dXJlLlxuICogQHBhcmFtIHtJbWFnZVByb3BzfSBgb3B0YCAtIG9iamVjdCBjb250YWluaW5nIGBwYXRoYC9gZGF0YWAsIGB4YCwgYHlgLCBldGMuXG4gKiBAcGFyYW0ge1ByZXNTbGlkZX0gYHRhcmdldGAgLSBzbGlkZSB0aGF0IHRoZSBpbWFnZSBzaG91bGQgYmUgYWRkZWQgdG8gKGlmIG5vdCBzcGVjaWZpZWQgYXMgdGhlIDJuZCBhcmcpXG4gKiBAbm90ZTogUmVtb3RlIGltYWdlcyAoZWc6IFwiaHR0cDovL3doYXRldi5jb20vYmxhaFwiL2Zyb20gd2ViIGFuZC9vciByZW1vdGUgc2VydmVyIGFyZW50IHN1cHBvcnRlZCB5ZXQgLSB3ZSdkIG5lZWQgdG8gY3JlYXRlIGFuIDxpbWc+LCBsb2FkIGl0LCB0aGVuIHNlbmQgdG8gY2FudmFzXG4gKiBAc2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNjQxODEvaG93LXRvLWZldGNoLWEtcmVtb3RlLWltYWdlLXRvLWRpc3BsYXktaW4tYS1jYW52YXMpXG4gKi9cbmZ1bmN0aW9uIGFkZEltYWdlRGVmaW5pdGlvbih0YXJnZXQsIG9wdCkge1xuICAgIGNvbnN0IG5ld09iamVjdCA9IHtcbiAgICAgICAgX3R5cGU6IG51bGwsXG4gICAgICAgIHRleHQ6IG51bGwsXG4gICAgICAgIG9wdGlvbnM6IG51bGwsXG4gICAgICAgIGltYWdlOiBudWxsLFxuICAgICAgICBpbWFnZVJpZDogbnVsbCxcbiAgICAgICAgaHlwZXJsaW5rOiBudWxsLFxuICAgIH07XG4gICAgLy8gRklSU1Q6IFNldCB2YXJzIGZvciB0aGlzIGltYWdlIChvYmplY3QgcGFyYW0gcmVwbGFjZXMgcG9zaXRpb25hbCBhcmdzIGluIDEuMS4wKVxuICAgIGNvbnN0IGludFBvc1ggPSBvcHQueCB8fCAwO1xuICAgIGNvbnN0IGludFBvc1kgPSBvcHQueSB8fCAwO1xuICAgIGNvbnN0IGludFdpZHRoID0gb3B0LncgfHwgMDtcbiAgICBjb25zdCBpbnRIZWlnaHQgPSBvcHQuaCB8fCAwO1xuICAgIGNvbnN0IHNpemluZyA9IG9wdC5zaXppbmcgfHwgbnVsbDtcbiAgICBjb25zdCBvYmpIeXBlcmxpbmsgPSBvcHQuaHlwZXJsaW5rIHx8ICcnO1xuICAgIGNvbnN0IHN0ckltYWdlRGF0YSA9IG9wdC5kYXRhIHx8ICcnO1xuICAgIGNvbnN0IHN0ckltYWdlUGF0aCA9IG9wdC5wYXRoIHx8ICcnO1xuICAgIGxldCBpbWFnZVJlbElkID0gZ2V0TmV3UmVsSWQodGFyZ2V0KTtcbiAgICBjb25zdCBvYmplY3ROYW1lID0gb3B0Lm9iamVjdE5hbWUgPyBlbmNvZGVYbWxFbnRpdGllcyhvcHQub2JqZWN0TmFtZSkgOiBgSW1hZ2UgJHt0YXJnZXQuX3NsaWRlT2JqZWN0cy5maWx0ZXIob2JqID0+IG9iai5fdHlwZSA9PT0gU0xJREVfT0JKRUNUX1RZUEVTLmltYWdlKS5sZW5ndGh9YDtcbiAgICAvLyBSRUFMSVRZLUNIRUNLOlxuICAgIGlmICghc3RySW1hZ2VQYXRoICYmICFzdHJJbWFnZURhdGEpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRVJST1I6IGFkZEltYWdlKCkgcmVxdWlyZXMgZWl0aGVyIFxcJ2RhdGFcXCcgb3IgXFwncGF0aFxcJyBwYXJhbWV0ZXIhJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdHJJbWFnZVBhdGggJiYgdHlwZW9mIHN0ckltYWdlUGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRVJST1I6IGFkZEltYWdlKCkgJ3BhdGgnIHNob3VsZCBiZSBhIHN0cmluZywgZXg6IHtwYXRoOicvaW1nL3NhbXBsZS5wbmcnfSAtIHlvdSBzZW50ICR7U3RyaW5nKHN0ckltYWdlUGF0aCl9YCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdHJJbWFnZURhdGEgJiYgdHlwZW9mIHN0ckltYWdlRGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRVJST1I6IGFkZEltYWdlKCkgJ2RhdGEnIHNob3VsZCBiZSBhIHN0cmluZywgZXg6IHtkYXRhOidpbWFnZS9wbmc7YmFzZTY0LE5NUFsuLi5dJ30gLSB5b3Ugc2VudCAke1N0cmluZyhzdHJJbWFnZURhdGEpfWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RySW1hZ2VEYXRhICYmIHR5cGVvZiBzdHJJbWFnZURhdGEgPT09ICdzdHJpbmcnICYmICFzdHJJbWFnZURhdGEudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnYmFzZTY0LCcpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0VSUk9SOiBJbWFnZSBgZGF0YWAgdmFsdWUgbGFja3MgYSBiYXNlNjQgaGVhZGVyISBFeDogXFwnaW1hZ2UvcG5nO2Jhc2U2NCxOTVBbLi4uXVxcJyknKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFNURVAgMTogU2V0IGV4dGVuc2lvblxuICAgIC8vIE5PVEU6IFNwbGl0IHRvIGFkZHJlc3MgVVJMcyB3aXRoIHBhcmFtcyAoZWc6IGBwYXRoL2JyZW50LmpwZz9zb21lUGFyYW09dHJ1ZWApXG4gICAgbGV0IHN0ckltZ0V4dG4gPSAoc3RySW1hZ2VQYXRoXG4gICAgICAgIC5zdWJzdHJpbmcoc3RySW1hZ2VQYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKVxuICAgICAgICAuc3BsaXQoJz8nKVswXVxuICAgICAgICAuc3BsaXQoJy4nKVxuICAgICAgICAucG9wKClcbiAgICAgICAgLnNwbGl0KCcjJylbMF0gfHwgJ3BuZycpLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gSG93ZXZlciwgcHJlLWVuY29kZWQgaW1hZ2VzIGNhbiBiZSB3aGF0ZXZlciBtaW1lLXR5cGUgdGhleSB3YW50IChhbmQgZ29vZCBmb3IgdGhlbSEpXG4gICAgaWYgKHN0ckltYWdlRGF0YSAmJiAvaW1hZ2VcXC8oXFx3Kyk7Ly5leGVjKHN0ckltYWdlRGF0YSkgJiYgL2ltYWdlXFwvKFxcdyspOy8uZXhlYyhzdHJJbWFnZURhdGEpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RySW1nRXh0biA9IC9pbWFnZVxcLyhcXHcrKTsvLmV4ZWMoc3RySW1hZ2VEYXRhKVsxXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RySW1hZ2VEYXRhID09PSBudWxsIHx8IHN0ckltYWdlRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RySW1hZ2VEYXRhLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2ltYWdlL3N2Zyt4bWwnKSkge1xuICAgICAgICBzdHJJbWdFeHRuID0gJ3N2Zyc7XG4gICAgfVxuICAgIC8vIFNURVAgMjogU2V0IHR5cGUvcGF0aFxuICAgIG5ld09iamVjdC5fdHlwZSA9IFNMSURFX09CSkVDVF9UWVBFUy5pbWFnZTtcbiAgICBuZXdPYmplY3QuaW1hZ2UgPSBzdHJJbWFnZVBhdGggfHwgJ3ByZWVuY29kZWQucG5nJztcbiAgICAvLyBTVEVQIDM6IFNldCBpbWFnZSBwcm9wZXJ0aWVzICYgb3B0aW9uc1xuICAgIC8vIEZJWE1FOiBNZWFzdXJlIGFjdHVhbCBpbWFnZSB3aGVuIG5vIGludFdpZHRoL2ludEhlaWdodCBwYXJhbXMgcGFzc2VkXG4gICAgLy8gLi4uLjogVGhpcyBpcyBhbiBhc3luYyBwcm9jZXNzOiB3ZSBuZWVkIHRvIG1ha2UgZ2V0U2l6ZUZyb21JbWFnZSB1c2UgY2FsbGJhY2ssIHRoZW4gc2V0IEgvVy4uLlxuICAgIC8vIGlmICggIWludFdpZHRoIHx8ICFpbnRIZWlnaHQgKSB7IHZhciBpbWdPYmogPSBnZXRTaXplRnJvbUltYWdlKHN0ckltYWdlUGF0aCk7XG4gICAgbmV3T2JqZWN0Lm9wdGlvbnMgPSB7XG4gICAgICAgIHg6IGludFBvc1ggfHwgMCxcbiAgICAgICAgeTogaW50UG9zWSB8fCAwLFxuICAgICAgICB3OiBpbnRXaWR0aCB8fCAxLFxuICAgICAgICBoOiBpbnRIZWlnaHQgfHwgMSxcbiAgICAgICAgYWx0VGV4dDogb3B0LmFsdFRleHQgfHwgJycsXG4gICAgICAgIHJvdW5kaW5nOiB0eXBlb2Ygb3B0LnJvdW5kaW5nID09PSAnYm9vbGVhbicgPyBvcHQucm91bmRpbmcgOiBmYWxzZSxcbiAgICAgICAgc2l6aW5nLFxuICAgICAgICBwbGFjZWhvbGRlcjogb3B0LnBsYWNlaG9sZGVyLFxuICAgICAgICByb3RhdGU6IG9wdC5yb3RhdGUgfHwgMCxcbiAgICAgICAgZmxpcFY6IG9wdC5mbGlwViB8fCBmYWxzZSxcbiAgICAgICAgZmxpcEg6IG9wdC5mbGlwSCB8fCBmYWxzZSxcbiAgICAgICAgdHJhbnNwYXJlbmN5OiBvcHQudHJhbnNwYXJlbmN5IHx8IDAsXG4gICAgICAgIG9iamVjdE5hbWUsXG4gICAgICAgIHNoYWRvdzogY29ycmVjdFNoYWRvd09wdGlvbnMob3B0LnNoYWRvdyksXG4gICAgfTtcbiAgICAvLyBTVEVQIDQ6IEFkZCB0aGlzIGltYWdlIHRvIHRoaXMgU2xpZGUgUmVscyAocklkL3JlbHMgY291bnQgc3BhbnMgYWxsIHNsaWRlcyEgQ291bnQgYWxsIGltYWdlcyB0byBnZXQgbmV4dCBySWQpXG4gICAgaWYgKHN0ckltZ0V4dG4gPT09ICdzdmcnKSB7XG4gICAgICAgIC8vIFNWRyBmaWxlcyBjb25zdW1lICpUV08qIHJJZCdzOiAoYSBwbmcgdmVyc2lvbiBhbmQgdGhlIHN2ZyBpbWFnZSlcbiAgICAgICAgLy8gPFJlbGF0aW9uc2hpcCBJZD1cInJJZDNcIiBUeXBlPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcy9pbWFnZVwiIFRhcmdldD1cIi4uL21lZGlhL2ltYWdlMS5wbmdcIi8+XG4gICAgICAgIC8vIDxSZWxhdGlvbnNoaXAgSWQ9XCJySWQ0XCIgVHlwZT1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHMvaW1hZ2VcIiBUYXJnZXQ9XCIuLi9tZWRpYS9pbWFnZTIuc3ZnXCIvPlxuICAgICAgICB0YXJnZXQuX3JlbHNNZWRpYS5wdXNoKHtcbiAgICAgICAgICAgIHBhdGg6IHN0ckltYWdlUGF0aCB8fCBzdHJJbWFnZURhdGEgKyAncG5nJyxcbiAgICAgICAgICAgIHR5cGU6ICdpbWFnZS9wbmcnLFxuICAgICAgICAgICAgZXh0bjogJ3BuZycsXG4gICAgICAgICAgICBkYXRhOiBzdHJJbWFnZURhdGEgfHwgJycsXG4gICAgICAgICAgICBySWQ6IGltYWdlUmVsSWQsXG4gICAgICAgICAgICBUYXJnZXQ6IGAuLi9tZWRpYS9pbWFnZS0ke3RhcmdldC5fc2xpZGVOdW19LSR7dGFyZ2V0Ll9yZWxzTWVkaWEubGVuZ3RoICsgMX0ucG5nYCxcbiAgICAgICAgICAgIGlzU3ZnUG5nOiB0cnVlLFxuICAgICAgICAgICAgc3ZnU2l6ZTogeyB3OiBnZXRTbWFydFBhcnNlTnVtYmVyKG5ld09iamVjdC5vcHRpb25zLncsICdYJywgdGFyZ2V0Ll9wcmVzTGF5b3V0KSwgaDogZ2V0U21hcnRQYXJzZU51bWJlcihuZXdPYmplY3Qub3B0aW9ucy5oLCAnWScsIHRhcmdldC5fcHJlc0xheW91dCkgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIG5ld09iamVjdC5pbWFnZVJpZCA9IGltYWdlUmVsSWQ7XG4gICAgICAgIHRhcmdldC5fcmVsc01lZGlhLnB1c2goe1xuICAgICAgICAgICAgcGF0aDogc3RySW1hZ2VQYXRoIHx8IHN0ckltYWdlRGF0YSxcbiAgICAgICAgICAgIHR5cGU6ICdpbWFnZS9zdmcreG1sJyxcbiAgICAgICAgICAgIGV4dG46IHN0ckltZ0V4dG4sXG4gICAgICAgICAgICBkYXRhOiBzdHJJbWFnZURhdGEgfHwgJycsXG4gICAgICAgICAgICBySWQ6IGltYWdlUmVsSWQgKyAxLFxuICAgICAgICAgICAgVGFyZ2V0OiBgLi4vbWVkaWEvaW1hZ2UtJHt0YXJnZXQuX3NsaWRlTnVtfS0ke3RhcmdldC5fcmVsc01lZGlhLmxlbmd0aCArIDF9LiR7c3RySW1nRXh0bn1gLFxuICAgICAgICB9KTtcbiAgICAgICAgbmV3T2JqZWN0LmltYWdlUmlkID0gaW1hZ2VSZWxJZCArIDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBQRVJGOiBEdXBsaWNhdGUgbWVkaWEgc2hvdWxkIHJldXNlIGV4aXN0aW5nIGBUYXJnZXRgIHZhbHVlIGFuZCBub3QgY3JlYXRlIGFuIGFkZGl0aW9uYWwgY29weVxuICAgICAgICBjb25zdCBkdXBlSXRlbSA9IHRhcmdldC5fcmVsc01lZGlhLmZpbHRlcihpdGVtID0+IGl0ZW0ucGF0aCAmJiBpdGVtLnBhdGggPT09IHN0ckltYWdlUGF0aCAmJiBpdGVtLnR5cGUgPT09ICdpbWFnZS8nICsgc3RySW1nRXh0biAmJiAhaXRlbS5pc0R1cGxpY2F0ZSlbMF07XG4gICAgICAgIHRhcmdldC5fcmVsc01lZGlhLnB1c2goe1xuICAgICAgICAgICAgcGF0aDogc3RySW1hZ2VQYXRoIHx8ICdwcmVlbmNvZGVkLicgKyBzdHJJbWdFeHRuLFxuICAgICAgICAgICAgdHlwZTogJ2ltYWdlLycgKyBzdHJJbWdFeHRuLFxuICAgICAgICAgICAgZXh0bjogc3RySW1nRXh0bixcbiAgICAgICAgICAgIGRhdGE6IHN0ckltYWdlRGF0YSB8fCAnJyxcbiAgICAgICAgICAgIHJJZDogaW1hZ2VSZWxJZCxcbiAgICAgICAgICAgIGlzRHVwbGljYXRlOiAhIShkdXBlSXRlbSA9PT0gbnVsbCB8fCBkdXBlSXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZHVwZUl0ZW0uVGFyZ2V0KSxcbiAgICAgICAgICAgIFRhcmdldDogKGR1cGVJdGVtID09PSBudWxsIHx8IGR1cGVJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkdXBlSXRlbS5UYXJnZXQpID8gZHVwZUl0ZW0uVGFyZ2V0IDogYC4uL21lZGlhL2ltYWdlLSR7dGFyZ2V0Ll9zbGlkZU51bX0tJHt0YXJnZXQuX3JlbHNNZWRpYS5sZW5ndGggKyAxfS4ke3N0ckltZ0V4dG59YCxcbiAgICAgICAgfSk7XG4gICAgICAgIG5ld09iamVjdC5pbWFnZVJpZCA9IGltYWdlUmVsSWQ7XG4gICAgfVxuICAgIC8vIFNURVAgNTogSHlwZXJsaW5rIHN1cHBvcnRcbiAgICBpZiAodHlwZW9mIG9iakh5cGVybGluayA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKCFvYmpIeXBlcmxpbmsudXJsICYmICFvYmpIeXBlcmxpbmsuc2xpZGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VSUk9SOiBgaHlwZXJsaW5rYCBvcHRpb24gcmVxdWlyZXMgZWl0aGVyOiBgdXJsYCBvciBgc2xpZGVgJyk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW1hZ2VSZWxJZCsrO1xuICAgICAgICAgICAgdGFyZ2V0Ll9yZWxzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFNMSURFX09CSkVDVF9UWVBFUy5oeXBlcmxpbmssXG4gICAgICAgICAgICAgICAgZGF0YTogb2JqSHlwZXJsaW5rLnNsaWRlID8gJ3NsaWRlJyA6ICdkdW1teScsXG4gICAgICAgICAgICAgICAgcklkOiBpbWFnZVJlbElkLFxuICAgICAgICAgICAgICAgIFRhcmdldDogb2JqSHlwZXJsaW5rLnVybCB8fCBvYmpIeXBlcmxpbmsuc2xpZGUudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb2JqSHlwZXJsaW5rLl9ySWQgPSBpbWFnZVJlbElkO1xuICAgICAgICAgICAgbmV3T2JqZWN0Lmh5cGVybGluayA9IG9iakh5cGVybGluaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTVEVQIDY6IEFkZCBvYmplY3QgdG8gc2xpZGVcbiAgICB0YXJnZXQuX3NsaWRlT2JqZWN0cy5wdXNoKG5ld09iamVjdCk7XG59XG4vKipcbiAqIEFkZHMgYSBtZWRpYSBvYmplY3QgdG8gYSBzbGlkZSBkZWZpbml0aW9uLlxuICogQHBhcmFtIHtQcmVzU2xpZGV9IGB0YXJnZXRgIC0gc2xpZGUgb2JqZWN0IHRoYXQgdGhlIG1lZGlhIHdpbGwgYmUgYWRkZWQgdG9cbiAqIEBwYXJhbSB7TWVkaWFQcm9wc30gYG9wdGAgLSBtZWRpYSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGFkZE1lZGlhRGVmaW5pdGlvbih0YXJnZXQsIG9wdCkge1xuICAgIGNvbnN0IGludFBvc1ggPSBvcHQueCB8fCAwO1xuICAgIGNvbnN0IGludFBvc1kgPSBvcHQueSB8fCAwO1xuICAgIGNvbnN0IGludFNpemVYID0gb3B0LncgfHwgMjtcbiAgICBjb25zdCBpbnRTaXplWSA9IG9wdC5oIHx8IDI7XG4gICAgY29uc3Qgc3RyRGF0YSA9IG9wdC5kYXRhIHx8ICcnO1xuICAgIGNvbnN0IHN0ckxpbmsgPSBvcHQubGluayB8fCAnJztcbiAgICBjb25zdCBzdHJQYXRoID0gb3B0LnBhdGggfHwgJyc7XG4gICAgY29uc3Qgc3RyVHlwZSA9IG9wdC50eXBlIHx8ICdhdWRpbyc7XG4gICAgbGV0IHN0ckV4dG4gPSAnJztcbiAgICBjb25zdCBzdHJDb3ZlciA9IG9wdC5jb3ZlciB8fCBJTUdfUExBWUJUTjtcbiAgICBjb25zdCBvYmplY3ROYW1lID0gb3B0Lm9iamVjdE5hbWUgPyBlbmNvZGVYbWxFbnRpdGllcyhvcHQub2JqZWN0TmFtZSkgOiBgTWVkaWEgJHt0YXJnZXQuX3NsaWRlT2JqZWN0cy5maWx0ZXIob2JqID0+IG9iai5fdHlwZSA9PT0gU0xJREVfT0JKRUNUX1RZUEVTLm1lZGlhKS5sZW5ndGh9YDtcbiAgICBjb25zdCBzbGlkZURhdGEgPSB7IF90eXBlOiBTTElERV9PQkpFQ1RfVFlQRVMubWVkaWEgfTtcbiAgICAvLyBTVEVQIDE6IFJFQUxJVFktQ0hFQ0tcbiAgICBpZiAoIXN0clBhdGggJiYgIXN0ckRhdGEgJiYgc3RyVHlwZSAhPT0gJ29ubGluZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGRNZWRpYSgpIGVycm9yOiBlaXRoZXIgYGRhdGFgIG9yIGBwYXRoYCBhcmUgcmVxdWlyZWQhJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0ckRhdGEgJiYgIXN0ckRhdGEudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnYmFzZTY0LCcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYWRkTWVkaWEoKSBlcnJvcjogYGRhdGFgIHZhbHVlIGxhY2tzIGEgYmFzZTY0IGhlYWRlciEgRXg6IFxcJ3ZpZGVvL21wZWc7YmFzZTY0LE5NUFsuLi5dXFwnKScpO1xuICAgIH1cbiAgICBlbHNlIGlmICghc3RyQ292ZXIudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnYmFzZTY0LCcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYWRkTWVkaWEoKSBlcnJvcjogYGNvdmVyYCB2YWx1ZSBsYWNrcyBhIGJhc2U2NCBoZWFkZXIhIEV4OiBcXCdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZbLi4uXVxcJyknKTtcbiAgICB9XG4gICAgLy8gT25saW5lIFZpZGVvOiByZXF1aXJlcyBgbGlua2BcbiAgICBpZiAoc3RyVHlwZSA9PT0gJ29ubGluZScgJiYgIXN0ckxpbmspIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGRNZWRpYSgpIGVycm9yOiBvbmxpbmUgdmlkZW9zIHJlcXVpcmUgYGxpbmtgIHZhbHVlJyk7XG4gICAgfVxuICAgIC8vIEZJWE1FOiAyMDE5MDcwN1xuICAgIC8vIHN0clR5cGUgPSBzdHJEYXRhID8gc3RyRGF0YS5zcGxpdCgnOycpWzBdLnNwbGl0KCcvJylbMF0gOiBzdHJUeXBlXG4gICAgc3RyRXh0biA9IG9wdC5leHRuIHx8IChzdHJEYXRhID8gc3RyRGF0YS5zcGxpdCgnOycpWzBdLnNwbGl0KCcvJylbMV0gOiBzdHJQYXRoLnNwbGl0KCcuJykucG9wKCkpIHx8ICdtcDMnO1xuICAgIC8vIFNURVAgMjogU2V0IHR5cGUsIG1lZGlhXG4gICAgc2xpZGVEYXRhLm10eXBlID0gc3RyVHlwZTtcbiAgICBzbGlkZURhdGEubWVkaWEgPSBzdHJQYXRoIHx8ICdwcmVlbmNvZGVkLm1vdic7XG4gICAgc2xpZGVEYXRhLm9wdGlvbnMgPSB7fTtcbiAgICAvLyBTVEVQIDM6IFNldCBtZWRpYSBwcm9wZXJ0aWVzICYgb3B0aW9uc1xuICAgIHNsaWRlRGF0YS5vcHRpb25zLnggPSBpbnRQb3NYO1xuICAgIHNsaWRlRGF0YS5vcHRpb25zLnkgPSBpbnRQb3NZO1xuICAgIHNsaWRlRGF0YS5vcHRpb25zLncgPSBpbnRTaXplWDtcbiAgICBzbGlkZURhdGEub3B0aW9ucy5oID0gaW50U2l6ZVk7XG4gICAgc2xpZGVEYXRhLm9wdGlvbnMub2JqZWN0TmFtZSA9IG9iamVjdE5hbWU7XG4gICAgLy8gU1RFUCA0OiBBZGQgdGhpcyBtZWRpYSB0byB0aGlzIFNsaWRlIFJlbHMgKHJJZC9yZWxzIGNvdW50IHNwYW5zIGFsbCBzbGlkZXMhIENvdW50IGFsbCBtZWRpYSB0byBnZXQgbmV4dCBySWQpXG4gICAgLyoqXG4gICAgICogTk9URTpcbiAgICAgKiAtIHJJZCBzdGFydHMgYXQgMiAoaGVuY2UgdGhlIGludFJlbHMrMSBiZWxvdykgYXMgc2xpZGVMYXlvdXQueG1sIGlzIHJJZD0xIVxuICAgICAqXG4gICAgICogTk9URTpcbiAgICAgKiAtIEF1ZGlvL1ZpZGVvIGZpbGVzIGNvbnN1bWUgKlRXTyogcklkJ3M6XG4gICAgICogPFJlbGF0aW9uc2hpcCBJZD1cInJJZDJcIiBUYXJnZXQ9XCIuLi9tZWRpYS9tZWRpYTEubW92XCIgVHlwZT1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHMvdmlkZW9cIi8+XG4gICAgICogPFJlbGF0aW9uc2hpcCBJZD1cInJJZDNcIiBUYXJnZXQ9XCIuLi9tZWRpYS9tZWRpYTEubW92XCIgVHlwZT1cImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlLzIwMDcvcmVsYXRpb25zaGlwcy9tZWRpYVwiLz5cbiAgICAgKi9cbiAgICBpZiAoc3RyVHlwZSA9PT0gJ29ubGluZScpIHtcbiAgICAgICAgY29uc3QgcmVsSWQxID0gZ2V0TmV3UmVsSWQodGFyZ2V0KTtcbiAgICAgICAgLy8gQTogQWRkIHZpZGVvXG4gICAgICAgIHRhcmdldC5fcmVsc01lZGlhLnB1c2goe1xuICAgICAgICAgICAgcGF0aDogc3RyUGF0aCB8fCAncHJlZW5jb2RlZCcgKyBzdHJFeHRuLFxuICAgICAgICAgICAgZGF0YTogJ2R1bW15JyxcbiAgICAgICAgICAgIHR5cGU6ICdvbmxpbmUnLFxuICAgICAgICAgICAgZXh0bjogc3RyRXh0bixcbiAgICAgICAgICAgIHJJZDogcmVsSWQxLFxuICAgICAgICAgICAgVGFyZ2V0OiBzdHJMaW5rLFxuICAgICAgICB9KTtcbiAgICAgICAgc2xpZGVEYXRhLm1lZGlhUmlkID0gcmVsSWQxO1xuICAgICAgICAvLyBCOiBBZGQgY292ZXIgKHByZXZpZXcvb3ZlcmxheSkgaW1hZ2VcbiAgICAgICAgdGFyZ2V0Ll9yZWxzTWVkaWEucHVzaCh7XG4gICAgICAgICAgICBwYXRoOiAncHJlZW5jb2RlZC5wbmcnLFxuICAgICAgICAgICAgZGF0YTogc3RyQ292ZXIsXG4gICAgICAgICAgICB0eXBlOiAnaW1hZ2UvcG5nJyxcbiAgICAgICAgICAgIGV4dG46ICdwbmcnLFxuICAgICAgICAgICAgcklkOiBnZXROZXdSZWxJZCh0YXJnZXQpLFxuICAgICAgICAgICAgVGFyZ2V0OiBgLi4vbWVkaWEvaW1hZ2UtJHt0YXJnZXQuX3NsaWRlTnVtfS0ke3RhcmdldC5fcmVsc01lZGlhLmxlbmd0aCArIDF9LnBuZ2AsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gUEVSRjogRHVwbGljYXRlIG1lZGlhIHNob3VsZCByZXVzZSBleGlzdGluZyBgVGFyZ2V0YCB2YWx1ZSBhbmQgbm90IGNyZWF0ZSBhbiBhZGRpdGlvbmFsIGNvcHlcbiAgICAgICAgY29uc3QgZHVwZUl0ZW0gPSB0YXJnZXQuX3JlbHNNZWRpYS5maWx0ZXIoaXRlbSA9PiBpdGVtLnBhdGggJiYgaXRlbS5wYXRoID09PSBzdHJQYXRoICYmIGl0ZW0udHlwZSA9PT0gc3RyVHlwZSArICcvJyArIHN0ckV4dG4gJiYgIWl0ZW0uaXNEdXBsaWNhdGUpWzBdO1xuICAgICAgICAvLyBBOiBcInJlbGF0aW9uc2hpcHMvdmlkZW9cIlxuICAgICAgICBjb25zdCByZWxJZDEgPSBnZXROZXdSZWxJZCh0YXJnZXQpO1xuICAgICAgICB0YXJnZXQuX3JlbHNNZWRpYS5wdXNoKHtcbiAgICAgICAgICAgIHBhdGg6IHN0clBhdGggfHwgJ3ByZWVuY29kZWQnICsgc3RyRXh0bixcbiAgICAgICAgICAgIHR5cGU6IHN0clR5cGUgKyAnLycgKyBzdHJFeHRuLFxuICAgICAgICAgICAgZXh0bjogc3RyRXh0bixcbiAgICAgICAgICAgIGRhdGE6IHN0ckRhdGEgfHwgJycsXG4gICAgICAgICAgICBySWQ6IHJlbElkMSxcbiAgICAgICAgICAgIGlzRHVwbGljYXRlOiAhIShkdXBlSXRlbSA9PT0gbnVsbCB8fCBkdXBlSXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZHVwZUl0ZW0uVGFyZ2V0KSxcbiAgICAgICAgICAgIFRhcmdldDogKGR1cGVJdGVtID09PSBudWxsIHx8IGR1cGVJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkdXBlSXRlbS5UYXJnZXQpID8gZHVwZUl0ZW0uVGFyZ2V0IDogYC4uL21lZGlhL21lZGlhLSR7dGFyZ2V0Ll9zbGlkZU51bX0tJHt0YXJnZXQuX3JlbHNNZWRpYS5sZW5ndGggKyAxfS4ke3N0ckV4dG59YCxcbiAgICAgICAgfSk7XG4gICAgICAgIHNsaWRlRGF0YS5tZWRpYVJpZCA9IHJlbElkMTtcbiAgICAgICAgLy8gQjogXCJyZWxhdGlvbnNoaXBzL21lZGlhXCJcbiAgICAgICAgdGFyZ2V0Ll9yZWxzTWVkaWEucHVzaCh7XG4gICAgICAgICAgICBwYXRoOiBzdHJQYXRoIHx8ICdwcmVlbmNvZGVkJyArIHN0ckV4dG4sXG4gICAgICAgICAgICB0eXBlOiBzdHJUeXBlICsgJy8nICsgc3RyRXh0bixcbiAgICAgICAgICAgIGV4dG46IHN0ckV4dG4sXG4gICAgICAgICAgICBkYXRhOiBzdHJEYXRhIHx8ICcnLFxuICAgICAgICAgICAgcklkOiBnZXROZXdSZWxJZCh0YXJnZXQpLFxuICAgICAgICAgICAgaXNEdXBsaWNhdGU6ICEhKGR1cGVJdGVtID09PSBudWxsIHx8IGR1cGVJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkdXBlSXRlbS5UYXJnZXQpLFxuICAgICAgICAgICAgVGFyZ2V0OiAoZHVwZUl0ZW0gPT09IG51bGwgfHwgZHVwZUl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGR1cGVJdGVtLlRhcmdldCkgPyBkdXBlSXRlbS5UYXJnZXQgOiBgLi4vbWVkaWEvbWVkaWEtJHt0YXJnZXQuX3NsaWRlTnVtfS0ke3RhcmdldC5fcmVsc01lZGlhLmxlbmd0aCArIDB9LiR7c3RyRXh0bn1gLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQzogQWRkIGNvdmVyIChwcmV2aWV3L292ZXJsYXkpIGltYWdlXG4gICAgICAgIHRhcmdldC5fcmVsc01lZGlhLnB1c2goe1xuICAgICAgICAgICAgcGF0aDogJ3ByZWVuY29kZWQucG5nJyxcbiAgICAgICAgICAgIHR5cGU6ICdpbWFnZS9wbmcnLFxuICAgICAgICAgICAgZXh0bjogJ3BuZycsXG4gICAgICAgICAgICBkYXRhOiBzdHJDb3ZlcixcbiAgICAgICAgICAgIHJJZDogZ2V0TmV3UmVsSWQodGFyZ2V0KSxcbiAgICAgICAgICAgIFRhcmdldDogYC4uL21lZGlhL2ltYWdlLSR7dGFyZ2V0Ll9zbGlkZU51bX0tJHt0YXJnZXQuX3JlbHNNZWRpYS5sZW5ndGggKyAxfS5wbmdgLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gTEFTVFxuICAgIHRhcmdldC5fc2xpZGVPYmplY3RzLnB1c2goc2xpZGVEYXRhKTtcbn1cbi8qKlxuICogQWRkcyBOb3RlcyB0byBhIHNsaWRlLlxuICogQHBhcmFtIHtQcmVzU2xpZGV9IGB0YXJnZXRgIHNsaWRlIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IGBub3Rlc2BcbiAqIEBzaW5jZSAyLjMuMFxuICovXG5mdW5jdGlvbiBhZGROb3Rlc0RlZmluaXRpb24odGFyZ2V0LCBub3Rlcykge1xuICAgIHRhcmdldC5fc2xpZGVPYmplY3RzLnB1c2goe1xuICAgICAgICBfdHlwZTogU0xJREVfT0JKRUNUX1RZUEVTLm5vdGVzLFxuICAgICAgICB0ZXh0OiBbeyB0ZXh0OiBub3RlcyB9XSxcbiAgICB9KTtcbn1cbi8qKlxuICogQWRkcyBhIHNoYXBlIG9iamVjdCB0byBhIHNsaWRlIGRlZmluaXRpb24uXG4gKiBAcGFyYW0ge1ByZXNTbGlkZX0gdGFyZ2V0IHNsaWRlIG9iamVjdCB0aGF0IHRoZSBzaGFwZSBzaG91bGQgYmUgYWRkZWQgdG9cbiAqIEBwYXJhbSB7U0hBUEVfTkFNRX0gc2hhcGVOYW1lIHNoYXBlIG5hbWVcbiAqIEBwYXJhbSB7U2hhcGVQcm9wc30gb3B0cyBzaGFwZSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGFkZFNoYXBlRGVmaW5pdGlvbih0YXJnZXQsIHNoYXBlTmFtZSwgb3B0cykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygb3B0cyA9PT0gJ29iamVjdCcgPyBvcHRzIDoge307XG4gICAgb3B0aW9ucy5saW5lID0gb3B0aW9ucy5saW5lIHx8IHsgdHlwZTogJ25vbmUnIH07XG4gICAgY29uc3QgbmV3T2JqZWN0ID0ge1xuICAgICAgICBfdHlwZTogU0xJREVfT0JKRUNUX1RZUEVTLnRleHQsXG4gICAgICAgIHNoYXBlOiBzaGFwZU5hbWUgfHwgU0hBUEVfVFlQRS5SRUNUQU5HTEUsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIHRleHQ6IG51bGwsXG4gICAgfTtcbiAgICAvLyBSZWFsaXR5IGNoZWNrXG4gICAgaWYgKCFzaGFwZU5hbWUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZy9JbnZhbGlkIHNoYXBlIHBhcmFtZXRlciEgRXhhbXBsZTogYGFkZFNoYXBlKHBwdHhnZW4uc2hhcGVzLkxJTkUsIHt4OjEsIHk6MSwgdzoxLCBoOjF9KTtgJyk7XG4gICAgLy8gMTogU2hhcGVMaW5lUHJvcHMgZGVmYXVsdHNcbiAgICBjb25zdCBuZXdMaW5lT3B0cyA9IHtcbiAgICAgICAgdHlwZTogb3B0aW9ucy5saW5lLnR5cGUgfHwgJ3NvbGlkJyxcbiAgICAgICAgY29sb3I6IG9wdGlvbnMubGluZS5jb2xvciB8fCBERUZfU0hBUEVfTElORV9DT0xPUixcbiAgICAgICAgdHJhbnNwYXJlbmN5OiBvcHRpb25zLmxpbmUudHJhbnNwYXJlbmN5IHx8IDAsXG4gICAgICAgIHdpZHRoOiBvcHRpb25zLmxpbmUud2lkdGggfHwgMSxcbiAgICAgICAgZGFzaFR5cGU6IG9wdGlvbnMubGluZS5kYXNoVHlwZSB8fCAnc29saWQnLFxuICAgICAgICBiZWdpbkFycm93VHlwZTogb3B0aW9ucy5saW5lLmJlZ2luQXJyb3dUeXBlIHx8IG51bGwsXG4gICAgICAgIGVuZEFycm93VHlwZTogb3B0aW9ucy5saW5lLmVuZEFycm93VHlwZSB8fCBudWxsLFxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmxpbmUgPT09ICdvYmplY3QnICYmIG9wdGlvbnMubGluZS50eXBlICE9PSAnbm9uZScpXG4gICAgICAgIG9wdGlvbnMubGluZSA9IG5ld0xpbmVPcHRzO1xuICAgIC8vIDI6IFNldCBvcHRpb25zIGRlZmF1bHRzXG4gICAgb3B0aW9ucy54ID0gb3B0aW9ucy54IHx8IChvcHRpb25zLnggPT09IDAgPyAwIDogMSk7XG4gICAgb3B0aW9ucy55ID0gb3B0aW9ucy55IHx8IChvcHRpb25zLnkgPT09IDAgPyAwIDogMSk7XG4gICAgb3B0aW9ucy53ID0gb3B0aW9ucy53IHx8IChvcHRpb25zLncgPT09IDAgPyAwIDogMSk7XG4gICAgb3B0aW9ucy5oID0gb3B0aW9ucy5oIHx8IChvcHRpb25zLmggPT09IDAgPyAwIDogMSk7XG4gICAgb3B0aW9ucy5vYmplY3ROYW1lID0gb3B0aW9ucy5vYmplY3ROYW1lXG4gICAgICAgID8gZW5jb2RlWG1sRW50aXRpZXMob3B0aW9ucy5vYmplY3ROYW1lKVxuICAgICAgICA6IGBTaGFwZSAke3RhcmdldC5fc2xpZGVPYmplY3RzLmZpbHRlcihvYmogPT4gb2JqLl90eXBlID09PSBTTElERV9PQkpFQ1RfVFlQRVMudGV4dCkubGVuZ3RofWA7XG4gICAgLy8gMzogSGFuZGxlIGxpbmUgKGxvdHMgb2YgZGVwcmVjYXRlZCBvcHRzKVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5saW5lID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCB0bXBPcHRzID0gbmV3TGluZU9wdHM7XG4gICAgICAgIHRtcE9wdHMuY29sb3IgPSBTdHJpbmcob3B0aW9ucy5saW5lKTsgLy8gQGRlcHJlY2F0ZWQgYG9wdGlvbnMubGluZWAgc3RyaW5nICh3YXMgbGluZSBjb2xvcilcbiAgICAgICAgb3B0aW9ucy5saW5lID0gdG1wT3B0cztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmxpbmVTaXplID09PSAnbnVtYmVyJylcbiAgICAgICAgb3B0aW9ucy5saW5lLndpZHRoID0gb3B0aW9ucy5saW5lU2l6ZTsgLy8gQGRlcHJlY2F0ZWQgKHBhcnQgb2YgYFNoYXBlTGluZVByb3BzYCBub3cpXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmxpbmVEYXNoID09PSAnc3RyaW5nJylcbiAgICAgICAgb3B0aW9ucy5saW5lLmRhc2hUeXBlID0gb3B0aW9ucy5saW5lRGFzaDsgLy8gQGRlcHJlY2F0ZWQgKHBhcnQgb2YgYFNoYXBlTGluZVByb3BzYCBub3cpXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmxpbmVIZWFkID09PSAnc3RyaW5nJylcbiAgICAgICAgb3B0aW9ucy5saW5lLmJlZ2luQXJyb3dUeXBlID0gb3B0aW9ucy5saW5lSGVhZDsgLy8gQGRlcHJlY2F0ZWQgKHBhcnQgb2YgYFNoYXBlTGluZVByb3BzYCBub3cpXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmxpbmVUYWlsID09PSAnc3RyaW5nJylcbiAgICAgICAgb3B0aW9ucy5saW5lLmVuZEFycm93VHlwZSA9IG9wdGlvbnMubGluZVRhaWw7IC8vIEBkZXByZWNhdGVkIChwYXJ0IG9mIGBTaGFwZUxpbmVQcm9wc2Agbm93KVxuICAgIC8vIDQ6IENyZWF0ZSBoeXBlcmxpbmsgcmVsc1xuICAgIGNyZWF0ZUh5cGVybGlua1JlbHModGFyZ2V0LCBuZXdPYmplY3QpO1xuICAgIC8vIExBU1Q6IEFkZCBvYmplY3QgdG8gc2xpZGVcbiAgICB0YXJnZXQuX3NsaWRlT2JqZWN0cy5wdXNoKG5ld09iamVjdCk7XG59XG4vKipcbiAqIEFkZHMgYSB0YWJsZSBvYmplY3QgdG8gYSBzbGlkZSBkZWZpbml0aW9uLlxuICogQHBhcmFtIHtQcmVzU2xpZGV9IHRhcmdldCAtIHNsaWRlIG9iamVjdCB0aGF0IHRoZSB0YWJsZSBzaG91bGQgYmUgYWRkZWQgdG9cbiAqIEBwYXJhbSB7VGFibGVSb3dbXX0gdGFibGVSb3dzIC0gdGFibGUgZGF0YVxuICogQHBhcmFtIHtUYWJsZVByb3BzfSBvcHRpb25zIC0gdGFibGUgb3B0aW9uc1xuICogQHBhcmFtIHtTbGlkZUxheW91dH0gc2xpZGVMYXlvdXQgLSBTbGlkZSBsYXlvdXRcbiAqIEBwYXJhbSB7UHJlc0xheW91dH0gcHJlc0xheW91dCAtIFByZXNlbnRhdGlvbiBsYXlvdXRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFkZFNsaWRlIC0gbWV0aG9kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXRTbGlkZSAtIG1ldGhvZFxuICovXG5mdW5jdGlvbiBhZGRUYWJsZURlZmluaXRpb24odGFyZ2V0LCB0YWJsZVJvd3MsIG9wdGlvbnMsIHNsaWRlTGF5b3V0LCBwcmVzTGF5b3V0LCBhZGRTbGlkZSwgZ2V0U2xpZGUpIHtcbiAgICBjb25zdCBzbGlkZXMgPSBbdGFyZ2V0XTsgLy8gQ3JlYXRlIGFycmF5IG9mIFNsaWRlcyBhcyBtb3JlIG1heSBiZSBhZGRlZCBieSBhdXRvLXBhZ2luZ1xuICAgIGNvbnN0IG9wdCA9IG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnID8gb3B0aW9ucyA6IHt9O1xuICAgIG9wdC5vYmplY3ROYW1lID0gb3B0Lm9iamVjdE5hbWUgPyBlbmNvZGVYbWxFbnRpdGllcyhvcHQub2JqZWN0TmFtZSkgOiBgVGFibGUgJHt0YXJnZXQuX3NsaWRlT2JqZWN0cy5maWx0ZXIob2JqID0+IG9iai5fdHlwZSA9PT0gU0xJREVfT0JKRUNUX1RZUEVTLnRhYmxlKS5sZW5ndGh9YDtcbiAgICAvLyBTVEVQIDE6IFJFQUxJVFktQ0hFQ0tcbiAgICB7XG4gICAgICAgIC8vIEE6IGNoZWNrIGZvciBlbXB0eVxuICAgICAgICBpZiAodGFibGVSb3dzID09PSBudWxsIHx8IHRhYmxlUm93cy5sZW5ndGggPT09IDAgfHwgIUFycmF5LmlzQXJyYXkodGFibGVSb3dzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGRUYWJsZTogQXJyYXkgZXhwZWN0ZWQhIEVYOiBcXCdzbGlkZS5hZGRUYWJsZSggW3Jvd3NdLCB7b3B0aW9uc30gKTtcXCcgKGh0dHBzOi8vZ2l0YnJlbnQuZ2l0aHViLmlvL1BwdHhHZW5KUy9kb2NzL2FwaS10YWJsZXMuaHRtbCknKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCOiBjaGVjayBmb3Igbm9uLXdlbGwtZm9ybWF0dGVkIGFycmF5IChleDogcm93cz1bJ2EnLCdiJ10gaW5zdGVhZCBvZiBbWydhJywnYiddXSlcbiAgICAgICAgaWYgKCF0YWJsZVJvd3NbMF0gfHwgIUFycmF5LmlzQXJyYXkodGFibGVSb3dzWzBdKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGRUYWJsZTogXFwncm93c1xcJyBzaG91bGQgYmUgYW4gYXJyYXkgb2YgY2VsbHMhIEVYOiBcXCdzbGlkZS5hZGRUYWJsZSggWyBbXFwnQVxcJ10sIFtcXCdCXFwnXSwge3RleHQ6XFwnQ1xcJyxvcHRpb25zOnthbGlnbjpcXCdjZW50ZXJcXCd9fSBdICk7XFwnIChodHRwczovL2dpdGJyZW50LmdpdGh1Yi5pby9QcHR4R2VuSlMvZG9jcy9hcGktdGFibGVzLmh0bWwpJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogRlVUVVJFOiBUaGlzIGlzIHdhY2t5IGFuZCB3b250IGZ1bmN0aW9uIHJpZ2h0IChzaG93cyAudyB2YWx1ZSB3aGVuIHRoZXJlIGlzIG5vbmUgZnJvbSBkZW1vLmpzPyEpIDIwMTkxMjE5XG4gICAgICAgIC8qXG4gICAgICAgIGlmIChvcHQudyAmJiBvcHQuY29sVykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZGRUYWJsZTogcGxlYXNlIHVzZSBlaXRoZXIgYGNvbFdgIG9yIGB3YCAtIG5vdCBib3RoICh0YWJsZSB3aWxsIHVzZSBgY29sV2AgYW5kIGlnbm9yZSBgd2ApJylcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAke29wdC53fSAke29wdC5jb2xXfWApXG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICB9XG4gICAgLy8gU1RFUCAyOiBUcmFuc2Zvcm0gYHRhYmxlUm93c2AgaW50byB3ZWxsLWZvcm1hdHRlZCBUYWJsZUNlbGwnc1xuICAgIC8vIHRhYmxlUm93cyBjYW4gYmUgb2JqZWN0IG9yIHBsYWluIHRleHQgYXJyYXk6IGBbe3RleHQ6J2NlbGwgMSd9LCB7dGV4dDonY2VsbCAyJywgb3B0aW9uczp7Y29sb3I6J2ZmMDAwMCd9fV1gIHwgYFtcImNlbGwgMVwiLCBcImNlbGwgMlwiXWBcbiAgICBjb25zdCBhcnJSb3dzID0gW107XG4gICAgdGFibGVSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgY29uc3QgbmV3Um93ID0gW107XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJvdykpIHtcbiAgICAgICAgICAgIHJvdy5mb3JFYWNoKChjZWxsKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQTpcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDZWxsID0ge1xuICAgICAgICAgICAgICAgICAgICBfdHlwZTogU0xJREVfT0JKRUNUX1RZUEVTLnRhYmxlY2VsbCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHR5cGVvZiBjZWxsID09PSAnb2JqZWN0JyAmJiBjZWxsLm9wdGlvbnMgPyBjZWxsLm9wdGlvbnMgOiB7fSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIEI6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjZWxsID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2VsbCA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgICAgIG5ld0NlbGwudGV4dCA9IGNlbGwudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjZWxsLnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2VsbCBjYW4gY29udGFpbiBjb21wbGV4IHRleHQgdHlwZSwgb3Igc3RyaW5nLCBvciBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjZWxsLnRleHQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjZWxsLnRleHQgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2VsbC50ZXh0ID0gY2VsbC50ZXh0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNlbGwudGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NlbGwudGV4dCA9IGNlbGwudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsLm9wdGlvbnMgJiYgdHlwZW9mIGNlbGwub3B0aW9ucyA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDZWxsLm9wdGlvbnMgPSBjZWxsLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEM6IFNldCBjZWxsIGJvcmRlcnNcbiAgICAgICAgICAgICAgICBuZXdDZWxsLm9wdGlvbnMuYm9yZGVyID0gbmV3Q2VsbC5vcHRpb25zLmJvcmRlciB8fCBvcHQuYm9yZGVyIHx8IFt7IHR5cGU6ICdub25lJyB9LCB7IHR5cGU6ICdub25lJyB9LCB7IHR5cGU6ICdub25lJyB9LCB7IHR5cGU6ICdub25lJyB9XTtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsQm9yZGVyID0gbmV3Q2VsbC5vcHRpb25zLmJvcmRlcjtcbiAgICAgICAgICAgICAgICAvLyBDQVNFIDE6IGJvcmRlciBpbnRlcmZhY2UgaXM6IEJvcmRlck9wdGlvbnMgfCBbQm9yZGVyT3B0aW9ucywgQm9yZGVyT3B0aW9ucywgQm9yZGVyT3B0aW9ucywgQm9yZGVyT3B0aW9uc11cbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2VsbEJvcmRlcikgJiYgdHlwZW9mIGNlbGxCb3JkZXIgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgICAgICAgICBuZXdDZWxsLm9wdGlvbnMuYm9yZGVyID0gW2NlbGxCb3JkZXIsIGNlbGxCb3JkZXIsIGNlbGxCb3JkZXIsIGNlbGxCb3JkZXJdO1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZTogW251bGwsIG51bGwsIHt0eXBlOidzb2xpZCd9LCBudWxsXVxuICAgICAgICAgICAgICAgIGlmICghbmV3Q2VsbC5vcHRpb25zLmJvcmRlclswXSlcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2VsbC5vcHRpb25zLmJvcmRlclswXSA9IHsgdHlwZTogJ25vbmUnIH07XG4gICAgICAgICAgICAgICAgaWYgKCFuZXdDZWxsLm9wdGlvbnMuYm9yZGVyWzFdKVxuICAgICAgICAgICAgICAgICAgICBuZXdDZWxsLm9wdGlvbnMuYm9yZGVyWzFdID0geyB0eXBlOiAnbm9uZScgfTtcbiAgICAgICAgICAgICAgICBpZiAoIW5ld0NlbGwub3B0aW9ucy5ib3JkZXJbMl0pXG4gICAgICAgICAgICAgICAgICAgIG5ld0NlbGwub3B0aW9ucy5ib3JkZXJbMl0gPSB7IHR5cGU6ICdub25lJyB9O1xuICAgICAgICAgICAgICAgIGlmICghbmV3Q2VsbC5vcHRpb25zLmJvcmRlclszXSlcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2VsbC5vcHRpb25zLmJvcmRlclszXSA9IHsgdHlwZTogJ25vbmUnIH07XG4gICAgICAgICAgICAgICAgLy8gc2V0IGNvbXBsZXRlIEJvcmRlck9wdGlvbnMgZm9yIGFsbCBzaWRlc1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyclNpZGVzID0gWzAsIDEsIDIsIDNdO1xuICAgICAgICAgICAgICAgIGFyclNpZGVzLmZvckVhY2goaWR4ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2VsbC5vcHRpb25zLmJvcmRlcltpZHhdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogbmV3Q2VsbC5vcHRpb25zLmJvcmRlcltpZHhdLnR5cGUgfHwgREVGX0NFTExfQk9SREVSLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogbmV3Q2VsbC5vcHRpb25zLmJvcmRlcltpZHhdLmNvbG9yIHx8IERFRl9DRUxMX0JPUkRFUi5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHB0OiB0eXBlb2YgbmV3Q2VsbC5vcHRpb25zLmJvcmRlcltpZHhdLnB0ID09PSAnbnVtYmVyJyA/IG5ld0NlbGwub3B0aW9ucy5ib3JkZXJbaWR4XS5wdCA6IERFRl9DRUxMX0JPUkRFUi5wdCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBMQVNUOlxuICAgICAgICAgICAgICAgIG5ld1Jvdy5wdXNoKG5ld0NlbGwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnYWRkVGFibGU6IHRhYmxlUm93cyBoYXMgYSBiYWQgcm93LiBBIHJvdyBzaG91bGQgYmUgYW4gYXJyYXkgb2YgY2VsbHMuIFlvdSBwcm92aWRlZDonKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyUm93cy5wdXNoKG5ld1Jvdyk7XG4gICAgfSk7XG4gICAgLy8gU1RFUCAzOiBTZXQgb3B0aW9uc1xuICAgIG9wdC54ID0gZ2V0U21hcnRQYXJzZU51bWJlcihvcHQueCB8fCAob3B0LnggPT09IDAgPyAwIDogRU1VIC8gMiksICdYJywgcHJlc0xheW91dCk7XG4gICAgb3B0LnkgPSBnZXRTbWFydFBhcnNlTnVtYmVyKG9wdC55IHx8IChvcHQueSA9PT0gMCA/IDAgOiBFTVUgLyAyKSwgJ1knLCBwcmVzTGF5b3V0KTtcbiAgICBpZiAob3B0LmgpXG4gICAgICAgIG9wdC5oID0gZ2V0U21hcnRQYXJzZU51bWJlcihvcHQuaCwgJ1knLCBwcmVzTGF5b3V0KTsgLy8gTk9URTogRG9udCBzZXQgZGVmYXVsdCBgaGAgLSBsZWF2aW5nIGl0IG51bGwgdHJpZ2dlcnMgYXV0by1yb3dIIGluIGBtYWtlWE1MU2xpZGUoKWBcbiAgICBvcHQuZm9udFNpemUgPSBvcHQuZm9udFNpemUgfHwgREVGX0ZPTlRfU0laRTtcbiAgICBvcHQubWFyZ2luID0gb3B0Lm1hcmdpbiA9PT0gMCB8fCBvcHQubWFyZ2luID8gb3B0Lm1hcmdpbiA6IERFRl9DRUxMX01BUkdJTl9JTjtcbiAgICBpZiAodHlwZW9mIG9wdC5tYXJnaW4gPT09ICdudW1iZXInKVxuICAgICAgICBvcHQubWFyZ2luID0gW051bWJlcihvcHQubWFyZ2luKSwgTnVtYmVyKG9wdC5tYXJnaW4pLCBOdW1iZXIob3B0Lm1hcmdpbiksIE51bWJlcihvcHQubWFyZ2luKV07XG4gICAgLy8gTk9URTogZG9udCBhZGQgZGVmYXVsdCBjb2xvciBvbiB0YWJsZXMgd2l0aCBoeXBlcmxpbmtzISAoaXQgY2F1c2VzIGFueSB0ZXh0T2JqJ3Mgd2l0aCBoeXBlcmxpbmtzIHRvIGhhdmUgc3Vic2VxdWVudCB3b3JkcyB0byBiZSBibGFjaylcbiAgICBpZiAoSlNPTi5zdHJpbmdpZnkoeyBhcnJSb3dzOiBhcnJSb3dzIH0pLmluZGV4T2YoJ2h5cGVybGluaycpID09PSAtMSkge1xuICAgICAgICBpZiAoIW9wdC5jb2xvcilcbiAgICAgICAgICAgIG9wdC5jb2xvciA9IG9wdC5jb2xvciB8fCBERUZfRk9OVF9DT0xPUjsgLy8gU2V0IGRlZmF1bHQgY29sb3IgaWYgbmVlZGVkICh0YWJsZSBvcHRpb24gPiBpbmhlcml0IGZyb20gU2xpZGUgPiBkZWZhdWx0IHRvIGJsYWNrKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdC5ib3JkZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignYWRkVGFibGUgYGJvcmRlcmAgb3B0aW9uIG11c3QgYmUgYW4gb2JqZWN0LiBFeDogYHtib3JkZXI6IHt0eXBlOlxcJ25vbmVcXCd9fWAnKTtcbiAgICAgICAgb3B0LmJvcmRlciA9IG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3B0LmJvcmRlcikpIHtcbiAgICAgICAgWzAsIDEsIDIsIDNdLmZvckVhY2goaWR4ID0+IHtcbiAgICAgICAgICAgIG9wdC5ib3JkZXJbaWR4XSA9IG9wdC5ib3JkZXJbaWR4XVxuICAgICAgICAgICAgICAgID8geyB0eXBlOiBvcHQuYm9yZGVyW2lkeF0udHlwZSB8fCBERUZfQ0VMTF9CT1JERVIudHlwZSwgY29sb3I6IG9wdC5ib3JkZXJbaWR4XS5jb2xvciB8fCBERUZfQ0VMTF9CT1JERVIuY29sb3IsIHB0OiBvcHQuYm9yZGVyW2lkeF0ucHQgfHwgREVGX0NFTExfQk9SREVSLnB0IH1cbiAgICAgICAgICAgICAgICA6IHsgdHlwZTogJ25vbmUnIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvcHQuYXV0b1BhZ2UgPSB0eXBlb2Ygb3B0LmF1dG9QYWdlID09PSAnYm9vbGVhbicgPyBvcHQuYXV0b1BhZ2UgOiBmYWxzZTtcbiAgICBvcHQuYXV0b1BhZ2VSZXBlYXRIZWFkZXIgPSB0eXBlb2Ygb3B0LmF1dG9QYWdlUmVwZWF0SGVhZGVyID09PSAnYm9vbGVhbicgPyBvcHQuYXV0b1BhZ2VSZXBlYXRIZWFkZXIgOiBmYWxzZTtcbiAgICBvcHQuYXV0b1BhZ2VIZWFkZXJSb3dzID0gdHlwZW9mIG9wdC5hdXRvUGFnZUhlYWRlclJvd3MgIT09ICd1bmRlZmluZWQnICYmICFpc05hTihOdW1iZXIob3B0LmF1dG9QYWdlSGVhZGVyUm93cykpID8gTnVtYmVyKG9wdC5hdXRvUGFnZUhlYWRlclJvd3MpIDogMTtcbiAgICBvcHQuYXV0b1BhZ2VMaW5lV2VpZ2h0ID0gdHlwZW9mIG9wdC5hdXRvUGFnZUxpbmVXZWlnaHQgIT09ICd1bmRlZmluZWQnICYmICFpc05hTihOdW1iZXIob3B0LmF1dG9QYWdlTGluZVdlaWdodCkpID8gTnVtYmVyKG9wdC5hdXRvUGFnZUxpbmVXZWlnaHQpIDogMDtcbiAgICBpZiAob3B0LmF1dG9QYWdlTGluZVdlaWdodCkge1xuICAgICAgICBpZiAob3B0LmF1dG9QYWdlTGluZVdlaWdodCA+IDEpXG4gICAgICAgICAgICBvcHQuYXV0b1BhZ2VMaW5lV2VpZ2h0ID0gMTtcbiAgICAgICAgZWxzZSBpZiAob3B0LmF1dG9QYWdlTGluZVdlaWdodCA8IC0xKVxuICAgICAgICAgICAgb3B0LmF1dG9QYWdlTGluZVdlaWdodCA9IC0xO1xuICAgIH1cbiAgICAvLyBhdXRvUGFnZSBeXl5cbiAgICAvLyBTZXQvQ2FsYyB0YWJsZSB3aWR0aFxuICAgIC8vIEdldCBzbGlkZSBtYXJnaW5zIC0gc3RhcnQgd2l0aCBkZWZhdWx0IHZhbHVlcywgdGhlbiBhZGp1c3QgaWYgbWFzdGVyIG9yIHNsaWRlIG1hcmdpbnMgZXhpc3RcbiAgICBsZXQgYXJyVGFibGVNYXJnaW4gPSBERUZfU0xJREVfTUFSR0lOX0lOO1xuICAgIC8vIENhc2UgMTogTWFzdGVyIG1hcmdpbnNcbiAgICBpZiAoc2xpZGVMYXlvdXQgJiYgdHlwZW9mIHNsaWRlTGF5b3V0Ll9tYXJnaW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNsaWRlTGF5b3V0Ll9tYXJnaW4pKVxuICAgICAgICAgICAgYXJyVGFibGVNYXJnaW4gPSBzbGlkZUxheW91dC5fbWFyZ2luO1xuICAgICAgICBlbHNlIGlmICghaXNOYU4oTnVtYmVyKHNsaWRlTGF5b3V0Ll9tYXJnaW4pKSkge1xuICAgICAgICAgICAgYXJyVGFibGVNYXJnaW4gPSBbTnVtYmVyKHNsaWRlTGF5b3V0Ll9tYXJnaW4pLCBOdW1iZXIoc2xpZGVMYXlvdXQuX21hcmdpbiksIE51bWJlcihzbGlkZUxheW91dC5fbWFyZ2luKSwgTnVtYmVyKHNsaWRlTGF5b3V0Ll9tYXJnaW4pXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDYXNlIDI6IFRhYmxlIG1hcmdpbnNcbiAgICAvKiBGSVhNRTogYWRkIGBfbWFyZ2luYCBvcHRpb24gdG8gc2xpZGUgb3B0aW9uc1xuICAgICAgICBlbHNlIGlmICggYWRkTmV3U2xpZGUuX21hcmdpbiApIHtcbiAgICAgICAgICAgIGlmICggQXJyYXkuaXNBcnJheShhZGROZXdTbGlkZS5fbWFyZ2luKSApIGFyclRhYmxlTWFyZ2luID0gYWRkTmV3U2xpZGUuX21hcmdpbjtcbiAgICAgICAgICAgIGVsc2UgaWYgKCAhaXNOYU4oTnVtYmVyKGFkZE5ld1NsaWRlLl9tYXJnaW4pKSApIGFyclRhYmxlTWFyZ2luID0gW051bWJlcihhZGROZXdTbGlkZS5fbWFyZ2luKSwgTnVtYmVyKGFkZE5ld1NsaWRlLl9tYXJnaW4pLCBOdW1iZXIoYWRkTmV3U2xpZGUuX21hcmdpbiksIE51bWJlcihhZGROZXdTbGlkZS5fbWFyZ2luKV07XG4gICAgICAgIH1cbiAgICAqL1xuICAgIC8qKlxuICAgICAqIENhbGMgdGFibGUgd2lkdGggZGVwZW5kaW5nIHVwb24gd2hhdCBkYXRhIHdlIGhhdmUgLSBzZXZlcmFsIHNjZW5hcmlvcyBleGlzdCAoaW5jbHVkaW5nIGJhZCBkYXRhLCBlZzogY29sVyBkb2VzbnQgbWF0Y2ggY29sIGNvdW50KVxuICAgICAqIFRoZSBBUEkgZG9lcyBub3QgcmVxdWlyZSBhIGB3YCB2YWx1ZSwgYnV0IFhNTCBnZW5lcmF0aW9uIGRvZXMsIGhlbmNlLCBjb2RlIHRvIGNhbGMgYSB3aWR0aCBiZWxvdyB1c2luZyBjb2xXIHZhbHVlKHMpXG4gICAgICovXG4gICAgaWYgKG9wdC5jb2xXKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Um93Q29sQ250ID0gYXJyUm93c1swXS5yZWR1Y2UoKHRvdGFsTGVuLCBjKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoKChfYSA9IGMgPT09IG51bGwgfHwgYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29sc3BhbikgJiYgdHlwZW9mIGMub3B0aW9ucy5jb2xzcGFuID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRvdGFsTGVuICs9IGMub3B0aW9ucy5jb2xzcGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG90YWxMZW4gKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b3RhbExlbjtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0LmNvbFcgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBvcHQuY29sVyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIEV4OiBgY29sVyA9IDNgIG9yIGBjb2xXID0gJzMnYFxuICAgICAgICAgICAgb3B0LncgPSBNYXRoLmZsb29yKE51bWJlcihvcHQuY29sVykgKiBmaXJzdFJvd0NvbENudCk7XG4gICAgICAgICAgICBvcHQuY29sVyA9IG51bGw7IC8vIElNUE9SVEFOVDogVW5zZXQgYGNvbFdgIHNvIHRhYmxlIGlzIGNyZWF0ZWQgdXNpbmcgYG9wdC53YCwgd2hpY2ggd2lsbCBldmVubHkgZGl2aWRlIGNvbHNcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHQuY29sVyAmJiBBcnJheS5pc0FycmF5KG9wdC5jb2xXKSAmJiBvcHQuY29sVy5sZW5ndGggPT09IDEgJiYgZmlyc3RSb3dDb2xDbnQgPiAxKSB7XG4gICAgICAgICAgICAvLyBFeDogYGNvbFc9WzNdYCBidXQgd2l0aCA+MSBjb2xzIChzYW1lIGFzIGFib3ZlLCB1c2VyIGlzIHNheWluZyBcInVzZSB0aGlzIHdpZHRoIGZvciBhbGxcIilcbiAgICAgICAgICAgIG9wdC53ID0gTWF0aC5mbG9vcihOdW1iZXIob3B0LmNvbFcpICogZmlyc3RSb3dDb2xDbnQpO1xuICAgICAgICAgICAgb3B0LmNvbFcgPSBudWxsOyAvLyBJTVBPUlRBTlQ6IFVuc2V0IGBjb2xXYCBzbyB0YWJsZSBpcyBjcmVhdGVkIHVzaW5nIGBvcHQud2AsIHdoaWNoIHdpbGwgZXZlbmx5IGRpdmlkZSBjb2xzXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0LmNvbFcgJiYgQXJyYXkuaXNBcnJheShvcHQuY29sVykgJiYgb3B0LmNvbFcubGVuZ3RoICE9PSBmaXJzdFJvd0NvbENudCkge1xuICAgICAgICAgICAgLy8gRXJyOiBNaXNtYXRjaGVkIGNvbFcgYW5kIGNvbHMgY291bnRcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYWRkVGFibGU6IG1pc21hdGNoOiAoY29sVy5sZW5ndGggIT0gZGF0YS5sZW5ndGgpIFRoZXJlZm9yZSwgZGVmYXVsdGluZyB0byBldmVubHkgZGlzdHJpYnV0ZWQgY29sIHdpZHRocy4nKTtcbiAgICAgICAgICAgIG9wdC5jb2xXID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChvcHQudykge1xuICAgICAgICBvcHQudyA9IGdldFNtYXJ0UGFyc2VOdW1iZXIob3B0LncsICdYJywgcHJlc0xheW91dCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvcHQudyA9IE1hdGguZmxvb3IocHJlc0xheW91dC5fc2l6ZVcgLyBFTVUgLSBhcnJUYWJsZU1hcmdpblsxXSAtIGFyclRhYmxlTWFyZ2luWzNdKTtcbiAgICB9XG4gICAgLy8gU1RFUCA0OiBDb252ZXJ0IHVuaXRzIHRvIEVNVSBub3cgKHdlIHVzZSBkaWZmZXJlbnQgbG9naWMgaW4gbWFrZVNsaWRlLT50YWJsZSAtIHNtYXJ0Q2FsYyBpcyBub3QgdXNlZClcbiAgICBpZiAob3B0LnggJiYgb3B0LnggPCAyMClcbiAgICAgICAgb3B0LnggPSBpbmNoMkVtdShvcHQueCk7XG4gICAgaWYgKG9wdC55ICYmIG9wdC55IDwgMjApXG4gICAgICAgIG9wdC55ID0gaW5jaDJFbXUob3B0LnkpO1xuICAgIGlmIChvcHQudyAmJiB0eXBlb2Ygb3B0LncgPT09ICdudW1iZXInICYmIG9wdC53IDwgMjApXG4gICAgICAgIG9wdC53ID0gaW5jaDJFbXUob3B0LncpO1xuICAgIGlmIChvcHQuaCAmJiB0eXBlb2Ygb3B0LmggPT09ICdudW1iZXInICYmIG9wdC5oIDwgMjApXG4gICAgICAgIG9wdC5oID0gaW5jaDJFbXUob3B0LmgpO1xuICAgIC8vIFNURVAgNTogTG9vcCBvdmVyIGNlbGxzOiB0cmFuc2Zvcm0gZWFjaCB0byBJVGFibGVDZWxsOyBjaGVjayB0byBzZWUgd2hldGhlciB0byB1bnNldCBgYXV0b1BhZ2VgIHdoaWxlIGhlcmVcbiAgICBhcnJSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgcm93LmZvckVhY2goKGNlbGwsIGlkeSkgPT4ge1xuICAgICAgICAgICAgLy8gQTogVHJhbnNmb3JtIGNlbGwgZGF0YSBpZiBuZWVkZWRcbiAgICAgICAgICAgIC8qIFRhYmxlIHJvd3MgY2FuIGJlIGFuIG9iamVjdCBvciBwbGFpbiB0ZXh0IC0gdHJhbnNmb3JtIGludG8gb2JqZWN0IHdoZW4gbmVlZGVkXG4gICAgICAgICAgICAgICAgLy8gRVg6XG4gICAgICAgICAgICAgICAgdmFyIGFyclRhYlJvd3MxID0gW1xuICAgICAgICAgICAgICAgICAgICBbIHsgdGV4dDonQTFcXG5BMicsIG9wdGlvbnM6e3Jvd3NwYW46MiwgZmlsbDonOTlGRkNDJ30gfSBdXG4gICAgICAgICAgICAgICAgICAgICxbICdCMicsICdDMicsICdEMicsICdFMicgXVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNlbGwgPT09ICdudW1iZXInIHx8IHR5cGVvZiBjZWxsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIEdyYWIgdGFibGUgZm9ybWF0dGluZyBgb3B0c2AgdG8gdXNlIGhlcmUgc28gdGV4dCBzdHlsZS9mb3JtYXQgaW5oZXJpdHMgYXMgaXQgc2hvdWxkXG4gICAgICAgICAgICAgICAgcm93W2lkeV0gPSB7IF90eXBlOiBTTElERV9PQkpFQ1RfVFlQRVMudGFibGVjZWxsLCB0ZXh0OiBTdHJpbmcocm93W2lkeV0pLCBvcHRpb25zOiBvcHQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjZWxsID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIEFSRzA6IGB0ZXh0YFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2VsbC50ZXh0ID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgcm93W2lkeV0udGV4dCA9IHJvd1tpZHldLnRleHQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2VsbC50ZXh0ID09PSAndW5kZWZpbmVkJyB8fCBjZWxsLnRleHQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJvd1tpZHldLnRleHQgPSAnJztcbiAgICAgICAgICAgICAgICAvLyBBUkcxOiBgb3B0aW9uc2A6IGVuc3VyZSBvcHRpb25zIGV4aXN0c1xuICAgICAgICAgICAgICAgIHJvd1tpZHldLm9wdGlvbnMgPSBjZWxsLm9wdGlvbnMgfHwge307XG4gICAgICAgICAgICAgICAgLy8gU2V0IHR5cGUgdG8gdGFiZWxjZWxsXG4gICAgICAgICAgICAgICAgcm93W2lkeV0uX3R5cGUgPSBTTElERV9PQkpFQ1RfVFlQRVMudGFibGVjZWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQjogQ2hlY2sgZm9yIGZpbmUtZ3JhaW5lZCBmb3JtYXR0aW5nLCBkaXNhYmxlIGF1dG8tcGFnZSB3aGVuIGZvdW5kXG4gICAgICAgICAgICAvLyBTaW5jZSBnZW5YbWxUZXh0Qm9keSBhbHJlYWR5IGNoZWNrcyBmb3IgdGV4dCBhcnJheSAoIHRleHQ6W3t9LC4ue31dICkgd2UncmUgZG9uZSFcbiAgICAgICAgICAgIC8vIFRleHQgaW4gaW5kaXZpZHVhbCBjZWxscyB3aWxsIGJlIGZvcm1hdHRlZCBhcyB0aGV5IGFyZSBhZGRlZCBieSBjYWxscyB0byBnZW5YbWxUZXh0Qm9keSB3aXRoaW4gdGFibGUgYnVpbGRlclxuICAgICAgICAgICAgLy8gaWYgKGNlbGwudGV4dCAmJiBBcnJheS5pc0FycmF5KGNlbGwudGV4dCkpIG9wdC5hdXRvUGFnZSA9IGZhbHNlXG4gICAgICAgICAgICAvLyBUT0RPOiBGSVhNRTogV0lQOiAyMDIxMDgwNzogV2UgY2FudCBkbyB0aGlzIGFueW1vcmVcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gSWYgYXV0b1BhZ2UgPSB0cnVlLCB3ZSBuZWVkIHRvIHJldHVybiByZWZlcmVuY2VzIHRvIG5ld2x5IGNyZWF0ZWQgc2xpZGVzIGlmIGFueVxuICAgIGNvbnN0IG5ld0F1dG9QYWdlZFNsaWRlcyA9IFtdO1xuICAgIC8vIFNURVAgNjogQXV0by1QYWdpbmc6ICh2aWEge29wdGlvbnN9IGFuZCB1c2VkIGludGVybmFsbHkpXG4gICAgLy8gKHVzZWQgaW50ZXJuYWxseSBieSBgdGFibGVUb1NsaWRlcygpYCB0byBub3QgZW5nYWdlIHJlY3Vyc2lvbiAtIHdlJ3ZlIGFscmVhZHkgcGFnZWQgdGhlIHRhYmxlIGRhdGEsIGp1c3QgYWRkIHRoaXMgb25lKVxuICAgIGlmIChvcHQgJiYgIW9wdC5hdXRvUGFnZSkge1xuICAgICAgICAvLyBDcmVhdGUgaHlwZXJsaW5rIHJlbHMgKElNUE9SVEFOVDogV2FpdCB1bnRpbCB0YWJsZSBoYXMgYmVlbiBzaHJlZGRlZCBhY3Jvc3MgU2xpZGVzIG9yIGFsbCByZWxzIHdpbGwgZW5kLXVwIG9uIFNsaWRlIDEhKVxuICAgICAgICBjcmVhdGVIeXBlcmxpbmtSZWxzKHRhcmdldCwgYXJyUm93cyk7XG4gICAgICAgIC8vIEFkZCBzbGlkZU9iamVjdHMgKE5PVEU6IFVzZSBgZXh0ZW5kYCB0byBhdm9pZCBtdXRhdGlvbilcbiAgICAgICAgdGFyZ2V0Ll9zbGlkZU9iamVjdHMucHVzaCh7XG4gICAgICAgICAgICBfdHlwZTogU0xJREVfT0JKRUNUX1RZUEVTLnRhYmxlLFxuICAgICAgICAgICAgYXJyVGFiUm93czogYXJyUm93cyxcbiAgICAgICAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIG9wdCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG9wdC5hdXRvUGFnZVJlcGVhdEhlYWRlcilcbiAgICAgICAgICAgIG9wdC5fYXJyT2JqVGFiSGVhZFJvd3MgPSBhcnJSb3dzLmZpbHRlcigoX3JvdywgaWR4KSA9PiBpZHggPCBvcHQuYXV0b1BhZ2VIZWFkZXJSb3dzKTtcbiAgICAgICAgLy8gTG9vcCBvdmVyIHJvd3MgYW5kIGNyZWF0ZSAxLU4gdGFibGVzIGFzIG5lZWRlZCAoSVNTVUUjMjEpXG4gICAgICAgIGdldFNsaWRlc0ZvclRhYmxlUm93cyhhcnJSb3dzLCBvcHQsIHByZXNMYXlvdXQsIHNsaWRlTGF5b3V0KS5mb3JFYWNoKChzbGlkZSwgaWR4KSA9PiB7XG4gICAgICAgICAgICAvLyBBOiBDcmVhdGUgbmV3IFNsaWRlIHdoZW4gbmVlZGVkLCBvdGhlcndpc2UsIHVzZSBleGlzdGluZyAoTk9URTogTW9yZSB0aGFuIDEgdGFibGUgY2FuIGJlIG9uIGEgU2xpZGUsIHNvIHdlIHdpbGwgZ28gdXAgQU5EIGRvd24gdGhlIFNsaWRlIGNoYWluKVxuICAgICAgICAgICAgaWYgKCFnZXRTbGlkZSh0YXJnZXQuX3NsaWRlTnVtICsgaWR4KSlcbiAgICAgICAgICAgICAgICBzbGlkZXMucHVzaChhZGRTbGlkZSh7IG1hc3Rlck5hbWU6IChzbGlkZUxheW91dCA9PT0gbnVsbCB8fCBzbGlkZUxheW91dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2xpZGVMYXlvdXQuX25hbWUpIHx8IG51bGwgfSkpO1xuICAgICAgICAgICAgLy8gQjogUmVzZXQgb3B0LnkgdG8gYG9wdGlvbmAvYG1hcmdpbmAgYWZ0ZXIgZmlyc3QgU2xpZGUgKElTU1VFIzQzLCBJU1NVRSM0NywgSVNTVUUjNDgpXG4gICAgICAgICAgICBpZiAoaWR4ID4gMClcbiAgICAgICAgICAgICAgICBvcHQueSA9IGluY2gyRW11KG9wdC5hdXRvUGFnZVNsaWRlU3RhcnRZIHx8IG9wdC5uZXdTbGlkZVN0YXJ0WSB8fCBhcnJUYWJsZU1hcmdpblswXSk7XG4gICAgICAgICAgICAvLyBDOiBBZGQgdGhpcyB0YWJsZSB0byBuZXcgU2xpZGVcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTbGlkZSA9IGdldFNsaWRlKHRhcmdldC5fc2xpZGVOdW0gKyBpZHgpO1xuICAgICAgICAgICAgICAgIG9wdC5hdXRvUGFnZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBoeXBlcmxpbmsgcmVscyAoSU1QT1JUQU5UOiBXYWl0IHVudGlsIHRhYmxlIGhhcyBiZWVuIHNocmVkZGVkIGFjcm9zcyBTbGlkZXMgb3IgYWxsIHJlbHMgd2lsbCBlbmQtdXAgb24gU2xpZGUgMSEpXG4gICAgICAgICAgICAgICAgY3JlYXRlSHlwZXJsaW5rUmVscyhuZXdTbGlkZSwgc2xpZGUucm93cyk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHJvd3MgdG8gbmV3IHNsaWRlXG4gICAgICAgICAgICAgICAgbmV3U2xpZGUuYWRkVGFibGUoc2xpZGUucm93cywgT2JqZWN0LmFzc2lnbih7fSwgb3B0KSk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHJlZmVyZW5jZSB0byB0aGUgbmV3IHNsaWRlIHNvIGl0IGNhbiBiZSByZXR1cm5lZCwgYnV0IGRvbid0IGFkZCB0aGUgZmlyc3Qgb25lIGJlY2F1c2UgdGhlIHVzZXIgYWxyZWFkeSBoYXMgYSByZWZlcmVuY2UgdG8gdGhhdCBvbmUuXG4gICAgICAgICAgICAgICAgaWYgKGlkeCA+IDApXG4gICAgICAgICAgICAgICAgICAgIG5ld0F1dG9QYWdlZFNsaWRlcy5wdXNoKG5ld1NsaWRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdBdXRvUGFnZWRTbGlkZXM7XG59XG4vKipcbiAqIEFkZHMgYSB0ZXh0IG9iamVjdCB0byBhIHNsaWRlIGRlZmluaXRpb24uXG4gKiBAcGFyYW0ge1ByZXNTbGlkZX0gdGFyZ2V0IC0gc2xpZGUgb2JqZWN0IHRoYXQgdGhlIHRleHQgc2hvdWxkIGJlIGFkZGVkIHRvXG4gKiBAcGFyYW0ge3N0cmluZ3xUZXh0UHJvcHNbXX0gdGV4dCB0ZXh0IHN0cmluZyBvciBvYmplY3RcbiAqIEBwYXJhbSB7VGV4dFByb3BzT3B0aW9uc30gb3B0cyB0ZXh0IG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNQbGFjZWhvbGRlciB3aGV0aGVyIHRoaXMgYSBwbGFjZWhvbGRlciBvYmplY3RcbiAqIEBzaW5jZTogMS4wLjBcbiAqL1xuZnVuY3Rpb24gYWRkVGV4dERlZmluaXRpb24odGFyZ2V0LCB0ZXh0LCBvcHRzLCBpc1BsYWNlaG9sZGVyKSB7XG4gICAgY29uc3QgbmV3T2JqZWN0ID0ge1xuICAgICAgICBfdHlwZTogaXNQbGFjZWhvbGRlciA/IFNMSURFX09CSkVDVF9UWVBFUy5wbGFjZWhvbGRlciA6IFNMSURFX09CSkVDVF9UWVBFUy50ZXh0LFxuICAgICAgICBzaGFwZTogKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zaGFwZSkgfHwgU0hBUEVfVFlQRS5SRUNUQU5HTEUsXG4gICAgICAgIHRleHQ6ICF0ZXh0IHx8IHRleHQubGVuZ3RoID09PSAwID8gW3sgdGV4dDogJycsIG9wdGlvbnM6IG51bGwgfV0gOiB0ZXh0LFxuICAgICAgICBvcHRpb25zOiBvcHRzIHx8IHt9LFxuICAgIH07XG4gICAgZnVuY3Rpb24gY2xlYW5PcHRzKGl0ZW1PcHRzKSB7XG4gICAgICAgIC8vIFNURVAgMTogU2V0IHNvbWUgb3B0aW9uc1xuICAgICAgICB7XG4gICAgICAgICAgICAvLyBBLjE6IENvbG9yIChwbGFjZWhvbGRlcnMgc2hvdWxkIGluaGVyaXQgdGhlaXIgY29sb3JzIG9yIG92ZXJyaWRlIHRoZW0sIHNvIGRvbid0IGRlZmF1bHQgdGhlbSlcbiAgICAgICAgICAgIGlmICghaXRlbU9wdHMucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBpdGVtT3B0cy5jb2xvciA9IGl0ZW1PcHRzLmNvbG9yIHx8IG5ld09iamVjdC5vcHRpb25zLmNvbG9yIHx8IHRhcmdldC5jb2xvciB8fCBERUZfRk9OVF9DT0xPUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEEuMjogUGxhY2Vob2xkZXIgc2hvdWxkIGluaGVyaXQgdGhlaXIgYnVsbGV0cyBvciBvdmVycmlkZSB0aGVtLCBzbyBkb24ndCBkZWZhdWx0IHRoZW1cbiAgICAgICAgICAgIGlmIChpdGVtT3B0cy5wbGFjZWhvbGRlciB8fCBpc1BsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgaXRlbU9wdHMuYnVsbGV0ID0gaXRlbU9wdHMuYnVsbGV0IHx8IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQS4zOiBUZXh0IHRhcmdldGluZyBhIHBsYWNlaG9sZGVyIG5lZWQgdG8gaW5oZXJpdCB0aGUgcGxhY2Vob2xkZXJzIG9wdGlvbnMgKGVnOiBtYXJnaW4sIHZhbGlnbiwgZXRjLikgKElzc3VlICM2NDApXG4gICAgICAgICAgICBpZiAoaXRlbU9wdHMucGxhY2Vob2xkZXIgJiYgdGFyZ2V0Ll9zbGlkZUxheW91dCAmJiB0YXJnZXQuX3NsaWRlTGF5b3V0Ll9zbGlkZU9iamVjdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZUhvbGQgPSB0YXJnZXQuX3NsaWRlTGF5b3V0Ll9zbGlkZU9iamVjdHMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5fdHlwZSA9PT0gJ3BsYWNlaG9sZGVyJyAmJiBpdGVtLm9wdGlvbnMgJiYgaXRlbS5vcHRpb25zLnBsYWNlaG9sZGVyICYmIGl0ZW0ub3B0aW9ucy5wbGFjZWhvbGRlciA9PT0gaXRlbU9wdHMucGxhY2Vob2xkZXIpWzBdO1xuICAgICAgICAgICAgICAgIGlmIChwbGFjZUhvbGQgPT09IG51bGwgfHwgcGxhY2VIb2xkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwbGFjZUhvbGQub3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgaXRlbU9wdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGl0ZW1PcHRzKSwgcGxhY2VIb2xkLm9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQS40OiBPdGhlciBvcHRpb25zXG4gICAgICAgICAgICBpdGVtT3B0cy5vYmplY3ROYW1lID0gaXRlbU9wdHMub2JqZWN0TmFtZVxuICAgICAgICAgICAgICAgID8gZW5jb2RlWG1sRW50aXRpZXMoaXRlbU9wdHMub2JqZWN0TmFtZSlcbiAgICAgICAgICAgICAgICA6IGBUZXh0ICR7dGFyZ2V0Ll9zbGlkZU9iamVjdHMuZmlsdGVyKG9iaiA9PiBvYmouX3R5cGUgPT09IFNMSURFX09CSkVDVF9UWVBFUy50ZXh0KS5sZW5ndGh9YDtcbiAgICAgICAgICAgIC8vIEI6XG4gICAgICAgICAgICBpZiAoaXRlbU9wdHMuc2hhcGUgPT09IFNIQVBFX1RZUEUuTElORSkge1xuICAgICAgICAgICAgICAgIC8vIFNoYXBlTGluZVByb3BzIGRlZmF1bHRzXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TGluZU9wdHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGl0ZW1PcHRzLmxpbmUudHlwZSB8fCAnc29saWQnLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogaXRlbU9wdHMubGluZS5jb2xvciB8fCBERUZfU0hBUEVfTElORV9DT0xPUixcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwYXJlbmN5OiBpdGVtT3B0cy5saW5lLnRyYW5zcGFyZW5jeSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogaXRlbU9wdHMubGluZS53aWR0aCB8fCAxLFxuICAgICAgICAgICAgICAgICAgICBkYXNoVHlwZTogaXRlbU9wdHMubGluZS5kYXNoVHlwZSB8fCAnc29saWQnLFxuICAgICAgICAgICAgICAgICAgICBiZWdpbkFycm93VHlwZTogaXRlbU9wdHMubGluZS5iZWdpbkFycm93VHlwZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICBlbmRBcnJvd1R5cGU6IGl0ZW1PcHRzLmxpbmUuZW5kQXJyb3dUeXBlIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW1PcHRzLmxpbmUgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgICAgICAgICBpdGVtT3B0cy5saW5lID0gbmV3TGluZU9wdHM7XG4gICAgICAgICAgICAgICAgLy8gMzogSGFuZGxlIGxpbmUgKGxvdHMgb2YgZGVwcmVjYXRlZCBvcHRzKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbU9wdHMubGluZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG1wT3B0cyA9IG5ld0xpbmVPcHRzO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW1PcHRzLmxpbmUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wT3B0cy5jb2xvciA9IGl0ZW1PcHRzLmxpbmU7IC8vIEBkZXByZWNhdGVkIFtyZW1vdmUgaW4gdjQuMF1cbiAgICAgICAgICAgICAgICAgICAgLy8gdG1wT3B0cy5jb2xvciA9IGl0ZW1PcHRzLmxpbmUhLnRvU3RyaW5nKCkgLy8gQGRlcHJlY2F0ZWQgYGl0ZW1PcHRzLmxpbmVgOltzdHJpbmddICh3YXMgbGluZSBjb2xvcilcbiAgICAgICAgICAgICAgICAgICAgaXRlbU9wdHMubGluZSA9IHRtcE9wdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbU9wdHMubGluZVNpemUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICBpdGVtT3B0cy5saW5lLndpZHRoID0gaXRlbU9wdHMubGluZVNpemU7IC8vIEBkZXByZWNhdGVkIChwYXJ0IG9mIGBTaGFwZUxpbmVQcm9wc2Agbm93KVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbU9wdHMubGluZURhc2ggPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICBpdGVtT3B0cy5saW5lLmRhc2hUeXBlID0gaXRlbU9wdHMubGluZURhc2g7IC8vIEBkZXByZWNhdGVkIChwYXJ0IG9mIGBTaGFwZUxpbmVQcm9wc2Agbm93KVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbU9wdHMubGluZUhlYWQgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICBpdGVtT3B0cy5saW5lLmJlZ2luQXJyb3dUeXBlID0gaXRlbU9wdHMubGluZUhlYWQ7IC8vIEBkZXByZWNhdGVkIChwYXJ0IG9mIGBTaGFwZUxpbmVQcm9wc2Agbm93KVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbU9wdHMubGluZVRhaWwgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICBpdGVtT3B0cy5saW5lLmVuZEFycm93VHlwZSA9IGl0ZW1PcHRzLmxpbmVUYWlsOyAvLyBAZGVwcmVjYXRlZCAocGFydCBvZiBgU2hhcGVMaW5lUHJvcHNgIG5vdylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEM6IExpbmUgb3B0c1xuICAgICAgICAgICAgaXRlbU9wdHMubGluZSA9IGl0ZW1PcHRzLmxpbmUgfHwge307XG4gICAgICAgICAgICBpdGVtT3B0cy5saW5lU3BhY2luZyA9IGl0ZW1PcHRzLmxpbmVTcGFjaW5nICYmICFpc05hTihpdGVtT3B0cy5saW5lU3BhY2luZykgPyBpdGVtT3B0cy5saW5lU3BhY2luZyA6IG51bGw7XG4gICAgICAgICAgICBpdGVtT3B0cy5saW5lU3BhY2luZ011bHRpcGxlID0gaXRlbU9wdHMubGluZVNwYWNpbmdNdWx0aXBsZSAmJiAhaXNOYU4oaXRlbU9wdHMubGluZVNwYWNpbmdNdWx0aXBsZSkgPyBpdGVtT3B0cy5saW5lU3BhY2luZ011bHRpcGxlIDogbnVsbDtcbiAgICAgICAgICAgIC8vIEQ6IFRyYW5zZm9ybSB0ZXh0IG9wdGlvbnMgdG8gYm9keVByb3BlcnRpZXMgYXMgdGhhdHMgaG93IHdlIGJ1aWxkIFhNTFxuICAgICAgICAgICAgaXRlbU9wdHMuX2JvZHlQcm9wID0gaXRlbU9wdHMuX2JvZHlQcm9wIHx8IHt9O1xuICAgICAgICAgICAgaXRlbU9wdHMuX2JvZHlQcm9wLmF1dG9GaXQgPSBpdGVtT3B0cy5hdXRvRml0IHx8IGZhbHNlOyAvLyBERVBSRUNBVEVEOiAoMy4zLjApIElmIHRydWUsIHNoYXBlIHdpbGwgY29sbGFwc2UgdG8gdGV4dCBzaXplIChGaXQgVG8gc2hhcGUpXG4gICAgICAgICAgICBpdGVtT3B0cy5fYm9keVByb3AuYW5jaG9yID0gIWl0ZW1PcHRzLnBsYWNlaG9sZGVyID8gVEVYVF9WQUxJR04uY3RyIDogbnVsbDsgLy8gVkFMUzogW3QsY3RyLGJdXG4gICAgICAgICAgICBpdGVtT3B0cy5fYm9keVByb3AudmVydCA9IGl0ZW1PcHRzLnZlcnQgfHwgbnVsbDsgLy8gVkFMUzogW2VhVmVydCxob3J6LG1vbmdvbGlhblZlcnQsdmVydCx2ZXJ0MjcwLHdvcmRBcnRWZXJ0LHdvcmRBcnRWZXJ0UnRsXVxuICAgICAgICAgICAgaXRlbU9wdHMuX2JvZHlQcm9wLndyYXAgPSB0eXBlb2YgaXRlbU9wdHMud3JhcCA9PT0gJ2Jvb2xlYW4nID8gaXRlbU9wdHMud3JhcCA6IHRydWU7XG4gICAgICAgICAgICAvLyBFOiBJbnNldFxuICAgICAgICAgICAgLy8gQGRlcHJlY2F0ZWQgMy4xMC4wIChgaW5zZXRgIC0gdXNlIGBtYXJnaW5gKVxuICAgICAgICAgICAgaWYgKChpdGVtT3B0cy5pbnNldCAmJiAhaXNOYU4oTnVtYmVyKGl0ZW1PcHRzLmluc2V0KSkpIHx8IGl0ZW1PcHRzLmluc2V0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaXRlbU9wdHMuX2JvZHlQcm9wLmxJbnMgPSBpbmNoMkVtdShpdGVtT3B0cy5pbnNldCk7XG4gICAgICAgICAgICAgICAgaXRlbU9wdHMuX2JvZHlQcm9wLnJJbnMgPSBpbmNoMkVtdShpdGVtT3B0cy5pbnNldCk7XG4gICAgICAgICAgICAgICAgaXRlbU9wdHMuX2JvZHlQcm9wLnRJbnMgPSBpbmNoMkVtdShpdGVtT3B0cy5pbnNldCk7XG4gICAgICAgICAgICAgICAgaXRlbU9wdHMuX2JvZHlQcm9wLmJJbnMgPSBpbmNoMkVtdShpdGVtT3B0cy5pbnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGOiBUcmFuc2Zvcm0gQGRlcHJlY2F0ZWQgcHJvcHNcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbU9wdHMudW5kZXJsaW5lID09PSAnYm9vbGVhbicgJiYgaXRlbU9wdHMudW5kZXJsaW5lID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIGl0ZW1PcHRzLnVuZGVybGluZSA9IHsgc3R5bGU6ICdzbmcnIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU1RFUCAyOiBUcmFuc2Zvcm0gYGFsaWduYC9gdmFsaWduYCB0byBYTUwgdmFsdWVzLCBzdG9yZSBpbiBfYm9keVByb3AgZm9yIFhNTCBnZW5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKChpdGVtT3B0cy5hbGlnbiB8fCAnJykudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdjJykgPT09IDApXG4gICAgICAgICAgICAgICAgaXRlbU9wdHMuX2JvZHlQcm9wLmFsaWduID0gVEVYVF9IQUxJR04uY2VudGVyO1xuICAgICAgICAgICAgZWxzZSBpZiAoKGl0ZW1PcHRzLmFsaWduIHx8ICcnKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2wnKSA9PT0gMClcbiAgICAgICAgICAgICAgICBpdGVtT3B0cy5fYm9keVByb3AuYWxpZ24gPSBURVhUX0hBTElHTi5sZWZ0O1xuICAgICAgICAgICAgZWxzZSBpZiAoKGl0ZW1PcHRzLmFsaWduIHx8ICcnKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3InKSA9PT0gMClcbiAgICAgICAgICAgICAgICBpdGVtT3B0cy5fYm9keVByb3AuYWxpZ24gPSBURVhUX0hBTElHTi5yaWdodDtcbiAgICAgICAgICAgIGVsc2UgaWYgKChpdGVtT3B0cy5hbGlnbiB8fCAnJykudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdqJykgPT09IDApXG4gICAgICAgICAgICAgICAgaXRlbU9wdHMuX2JvZHlQcm9wLmFsaWduID0gVEVYVF9IQUxJR04uanVzdGlmeTtcbiAgICAgICAgICAgIGlmICgoaXRlbU9wdHMudmFsaWduIHx8ICcnKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2InKSA9PT0gMClcbiAgICAgICAgICAgICAgICBpdGVtT3B0cy5fYm9keVByb3AuYW5jaG9yID0gVEVYVF9WQUxJR04uYjtcbiAgICAgICAgICAgIGVsc2UgaWYgKChpdGVtT3B0cy52YWxpZ24gfHwgJycpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignbScpID09PSAwKVxuICAgICAgICAgICAgICAgIGl0ZW1PcHRzLl9ib2R5UHJvcC5hbmNob3IgPSBURVhUX1ZBTElHTi5jdHI7XG4gICAgICAgICAgICBlbHNlIGlmICgoaXRlbU9wdHMudmFsaWduIHx8ICcnKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3QnKSA9PT0gMClcbiAgICAgICAgICAgICAgICBpdGVtT3B0cy5fYm9keVByb3AuYW5jaG9yID0gVEVYVF9WQUxJR04udDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTVEVQIDM6IFJPQlVTVDogU2V0IHJhdGlvbmFsIHZhbHVlcyBmb3Igc29tZSBzaGFkb3cgcHJvcHMgaWYgbmVlZGVkXG4gICAgICAgIGNvcnJlY3RTaGFkb3dPcHRpb25zKGl0ZW1PcHRzLnNoYWRvdyk7XG4gICAgICAgIHJldHVybiBpdGVtT3B0cztcbiAgICB9XG4gICAgLy8gU1RFUCAxOiBDcmVhdGUvQ2xlYW4gb2JqZWN0IG9wdGlvbnNcbiAgICBuZXdPYmplY3Qub3B0aW9ucyA9IGNsZWFuT3B0cyhuZXdPYmplY3Qub3B0aW9ucyk7XG4gICAgLy8gU1RFUCAyOiBDcmVhdGUvQ2xlYW4gdGV4dCBvcHRpb25zXG4gICAgbmV3T2JqZWN0LnRleHQuZm9yRWFjaChpdGVtID0+IChpdGVtLm9wdGlvbnMgPSBjbGVhbk9wdHMoaXRlbS5vcHRpb25zIHx8IHt9KSkpO1xuICAgIC8vIFNURVAgMzogQ3JlYXRlIGh5cGVybGlua3NcbiAgICBjcmVhdGVIeXBlcmxpbmtSZWxzKHRhcmdldCwgbmV3T2JqZWN0LnRleHQgfHwgJycpO1xuICAgIC8vIExBU1Q6IEFkZCBvYmplY3QgdG8gU2xpZGVcbiAgICB0YXJnZXQuX3NsaWRlT2JqZWN0cy5wdXNoKG5ld09iamVjdCk7XG59XG4vKipcbiAqIEFkZHMgcGxhY2Vob2xkZXIgb2JqZWN0cyB0byBzbGlkZVxuICogQHBhcmFtIHtQcmVzU2xpZGV9IHNsaWRlIC0gc2xpZGUgb2JqZWN0IGNvbnRhaW5pbmcgbGF5b3V0c1xuICovXG5mdW5jdGlvbiBhZGRQbGFjZWhvbGRlcnNUb1NsaWRlTGF5b3V0cyhzbGlkZSkge1xuICAgIC8vIEFkZCBhbGwgcGxhY2Vob2xkZXJzIG9uIHRoaXMgU2xpZGUgdGhhdCBkb250IGFscmVhZHkgZXhpc3RcbiAgICAoc2xpZGUuX3NsaWRlTGF5b3V0Ll9zbGlkZU9iamVjdHMgfHwgW10pLmZvckVhY2goc2xpZGVMYXlvdXRPYmogPT4ge1xuICAgICAgICBpZiAoc2xpZGVMYXlvdXRPYmouX3R5cGUgPT09IFNMSURFX09CSkVDVF9UWVBFUy5wbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgLy8gQTogU2VhcmNoIGZvciB0aGlzIHBsYWNlaG9sZGVyIG9uIFNsaWRlIGJlZm9yZSB3ZSBhZGRcbiAgICAgICAgICAgIC8vIE5PVEU6IENoZWNrIHRvIGVuc3VyZSBhIHBsYWNlaG9sZGVyIGRvZXMgbm90IGFscmVhZHkgZXhpc3Qgb24gdGhlIFNsaWRlXG4gICAgICAgICAgICAvLyBUaGV5IGFyZSBjcmVhdGVkIHdoZW4gdGhleSBoYXZlIGJlZW4gcG9wdWxhdGVkIHdpdGggdGV4dCAoZXg6IGBzbGlkZS5hZGRUZXh0KCdIaScsIHsgcGxhY2Vob2xkZXI6J3RpdGxlJyB9KTtgKVxuICAgICAgICAgICAgaWYgKHNsaWRlLl9zbGlkZU9iamVjdHMuZmlsdGVyKHNsaWRlT2JqID0+IHNsaWRlT2JqLm9wdGlvbnMgJiYgc2xpZGVPYmoub3B0aW9ucy5wbGFjZWhvbGRlciA9PT0gc2xpZGVMYXlvdXRPYmoub3B0aW9ucy5wbGFjZWhvbGRlcikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYWRkVGV4dERlZmluaXRpb24oc2xpZGUsIFt7IHRleHQ6ICcnIH1dLCBzbGlkZUxheW91dE9iai5vcHRpb25zLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4vKipcbiAqIEFkZHMgYSBiYWNrZ3JvdW5kIGltYWdlIG9yIGNvbG9yIHRvIGEgc2xpZGUgZGVmaW5pdGlvbi5cbiAqIEBwYXJhbSB7QmFja2dyb3VuZFByb3BzfSBwcm9wcyAtIGNvbG9yIHN0cmluZyBvciBhbiBvYmplY3Qgd2l0aCBpbWFnZSBkZWZpbml0aW9uXG4gKiBAcGFyYW0ge1ByZXNTbGlkZX0gdGFyZ2V0IC0gc2xpZGUgb2JqZWN0IHRoYXQgdGhlIGJhY2tncm91bmQgaXMgc2V0IHRvXG4gKi9cbmZ1bmN0aW9uIGFkZEJhY2tncm91bmREZWZpbml0aW9uKHByb3BzLCB0YXJnZXQpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gQTogQGRlcHJlY2F0ZWRcbiAgICBpZiAodGFyZ2V0LmJrZ2QpIHtcbiAgICAgICAgaWYgKCF0YXJnZXQuYmFja2dyb3VuZClcbiAgICAgICAgICAgIHRhcmdldC5iYWNrZ3JvdW5kID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0LmJrZ2QgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGFyZ2V0LmJhY2tncm91bmQuY29sb3IgPSB0YXJnZXQuYmtnZDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0LmJrZ2QuZGF0YSlcbiAgICAgICAgICAgICAgICB0YXJnZXQuYmFja2dyb3VuZC5kYXRhID0gdGFyZ2V0LmJrZ2QuZGF0YTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQuYmtnZC5wYXRoKVxuICAgICAgICAgICAgICAgIHRhcmdldC5iYWNrZ3JvdW5kLnBhdGggPSB0YXJnZXQuYmtnZC5wYXRoO1xuICAgICAgICAgICAgaWYgKHRhcmdldC5ia2dkLnNyYylcbiAgICAgICAgICAgICAgICB0YXJnZXQuYmFja2dyb3VuZC5wYXRoID0gdGFyZ2V0LmJrZ2Quc3JjOyAvLyBAZGVwcmVjYXRlZCAoZHJvcCBpbiA0LngpXG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKChfYSA9IHRhcmdldC5iYWNrZ3JvdW5kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlsbClcbiAgICAgICAgdGFyZ2V0LmJhY2tncm91bmQuY29sb3IgPSB0YXJnZXQuYmFja2dyb3VuZC5maWxsO1xuICAgIC8vIEI6IEhhbmRsZSBtZWRpYVxuICAgIGlmIChwcm9wcyAmJiAocHJvcHMucGF0aCB8fCBwcm9wcy5kYXRhKSkge1xuICAgICAgICAvLyBBbGxvdyB0aGUgdXNlIG9mIG9ubHkgdGhlIGRhdGEga2V5IChgcGF0aGAgaXNudCByZXFkKVxuICAgICAgICBwcm9wcy5wYXRoID0gcHJvcHMucGF0aCB8fCAncHJlZW5jb2RlZC5wbmcnO1xuICAgICAgICBsZXQgc3RySW1nRXh0biA9IChwcm9wcy5wYXRoLnNwbGl0KCcuJykucG9wKCkgfHwgJ3BuZycpLnNwbGl0KCc/JylbMF07IC8vIEhhbmRsZSBcImJsYWguanBnP3dpZHRoPTU0MFwiIGV0Yy5cbiAgICAgICAgaWYgKHN0ckltZ0V4dG4gPT09ICdqcGcnKVxuICAgICAgICAgICAgc3RySW1nRXh0biA9ICdqcGVnJzsgLy8gYmFzZTY0LWVuY29kZWQganBnJ3MgY29tZSBvdXQgYXMgXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai9bLi4uXVwiLCBzbyBjb3JyZWN0IGV4dHRuZXNpb24gdG8gYXZvaWQgY29udGVudCB3YXJuaW5ncyBhdCBQUFQgc3RhcnR1cFxuICAgICAgICB0YXJnZXQuX3JlbHNNZWRpYSA9IHRhcmdldC5fcmVsc01lZGlhIHx8IFtdO1xuICAgICAgICBjb25zdCBpbnRSZWxzID0gdGFyZ2V0Ll9yZWxzTWVkaWEubGVuZ3RoICsgMTtcbiAgICAgICAgLy8gTk9URTogYFRhcmdldGAgY2Fubm90IGhhdmUgc3BhY2VzIChlZzpcIlNsaWRlIDEtaW1hZ2UtMS5qcGdcIikgb3IgYSBcInByZXNlbnRhdGlvbiBpcyBjb3JydXB0XCIgd2FybmluZyBjb21lcyB1cFxuICAgICAgICB0YXJnZXQuX3JlbHNNZWRpYS5wdXNoKHtcbiAgICAgICAgICAgIHBhdGg6IHByb3BzLnBhdGgsXG4gICAgICAgICAgICB0eXBlOiBTTElERV9PQkpFQ1RfVFlQRVMuaW1hZ2UsXG4gICAgICAgICAgICBleHRuOiBzdHJJbWdFeHRuLFxuICAgICAgICAgICAgZGF0YTogcHJvcHMuZGF0YSB8fCBudWxsLFxuICAgICAgICAgICAgcklkOiBpbnRSZWxzLFxuICAgICAgICAgICAgVGFyZ2V0OiBgLi4vbWVkaWEvJHsodGFyZ2V0Ll9uYW1lIHx8ICcnKS5yZXBsYWNlKC9cXHMrL2dpLCAnLScpfS1pbWFnZS0ke3RhcmdldC5fcmVsc01lZGlhLmxlbmd0aCArIDF9LiR7c3RySW1nRXh0bn1gLFxuICAgICAgICB9KTtcbiAgICAgICAgdGFyZ2V0Ll9ia2dkSW1nUmlkID0gaW50UmVscztcbiAgICB9XG59XG4vKipcbiAqIFBhcnNlcyB0ZXh0L3RleHQtb2JqZWN0cyBmcm9tIGBhZGRUZXh0KClgIGFuZCBgYWRkVGFibGUoKWAgbWV0aG9kczsgY3JlYXRlcyAnaHlwZXJsaW5rJy10eXBlIFNsaWRlIFJlbHMgZm9yIGVhY2ggaHlwZXJsaW5rIGZvdW5kXG4gKiBAcGFyYW0ge1ByZXNTbGlkZX0gdGFyZ2V0IC0gc2xpZGUgb2JqZWN0IHRoYXQgYW55IGh5cGVybGlua3Mgd2lsbCBiZSBiZSBhZGRlZCB0b1xuICogQHBhcmFtIHtudW1iZXIgfCBzdHJpbmcgfCBUZXh0UHJvcHMgfCBUZXh0UHJvcHNbXSB8IElUYWJsZUNlbGxbXVtdfSB0ZXh0IC0gdGV4dCB0byBwYXJzZVxuICovXG5mdW5jdGlvbiBjcmVhdGVIeXBlcmxpbmtSZWxzKHRhcmdldCwgdGV4dCwgb3B0aW9ucykge1xuICAgIGxldCB0ZXh0T2JqcyA9IFtdO1xuICAgIC8vIE9ubHkgdGV4dCBvYmplY3RzIGNhbiBoYXZlIGh5cGVybGlua3MsIGJhaWwgd2hlbiB0ZXh0IHBhcmFtIGlzIHBsYWluIHRleHRcbiAgICBpZiAodHlwZW9mIHRleHQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0ZXh0ID09PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIElNUE9SVEFOVDogXCJlbHNlIGlmXCIgQXJyYXkuaXNBcnJheSBtdXN0IGNvbWUgYmVmb3JlIHR5cGVvZj09PW9iamVjdCEgT3RoZXJ3aXNlLCBjb2RlIHdpbGwgZXhoYXVzdCByZWN1cnNpb24hXG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0ZXh0KSlcbiAgICAgICAgdGV4dE9ianMgPSB0ZXh0O1xuICAgIGVsc2UgaWYgKHR5cGVvZiB0ZXh0ID09PSAnb2JqZWN0JylcbiAgICAgICAgdGV4dE9ianMgPSBbdGV4dF07XG4gICAgdGV4dE9ianMuZm9yRWFjaCgodGV4dCwgaWR4KSA9PiB7XG4gICAgICAgIC8vIElNUE9SVEFOVDogYG9wdGlvbnNgIGFyZSBsb3N0IGR1ZSB0byByZWN1cnNpb24vY29weSFcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9uc1tpZHhdICYmIG9wdGlvbnNbaWR4XS5oeXBlcmxpbmspXG4gICAgICAgICAgICB0ZXh0Lm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRleHQub3B0aW9ucyksIG9wdGlvbnNbaWR4XSk7XG4gICAgICAgIC8vIE5PVEU6IGB0ZXh0YCBjYW4gYmUgYW4gYXJyYXkgb2Ygb3RoZXIgYHRleHRgIG9iamVjdHMgKHRhYmxlIGNlbGwgd29yZC1sZXZlbCBmb3JtYXR0aW5nKSwgY29udGludWUgcGFyc2luZyB1c2luZyByZWN1cnNpb25cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGV4dCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGxPcHRzID0gW107XG4gICAgICAgICAgICB0ZXh0LmZvckVhY2goKHRhYmxlY2VsbCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0YWJsZWNlbGwub3B0aW9ucyAmJiAhdGFibGVjZWxsLnRleHQub3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBjZWxsT3B0cy5wdXNoKHRhYmxlY2VsbC5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNyZWF0ZUh5cGVybGlua1JlbHModGFyZ2V0LCB0ZXh0LCBjZWxsT3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0ZXh0LnRleHQpKSB7XG4gICAgICAgICAgICBjcmVhdGVIeXBlcmxpbmtSZWxzKHRhcmdldCwgdGV4dC50ZXh0LCBvcHRpb25zICYmIG9wdGlvbnNbaWR4XSA/IFtvcHRpb25zW2lkeF1dIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXh0ICYmIHR5cGVvZiB0ZXh0ID09PSAnb2JqZWN0JyAmJiB0ZXh0Lm9wdGlvbnMgJiYgdGV4dC5vcHRpb25zLmh5cGVybGluayAmJiAhdGV4dC5vcHRpb25zLmh5cGVybGluay5fcklkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRleHQub3B0aW9ucy5oeXBlcmxpbmsgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0VSUk9SOiB0ZXh0IGBoeXBlcmxpbmtgIG9wdGlvbiBzaG91bGQgYmUgYW4gb2JqZWN0LiBFeDogYGh5cGVybGluazoge3VybDpcXCdodHRwczovL2dpdGh1Yi5jb21cXCd9YCAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0ZXh0Lm9wdGlvbnMuaHlwZXJsaW5rLnVybCAmJiAhdGV4dC5vcHRpb25zLmh5cGVybGluay5zbGlkZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFUlJPUjogXFwnaHlwZXJsaW5rIHJlcXVpcmVzIGVpdGhlcjogYHVybGAgb3IgYHNsaWRlYFxcJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVsSWQgPSBnZXROZXdSZWxJZCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHRhcmdldC5fcmVscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU0xJREVfT0JKRUNUX1RZUEVTLmh5cGVybGluayxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdGV4dC5vcHRpb25zLmh5cGVybGluay5zbGlkZSA/ICdzbGlkZScgOiAnZHVtbXknLFxuICAgICAgICAgICAgICAgICAgICBySWQ6IHJlbElkLFxuICAgICAgICAgICAgICAgICAgICBUYXJnZXQ6IGVuY29kZVhtbEVudGl0aWVzKHRleHQub3B0aW9ucy5oeXBlcmxpbmsudXJsKSB8fCB0ZXh0Lm9wdGlvbnMuaHlwZXJsaW5rLnNsaWRlLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGV4dC5vcHRpb25zLmh5cGVybGluay5fcklkID0gcmVsSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dCAmJiB0eXBlb2YgdGV4dCA9PT0gJ29iamVjdCcgJiYgdGV4dC5vcHRpb25zICYmIHRleHQub3B0aW9ucy5oeXBlcmxpbmsgJiYgdGV4dC5vcHRpb25zLmh5cGVybGluay5fcklkKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBhdXRvLXBhZ2luZyB3aWxsIGNyZWF0ZSBuZXcgc2xpZGVzLCBidXQgc2tpcCBhYm92ZSBhcyBfcklkIGV4aXN0cywgQlVUIHRoaXMgaXMgYSBuZXcgc2xpZGUsIHNvIGFkZCByZWxzIVxuICAgICAgICAgICAgaWYgKHRhcmdldC5fcmVscy5maWx0ZXIocmVsID0+IHJlbC5ySWQgPT09IHRleHQub3B0aW9ucy5oeXBlcmxpbmsuX3JJZCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Ll9yZWxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTTElERV9PQkpFQ1RfVFlQRVMuaHlwZXJsaW5rLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB0ZXh0Lm9wdGlvbnMuaHlwZXJsaW5rLnNsaWRlID8gJ3NsaWRlJyA6ICdkdW1teScsXG4gICAgICAgICAgICAgICAgICAgIHJJZDogdGV4dC5vcHRpb25zLmh5cGVybGluay5fcklkLFxuICAgICAgICAgICAgICAgICAgICBUYXJnZXQ6IGVuY29kZVhtbEVudGl0aWVzKHRleHQub3B0aW9ucy5oeXBlcmxpbmsudXJsKSB8fCB0ZXh0Lm9wdGlvbnMuaHlwZXJsaW5rLnNsaWRlLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuLyoqXG4gKiBQcHR4R2VuSlM6IFNsaWRlIENsYXNzXG4gKi9cbmNsYXNzIFNsaWRlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmFkZFNsaWRlID0gcGFyYW1zLmFkZFNsaWRlO1xuICAgICAgICB0aGlzLmdldFNsaWRlID0gcGFyYW1zLmdldFNsaWRlO1xuICAgICAgICB0aGlzLl9uYW1lID0gYFNsaWRlICR7cGFyYW1zLnNsaWRlTnVtYmVyfWA7XG4gICAgICAgIHRoaXMuX3ByZXNMYXlvdXQgPSBwYXJhbXMucHJlc0xheW91dDtcbiAgICAgICAgdGhpcy5fcklkID0gcGFyYW1zLnNsaWRlUklkO1xuICAgICAgICB0aGlzLl9yZWxzID0gW107XG4gICAgICAgIHRoaXMuX3JlbHNDaGFydCA9IFtdO1xuICAgICAgICB0aGlzLl9yZWxzTWVkaWEgPSBbXTtcbiAgICAgICAgdGhpcy5fc2V0U2xpZGVOdW0gPSBwYXJhbXMuc2V0U2xpZGVOdW07XG4gICAgICAgIHRoaXMuX3NsaWRlSWQgPSBwYXJhbXMuc2xpZGVJZDtcbiAgICAgICAgdGhpcy5fc2xpZGVMYXlvdXQgPSBwYXJhbXMuc2xpZGVMYXlvdXQgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5fc2xpZGVOdW0gPSBwYXJhbXMuc2xpZGVOdW1iZXI7XG4gICAgICAgIHRoaXMuX3NsaWRlT2JqZWN0cyA9IFtdO1xuICAgICAgICAvKiogTk9URTogU2xpZGUgTnVtYmVyczogSW4gb3JkZXIgZm9yIFNsaWRlIE51bWJlcnMgdG8gZnVuY3Rpb24gdGhleSBuZWVkIHRvIGJlIGluIGFsbCAzIGZpbGVzOiBtYXN0ZXIvbGF5b3V0L3NsaWRlXG4gICAgICAgICAqIGBkZWZpbmVTbGlkZU1hc3RlcmAgYW5kIGBhZGROZXdTbGlkZS5zbGlkZU51bWJlcmAgd2lsbCBhZGQge3NsaWRlTnVtYmVyfSB0byBgdGhpcy5tYXN0ZXJTbGlkZWAgYW5kIGB0aGlzLnNsaWRlTGF5b3V0c2BcbiAgICAgICAgICogc28sIGxhc3RseSwgYWRkIHRvIHRoZSBTbGlkZSBub3cuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zbGlkZU51bWJlclByb3BzID0gKChfYSA9IHRoaXMuX3NsaWRlTGF5b3V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX3NsaWRlTnVtYmVyUHJvcHMpID8gdGhpcy5fc2xpZGVMYXlvdXQuX3NsaWRlTnVtYmVyUHJvcHMgOiBudWxsO1xuICAgIH1cbiAgICBzZXQgYmtnZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9ia2dkID0gdmFsdWU7XG4gICAgICAgIGlmICghdGhpcy5fYmFja2dyb3VuZCB8fCAhdGhpcy5fYmFja2dyb3VuZC5jb2xvcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9iYWNrZ3JvdW5kKVxuICAgICAgICAgICAgICAgIHRoaXMuX2JhY2tncm91bmQgPSB7fTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRoaXMuX2JhY2tncm91bmQuY29sb3IgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgYmtnZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JrZ2Q7XG4gICAgfVxuICAgIHNldCBiYWNrZ3JvdW5kKHByb3BzKSB7XG4gICAgICAgIHRoaXMuX2JhY2tncm91bmQgPSBwcm9wcztcbiAgICAgICAgLy8gQWRkIGJhY2tncm91bmQgKGltYWdlIGRhdGEvcGF0aCBtdXN0IGJlIGNhcHR1cmVkIGJlZm9yZSBgZXhwb3J0UHJlc2VudGF0aW9uKClgIGlzIGNhbGxlZClcbiAgICAgICAgaWYgKHByb3BzKVxuICAgICAgICAgICAgYWRkQmFja2dyb3VuZERlZmluaXRpb24ocHJvcHMsIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgYmFja2dyb3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JhY2tncm91bmQ7XG4gICAgfVxuICAgIHNldCBjb2xvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jb2xvciA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgY29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvcjtcbiAgICB9XG4gICAgc2V0IGhpZGRlbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9oaWRkZW4gPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGhpZGRlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hpZGRlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHR5cGUge1NsaWRlTnVtYmVyUHJvcHN9XG4gICAgICovXG4gICAgc2V0IHNsaWRlTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIC8vIE5PVEU6IFNsaWRlIE51bWJlcnM6IEluIG9yZGVyIGZvciBTbGlkZSBOdW1iZXJzIHRvIGZ1bmN0aW9uIHRoZXkgbmVlZCB0byBiZSBpbiBhbGwgMyBmaWxlczogbWFzdGVyL2xheW91dC9zbGlkZVxuICAgICAgICB0aGlzLl9zbGlkZU51bWJlclByb3BzID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3NldFNsaWRlTnVtKHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IHNsaWRlTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2xpZGVOdW1iZXJQcm9wcztcbiAgICB9XG4gICAgZ2V0IG5ld0F1dG9QYWdlZFNsaWRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld0F1dG9QYWdlZFNsaWRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGNoYXJ0IHRvIFNsaWRlXG4gICAgICogQHBhcmFtIHtDSEFSVF9OQU1FfElDaGFydE11bHRpW119IHR5cGUgLSBjaGFydCB0eXBlXG4gICAgICogQHBhcmFtIHtvYmplY3RbXX0gZGF0YSAtIGRhdGEgb2JqZWN0XG4gICAgICogQHBhcmFtIHtJQ2hhcnRPcHRzfSBvcHRpb25zIC0gY2hhcnQgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1NsaWRlfSB0aGlzIFNsaWRlXG4gICAgICovXG4gICAgYWRkQ2hhcnQodHlwZSwgZGF0YSwgb3B0aW9ucykge1xuICAgICAgICAvLyBGVVRVUkU6IFRPRE8tVkVSU0lPTi00OiBSZW1vdmUgZmlyc3QgYXJnIC0gb25seSB0YWtlIGRhdGEgYW5kIG9wdHMsIHdpdGggXCJ0eXBlXCIgcmVxdWlyZWQgb24gb3B0c1xuICAgICAgICAvLyBTZXQgYF90eXBlYCBvbiBJQ2hhcnRPcHRzTGliIGFzIGl0cyB3aGF0IGlzIHVzZWQgYXMgb2JqZWN0IGlzIHBhc3NlZCBhcm91bmRcbiAgICAgICAgY29uc3Qgb3B0aW9uc1dpdGhUeXBlID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgb3B0aW9uc1dpdGhUeXBlLl90eXBlID0gdHlwZTtcbiAgICAgICAgYWRkQ2hhcnREZWZpbml0aW9uKHRoaXMsIHR5cGUsIGRhdGEsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGltYWdlIHRvIFNsaWRlXG4gICAgICogQHBhcmFtIHtJbWFnZVByb3BzfSBvcHRpb25zIC0gaW1hZ2Ugb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1NsaWRlfSB0aGlzIFNsaWRlXG4gICAgICovXG4gICAgYWRkSW1hZ2Uob3B0aW9ucykge1xuICAgICAgICBhZGRJbWFnZURlZmluaXRpb24odGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgbWVkaWEgKGF1ZGlvL3ZpZGVvKSB0byBTbGlkZVxuICAgICAqIEBwYXJhbSB7TWVkaWFQcm9wc30gb3B0aW9ucyAtIG1lZGlhIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtTbGlkZX0gdGhpcyBTbGlkZVxuICAgICAqL1xuICAgIGFkZE1lZGlhKG9wdGlvbnMpIHtcbiAgICAgICAgYWRkTWVkaWFEZWZpbml0aW9uKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHNwZWFrZXIgbm90ZXMgdG8gU2xpZGVcbiAgICAgKiBAZG9jcyBodHRwczovL2dpdGJyZW50LmdpdGh1Yi5pby9QcHR4R2VuSlMvZG9jcy9zcGVha2VyLW5vdGVzLmh0bWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbm90ZXMgLSBub3RlcyB0byBhZGQgdG8gc2xpZGVcbiAgICAgKiBAcmV0dXJuIHtTbGlkZX0gdGhpcyBTbGlkZVxuICAgICAqL1xuICAgIGFkZE5vdGVzKG5vdGVzKSB7XG4gICAgICAgIGFkZE5vdGVzRGVmaW5pdGlvbih0aGlzLCBub3Rlcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgc2hhcGUgdG8gU2xpZGVcbiAgICAgKiBAcGFyYW0ge1NIQVBFX05BTUV9IHNoYXBlTmFtZSAtIHNoYXBlIG5hbWVcbiAgICAgKiBAcGFyYW0ge1NoYXBlUHJvcHN9IG9wdGlvbnMgLSBzaGFwZSBvcHRpb25zXG4gICAgICogQHJldHVybiB7U2xpZGV9IHRoaXMgU2xpZGVcbiAgICAgKi9cbiAgICBhZGRTaGFwZShzaGFwZU5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gTk9URTogQXMgb2YgdjMuMS4wLCA8c2NyaXB0PiB1c2VycyBhcmUgcGFzc2luZyB0aGUgb2xkIHNoYXBlIG9iamVjdCBmcm9tIHRoZSBzaGFwZXMgZmlsZSAob3JpZyB0byB0aGUgcHJvamVjdClcbiAgICAgICAgLy8gQnV0IFJlYWN0L1R5cGVTY3JpcHQgdXNlcnMgYXJlIHBhc3NpbmcgdGhlIHNoYXBlTmFtZSBmcm9tIGFuIGVudW0sIHdoaWNoIGlzIGEgc2ltcGxlIHN0cmluZywgc28gbGV0cyBjYXN0XG4gICAgICAgIC8vIDxzY3JpcHQuLz4gPT4gYHBwdHguc2hhcGVzLlJFQ1RBTkdMRWAgW3N0cmluZ10gXCJyZWN0XCIgLi4uIHNoYXBlTmFtZVsnbmFtZSddID0gJ3JlY3QnXG4gICAgICAgIC8vIFR5cGVTY3JpcHQgPT4gYHBwdHhnZW4uc2hhcGVzLlJFQ1RBTkdMRWAgW3N0cmluZ10gXCJyZWN0XCIgLi4uIHNoYXBlTmFtZSA9ICdyZWN0J1xuICAgICAgICAvLyBsZXQgc2hhcGVOYW1lRGVjb2RlID0gdHlwZW9mIHNoYXBlTmFtZSA9PT0gJ29iamVjdCcgJiYgc2hhcGVOYW1lWyduYW1lJ10gPyBzaGFwZU5hbWVbJ25hbWUnXSA6IHNoYXBlTmFtZVxuICAgICAgICBhZGRTaGFwZURlZmluaXRpb24odGhpcywgc2hhcGVOYW1lLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCB0YWJsZSB0byBTbGlkZVxuICAgICAqIEBwYXJhbSB7VGFibGVSb3dbXX0gdGFibGVSb3dzIC0gdGFibGUgcm93c1xuICAgICAqIEBwYXJhbSB7VGFibGVQcm9wc30gb3B0aW9ucyAtIHRhYmxlIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtTbGlkZX0gdGhpcyBTbGlkZVxuICAgICAqL1xuICAgIGFkZFRhYmxlKHRhYmxlUm93cywgb3B0aW9ucykge1xuICAgICAgICAvLyBGVVRVUkU6IHdlIHBhc3MgYHRoaXNgIC0gd2UgZG9udCBuZWVkIHRvIHBhc3MgbGF5b3V0cyAtIHRoZXkgY2FuIGJlIHJlYWQgZnJvbSB0aGlzIVxuICAgICAgICB0aGlzLl9uZXdBdXRvUGFnZWRTbGlkZXMgPSBhZGRUYWJsZURlZmluaXRpb24odGhpcywgdGFibGVSb3dzLCBvcHRpb25zLCB0aGlzLl9zbGlkZUxheW91dCwgdGhpcy5fcHJlc0xheW91dCwgdGhpcy5hZGRTbGlkZSwgdGhpcy5nZXRTbGlkZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgdGV4dCB0byBTbGlkZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfFRleHRQcm9wc1tdfSB0ZXh0IC0gdGV4dCBzdHJpbmcgb3IgY29tcGxleCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1RleHRQcm9wc09wdGlvbnN9IG9wdGlvbnMgLSB0ZXh0IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtTbGlkZX0gdGhpcyBTbGlkZVxuICAgICAqL1xuICAgIGFkZFRleHQodGV4dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB0ZXh0UGFyYW0gPSB0eXBlb2YgdGV4dCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHRleHQgPT09ICdudW1iZXInID8gW3sgdGV4dCwgb3B0aW9ucyB9XSA6IHRleHQ7XG4gICAgICAgIGFkZFRleHREZWZpbml0aW9uKHRoaXMsIHRleHRQYXJhbSwgb3B0aW9ucywgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbi8qKlxuICogUHB0eEdlbkpTOiBDaGFydCBHZW5lcmF0aW9uXG4gKi9cbi8qKlxuICogQmFzZWQgb24gcGFzc2VkIGRhdGEsIGNyZWF0ZXMgRXhjZWwgV29ya3NoZWV0IHRoYXQgaXMgdXNlZCBhcyBhIGRhdGEgc291cmNlIGZvciBhIGNoYXJ0LlxuICogQHBhcmFtIHtJU2xpZGVSZWxDaGFydH0gY2hhcnRPYmplY3QgLSBjaGFydCBvYmplY3RcbiAqIEBwYXJhbSB7SlNaaXB9IHppcCAtIGZpbGUgdGhhdCB0aGUgcmVzdWx0aW5nIFhMU1ggc2hvdWxkIGJlIGFkZGVkIHRvXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIG9mIGdlbmVyYXRpbmcgdGhlIFhMU1ggZmlsZVxuICovXG5mdW5jdGlvbiBjcmVhdGVFeGNlbFdvcmtzaGVldChjaGFydE9iamVjdCwgemlwKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0T2JqZWN0LmRhdGE7XG4gICAgICAgIHJldHVybiB5aWVsZCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgY29uc3QgemlwRXhjZWwgPSBuZXcgSlNaaXAoKTtcbiAgICAgICAgICAgIGNvbnN0IGludEJ1YmJsZUNvbHMgPSAoZGF0YS5sZW5ndGggLSAxKSAqIDIgKyAxOyAvLyAxIGZvciBcIlgtVmFsdWVzXCIsIHRoZW4gMiBmb3IgZXZlcnkgWS1BeGlzXG4gICAgICAgICAgICBjb25zdCBJU19NVUxUSV9DQVRfQVhFUyA9ICgoX2IgPSAoX2EgPSBkYXRhWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGFiZWxzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RoKSA+IDE7XG4gICAgICAgICAgICAvLyBBOiBBZGQgZm9sZGVyc1xuICAgICAgICAgICAgemlwRXhjZWwuZm9sZGVyKCdfcmVscycpO1xuICAgICAgICAgICAgemlwRXhjZWwuZm9sZGVyKCdkb2NQcm9wcycpO1xuICAgICAgICAgICAgemlwRXhjZWwuZm9sZGVyKCd4bC9fcmVscycpO1xuICAgICAgICAgICAgemlwRXhjZWwuZm9sZGVyKCd4bC90YWJsZXMnKTtcbiAgICAgICAgICAgIHppcEV4Y2VsLmZvbGRlcigneGwvdGhlbWUnKTtcbiAgICAgICAgICAgIHppcEV4Y2VsLmZvbGRlcigneGwvd29ya3NoZWV0cycpO1xuICAgICAgICAgICAgemlwRXhjZWwuZm9sZGVyKCd4bC93b3Jrc2hlZXRzL19yZWxzJyk7XG4gICAgICAgICAgICAvLyBCOiBBZGQgY29yZSBjb250ZW50c1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHppcEV4Y2VsLmZpbGUoJ1tDb250ZW50X1R5cGVzXS54bWwnLCAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIiBzdGFuZGFsb25lPVwieWVzXCI/PjxUeXBlcyB4bWxucz1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9wYWNrYWdlLzIwMDYvY29udGVudC10eXBlc1wiPicgK1xuICAgICAgICAgICAgICAgICAgICAnICA8RGVmYXVsdCBFeHRlbnNpb249XCJyZWxzXCIgQ29udGVudFR5cGU9XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtcGFja2FnZS5yZWxhdGlvbnNoaXBzK3htbFwiLz4nICtcbiAgICAgICAgICAgICAgICAgICAgJyAgPERlZmF1bHQgRXh0ZW5zaW9uPVwieG1sXCIgQ29udGVudFR5cGU9XCJhcHBsaWNhdGlvbi94bWxcIi8+JyArXG4gICAgICAgICAgICAgICAgICAgICcgIDxPdmVycmlkZSBQYXJ0TmFtZT1cIi94bC93b3JrYm9vay54bWxcIiBDb250ZW50VHlwZT1cImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0Lm1haW4reG1sXCIvPicgK1xuICAgICAgICAgICAgICAgICAgICAnICA8T3ZlcnJpZGUgUGFydE5hbWU9XCIveGwvd29ya3NoZWV0cy9zaGVldDEueG1sXCIgQ29udGVudFR5cGU9XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC53b3Jrc2hlZXQreG1sXCIvPicgK1xuICAgICAgICAgICAgICAgICAgICAnICA8T3ZlcnJpZGUgUGFydE5hbWU9XCIveGwvdGhlbWUvdGhlbWUxLnhtbFwiIENvbnRlbnRUeXBlPVwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnRoZW1lK3htbFwiLz4nICtcbiAgICAgICAgICAgICAgICAgICAgJyAgPE92ZXJyaWRlIFBhcnROYW1lPVwiL3hsL3N0eWxlcy54bWxcIiBDb250ZW50VHlwZT1cImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnN0eWxlcyt4bWxcIi8+JyArXG4gICAgICAgICAgICAgICAgICAgICcgIDxPdmVycmlkZSBQYXJ0TmFtZT1cIi94bC9zaGFyZWRTdHJpbmdzLnhtbFwiIENvbnRlbnRUeXBlPVwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hhcmVkU3RyaW5ncyt4bWxcIi8+JyArXG4gICAgICAgICAgICAgICAgICAgICcgIDxPdmVycmlkZSBQYXJ0TmFtZT1cIi94bC90YWJsZXMvdGFibGUxLnhtbFwiIENvbnRlbnRUeXBlPVwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwudGFibGUreG1sXCIvPicgK1xuICAgICAgICAgICAgICAgICAgICAnICA8T3ZlcnJpZGUgUGFydE5hbWU9XCIvZG9jUHJvcHMvY29yZS54bWxcIiBDb250ZW50VHlwZT1cImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1wYWNrYWdlLmNvcmUtcHJvcGVydGllcyt4bWxcIi8+JyArXG4gICAgICAgICAgICAgICAgICAgICcgIDxPdmVycmlkZSBQYXJ0TmFtZT1cIi9kb2NQcm9wcy9hcHAueG1sXCIgQ29udGVudFR5cGU9XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuZXh0ZW5kZWQtcHJvcGVydGllcyt4bWxcIi8+JyArXG4gICAgICAgICAgICAgICAgICAgICc8L1R5cGVzPlxcbicpO1xuICAgICAgICAgICAgICAgIHppcEV4Y2VsLmZpbGUoJ19yZWxzLy5yZWxzJywgJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCIgc3RhbmRhbG9uZT1cInllc1wiPz48UmVsYXRpb25zaGlwcyB4bWxucz1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9wYWNrYWdlLzIwMDYvcmVsYXRpb25zaGlwc1wiPicgK1xuICAgICAgICAgICAgICAgICAgICAnPFJlbGF0aW9uc2hpcCBJZD1cInJJZDFcIiBUeXBlPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3BhY2thZ2UvMjAwNi9yZWxhdGlvbnNoaXBzL21ldGFkYXRhL2NvcmUtcHJvcGVydGllc1wiIFRhcmdldD1cImRvY1Byb3BzL2NvcmUueG1sXCIvPicgK1xuICAgICAgICAgICAgICAgICAgICAnPFJlbGF0aW9uc2hpcCBJZD1cInJJZDJcIiBUeXBlPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcy9leHRlbmRlZC1wcm9wZXJ0aWVzXCIgVGFyZ2V0PVwiZG9jUHJvcHMvYXBwLnhtbFwiLz4nICtcbiAgICAgICAgICAgICAgICAgICAgJzxSZWxhdGlvbnNoaXAgSWQ9XCJySWQzXCIgVHlwZT1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHMvb2ZmaWNlRG9jdW1lbnRcIiBUYXJnZXQ9XCJ4bC93b3JrYm9vay54bWxcIi8+JyArXG4gICAgICAgICAgICAgICAgICAgICc8L1JlbGF0aW9uc2hpcHM+XFxuJyk7XG4gICAgICAgICAgICAgICAgemlwRXhjZWwuZmlsZSgnZG9jUHJvcHMvYXBwLnhtbCcsICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiIHN0YW5kYWxvbmU9XCJ5ZXNcIj8+PFByb3BlcnRpZXMgeG1sbnM9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9leHRlbmRlZC1wcm9wZXJ0aWVzXCIgeG1sbnM6dnQ9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9kb2NQcm9wc1ZUeXBlc1wiPicgK1xuICAgICAgICAgICAgICAgICAgICAnPEFwcGxpY2F0aW9uPk1pY3Jvc29mdCBNYWNpbnRvc2ggRXhjZWw8L0FwcGxpY2F0aW9uPicgK1xuICAgICAgICAgICAgICAgICAgICAnPERvY1NlY3VyaXR5PjA8L0RvY1NlY3VyaXR5PicgK1xuICAgICAgICAgICAgICAgICAgICAnPFNjYWxlQ3JvcD5mYWxzZTwvU2NhbGVDcm9wPicgK1xuICAgICAgICAgICAgICAgICAgICAnPEhlYWRpbmdQYWlycz48dnQ6dmVjdG9yIHNpemU9XCIyXCIgYmFzZVR5cGU9XCJ2YXJpYW50XCI+PHZ0OnZhcmlhbnQ+PHZ0Omxwc3RyPldvcmtzaGVldHM8L3Z0Omxwc3RyPjwvdnQ6dmFyaWFudD48dnQ6dmFyaWFudD48dnQ6aTQ+MTwvdnQ6aTQ+PC92dDp2YXJpYW50PjwvdnQ6dmVjdG9yPjwvSGVhZGluZ1BhaXJzPicgK1xuICAgICAgICAgICAgICAgICAgICAnPFRpdGxlc09mUGFydHM+PHZ0OnZlY3RvciBzaXplPVwiMVwiIGJhc2VUeXBlPVwibHBzdHJcIj48dnQ6bHBzdHI+U2hlZXQxPC92dDpscHN0cj48L3Z0OnZlY3Rvcj48L1RpdGxlc09mUGFydHM+JyArXG4gICAgICAgICAgICAgICAgICAgICc8Q29tcGFueT48L0NvbXBhbnk+PExpbmtzVXBUb0RhdGU+ZmFsc2U8L0xpbmtzVXBUb0RhdGU+PFNoYXJlZERvYz5mYWxzZTwvU2hhcmVkRG9jPjxIeXBlcmxpbmtzQ2hhbmdlZD5mYWxzZTwvSHlwZXJsaW5rc0NoYW5nZWQ+PEFwcFZlcnNpb24+MTYuMDMwMDwvQXBwVmVyc2lvbj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzwvUHJvcGVydGllcz5cXG4nKTtcbiAgICAgICAgICAgICAgICB6aXBFeGNlbC5maWxlKCdkb2NQcm9wcy9jb3JlLnhtbCcsICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiIHN0YW5kYWxvbmU9XCJ5ZXNcIj8+PGNwOmNvcmVQcm9wZXJ0aWVzIHhtbG5zOmNwPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3BhY2thZ2UvMjAwNi9tZXRhZGF0YS9jb3JlLXByb3BlcnRpZXNcIiB4bWxuczpkYz1cImh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvXCIgeG1sbnM6ZGN0ZXJtcz1cImh0dHA6Ly9wdXJsLm9yZy9kYy90ZXJtcy9cIiB4bWxuczpkY21pdHlwZT1cImh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9cIiB4bWxuczp4c2k9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYS1pbnN0YW5jZVwiPicgK1xuICAgICAgICAgICAgICAgICAgICAnPGRjOmNyZWF0b3I+UHB0eEdlbkpTPC9kYzpjcmVhdG9yPicgK1xuICAgICAgICAgICAgICAgICAgICAnPGNwOmxhc3RNb2RpZmllZEJ5PlBwdHhHZW5KUzwvY3A6bGFzdE1vZGlmaWVkQnk+JyArXG4gICAgICAgICAgICAgICAgICAgICc8ZGN0ZXJtczpjcmVhdGVkIHhzaTp0eXBlPVwiZGN0ZXJtczpXM0NEVEZcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgbmV3IERhdGUoKS50b0lTT1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgJzwvZGN0ZXJtczpjcmVhdGVkPicgK1xuICAgICAgICAgICAgICAgICAgICAnPGRjdGVybXM6bW9kaWZpZWQgeHNpOnR5cGU9XCJkY3Rlcm1zOlczQ0RURlwiPicgK1xuICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICAgICAnPC9kY3Rlcm1zOm1vZGlmaWVkPicgK1xuICAgICAgICAgICAgICAgICAgICAnPC9jcDpjb3JlUHJvcGVydGllcz4nKTtcbiAgICAgICAgICAgICAgICB6aXBFeGNlbC5maWxlKCd4bC9fcmVscy93b3JrYm9vay54bWwucmVscycsICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiIHN0YW5kYWxvbmU9XCJ5ZXNcIj8+JyArXG4gICAgICAgICAgICAgICAgICAgICc8UmVsYXRpb25zaGlwcyB4bWxucz1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9wYWNrYWdlLzIwMDYvcmVsYXRpb25zaGlwc1wiPicgK1xuICAgICAgICAgICAgICAgICAgICAnPFJlbGF0aW9uc2hpcCBJZD1cInJJZDNcIiBUeXBlPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcy9zdHlsZXNcIiBUYXJnZXQ9XCJzdHlsZXMueG1sXCIvPicgK1xuICAgICAgICAgICAgICAgICAgICAnPFJlbGF0aW9uc2hpcCBJZD1cInJJZDJcIiBUeXBlPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcy90aGVtZVwiIFRhcmdldD1cInRoZW1lL3RoZW1lMS54bWxcIi8+JyArXG4gICAgICAgICAgICAgICAgICAgICc8UmVsYXRpb25zaGlwIElkPVwicklkMVwiIFR5cGU9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL3dvcmtzaGVldFwiIFRhcmdldD1cIndvcmtzaGVldHMvc2hlZXQxLnhtbFwiLz4nICtcbiAgICAgICAgICAgICAgICAgICAgJzxSZWxhdGlvbnNoaXAgSWQ9XCJySWQ0XCIgVHlwZT1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHMvc2hhcmVkU3RyaW5nc1wiIFRhcmdldD1cInNoYXJlZFN0cmluZ3MueG1sXCIvPicgK1xuICAgICAgICAgICAgICAgICAgICAnPC9SZWxhdGlvbnNoaXBzPicpO1xuICAgICAgICAgICAgICAgIHppcEV4Y2VsLmZpbGUoJ3hsL3N0eWxlcy54bWwnLCAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIiBzdGFuZGFsb25lPVwieWVzXCI/PjxzdHlsZVNoZWV0IHhtbG5zPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3NwcmVhZHNoZWV0bWwvMjAwNi9tYWluXCI+PG51bUZtdHMgY291bnQ9XCIxXCI+PG51bUZtdCBudW1GbXRJZD1cIjBcIiBmb3JtYXRDb2RlPVwiR2VuZXJhbFwiLz48L251bUZtdHM+PGZvbnRzIGNvdW50PVwiNFwiPjxmb250PjxzeiB2YWw9XCI5XCIvPjxjb2xvciBpbmRleGVkPVwiOFwiLz48bmFtZSB2YWw9XCJHZW5ldmFcIi8+PC9mb250Pjxmb250PjxzeiB2YWw9XCI5XCIvPjxjb2xvciBpbmRleGVkPVwiOFwiLz48bmFtZSB2YWw9XCJHZW5ldmFcIi8+PC9mb250Pjxmb250PjxzeiB2YWw9XCIxMFwiLz48Y29sb3IgaW5kZXhlZD1cIjhcIi8+PG5hbWUgdmFsPVwiR2VuZXZhXCIvPjwvZm9udD48Zm9udD48c3ogdmFsPVwiMThcIi8+PGNvbG9yIGluZGV4ZWQ9XCI4XCIvPicgK1xuICAgICAgICAgICAgICAgICAgICAnPG5hbWUgdmFsPVwiQXJpYWxcIi8+PC9mb250PjwvZm9udHM+PGZpbGxzIGNvdW50PVwiMlwiPjxmaWxsPjxwYXR0ZXJuRmlsbCBwYXR0ZXJuVHlwZT1cIm5vbmVcIi8+PC9maWxsPjxmaWxsPjxwYXR0ZXJuRmlsbCBwYXR0ZXJuVHlwZT1cImdyYXkxMjVcIi8+PC9maWxsPjwvZmlsbHM+PGJvcmRlcnMgY291bnQ9XCIxXCI+PGJvcmRlcj48bGVmdC8+PHJpZ2h0Lz48dG9wLz48Ym90dG9tLz48ZGlhZ29uYWwvPjwvYm9yZGVyPjwvYm9yZGVycz48ZHhmcyBjb3VudD1cIjBcIi8+PHRhYmxlU3R5bGVzIGNvdW50PVwiMFwiLz48Y29sb3JzPjxpbmRleGVkQ29sb3JzPjxyZ2JDb2xvciByZ2I9XCJmZjAwMDAwMFwiLz48cmdiQ29sb3IgcmdiPVwiZmZmZmZmZmZcIi8+PHJnYkNvbG9yIHJnYj1cImZmZmYwMDAwXCIvPjxyZ2JDb2xvciByZ2I9XCJmZjAwZmYwMFwiLz48cmdiQ29sb3IgcmdiPVwiZmYwMDAwZmZcIi8+JyArXG4gICAgICAgICAgICAgICAgICAgICc8cmdiQ29sb3IgcmdiPVwiZmZmZmZmMDBcIi8+PHJnYkNvbG9yIHJnYj1cImZmZmYwMGZmXCIvPjxyZ2JDb2xvciByZ2I9XCJmZjAwZmZmZlwiLz48cmdiQ29sb3IgcmdiPVwiZmYwMDAwMDBcIi8+PHJnYkNvbG9yIHJnYj1cImZmZmZmZmZmXCIvPjxyZ2JDb2xvciByZ2I9XCJmZjg3ODc4N1wiLz48cmdiQ29sb3IgcmdiPVwiZmZmOWY5ZjlcIi8+PC9pbmRleGVkQ29sb3JzPjwvY29sb3JzPjwvc3R5bGVTaGVldD5cXG4nKTtcbiAgICAgICAgICAgICAgICB6aXBFeGNlbC5maWxlKCd4bC90aGVtZS90aGVtZTEueG1sJywgJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCIgc3RhbmRhbG9uZT1cInllc1wiPz48YTp0aGVtZSB4bWxuczphPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL2RyYXdpbmdtbC8yMDA2L21haW5cIiBuYW1lPVwiT2ZmaWNlIFRoZW1lXCI+PGE6dGhlbWVFbGVtZW50cz48YTpjbHJTY2hlbWUgbmFtZT1cIk9mZmljZVwiPjxhOmRrMT48YTpzeXNDbHIgdmFsPVwid2luZG93VGV4dFwiIGxhc3RDbHI9XCIwMDAwMDBcIi8+PC9hOmRrMT48YTpsdDE+PGE6c3lzQ2xyIHZhbD1cIndpbmRvd1wiIGxhc3RDbHI9XCJGRkZGRkZcIi8+PC9hOmx0MT48YTpkazI+PGE6c3JnYkNsciB2YWw9XCI0NDU0NkFcIi8+PC9hOmRrMj48YTpsdDI+PGE6c3JnYkNsciB2YWw9XCJFN0U2RTZcIi8+PC9hOmx0Mj48YTphY2NlbnQxPjxhOnNyZ2JDbHIgdmFsPVwiNDQ3MkM0XCIvPjwvYTphY2NlbnQxPjxhOmFjY2VudDI+PGE6c3JnYkNsciB2YWw9XCJFRDdEMzFcIi8+PC9hOmFjY2VudDI+PGE6YWNjZW50Mz48YTpzcmdiQ2xyIHZhbD1cIkE1QTVBNVwiLz48L2E6YWNjZW50Mz48YTphY2NlbnQ0PjxhOnNyZ2JDbHIgdmFsPVwiRkZDMDAwXCIvPjwvYTphY2NlbnQ0PjxhOmFjY2VudDU+PGE6c3JnYkNsciB2YWw9XCI1QjlCRDVcIi8+PC9hOmFjY2VudDU+PGE6YWNjZW50Nj48YTpzcmdiQ2xyIHZhbD1cIjcwQUQ0N1wiLz48L2E6YWNjZW50Nj48YTpobGluaz48YTpzcmdiQ2xyIHZhbD1cIjA1NjNDMVwiLz48L2E6aGxpbms+PGE6Zm9sSGxpbms+PGE6c3JnYkNsciB2YWw9XCI5NTRGNzJcIi8+PC9hOmZvbEhsaW5rPjwvYTpjbHJTY2hlbWU+PGE6Zm9udFNjaGVtZSBuYW1lPVwiT2ZmaWNlXCI+PGE6bWFqb3JGb250PjxhOmxhdGluIHR5cGVmYWNlPVwiQ2FsaWJyaSBMaWdodFwiIHBhbm9zZT1cIjAyMEYwMzAyMDIwMjA0MDMwMjA0XCIvPjxhOmVhIHR5cGVmYWNlPVwiXCIvPjxhOmNzIHR5cGVmYWNlPVwiXCIvPjxhOmZvbnQgc2NyaXB0PVwiSnBhblwiIHR5cGVmYWNlPVwiWXUgR290aGljIExpZ2h0XCIvPjxhOmZvbnQgc2NyaXB0PVwiSGFuZ1wiIHR5cGVmYWNlPVwi66eR7J2AIOqzoOuUlVwiLz48YTpmb250IHNjcmlwdD1cIkhhbnNcIiB0eXBlZmFjZT1cIkRlbmdYaWFuIExpZ2h0XCIvPjxhOmZvbnQgc2NyaXB0PVwiSGFudFwiIHR5cGVmYWNlPVwi5paw57Sw5piO6auUXCIvPjxhOmZvbnQgc2NyaXB0PVwiQXJhYlwiIHR5cGVmYWNlPVwiVGltZXMgTmV3IFJvbWFuXCIvPjxhOmZvbnQgc2NyaXB0PVwiSGViclwiIHR5cGVmYWNlPVwiVGltZXMgTmV3IFJvbWFuXCIvPjxhOmZvbnQgc2NyaXB0PVwiVGhhaVwiIHR5cGVmYWNlPVwiVGFob21hXCIvPjxhOmZvbnQgc2NyaXB0PVwiRXRoaVwiIHR5cGVmYWNlPVwiTnlhbGFcIi8+PGE6Zm9udCBzY3JpcHQ9XCJCZW5nXCIgdHlwZWZhY2U9XCJWcmluZGFcIi8+PGE6Zm9udCBzY3JpcHQ9XCJHdWpyXCIgdHlwZWZhY2U9XCJTaHJ1dGlcIi8+PGE6Zm9udCBzY3JpcHQ9XCJLaG1yXCIgdHlwZWZhY2U9XCJNb29sQm9yYW5cIi8+PGE6Zm9udCBzY3JpcHQ9XCJLbmRhXCIgdHlwZWZhY2U9XCJUdW5nYVwiLz48YTpmb250IHNjcmlwdD1cIkd1cnVcIiB0eXBlZmFjZT1cIlJhYXZpXCIvPjxhOmZvbnQgc2NyaXB0PVwiQ2Fuc1wiIHR5cGVmYWNlPVwiRXVwaGVtaWFcIi8+PGE6Zm9udCBzY3JpcHQ9XCJDaGVyXCIgdHlwZWZhY2U9XCJQbGFudGFnZW5ldCBDaGVyb2tlZVwiLz48YTpmb250IHNjcmlwdD1cIllpaWlcIiB0eXBlZmFjZT1cIk1pY3Jvc29mdCBZaSBCYWl0aVwiLz48YTpmb250IHNjcmlwdD1cIlRpYnRcIiB0eXBlZmFjZT1cIk1pY3Jvc29mdCBIaW1hbGF5YVwiLz48YTpmb250IHNjcmlwdD1cIlRoYWFcIiB0eXBlZmFjZT1cIk1WIEJvbGlcIi8+PGE6Zm9udCBzY3JpcHQ9XCJEZXZhXCIgdHlwZWZhY2U9XCJNYW5nYWxcIi8+PGE6Zm9udCBzY3JpcHQ9XCJUZWx1XCIgdHlwZWZhY2U9XCJHYXV0YW1pXCIvPjxhOmZvbnQgc2NyaXB0PVwiVGFtbFwiIHR5cGVmYWNlPVwiTGF0aGFcIi8+PGE6Zm9udCBzY3JpcHQ9XCJTeXJjXCIgdHlwZWZhY2U9XCJFc3RyYW5nZWxvIEVkZXNzYVwiLz48YTpmb250IHNjcmlwdD1cIk9yeWFcIiB0eXBlZmFjZT1cIkthbGluZ2FcIi8+PGE6Zm9udCBzY3JpcHQ9XCJNbHltXCIgdHlwZWZhY2U9XCJLYXJ0aWthXCIvPjxhOmZvbnQgc2NyaXB0PVwiTGFvb1wiIHR5cGVmYWNlPVwiRG9rQ2hhbXBhXCIvPjxhOmZvbnQgc2NyaXB0PVwiU2luaFwiIHR5cGVmYWNlPVwiSXNrb29sYSBQb3RhXCIvPjxhOmZvbnQgc2NyaXB0PVwiTW9uZ1wiIHR5cGVmYWNlPVwiTW9uZ29saWFuIEJhaXRpXCIvPjxhOmZvbnQgc2NyaXB0PVwiVmlldFwiIHR5cGVmYWNlPVwiVGltZXMgTmV3IFJvbWFuXCIvPjxhOmZvbnQgc2NyaXB0PVwiVWlnaFwiIHR5cGVmYWNlPVwiTWljcm9zb2Z0IFVpZ2h1clwiLz48YTpmb250IHNjcmlwdD1cIkdlb3JcIiB0eXBlZmFjZT1cIlN5bGZhZW5cIi8+PC9hOm1ham9yRm9udD48YTptaW5vckZvbnQ+PGE6bGF0aW4gdHlwZWZhY2U9XCJDYWxpYnJpXCIgcGFub3NlPVwiMDIwRjA1MDIwMjAyMDQwMzAyMDRcIi8+PGE6ZWEgdHlwZWZhY2U9XCJcIi8+PGE6Y3MgdHlwZWZhY2U9XCJcIi8+PGE6Zm9udCBzY3JpcHQ9XCJKcGFuXCIgdHlwZWZhY2U9XCJZdSBHb3RoaWNcIi8+PGE6Zm9udCBzY3JpcHQ9XCJIYW5nXCIgdHlwZWZhY2U9XCLrp5HsnYAg6rOg65SVXCIvPjxhOmZvbnQgc2NyaXB0PVwiSGFuc1wiIHR5cGVmYWNlPVwiRGVuZ1hpYW5cIi8+PGE6Zm9udCBzY3JpcHQ9XCJIYW50XCIgdHlwZWZhY2U9XCLmlrDntLDmmI7pq5RcIi8+PGE6Zm9udCBzY3JpcHQ9XCJBcmFiXCIgdHlwZWZhY2U9XCJBcmlhbFwiLz48YTpmb250IHNjcmlwdD1cIkhlYnJcIiB0eXBlZmFjZT1cIkFyaWFsXCIvPjxhOmZvbnQgc2NyaXB0PVwiVGhhaVwiIHR5cGVmYWNlPVwiVGFob21hXCIvPjxhOmZvbnQgc2NyaXB0PVwiRXRoaVwiIHR5cGVmYWNlPVwiTnlhbGFcIi8+PGE6Zm9udCBzY3JpcHQ9XCJCZW5nXCIgdHlwZWZhY2U9XCJWcmluZGFcIi8+PGE6Zm9udCBzY3JpcHQ9XCJHdWpyXCIgdHlwZWZhY2U9XCJTaHJ1dGlcIi8+PGE6Zm9udCBzY3JpcHQ9XCJLaG1yXCIgdHlwZWZhY2U9XCJEYXVuUGVuaFwiLz48YTpmb250IHNjcmlwdD1cIktuZGFcIiB0eXBlZmFjZT1cIlR1bmdhXCIvPjxhOmZvbnQgc2NyaXB0PVwiR3VydVwiIHR5cGVmYWNlPVwiUmFhdmlcIi8+PGE6Zm9udCBzY3JpcHQ9XCJDYW5zXCIgdHlwZWZhY2U9XCJFdXBoZW1pYVwiLz48YTpmb250IHNjcmlwdD1cIkNoZXJcIiB0eXBlZmFjZT1cIlBsYW50YWdlbmV0IENoZXJva2VlXCIvPjxhOmZvbnQgc2NyaXB0PVwiWWlpaVwiIHR5cGVmYWNlPVwiTWljcm9zb2Z0IFlpIEJhaXRpXCIvPjxhOmZvbnQgc2NyaXB0PVwiVGlidFwiIHR5cGVmYWNlPVwiTWljcm9zb2Z0IEhpbWFsYXlhXCIvPjxhOmZvbnQgc2NyaXB0PVwiVGhhYVwiIHR5cGVmYWNlPVwiTVYgQm9saVwiLz48YTpmb250IHNjcmlwdD1cIkRldmFcIiB0eXBlZmFjZT1cIk1hbmdhbFwiLz48YTpmb250IHNjcmlwdD1cIlRlbHVcIiB0eXBlZmFjZT1cIkdhdXRhbWlcIi8+PGE6Zm9udCBzY3JpcHQ9XCJUYW1sXCIgdHlwZWZhY2U9XCJMYXRoYVwiLz48YTpmb250IHNjcmlwdD1cIlN5cmNcIiB0eXBlZmFjZT1cIkVzdHJhbmdlbG8gRWRlc3NhXCIvPjxhOmZvbnQgc2NyaXB0PVwiT3J5YVwiIHR5cGVmYWNlPVwiS2FsaW5nYVwiLz48YTpmb250IHNjcmlwdD1cIk1seW1cIiB0eXBlZmFjZT1cIkthcnRpa2FcIi8+PGE6Zm9udCBzY3JpcHQ9XCJMYW9vXCIgdHlwZWZhY2U9XCJEb2tDaGFtcGFcIi8+PGE6Zm9udCBzY3JpcHQ9XCJTaW5oXCIgdHlwZWZhY2U9XCJJc2tvb2xhIFBvdGFcIi8+PGE6Zm9udCBzY3JpcHQ9XCJNb25nXCIgdHlwZWZhY2U9XCJNb25nb2xpYW4gQmFpdGlcIi8+PGE6Zm9udCBzY3JpcHQ9XCJWaWV0XCIgdHlwZWZhY2U9XCJBcmlhbFwiLz48YTpmb250IHNjcmlwdD1cIlVpZ2hcIiB0eXBlZmFjZT1cIk1pY3Jvc29mdCBVaWdodXJcIi8+PGE6Zm9udCBzY3JpcHQ9XCJHZW9yXCIgdHlwZWZhY2U9XCJTeWxmYWVuXCIvPjwvYTptaW5vckZvbnQ+PC9hOmZvbnRTY2hlbWU+PGE6Zm10U2NoZW1lIG5hbWU9XCJPZmZpY2VcIj48YTpmaWxsU3R5bGVMc3Q+PGE6c29saWRGaWxsPjxhOnNjaGVtZUNsciB2YWw9XCJwaENsclwiLz48L2E6c29saWRGaWxsPjxhOmdyYWRGaWxsIHJvdFdpdGhTaGFwZT1cIjFcIj48YTpnc0xzdD48YTpncyBwb3M9XCIwXCI+PGE6c2NoZW1lQ2xyIHZhbD1cInBoQ2xyXCI+PGE6bHVtTW9kIHZhbD1cIjExMDAwMFwiLz48YTpzYXRNb2QgdmFsPVwiMTA1MDAwXCIvPjxhOnRpbnQgdmFsPVwiNjcwMDBcIi8+PC9hOnNjaGVtZUNscj48L2E6Z3M+PGE6Z3MgcG9zPVwiNTAwMDBcIj48YTpzY2hlbWVDbHIgdmFsPVwicGhDbHJcIj48YTpsdW1Nb2QgdmFsPVwiMTA1MDAwXCIvPjxhOnNhdE1vZCB2YWw9XCIxMDMwMDBcIi8+PGE6dGludCB2YWw9XCI3MzAwMFwiLz48L2E6c2NoZW1lQ2xyPjwvYTpncz48YTpncyBwb3M9XCIxMDAwMDBcIj48YTpzY2hlbWVDbHIgdmFsPVwicGhDbHJcIj48YTpsdW1Nb2QgdmFsPVwiMTA1MDAwXCIvPjxhOnNhdE1vZCB2YWw9XCIxMDkwMDBcIi8+PGE6dGludCB2YWw9XCI4MTAwMFwiLz48L2E6c2NoZW1lQ2xyPjwvYTpncz48L2E6Z3NMc3Q+PGE6bGluIGFuZz1cIjU0MDAwMDBcIiBzY2FsZWQ9XCIwXCIvPjwvYTpncmFkRmlsbD48YTpncmFkRmlsbCByb3RXaXRoU2hhcGU9XCIxXCI+PGE6Z3NMc3Q+PGE6Z3MgcG9zPVwiMFwiPjxhOnNjaGVtZUNsciB2YWw9XCJwaENsclwiPjxhOnNhdE1vZCB2YWw9XCIxMDMwMDBcIi8+PGE6bHVtTW9kIHZhbD1cIjEwMjAwMFwiLz48YTp0aW50IHZhbD1cIjk0MDAwXCIvPjwvYTpzY2hlbWVDbHI+PC9hOmdzPjxhOmdzIHBvcz1cIjUwMDAwXCI+PGE6c2NoZW1lQ2xyIHZhbD1cInBoQ2xyXCI+PGE6c2F0TW9kIHZhbD1cIjExMDAwMFwiLz48YTpsdW1Nb2QgdmFsPVwiMTAwMDAwXCIvPjxhOnNoYWRlIHZhbD1cIjEwMDAwMFwiLz48L2E6c2NoZW1lQ2xyPjwvYTpncz48YTpncyBwb3M9XCIxMDAwMDBcIj48YTpzY2hlbWVDbHIgdmFsPVwicGhDbHJcIj48YTpsdW1Nb2QgdmFsPVwiOTkwMDBcIi8+PGE6c2F0TW9kIHZhbD1cIjEyMDAwMFwiLz48YTpzaGFkZSB2YWw9XCI3ODAwMFwiLz48L2E6c2NoZW1lQ2xyPjwvYTpncz48L2E6Z3NMc3Q+PGE6bGluIGFuZz1cIjU0MDAwMDBcIiBzY2FsZWQ9XCIwXCIvPjwvYTpncmFkRmlsbD48L2E6ZmlsbFN0eWxlTHN0PjxhOmxuU3R5bGVMc3Q+PGE6bG4gdz1cIjYzNTBcIiBjYXA9XCJmbGF0XCIgY21wZD1cInNuZ1wiIGFsZ249XCJjdHJcIj48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD1cInBoQ2xyXCIvPjwvYTpzb2xpZEZpbGw+PGE6cHJzdERhc2ggdmFsPVwic29saWRcIi8+PGE6bWl0ZXIgbGltPVwiODAwMDAwXCIvPjwvYTpsbj48YTpsbiB3PVwiMTI3MDBcIiBjYXA9XCJmbGF0XCIgY21wZD1cInNuZ1wiIGFsZ249XCJjdHJcIj48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD1cInBoQ2xyXCIvPjwvYTpzb2xpZEZpbGw+PGE6cHJzdERhc2ggdmFsPVwic29saWRcIi8+PGE6bWl0ZXIgbGltPVwiODAwMDAwXCIvPjwvYTpsbj48YTpsbiB3PVwiMTkwNTBcIiBjYXA9XCJmbGF0XCIgY21wZD1cInNuZ1wiIGFsZ249XCJjdHJcIj48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD1cInBoQ2xyXCIvPjwvYTpzb2xpZEZpbGw+PGE6cHJzdERhc2ggdmFsPVwic29saWRcIi8+PGE6bWl0ZXIgbGltPVwiODAwMDAwXCIvPjwvYTpsbj48L2E6bG5TdHlsZUxzdD48YTplZmZlY3RTdHlsZUxzdD48YTplZmZlY3RTdHlsZT48YTplZmZlY3RMc3QvPjwvYTplZmZlY3RTdHlsZT48YTplZmZlY3RTdHlsZT48YTplZmZlY3RMc3QvPjwvYTplZmZlY3RTdHlsZT48YTplZmZlY3RTdHlsZT48YTplZmZlY3RMc3Q+PGE6b3V0ZXJTaGR3IGJsdXJSYWQ9XCI1NzE1MFwiIGRpc3Q9XCIxOTA1MFwiIGRpcj1cIjU0MDAwMDBcIiBhbGduPVwiY3RyXCIgcm90V2l0aFNoYXBlPVwiMFwiPjxhOnNyZ2JDbHIgdmFsPVwiMDAwMDAwXCI+PGE6YWxwaGEgdmFsPVwiNjMwMDBcIi8+PC9hOnNyZ2JDbHI+PC9hOm91dGVyU2hkdz48L2E6ZWZmZWN0THN0PjwvYTplZmZlY3RTdHlsZT48L2E6ZWZmZWN0U3R5bGVMc3Q+PGE6YmdGaWxsU3R5bGVMc3Q+PGE6c29saWRGaWxsPjxhOnNjaGVtZUNsciB2YWw9XCJwaENsclwiLz48L2E6c29saWRGaWxsPjxhOnNvbGlkRmlsbD48YTpzY2hlbWVDbHIgdmFsPVwicGhDbHJcIj48YTp0aW50IHZhbD1cIjk1MDAwXCIvPjxhOnNhdE1vZCB2YWw9XCIxNzAwMDBcIi8+PC9hOnNjaGVtZUNscj48L2E6c29saWRGaWxsPjxhOmdyYWRGaWxsIHJvdFdpdGhTaGFwZT1cIjFcIj48YTpnc0xzdD48YTpncyBwb3M9XCIwXCI+PGE6c2NoZW1lQ2xyIHZhbD1cInBoQ2xyXCI+PGE6dGludCB2YWw9XCI5MzAwMFwiLz48YTpzYXRNb2QgdmFsPVwiMTUwMDAwXCIvPjxhOnNoYWRlIHZhbD1cIjk4MDAwXCIvPjxhOmx1bU1vZCB2YWw9XCIxMDIwMDBcIi8+PC9hOnNjaGVtZUNscj48L2E6Z3M+PGE6Z3MgcG9zPVwiNTAwMDBcIj48YTpzY2hlbWVDbHIgdmFsPVwicGhDbHJcIj48YTp0aW50IHZhbD1cIjk4MDAwXCIvPjxhOnNhdE1vZCB2YWw9XCIxMzAwMDBcIi8+PGE6c2hhZGUgdmFsPVwiOTAwMDBcIi8+PGE6bHVtTW9kIHZhbD1cIjEwMzAwMFwiLz48L2E6c2NoZW1lQ2xyPjwvYTpncz48YTpncyBwb3M9XCIxMDAwMDBcIj48YTpzY2hlbWVDbHIgdmFsPVwicGhDbHJcIj48YTpzaGFkZSB2YWw9XCI2MzAwMFwiLz48YTpzYXRNb2QgdmFsPVwiMTIwMDAwXCIvPjwvYTpzY2hlbWVDbHI+PC9hOmdzPjwvYTpnc0xzdD48YTpsaW4gYW5nPVwiNTQwMDAwMFwiIHNjYWxlZD1cIjBcIi8+PC9hOmdyYWRGaWxsPjwvYTpiZ0ZpbGxTdHlsZUxzdD48L2E6Zm10U2NoZW1lPjwvYTp0aGVtZUVsZW1lbnRzPjxhOm9iamVjdERlZmF1bHRzLz48YTpleHRyYUNsclNjaGVtZUxzdC8+PGE6ZXh0THN0PjxhOmV4dCB1cmk9XCJ7MDVBNEMyNUMtMDg1RS00MzQwLTg1QTMtQTU1MzFFNTEwREIyfVwiPjx0aG0xNTp0aGVtZUZhbWlseSB4bWxuczp0aG0xNT1cImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3RoZW1lbWwvMjAxMi9tYWluXCIgbmFtZT1cIk9mZmljZSBUaGVtZVwiIGlkPVwiezYyRjkzOUI2LTkzQUYtNERCOC05QzZCLUQ2QzdERkRDNTg5Rn1cIiB2aWQ9XCJ7NEEzQzQ2RTgtNjFDQy00NjAzLUE1ODktNzQyMkE0N0E4RTRBfVwiLz48L2E6ZXh0PjwvYTpleHRMc3Q+PC9hOnRoZW1lPicpO1xuICAgICAgICAgICAgICAgIHppcEV4Y2VsLmZpbGUoJ3hsL3dvcmtib29rLnhtbCcsICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiIHN0YW5kYWxvbmU9XCJ5ZXNcIj8+JyArXG4gICAgICAgICAgICAgICAgICAgICc8d29ya2Jvb2sgeG1sbnM9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvc3ByZWFkc2hlZXRtbC8yMDA2L21haW5cIiB4bWxuczpyPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwc1wiIHhtbG5zOm1jPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL21hcmt1cC1jb21wYXRpYmlsaXR5LzIwMDZcIiBtYzpJZ25vcmFibGU9XCJ4MTVcIiB4bWxuczp4MTU9XCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9zcHJlYWRzaGVldG1sLzIwMTAvMTEvbWFpblwiPicgK1xuICAgICAgICAgICAgICAgICAgICAnPGZpbGVWZXJzaW9uIGFwcE5hbWU9XCJ4bFwiIGxhc3RFZGl0ZWQ9XCI3XCIgbG93ZXN0RWRpdGVkPVwiNlwiIHJ1cEJ1aWxkPVwiMTA1MDdcIi8+JyArXG4gICAgICAgICAgICAgICAgICAgICc8d29ya2Jvb2tQci8+JyArXG4gICAgICAgICAgICAgICAgICAgICc8Ym9va1ZpZXdzPjx3b3JrYm9va1ZpZXcgeFdpbmRvdz1cIjBcIiB5V2luZG93PVwiNTAwXCIgd2luZG93V2lkdGg9XCIyMDk2MFwiIHdpbmRvd0hlaWdodD1cIjE1OTYwXCIvPjwvYm9va1ZpZXdzPicgK1xuICAgICAgICAgICAgICAgICAgICAnPHNoZWV0cz48c2hlZXQgbmFtZT1cIlNoZWV0MVwiIHNoZWV0SWQ9XCIxXCIgcjppZD1cInJJZDFcIi8+PC9zaGVldHM+JyArXG4gICAgICAgICAgICAgICAgICAgICc8Y2FsY1ByIGNhbGNJZD1cIjBcIiBjb25jdXJyZW50Q2FsYz1cIjBcIi8+JyArXG4gICAgICAgICAgICAgICAgICAgICc8L3dvcmtib29rPlxcbicpO1xuICAgICAgICAgICAgICAgIHppcEV4Y2VsLmZpbGUoJ3hsL3dvcmtzaGVldHMvX3JlbHMvc2hlZXQxLnhtbC5yZWxzJywgJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCIgc3RhbmRhbG9uZT1cInllc1wiPz4nICtcbiAgICAgICAgICAgICAgICAgICAgJzxSZWxhdGlvbnNoaXBzIHhtbG5zPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3BhY2thZ2UvMjAwNi9yZWxhdGlvbnNoaXBzXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICc8UmVsYXRpb25zaGlwIElkPVwicklkMVwiIFR5cGU9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL3RhYmxlXCIgVGFyZ2V0PVwiLi4vdGFibGVzL3RhYmxlMS54bWxcIi8+JyArXG4gICAgICAgICAgICAgICAgICAgICc8L1JlbGF0aW9uc2hpcHM+XFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzaGFyZWRTdHJpbmdzLnhtbFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIEE6IFN0YXJ0IFhNTFxuICAgICAgICAgICAgICAgIGxldCBzdHJTaGFyZWRTdHJpbmdzID0gJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCIgc3RhbmRhbG9uZT1cInllc1wiPz4nO1xuICAgICAgICAgICAgICAgIGlmIChjaGFydE9iamVjdC5vcHRzLl90eXBlID09PSBDSEFSVF9UWVBFLkJVQkJMRSB8fCBjaGFydE9iamVjdC5vcHRzLl90eXBlID09PSBDSEFSVF9UWVBFLkJVQkJMRTNEKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0clNoYXJlZFN0cmluZ3MgKz0gYDxzc3QgeG1sbnM9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvc3ByZWFkc2hlZXRtbC8yMDA2L21haW5cIiBjb3VudD1cIiR7aW50QnViYmxlQ29sc31cIiB1bmlxdWVDb3VudD1cIiR7aW50QnViYmxlQ29sc31cIj5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFydE9iamVjdC5vcHRzLl90eXBlID09PSBDSEFSVF9UWVBFLlNDQVRURVIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyU2hhcmVkU3RyaW5ncyArPSBgPHNzdCB4bWxucz1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9zcHJlYWRzaGVldG1sLzIwMDYvbWFpblwiIGNvdW50PVwiJHtkYXRhLmxlbmd0aH1cIiB1bmlxdWVDb3VudD1cIiR7ZGF0YS5sZW5ndGh9XCI+YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoSVNfTVVMVElfQ0FUX0FYRVMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvdENvdW50ID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbMF0ubGFiZWxzLmZvckVhY2goYXJyTGFiZWwgPT4gKHRvdENvdW50ICs9IGFyckxhYmVsLmZpbHRlcihsYWJlbCA9PiBsYWJlbCAmJiBsYWJlbCAhPT0gJycpLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICBzdHJTaGFyZWRTdHJpbmdzICs9IGA8c3N0IHhtbG5zPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3NwcmVhZHNoZWV0bWwvMjAwNi9tYWluXCIgY291bnQ9XCIke3RvdENvdW50fVwiIHVuaXF1ZUNvdW50PVwiJHt0b3RDb3VudH1cIj5gO1xuICAgICAgICAgICAgICAgICAgICBzdHJTaGFyZWRTdHJpbmdzICs9ICc8c2k+PHQvPjwvc2k+JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlcmllcyBuYW1lcyArIGFsbCBsYWJlbHMgb2Ygb25lIHNlcmllcyArIG51bWJlciBvZiBsYWJlbCBncm91cHMgKGRhdGEubGFiZWxzLmxlbmd0aCkgb2Ygb25lIHNlcmllcyAoaS5lLiBob3cgbWFueSB0aW1lcyB0aGUgYmxhbmsgc3RyaW5nIGlzIHVzZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvdENvdW50ID0gZGF0YS5sZW5ndGggKyBkYXRhWzBdLmxhYmVscy5sZW5ndGggKiBkYXRhWzBdLmxhYmVsc1swXS5sZW5ndGggKyBkYXRhWzBdLmxhYmVscy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlcmllcyBuYW1lcyArIGxhYmVscyBvZiBvbmUgc2VyaWVzICsgYmxhbmsgc3RyaW5nIChzYW1lIGZvciBhbGwgbGFiZWwgZ3JvdXBzKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1bnFDb3VudCA9IGRhdGEubGVuZ3RoICsgZGF0YVswXS5sYWJlbHMubGVuZ3RoICogZGF0YVswXS5sYWJlbHNbMF0ubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgYHNzdGBcbiAgICAgICAgICAgICAgICAgICAgc3RyU2hhcmVkU3RyaW5ncyArPSBgPHNzdCB4bWxucz1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9zcHJlYWRzaGVldG1sLzIwMDYvbWFpblwiIGNvdW50PVwiJHt0b3RDb3VudH1cIiB1bmlxdWVDb3VudD1cIiR7dW5xQ291bnR9XCI+YDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQjogQWRkICdibGFuaycgZm9yIEExLCBCMSwgLi4uLCBvZiBldmVyeSBsYWJlbCBncm91cCBpbnNpZGUgZGF0YVtuXS5sYWJlbHNcbiAgICAgICAgICAgICAgICAgICAgc3RyU2hhcmVkU3RyaW5ncyArPSAnPHNpPjx0IHhtbDpzcGFjZT1cInByZXNlcnZlXCI+PC90Pjwvc2k+JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQzogQWRkIGBuYW1lYC9TZXJpZXNcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnRPYmplY3Qub3B0cy5fdHlwZSA9PT0gQ0hBUlRfVFlQRS5CVUJCTEUgfHwgY2hhcnRPYmplY3Qub3B0cy5fdHlwZSA9PT0gQ0hBUlRfVFlQRS5CVUJCTEUzRCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goKG9iakRhdGEsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJTaGFyZWRTdHJpbmdzICs9ICc8c2k+PHQ+WC1BeGlzPC90Pjwvc2k+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clNoYXJlZFN0cmluZ3MgKz0gYDxzaT48dD4ke2VuY29kZVhtbEVudGl0aWVzKG9iakRhdGEubmFtZSB8fCBgWS1BeGlzJHtpZHh9YCl9PC90Pjwvc2k+YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJTaGFyZWRTdHJpbmdzICs9IGA8c2k+PHQ+JHtlbmNvZGVYbWxFbnRpdGllcyhgU2l6ZSR7aWR4fWApfTwvdD48L3NpPmA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKG9iakRhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyU2hhcmVkU3RyaW5ncyArPSBgPHNpPjx0PiR7ZW5jb2RlWG1sRW50aXRpZXMoKG9iakRhdGEubmFtZSB8fCAnICcpLnJlcGxhY2UoJ1gtQXhpcycsICdYLVZhbHVlcycpKX08L3Q+PC9zaT5gO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRDogQWRkIGBsYWJlbHNgL0NhdGVnb3JpZXNcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnRPYmplY3Qub3B0cy5fdHlwZSAhPT0gQ0hBUlRfVFlQRS5CVUJCTEUgJiYgY2hhcnRPYmplY3Qub3B0cy5fdHlwZSAhPT0gQ0hBUlRfVFlQRS5CVUJCTEUzRCAmJiBjaGFydE9iamVjdC5vcHRzLl90eXBlICE9PSBDSEFSVF9UWVBFLlNDQVRURVIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGZvckVhY2ggYmFja3dhcmRzICYgY2hlY2sgZm9yICcnIHRvIHN1cHBvcnQgbXVsdGktY2F0IGF4ZXNcbiAgICAgICAgICAgICAgICAgICAgZGF0YVswXS5sYWJlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChsYWJlbHNHcm91cCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbHNHcm91cFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobGFiZWwgPT4gbGFiZWwgJiYgbGFiZWwgIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGxhYmVsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJTaGFyZWRTdHJpbmdzICs9IGA8c2k+PHQ+JHtlbmNvZGVYbWxFbnRpdGllcyhsYWJlbCl9PC90Pjwvc2k+YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRE9ORTpcbiAgICAgICAgICAgICAgICBzdHJTaGFyZWRTdHJpbmdzICs9ICc8L3NzdD5cXG4nO1xuICAgICAgICAgICAgICAgIHppcEV4Y2VsLmZpbGUoJ3hsL3NoYXJlZFN0cmluZ3MueG1sJywgc3RyU2hhcmVkU3RyaW5ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0YWJsZXMvdGFibGUxLnhtbFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxldCBzdHJUYWJsZVhtbCA9ICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiIHN0YW5kYWxvbmU9XCJ5ZXNcIj8+JztcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnRPYmplY3Qub3B0cy5fdHlwZSA9PT0gQ0hBUlRfVFlQRS5CVUJCTEUgfHwgY2hhcnRPYmplY3Qub3B0cy5fdHlwZSA9PT0gQ0hBUlRfVFlQRS5CVUJCTEUzRCkge1xuICAgICAgICAgICAgICAgICAgICBzdHJUYWJsZVhtbCArPSBgPHRhYmxlIHhtbG5zPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3NwcmVhZHNoZWV0bWwvMjAwNi9tYWluXCIgaWQ9XCIxXCIgbmFtZT1cIlRhYmxlMVwiIGRpc3BsYXlOYW1lPVwiVGFibGUxXCIgcmVmPVwiQTE6JHtnZXRFeGNlbENvbE5hbWUoaW50QnViYmxlQ29scyl9JHtpbnRCdWJibGVDb2xzfVwiIHRvdGFsc1Jvd1Nob3duPVwiMFwiPmA7XG4gICAgICAgICAgICAgICAgICAgIHN0clRhYmxlWG1sICs9IGA8dGFibGVDb2x1bW5zIGNvdW50PVwiJHtpbnRCdWJibGVDb2xzfVwiPmA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpZHhDb2xMdHIgPSAxO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goKG9iaiwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyVGFibGVYbWwgKz0gYDx0YWJsZUNvbHVtbiBpZD1cIiR7aWR4ICsgMX1cIiBuYW1lPVwiWC1WYWx1ZXNcIi8+YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clRhYmxlWG1sICs9IGA8dGFibGVDb2x1bW4gaWQ9XCIke2lkeCArIGlkeENvbEx0cn1cIiBuYW1lPVwiJHtvYmoubmFtZX1cIi8+YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHhDb2xMdHIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJUYWJsZVhtbCArPSBgPHRhYmxlQ29sdW1uIGlkPVwiJHtpZHggKyBpZHhDb2xMdHJ9XCIgbmFtZT1cIlNpemUke2lkeH1cIi8+YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJ0T2JqZWN0Lm9wdHMuX3R5cGUgPT09IENIQVJUX1RZUEUuU0NBVFRFUikge1xuICAgICAgICAgICAgICAgICAgICBzdHJUYWJsZVhtbCArPSBgPHRhYmxlIHhtbG5zPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3NwcmVhZHNoZWV0bWwvMjAwNi9tYWluXCIgaWQ9XCIxXCIgbmFtZT1cIlRhYmxlMVwiIGRpc3BsYXlOYW1lPVwiVGFibGUxXCIgcmVmPVwiQTE6JHtnZXRFeGNlbENvbE5hbWUoZGF0YS5sZW5ndGgpfSR7ZGF0YVswXS52YWx1ZXMubGVuZ3RoICsgMX1cIiB0b3RhbHNSb3dTaG93bj1cIjBcIj5gO1xuICAgICAgICAgICAgICAgICAgICBzdHJUYWJsZVhtbCArPSBgPHRhYmxlQ29sdW1ucyBjb3VudD1cIiR7ZGF0YS5sZW5ndGh9XCI+YDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKChfb2JqLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clRhYmxlWG1sICs9IGA8dGFibGVDb2x1bW4gaWQ9XCIke2lkeCArIDF9XCIgbmFtZT1cIiR7aWR4ID09PSAwID8gJ1gtVmFsdWVzJyA6ICdZLVZhbHVlICd9JHtpZHh9XCIvPmA7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyVGFibGVYbWwgKz0gYDx0YWJsZSB4bWxucz1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9zcHJlYWRzaGVldG1sLzIwMDYvbWFpblwiIGlkPVwiMVwiIG5hbWU9XCJUYWJsZTFcIiBkaXNwbGF5TmFtZT1cIlRhYmxlMVwiIHJlZj1cIkExOiR7Z2V0RXhjZWxDb2xOYW1lKGRhdGEubGVuZ3RoICsgZGF0YVswXS5sYWJlbHMubGVuZ3RoKX0ke2RhdGFbMF0ubGFiZWxzWzBdLmxlbmd0aCArIDF9J1wiIHRvdGFsc1Jvd1Nob3duPVwiMFwiPmA7XG4gICAgICAgICAgICAgICAgICAgIHN0clRhYmxlWG1sICs9IGA8dGFibGVDb2x1bW5zIGNvdW50PVwiJHtkYXRhLmxlbmd0aCArIGRhdGFbMF0ubGFiZWxzLmxlbmd0aH1cIj5gO1xuICAgICAgICAgICAgICAgICAgICBkYXRhWzBdLmxhYmVscy5mb3JFYWNoKChfbGFiZWxzR3JvdXAsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyVGFibGVYbWwgKz0gYDx0YWJsZUNvbHVtbiBpZD1cIiR7aWR4ICsgMX1cIiBuYW1lPVwiQ29sdW1uJHtpZHggKyAxfVwiLz5gO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKChvYmosIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyVGFibGVYbWwgKz0gYDx0YWJsZUNvbHVtbiBpZD1cIiR7aWR4ICsgZGF0YVswXS5sYWJlbHMubGVuZ3RoICsgMX1cIiBuYW1lPVwiJHtlbmNvZGVYbWxFbnRpdGllcyhvYmoubmFtZSl9XCIvPmA7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJUYWJsZVhtbCArPSAnPC90YWJsZUNvbHVtbnM+JztcbiAgICAgICAgICAgICAgICBzdHJUYWJsZVhtbCArPSAnPHRhYmxlU3R5bGVJbmZvIHNob3dGaXJzdENvbHVtbj1cIjBcIiBzaG93TGFzdENvbHVtbj1cIjBcIiBzaG93Um93U3RyaXBlcz1cIjFcIiBzaG93Q29sdW1uU3RyaXBlcz1cIjBcIi8+JztcbiAgICAgICAgICAgICAgICBzdHJUYWJsZVhtbCArPSAnPC90YWJsZT4nO1xuICAgICAgICAgICAgICAgIHppcEV4Y2VsLmZpbGUoJ3hsL3RhYmxlcy90YWJsZTEueG1sJywgc3RyVGFibGVYbWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd29ya3NoZWV0cy9zaGVldDEueG1sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGV0IHN0clNoZWV0WG1sID0gJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCIgc3RhbmRhbG9uZT1cInllc1wiPz4nO1xuICAgICAgICAgICAgICAgIHN0clNoZWV0WG1sICs9XG4gICAgICAgICAgICAgICAgICAgICc8d29ya3NoZWV0IHhtbG5zPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3NwcmVhZHNoZWV0bWwvMjAwNi9tYWluXCIgeG1sbnM6cj1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHNcIiB4bWxuczptYz1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9tYXJrdXAtY29tcGF0aWJpbGl0eS8yMDA2XCIgbWM6SWdub3JhYmxlPVwieDE0YWNcIiB4bWxuczp4MTRhYz1cImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3NwcmVhZHNoZWV0bWwvMjAwOS85L2FjXCI+JztcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnRPYmplY3Qub3B0cy5fdHlwZSA9PT0gQ0hBUlRfVFlQRS5CVUJCTEUgfHwgY2hhcnRPYmplY3Qub3B0cy5fdHlwZSA9PT0gQ0hBUlRfVFlQRS5CVUJCTEUzRCkge1xuICAgICAgICAgICAgICAgICAgICBzdHJTaGVldFhtbCArPSBgPGRpbWVuc2lvbiByZWY9XCJBMToke2dldEV4Y2VsQ29sTmFtZShpbnRCdWJibGVDb2xzKX0ke2RhdGFbMF0udmFsdWVzLmxlbmd0aCArIDF9XCIvPmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJ0T2JqZWN0Lm9wdHMuX3R5cGUgPT09IENIQVJUX1RZUEUuU0NBVFRFUikge1xuICAgICAgICAgICAgICAgICAgICBzdHJTaGVldFhtbCArPSBgPGRpbWVuc2lvbiByZWY9XCJBMToke2dldEV4Y2VsQ29sTmFtZShkYXRhLmxlbmd0aCl9JHtkYXRhWzBdLnZhbHVlcy5sZW5ndGggKyAxfVwiLz5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyU2hlZXRYbWwgKz0gYDxkaW1lbnNpb24gcmVmPVwiQTE6JHtnZXRFeGNlbENvbE5hbWUoZGF0YS5sZW5ndGggKyAxKX0ke2RhdGFbMF0udmFsdWVzLmxlbmd0aCArIDF9XCIvPmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0clNoZWV0WG1sICs9ICc8c2hlZXRWaWV3cz48c2hlZXRWaWV3IHRhYlNlbGVjdGVkPVwiMVwiIHdvcmtib29rVmlld0lkPVwiMFwiPjxzZWxlY3Rpb24gYWN0aXZlQ2VsbD1cIkIxXCIgc3FyZWY9XCJCMVwiLz48L3NoZWV0Vmlldz48L3NoZWV0Vmlld3M+JztcbiAgICAgICAgICAgICAgICBzdHJTaGVldFhtbCArPSAnPHNoZWV0Rm9ybWF0UHIgYmFzZUNvbFdpZHRoPVwiMTBcIiBkZWZhdWx0Um93SGVpZ2h0PVwiMTZcIi8+JztcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnRPYmplY3Qub3B0cy5fdHlwZSA9PT0gQ0hBUlRfVFlQRS5CVUJCTEUgfHwgY2hhcnRPYmplY3Qub3B0cy5fdHlwZSA9PT0gQ0hBUlRfVFlQRS5CVUJCTEUzRCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVTlVTRUQ6IHN0clNoZWV0WG1sICs9IGA8Y29scz48Y29sIG1pbj1cIjFcIiBtYXg9XCIke2RhdGEubGVuZ3RofVwiIHdpZHRoPVwiMTFcIiBjdXN0b21XaWR0aD1cIjFcIiAvPjwvY29scz5gXG4gICAgICAgICAgICAgICAgICAgIC8qIEVYOiBJTlBVVDogYGRhdGFgXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTonWC1BeGlzJyAgLCB2YWx1ZXM6WzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOidZLUF4aXMgMScsIHZhbHVlczpbIDEsIDYsIDcsIDgsIDldLCBzaXplczpbIDQsIDUsIDYsIDcsIDhdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6J1ktQXhpcyAyJywgdmFsdWVzOlszMywzMiw0Miw1Myw2M10sIHNpemVzOlsxMSwxMiwxMywxNCwxNV0gfVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAvKiBFWDogT1VUUFVUOiBidWJibGVDaGFydCBXb3Jrc2hlZXQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAtfC0tLS1BLS0tLS18LS0tLS0tQi0tLS0tfC0tLS0tLUMtLS0tLXwtLS0tLS1ELS0tLS18LS0tLS0tRS0tLS0tfFxuICAgICAgICAgICAgICAgICAgICAgICAgMXwgWC1WYWx1ZXMgfCBZLVZhbHVlcyAxIHwgWS1TaXplcyAxICB8IFktVmFsdWVzIDIgfCBZLVNpemVzIDIgIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIDJ8ICAgIDExICAgIHwgICAgIDIyICAgICB8ICAgICAgNCAgICAgfCAgICAgMzMgICAgIHwgICAgICA4ICAgICB8XG4gICAgICAgICAgICAgICAgICAgICAgICAtfC0tLS0tLS0tLS18LS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tfFxuICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBzdHJTaGVldFhtbCArPSAnPHNoZWV0RGF0YT4nO1xuICAgICAgICAgICAgICAgICAgICAvLyBBOiBDcmVhdGUgaGVhZGVyIHJvdyBmaXJzdCAoTk9URTogU3RhcnQgYXQgaW5kZXg9MSBhcyBoZWFkZXJzIGNvbHMgc3RhcnQgd2l0aCAnQicpXG4gICAgICAgICAgICAgICAgICAgIHN0clNoZWV0WG1sICs9IGA8cm93IHI9XCIxXCIgc3BhbnM9XCIxOiR7aW50QnViYmxlQ29sc31cIj5gO1xuICAgICAgICAgICAgICAgICAgICBzdHJTaGVldFhtbCArPSAnPGMgcj1cIkExXCIgdD1cInNcIj48dj4wPC92PjwvYz4nO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpZHggPSAxOyBpZHggPCBpbnRCdWJibGVDb2xzOyBpZHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyU2hlZXRYbWwgKz0gYDxjIHI9XCIke2dldEV4Y2VsQ29sTmFtZShpZHggKyAxKX0xXCIgdD1cInNcIj48dj4ke2lkeH08L3Y+PC9jPmA7IC8vIE5PVEU6IGFkZCBgdD1cInNcImAgZm9yIGxhYmVsIGNvbHMhXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RyU2hlZXRYbWwgKz0gJzwvcm93Pic7XG4gICAgICAgICAgICAgICAgICAgIC8vIEI6IEFkZCByb3cgZm9yIGVhY2ggWC1BeGlzIHZhbHVlIChZLUF4aXMqIHZhbHVlIGlzIG9wdGlvbmFsKVxuICAgICAgICAgICAgICAgICAgICBkYXRhWzBdLnZhbHVlcy5mb3JFYWNoKCh2YWwsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVhZGluZyBjb2wgaXMgcmVzZXJ2ZWQgZm9yIHRoZSAnWC1BeGlzJyB2YWx1ZSwgc28gaGFyZC1jb2RlIGl0LCB0aGVuIGxvb3Agb3ZlciBjb2wgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJTaGVldFhtbCArPSBgPHJvdyByPVwiJHtpZHggKyAyfVwiIHNwYW5zPVwiMToke2ludEJ1YmJsZUNvbHN9XCI+YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clNoZWV0WG1sICs9IGA8YyByPVwiQSR7aWR4ICsgMn1cIj48dj4ke3ZhbH08L3Y+PC9jPmA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgWS1BeGlzIDEtPk4gKGlkeT0wID0gWGF4aXMpXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaWR4Q29sTHRyID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGlkeSA9IDE7IGlkeSA8IGRhdGEubGVuZ3RoOyBpZHkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHktdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJTaGVldFhtbCArPSBgPGMgcj1cIiR7Z2V0RXhjZWxDb2xOYW1lKGlkeENvbEx0cil9JHtpZHggKyAyfVwiPjx2PiR7ZGF0YVtpZHldLnZhbHVlc1tpZHhdIHx8ICcnfTwvdj48L2M+YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHhDb2xMdHIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB5LXNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJTaGVldFhtbCArPSBgPGMgcj1cIiR7Z2V0RXhjZWxDb2xOYW1lKGlkeENvbEx0cil9JHtpZHggKyAyfVwiPjx2PiR7ZGF0YVtpZHldLnNpemVzW2lkeF0gfHwgJyd9PC92PjwvYz5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkeENvbEx0cisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyU2hlZXRYbWwgKz0gJzwvcm93Pic7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFydE9iamVjdC5vcHRzLl90eXBlID09PSBDSEFSVF9UWVBFLlNDQVRURVIpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogVU5VU0VEOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyU2hlZXRYbWwgKz0gJzxjb2xzPidcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clNoZWV0WG1sICs9ICc8Y29sIG1pbj1cIjFcIiBtYXg9XCInICsgZGF0YS5sZW5ndGggKyAnXCIgd2lkdGg9XCIxMVwiIGN1c3RvbVdpZHRoPVwiMVwiIC8+J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9kYXRhLmZvckVhY2goKG9iaixpZHgpPT57IHN0clNoZWV0WG1sICs9ICc8Y29sIG1pbj1cIicrKGlkeCsxKSsnXCIgbWF4PVwiJysoaWR4KzEpKydcIiB3aWR0aD1cIjExXCIgY3VzdG9tV2lkdGg9XCIxXCIgLz4nIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyU2hlZXRYbWwgKz0gJzwvY29scz4nXG4gICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIC8qIEVYOiBJTlBVVDogYGRhdGFgXG4gICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOidYLUF4aXNBJywgdmFsdWVzOlsgMSwgMiwgMywgNCwgNV0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6J1ktQXhpc0InLCB2YWx1ZXM6WyAyLDIyLDQyLDUyLDYyXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTonWS1BeGlzQycsIHZhbHVlczpbIDMsMzMsNDMsNTMsNjNdIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIC8qIEVYOiBPVVRQVVQ6IHNoZWV0MS54bWw6XG4gICAgICAgICAgICAgICAgICAgICAgICAtfC0tLS1BLS0tLXwtLS0tQi0tLS18LS0tLUMtLS0tfFxuICAgICAgICAgICAgICAgICAgICAgICAgMXwgWC1BeGlzQSB8IFktQXhpc0IgfCBZLUF4aXNDIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIDJ8ICAgIDEgICAgfCAgICAyICAgIHwgICAgMyAgICB8XG4gICAgICAgICAgICAgICAgICAgICAgICAtfC0tLS0tLS0tLXwtLS0tLS0tLS18LS0tLS0tLS0tfFxuICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBzdHJTaGVldFhtbCArPSAnPHNoZWV0RGF0YT4nO1xuICAgICAgICAgICAgICAgICAgICAvLyBBOiBDcmVhdGUgaGVhZGVyIHJvdyBmaXJzdCAoZXZlcnkgYG5hbWVgIHJvdyBwcm92aWRlZClcbiAgICAgICAgICAgICAgICAgICAgc3RyU2hlZXRYbWwgKz0gYDxyb3cgcj1cIjFcIiBzcGFucz1cIjE6JHtkYXRhLmxlbmd0aH1cIj5gO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBkYXRhLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clNoZWV0WG1sICs9IGA8YyByPVwiJHtnZXRFeGNlbENvbE5hbWUoaWR4ICsgMSl9MVwiIHQ9XCJzXCI+PHY+JHtpZHh9PC92PjwvYz5gOyAvLyBOT1RFOiBhZGQgYHQ9XCJzXCJgIGZvciBsYWJlbCBjb2xzIVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0clNoZWV0WG1sICs9ICc8L3Jvdz4nO1xuICAgICAgICAgICAgICAgICAgICAvLyBCOiBBZGQgcm93IGZvciBlYWNoIFgtQXhpcyB2YWx1ZSAoWS1BeGlzKiB2YWx1ZSBpcyBvcHRpb25hbClcbiAgICAgICAgICAgICAgICAgICAgZGF0YVswXS52YWx1ZXMuZm9yRWFjaCgodmFsLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgY29sIGlzIHJlc2VydmVkIGZvciB0aGUgJ1gtQXhpcycgdmFsdWUsIHNvIGhhcmQtY29kZSBpdCwgdGhlbiBsb29wIG92ZXIgY29sIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyU2hlZXRYbWwgKz0gYDxyb3cgcj1cIiR7aWR4ICsgMn1cIiBzcGFucz1cIjE6JHtkYXRhLmxlbmd0aH1cIj5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyU2hlZXRYbWwgKz0gYDxjIHI9XCJBJHtpZHggKyAyfVwiPjx2PiR7dmFsfTwvdj48L2M+YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBZLUF4aXMgMS0+TlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaWR5ID0gMTsgaWR5IDwgZGF0YS5sZW5ndGg7IGlkeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyU2hlZXRYbWwgKz0gYDxjIHI9XCIke2dldEV4Y2VsQ29sTmFtZShpZHkgKyAxKX0ke2lkeCArIDJ9XCI+PHY+JHtkYXRhW2lkeV0udmFsdWVzW2lkeF0gfHwgZGF0YVtpZHldLnZhbHVlc1tpZHhdID09PSAwID8gZGF0YVtpZHldLnZhbHVlc1tpZHhdIDogJyd9PC92PjwvYz5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyU2hlZXRYbWwgKz0gJzwvcm93Pic7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RyU2hlZXRYbWwgKz0gJzxjb2xzPjxjb2wgbWluPVwiMVwiIG1heD1cIjFcIiB3aWR0aD1cIjExXCIgY3VzdG9tV2lkdGg9XCIxXCIgLz48L2NvbHM+J1xuICAgICAgICAgICAgICAgICAgICBzdHJTaGVldFhtbCArPSAnPHNoZWV0RGF0YT4nO1xuICAgICAgICAgICAgICAgICAgICAvKiBFWDogSU5QVVQ6IGBkYXRhYFxuICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTonUmVkJywgbGFiZWxzOlsnSmFuLi5NYXktMTcnXSwgdmFsdWVzOlsxMSwxMywxNCwxNSwxNl0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6J0FtYicsIGxhYmVsczpbJ0phbi4uTWF5LTE3J10sIHZhbHVlczpbMjIsIDYsIDcsIDgsIDldIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOidHcm4nLCBsYWJlbHM6WydKYW4uLk1heS0xNyddLCB2YWx1ZXM6WzMzLDMyLDQyLDUzLDYzXSB9XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAvKiBFWDogT1VUUFVUOiBsaW5lQ2hhcnQgV29ya3NoZWV0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLXwtLS1BLS0tfC0tQi0tfC0tQy0tfC0tRC0tfFxuICAgICAgICAgICAgICAgICAgICAgICAgMXwgICAgICAgfCBSZWQgfCBBbWIgfCBHcm4gfFxuICAgICAgICAgICAgICAgICAgICAgICAgMnxKYW4tMTcgfCAgIDExfCAgIDIyfCAgIDMzfFxuICAgICAgICAgICAgICAgICAgICAgICAgM3xGZWItMTcgfCAgIDU1fCAgIDQzfCAgIDcwfFxuICAgICAgICAgICAgICAgICAgICAgICAgNHxNYXItMTcgfCAgIDU2fCAgMTQzfCAgIDk5fFxuICAgICAgICAgICAgICAgICAgICAgICAgNXxBcHItMTcgfCAgIDY1fCAgICAzfCAgMTIwfFxuICAgICAgICAgICAgICAgICAgICAgICAgNnxNYXktMTcgfCAgIDc1fCAgIDkzfCAgMTcwfFxuICAgICAgICAgICAgICAgICAgICAgICAgLXwtLS0tLS0tfC0tLS0tfC0tLS0tfC0tLS0tfFxuICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUlTX01VTFRJX0NBVF9BWEVTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBOiBDcmVhdGUgaGVhZGVyIHJvdyBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyU2hlZXRYbWwgKz0gYDxyb3cgcj1cIjFcIiBzcGFucz1cIjE6JHtkYXRhLmxlbmd0aCArIGRhdGFbMF0ubGFiZWxzLmxlbmd0aH1cIj5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVswXS5sYWJlbHMuZm9yRWFjaCgoX2xhYmVsc0dyb3VwLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJTaGVldFhtbCArPSBgPGMgcj1cIiR7Z2V0RXhjZWxDb2xOYW1lKGlkeCArIDEpfTFcIiB0PVwic1wiPjx2PjA8L3Y+PC9jPmA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGRhdGEubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clNoZWV0WG1sICs9IGA8YyByPVwiJHtnZXRFeGNlbENvbE5hbWUoaWR4ICsgMSArIGRhdGFbMF0ubGFiZWxzLmxlbmd0aCl9MVwiIHQ9XCJzXCI+PHY+JHtpZHggKyAxfTwvdj48L2M+YDsgLy8gTk9URTogdXNlIGB0PVwic1wiYCBmb3IgbGFiZWwgY29scyFcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clNoZWV0WG1sICs9ICc8L3Jvdz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQjogQWRkIGRhdGEgcm93KHMpIGZvciBlYWNoIGNhdGVnb3J5XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhWzBdLmxhYmVsc1swXS5mb3JFYWNoKChfY2F0LCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJTaGVldFhtbCArPSBgPHJvdyByPVwiJHtpZHggKyAyfVwiIHNwYW5zPVwiMToke2RhdGEubGVuZ3RoICsgZGF0YVswXS5sYWJlbHMubGVuZ3RofVwiPmA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVhZGluZyBjb2xzIGFyZSByZXNlcnZlZCBmb3IgdGhlIGxhYmVsIGdyb3Vwc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGlkeDIgPSBkYXRhWzBdLmxhYmVscy5sZW5ndGggLSAxOyBpZHgyID49IDA7IGlkeDItLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJTaGVldFhtbCArPSBgPGMgcj1cIiR7Z2V0RXhjZWxDb2xOYW1lKGRhdGFbMF0ubGFiZWxzLmxlbmd0aCAtIGlkeDIpfSR7aWR4ICsgMn1cIiB0PVwic1wiPmA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clNoZWV0WG1sICs9IGA8dj4ke2RhdGEubGVuZ3RoICsgaWR4ICsgMX08L3Y+YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyU2hlZXRYbWwgKz0gJzwvYz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpZHkgPSAwOyBpZHkgPCBkYXRhLmxlbmd0aDsgaWR5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyU2hlZXRYbWwgKz0gYDxjIHI9XCIke2dldEV4Y2VsQ29sTmFtZShkYXRhWzBdLmxhYmVscy5sZW5ndGggKyBpZHkgKyAxKX0ke2lkeCArIDJ9XCI+PHY+JHtkYXRhW2lkeV0udmFsdWVzW2lkeF0gfHwgJyd9PC92PjwvYz5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJTaGVldFhtbCArPSAnPC9yb3c+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQTogY3JlYXRlIGhlYWRlciByb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clNoZWV0WG1sICs9IGA8cm93IHI9XCIxXCIgc3BhbnM9XCIxOiR7ZGF0YS5sZW5ndGggKyBkYXRhWzBdLmxhYmVscy5sZW5ndGh9XCI+YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGRhdGFbMF0ubGFiZWxzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJTaGVldFhtbCArPSBgPGMgcj1cIiR7Z2V0RXhjZWxDb2xOYW1lKGlkeCArIDEpfTFcIiB0PVwic1wiPjx2PjA8L3Y+PC9jPmA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpZHggPSBkYXRhWzBdLmxhYmVscy5sZW5ndGggLSAxOyBpZHggPCBkYXRhLmxlbmd0aCArIGRhdGFbMF0ubGFiZWxzLmxlbmd0aCAtIDE7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyU2hlZXRYbWwgKz0gYDxjIHI9XCIke2dldEV4Y2VsQ29sTmFtZShpZHggKyBkYXRhWzBdLmxhYmVscy5sZW5ndGgpfTFcIiB0PVwic1wiPjx2PiR7aWR4fTwvdj48L2M+YDsgLy8gTk9URTogdXNlIGB0PVwic1wiYCBmb3IgbGFiZWwgY29scyFcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clNoZWV0WG1sICs9ICc8L3Jvdz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IDIwMjIwNTI0ICh2My4xMS4wKVxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZSBJTlBVVFxuICAgICAgICAgICAgICAgICAgICAgICAgICogY29uc3QgTEFCRUxTID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICogICBbXCJHZWFyXCIsIFwiQmVyZ1wiLCBcIk1vdHJcIiwgXCJTd2NoXCIsIFwiUGx1Z1wiLCBcIkNvcmRcIiwgXCJQdW1wXCIsIFwiTGVha1wiLCBcIlNlYWxcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAgIFtcIk1lY2hcIiwgXCJcIiwgXCJcIiwgXCJFbGVjXCIsIFwiXCIsIFwiXCIsIFwiSHlkclwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBjb25zdCBhcnJEYXRhUmVnaW9ucyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAqICAgeyBuYW1lOiBcIldlc3RcIiwgbGFiZWxzOiBMQUJFTFMsIHZhbHVlczogWzExLCA4LCAzLCAwLCAxMSwgMywgMCwgMCwgMF0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAqICAgeyBuYW1lOiBcIkN0cmxcIiwgbGFiZWxzOiBMQUJFTFMsIHZhbHVlczogWzAsIDExLCA2LCAxOSwgMTIsIDUsIDAsIDAsIDBdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAgIHsgbmFtZTogXCJFYXN0XCIsIGxhYmVsczogTEFCRUxTLCB2YWx1ZXM6IFswLCAzLCAyLCAwLCAwLCAwLCA0LCAzLCAxXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICogXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZSBPVVRQVVQgRVhDRUwgU0hFRVRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHwvfC0tLUEtLXwtLS1CLS18LS0tQy0tfC0tLUQtLXwtLS1FLS18XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB8MXwgICAgICB8ICAgICAgfCBXZXN0IHwgQ3RybCB8IEVhc3QgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICogfDJ8IE1lY2ggfCBHZWFyIHwgICMjICB8ICAjIyAgfCAgIyMgIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHwzfCAgICAgIHwgQnJuZyB8ICAjIyAgfCAgIyMgIHwgICMjICB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB8NHwgICAgICB8IE1vdHIgfCAgIyMgIHwgICMjICB8ICAjIyAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICogfDV8IEVsZWMgfCBTd2NoIHwgICMjICB8ICAjIyAgfCAgIyMgIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHw2fCAgICAgIHwgUGx1ZyB8ICAjIyAgfCAgIyMgIHwgICMjICB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB8N3wgICAgICB8IENvcmQgfCAgIyMgIHwgICMjICB8ICAjIyAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICogfDh8IEh5ZHIgfCBQdW1wIHwgICMjICB8ICAjIyAgfCAgIyMgIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHw5fCAgICAgIHwgTGVhayB8ICAjIyAgfCAgIyMgIHwgICMjICB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKnwxMHwgICAgICB8IFNlYWwgfCAgIyMgIHwgICMjICB8ICAjIyAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleGFtcGxlIE9VVFBVVCBFWENFTCBTSEVFVCBYTUxcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIDxyb3cgcj1cIjFcIiBzcGFucz1cIjE6NVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICogICA8YyByPVwiQTFcIiB0PVwic1wiPjx2PjA8L3Y+PC9jPlxuICAgICAgICAgICAgICAgICAgICAgICAgICogICA8YyByPVwiQjFcIiB0PVwic1wiPjx2PjA8L3Y+PC9jPlxuICAgICAgICAgICAgICAgICAgICAgICAgICogICA8YyByPVwiQzFcIiB0PVwic1wiPjx2PjE8L3Y+PC9jPlxuICAgICAgICAgICAgICAgICAgICAgICAgICogICA8YyByPVwiRDFcIiB0PVwic1wiPjx2PjI8L3Y+PC9jPlxuICAgICAgICAgICAgICAgICAgICAgICAgICogICA8YyByPVwiRTFcIiB0PVwic1wiPjx2PjM8L3Y+PC9jPlxuICAgICAgICAgICAgICAgICAgICAgICAgICogPC9yb3c+XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiA8cm93IHI9XCIyXCIgc3BhbnM9XCIxOjVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqICAgPGMgcj1cIkEyXCIgdD1cInNcIj48dj40PC92PjwvYz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqICAgPGMgcj1cIkIyXCIgdD1cInNcIj48dj43PC92PjwvYz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqICAgPGMgcj1cIkMyXCIgICAgICA+PHY+IyMjPC92PjwvYz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIDwvcm93PlxuICAgICAgICAgICAgICAgICAgICAgICAgICogPHJvdyByPVwiM1wiIHNwYW5zPVwiMTo1XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAgIDxjIHI9XCJBM1wiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAgIDxjIHI9XCJCM1wiIHQ9XCJzXCI+PHY+ODwvdj48L2M+XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAgIDxjIHI9XCJDM1wiICAgICAgPjx2PiMjIzwvdj48L2M+XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiA8L3Jvdz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZSBTSEFSRUQtU1RSSU5HU1xuICAgICAgICAgICAgICAgICAgICAgICAgICogMT1XZXN0LCAyPUN0cmwsIDM9RWFzdCwgND1NZWNoLCA1PUVsZWMsIDY9TXlkciwgNz1HZWFyLCA4PUJybmcsIFsuLi5dLCAxNT1TZWFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEI6IEFkZCBkYXRhIHJvdyhzKSBmb3IgZWFjaCBjYXRlZ29yeVxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBjb25zdCBMQUJFTFMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAgIFtcIkdlYXJcIiwgXCJCZXJnXCIsIFwiTW90clwiLCBcIlN3Y2hcIiwgXCJQbHVnXCIsIFwiQ29yZFwiLCBcIlB1bXBcIiwgXCJMZWFrXCIsIFwiU2VhbFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAqICAgW1wiTWVjaFwiLCAgICAgXCJcIiwgICAgIFwiXCIsIFwiRWxlY1wiLCAgICAgXCJcIiwgICAgIFwiXCIsIFwiSHlkclwiLCAgICAgXCJcIiwgICAgIFwiXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICogICBbXCIyMDEwXCIsICAgICBcIlwiLCAgICAgXCJcIiwgICAgIFwiXCIsICAgICBcIlwiLCAgICAgXCJcIiwgICAgIFwiXCIsICAgICBcIlwiLCAgICAgXCJcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBUT1RfU0VSID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBUT1RfQ0FUID0gZGF0YVswXS5sYWJlbHNbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgVE9UX0xWTCA9IGRhdGFbMF0ubGFiZWxzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGUgYWNyb3NzIGxhYmVscy9jYXRzIGFzIHRoZXNlIGFyZSB0aGUgPHJvdz4nc1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgVE9UX0NBVDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBOiBzdGFydCByb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJTaGVldFhtbCArPSBgPHJvdyByPVwiJHtpZHggKyAyfVwiIHNwYW5zPVwiMToke1RPVF9TRVIgKyBUT1RfTFZMfVwiPmA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV0lQOiBGSVhNRTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCOiBhZGQgYSBjb2wgZm9yIGVhY2ggbGFiZWwvY2F0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRvdExhYmVscyA9IFRPVF9TRVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV2TGFiZWxHcm91cHMgPSBkYXRhWzBdLmxhYmVscy5zbGljZSgpLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZMYWJlbEdyb3Vwcy5mb3JFYWNoKChsYWJlbHNHcm91cCwgaWR5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBjb25zdCBMQUJFTFNfUkVWRVJTRUQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgW1wiTWVjaFwiLCAgICAgXCJcIiwgICAgIFwiXCIsIFwiRWxlY1wiLCAgICAgXCJcIiwgICAgIFwiXCIsIFwiSHlkclwiLCAgICAgXCJcIiwgICAgIFwiXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgIFtcIkdlYXJcIiwgXCJCZXJnXCIsIFwiTW90clwiLCBcIlN3Y2hcIiwgXCJQbHVnXCIsIFwiQ29yZFwiLCBcIlB1bXBcIiwgXCJMZWFrXCIsIFwiU2VhbFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbExhYmVsID0gbGFiZWxzR3JvdXBbaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbExhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b3RHcnBMYmxzID0gaWR5ID09PSAwID8gMSA6IHJldkxhYmVsR3JvdXBzW2lkeSAtIDFdLmZpbHRlcihsYWJlbCA9PiBsYWJlbCAmJiBsYWJlbCAhPT0gJycpLmxlbmd0aDsgLy8gZ2V0IHVuaXF1ZSBsYWJlbCBzbyB3ZSBjYW4gYWRkIHRvIGdldCBwcm9wZXIgc2hhcmVkLXN0cmluZyAjXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RMYWJlbHMgKz0gdG90R3JwTGJscztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clNoZWV0WG1sICs9IGA8YyByPVwiJHtnZXRFeGNlbENvbE5hbWUoaWR4ICsgMSArIGlkeSl9JHtpZHggKyAyfVwiIHQ9XCJzXCI+PHY+JHt0b3RMYWJlbHN9PC92PjwvYz5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV0lQOiBGSVhNRTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDOiBhZGQgYSBjb2wgZm9yIGVhY2ggZGF0YSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGlkeSA9IDA7IGlkeSA8IFRPVF9TRVI7IGlkeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clNoZWV0WG1sICs9IGA8YyByPVwiJHtnZXRFeGNlbENvbE5hbWUoVE9UX0xWTCArIGlkeSArIDEpfSR7aWR4ICsgMn1cIj48dj4ke2RhdGFbaWR5XS52YWx1ZXNbaWR4XSB8fCAwfTwvdj48L2M+YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRDogRG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clNoZWV0WG1sICs9ICc8L3Jvdz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coc3RyU2hlZXRYbWwpIC8vIFdJUDogQ0hFQ0s6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgLS0tQ0hFQ0sgQUJPVkUtLS0tLS0tLS0tLS0tLS0tLS0tLS1gKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0clNoZWV0WG1sICs9ICc8L3NoZWV0RGF0YT4nO1xuICAgICAgICAgICAgICAgIC8qIEZJWE1FOiBzdXBwb3J0IG11bHRpLWxldmVsXG4gICAgICAgICAgICAgICAgaWYgKElTX01VTFRJX0NBVF9BWEVTKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0clNoZWV0WG1sICs9ICc8bWVyZ2VDZWxscyBjb3VudD1cIjNcIj4nXG4gICAgICAgICAgICAgICAgICAgIHN0clNoZWV0WG1sICs9ICcgPG1lcmdlQ2VsbCByZWY9XCJBMjpBNFwiLz4nXG4gICAgICAgICAgICAgICAgICAgIHN0clNoZWV0WG1sICs9ICcgPG1lcmdlQ2VsbCByZWY9XCJBMTA6QTEyXCIvPidcbiAgICAgICAgICAgICAgICAgICAgc3RyU2hlZXRYbWwgKz0gJyA8bWVyZ2VDZWxsIHJlZj1cIkE1OkE5XCIvPidcbiAgICAgICAgICAgICAgICAgICAgc3RyU2hlZXRYbWwgKz0gJzwvbWVyZ2VDZWxscz4nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc3RyU2hlZXRYbWwgKz0gJzxwYWdlTWFyZ2lucyBsZWZ0PVwiMC43XCIgcmlnaHQ9XCIwLjdcIiB0b3A9XCIwLjc1XCIgYm90dG9tPVwiMC43NVwiIGhlYWRlcj1cIjAuM1wiIGZvb3Rlcj1cIjAuM1wiLz4nO1xuICAgICAgICAgICAgICAgIC8vIExpbmsgdGhlIGB0YWJsZTEueG1sYCBmaWxlIHRvIGRlZmluZSBhbiBhY3R1YWwgVGFibGUgaW4gRXhjZWxcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBUaGlzIG9ubHkgd29ya3Mgd2l0aCBzY2F0dGVyIGNoYXJ0cyAtIGFsbCBvdGhlcnMgZ2l2ZSBhIFwiY2Fubm90IGZpbmQgbGlua2VkIGZpbGVcIiBlcnJvclxuICAgICAgICAgICAgICAgIC8vIC4uLi46IFNpbmNlIHdlIGRvbnQgbmVlZCB0aGUgdGFibGUgYW55d2F5IChjaGFydCBkYXRhIGNhbiBiZSBlZGl0ZWQvcmFuZ2Ugc2VsZWN0ZWQsIGV0Yy4pLCBqdXN0IGRvbnQgdXNlIHRoaXNcbiAgICAgICAgICAgICAgICAvLyAuLi4uOiBMZWF2aW5nIHRoaXMgc28gbm9ib2R5IGZvb2xpc2hseSBhdHRlbXB0cyB0byBhZGQgdGhpcyBpbiB0aGUgZnV0dXJlXG4gICAgICAgICAgICAgICAgLy8gc3RyU2hlZXRYbWwgKz0gJzx0YWJsZVBhcnRzIGNvdW50PVwiMVwiPjx0YWJsZVBhcnQgcjppZD1cInJJZDFcIi8+PC90YWJsZVBhcnRzPidcbiAgICAgICAgICAgICAgICBzdHJTaGVldFhtbCArPSAnPC93b3Jrc2hlZXQ+XFxuJztcbiAgICAgICAgICAgICAgICB6aXBFeGNlbC5maWxlKCd4bC93b3Jrc2hlZXRzL3NoZWV0MS54bWwnLCBzdHJTaGVldFhtbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDOiBBZGQgWExTWCB0byBQUFRYIGV4cG9ydFxuICAgICAgICAgICAgemlwRXhjZWxcbiAgICAgICAgICAgICAgICAuZ2VuZXJhdGVBc3luYyh7IHR5cGU6ICdiYXNlNjQnIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oY29udGVudCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gMTogQ3JlYXRlIHRoZSBlbWJlZGRlZCBFeGNlbCB3b3Jrc2hlZXQgd2l0aCBsYWJlbHMgYW5kIGRhdGFcbiAgICAgICAgICAgICAgICB6aXAuZmlsZShgcHB0L2VtYmVkZGluZ3MvTWljcm9zb2Z0X0V4Y2VsX1dvcmtzaGVldCR7Y2hhcnRPYmplY3QuZ2xvYmFsSWR9Lnhsc3hgLCBjb250ZW50LCB7IGJhc2U2NDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAvLyAyOiBDcmVhdGUgdGhlIGNoYXJ0LnhtbCBhbmQgcmVsIGZpbGVzXG4gICAgICAgICAgICAgICAgemlwLmZpbGUoJ3BwdC9jaGFydHMvX3JlbHMvJyArIGNoYXJ0T2JqZWN0LmZpbGVOYW1lICsgJy5yZWxzJywgJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCIgc3RhbmRhbG9uZT1cInllc1wiPz4nICtcbiAgICAgICAgICAgICAgICAgICAgJzxSZWxhdGlvbnNoaXBzIHhtbG5zPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3BhY2thZ2UvMjAwNi9yZWxhdGlvbnNoaXBzXCI+JyArXG4gICAgICAgICAgICAgICAgICAgIGA8UmVsYXRpb25zaGlwIElkPVwicklkMVwiIFR5cGU9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL3BhY2thZ2VcIiBUYXJnZXQ9XCIuLi9lbWJlZGRpbmdzL01pY3Jvc29mdF9FeGNlbF9Xb3Jrc2hlZXQke2NoYXJ0T2JqZWN0Lmdsb2JhbElkfS54bHN4XCIvPmAgK1xuICAgICAgICAgICAgICAgICAgICAnPC9SZWxhdGlvbnNoaXBzPicpO1xuICAgICAgICAgICAgICAgIHppcC5maWxlKGBwcHQvY2hhcnRzLyR7Y2hhcnRPYmplY3QuZmlsZU5hbWV9YCwgbWFrZVhtbENoYXJ0cyhjaGFydE9iamVjdCkpO1xuICAgICAgICAgICAgICAgIC8vIDM6IERvbmVcbiAgICAgICAgICAgICAgICByZXNvbHZlKCcnKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKHN0ckVyciA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHN0ckVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vKipcbiAqIE1haW4gZW50cnkgcG9pbnQgbWV0aG9kIGZvciBjcmVhdGUgY2hhcnRzXG4gKiBAc2VlOiBodHRwOi8vd3d3LmRhdHlwaWMuY29tL3NjL29veG1sL3MtZG1sLWNoYXJ0LnhzZC5odG1sXG4gKiBAcGFyYW0ge0lTbGlkZVJlbENoYXJ0fSByZWwgLSBjaGFydCBvYmplY3RcbiAqIEByZXR1cm4ge3N0cmluZ30gWE1MXG4gKi9cbmZ1bmN0aW9uIG1ha2VYbWxDaGFydHMocmVsKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGxldCBzdHJYbWwgPSAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIiBzdGFuZGFsb25lPVwieWVzXCI/Pic7XG4gICAgbGV0IHVzZXNTZWNvbmRhcnlWYWxBeGlzID0gZmFsc2U7XG4gICAgLy8gU1RFUCAxOiBDcmVhdGUgY2hhcnRcbiAgICB7XG4gICAgICAgIC8vIENIQVJUU1BBQ0U6IEJFR0lOIHZ2dlxuICAgICAgICBzdHJYbWwgKz1cbiAgICAgICAgICAgICc8YzpjaGFydFNwYWNlIHhtbG5zOmM9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvZHJhd2luZ21sLzIwMDYvY2hhcnRcIiB4bWxuczphPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL2RyYXdpbmdtbC8yMDA2L21haW5cIiB4bWxuczpyPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwc1wiPic7XG4gICAgICAgIHN0clhtbCArPSAnPGM6ZGF0ZTE5MDQgdmFsPVwiMFwiLz4nOyAvLyBwcHQgZGVmYXVsdHMgdG8gMTkwNCBkYXRlcywgZXhjZWwgdG8gMTkwMFxuICAgICAgICBzdHJYbWwgKz0gYDxjOnJvdW5kZWRDb3JuZXJzIHZhbD1cIiR7cmVsLm9wdHMuY2hhcnRBcmVhLnJvdW5kZWRDb3JuZXJzID8gJzEnIDogJzAnfVwiLz5gO1xuICAgICAgICBzdHJYbWwgKz0gJzxjOmNoYXJ0Pic7XG4gICAgICAgIC8vIE9QVElPTjogVGl0bGVcbiAgICAgICAgaWYgKHJlbC5vcHRzLnNob3dUaXRsZSkge1xuICAgICAgICAgICAgc3RyWG1sICs9IGdlblhtbFRpdGxlKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogcmVsLm9wdHMudGl0bGUgfHwgJ0NoYXJ0IFRpdGxlJyxcbiAgICAgICAgICAgICAgICBjb2xvcjogcmVsLm9wdHMudGl0bGVDb2xvcixcbiAgICAgICAgICAgICAgICBmb250RmFjZTogcmVsLm9wdHMudGl0bGVGb250RmFjZSxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogcmVsLm9wdHMudGl0bGVGb250U2l6ZSB8fCBERUZfRk9OVF9USVRMRV9TSVpFLFxuICAgICAgICAgICAgICAgIHRpdGxlQWxpZ246IHJlbC5vcHRzLnRpdGxlQWxpZ24sXG4gICAgICAgICAgICAgICAgdGl0bGVCb2xkOiByZWwub3B0cy50aXRsZUJvbGQsXG4gICAgICAgICAgICAgICAgdGl0bGVQb3M6IHJlbC5vcHRzLnRpdGxlUG9zLFxuICAgICAgICAgICAgICAgIHRpdGxlUm90YXRlOiByZWwub3B0cy50aXRsZVJvdGF0ZSxcbiAgICAgICAgICAgIH0sIHJlbC5vcHRzLngsIHJlbC5vcHRzLnkpO1xuICAgICAgICAgICAgc3RyWG1sICs9ICc8YzphdXRvVGl0bGVEZWxldGVkIHZhbD1cIjBcIi8+JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IEFkZCBhdXRvVGl0bGVEZWxldGVkIHRhZyBpbiBlbHNlIHRvIHByZXZlbnQgZGVmYXVsdCBjcmVhdGlvbiBvZiBjaGFydCB0aXRsZSBldmVuIHdoZW4gc2hvd1RpdGxlIGlzIHNldCB0byBmYWxzZVxuICAgICAgICAgICAgc3RyWG1sICs9ICc8YzphdXRvVGl0bGVEZWxldGVkIHZhbD1cIjFcIi8+JztcbiAgICAgICAgfVxuICAgICAgICAvKiogQWRkIDNEIHZpZXcgdGFnXG4gICAgICAgICAqIEBzZWU6IGh0dHBzOi8vYy1yZXgubmV0L3Byb2plY3RzL3NhbXBsZXMvb294bWwvZTEvUGFydDQvT09YTUxfUDRfRE9DWF9wZXJzcGVjdGl2ZV90b3BpY19JRDBFNkJVUUIuaHRtbFxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHJlbC5vcHRzLl90eXBlID09PSBDSEFSVF9UWVBFLkJBUjNEKSB7XG4gICAgICAgICAgICBzdHJYbWwgKz0gYDxjOnZpZXczRD48Yzpyb3RYIHZhbD1cIiR7cmVsLm9wdHMudjNEUm90WH1cIi8+PGM6cm90WSB2YWw9XCIke3JlbC5vcHRzLnYzRFJvdFl9XCIvPjxjOnJBbmdBeCB2YWw9XCIkeyFyZWwub3B0cy52M0RSQW5nQXggPyAwIDogMX1cIi8+PGM6cGVyc3BlY3RpdmUgdmFsPVwiJHtyZWwub3B0cy52M0RQZXJzcGVjdGl2ZX1cIi8+PC9jOnZpZXczRD5gO1xuICAgICAgICB9XG4gICAgICAgIHN0clhtbCArPSAnPGM6cGxvdEFyZWE+JztcbiAgICAgICAgLy8gSU1QT1JUQU5UOiBEb250IHNwZWNpZnkgbGF5b3V0IHRvIGVuYWJsZSBhdXRvLWZpdDogUFBUIGRvZXMgYSBncmVhdCBqb2IgbWF4aW1pemluZyBzcGFjZSB3aXRoIGFsbCA0IFRSQkwgbG9jYXRpb25zXG4gICAgICAgIGlmIChyZWwub3B0cy5sYXlvdXQpIHtcbiAgICAgICAgICAgIHN0clhtbCArPSAnPGM6bGF5b3V0Pic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyA8YzptYW51YWxMYXlvdXQ+JztcbiAgICAgICAgICAgIHN0clhtbCArPSAnICA8YzpsYXlvdXRUYXJnZXQgdmFsPVwiaW5uZXJcIiAvPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyAgPGM6eE1vZGUgdmFsPVwiZWRnZVwiIC8+JztcbiAgICAgICAgICAgIHN0clhtbCArPSAnICA8Yzp5TW9kZSB2YWw9XCJlZGdlXCIgLz4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgIDxjOnggdmFsPVwiJyArIChyZWwub3B0cy5sYXlvdXQueCB8fCAwKSArICdcIiAvPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyAgPGM6eSB2YWw9XCInICsgKHJlbC5vcHRzLmxheW91dC55IHx8IDApICsgJ1wiIC8+JztcbiAgICAgICAgICAgIHN0clhtbCArPSAnICA8Yzp3IHZhbD1cIicgKyAocmVsLm9wdHMubGF5b3V0LncgfHwgMSkgKyAnXCIgLz4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgIDxjOmggdmFsPVwiJyArIChyZWwub3B0cy5sYXlvdXQuaCB8fCAxKSArICdcIiAvPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyA8L2M6bWFudWFsTGF5b3V0Pic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJzwvYzpsYXlvdXQ+JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0clhtbCArPSAnPGM6bGF5b3V0Lz4nO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEE6IENyZWF0ZSBDaGFydCBYTUwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWwub3B0cy5fdHlwZSkpIHtcbiAgICAgICAgcmVsLm9wdHMuX3R5cGUuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgICAgICAgIC8vIFRPRE86IEZJWE1FOiB0aGVyZXMgYG9wdGlvbnNgIG9uIGNoYXJ0IHJlbHM/P1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVsLm9wdHMpLCB0eXBlLm9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gbGV0IG9wdGlvbnM6IElDaGFydE9wdHNMaWIgPSB7IHR5cGU6IHR5cGUudHlwZSwgfVxuICAgICAgICAgICAgY29uc3QgdmFsQXhpc0lkID0gb3B0aW9ucy5zZWNvbmRhcnlWYWxBeGlzID8gQVhJU19JRF9WQUxVRV9TRUNPTkRBUlkgOiBBWElTX0lEX1ZBTFVFX1BSSU1BUlk7XG4gICAgICAgICAgICBjb25zdCBjYXRBeGlzSWQgPSBvcHRpb25zLnNlY29uZGFyeUNhdEF4aXMgPyBBWElTX0lEX0NBVEVHT1JZX1NFQ09OREFSWSA6IEFYSVNfSURfQ0FURUdPUllfUFJJTUFSWTtcbiAgICAgICAgICAgIHVzZXNTZWNvbmRhcnlWYWxBeGlzID0gdXNlc1NlY29uZGFyeVZhbEF4aXMgfHwgb3B0aW9ucy5zZWNvbmRhcnlWYWxBeGlzO1xuICAgICAgICAgICAgc3RyWG1sICs9IG1ha2VDaGFydFR5cGUodHlwZS50eXBlLCB0eXBlLmRhdGEsIG9wdGlvbnMsIHZhbEF4aXNJZCwgY2F0QXhpc0lkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdHJYbWwgKz0gbWFrZUNoYXJ0VHlwZShyZWwub3B0cy5fdHlwZSwgcmVsLmRhdGEsIHJlbC5vcHRzLCBBWElTX0lEX1ZBTFVFX1BSSU1BUlksIEFYSVNfSURfQ0FURUdPUllfUFJJTUFSWSk7XG4gICAgfVxuICAgIC8vIEI6IEF4ZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBpZiAocmVsLm9wdHMuX3R5cGUgIT09IENIQVJUX1RZUEUuUElFICYmIHJlbC5vcHRzLl90eXBlICE9PSBDSEFSVF9UWVBFLkRPVUdITlVUKSB7XG4gICAgICAgIC8vIFBhcmFtIGNoZWNrXG4gICAgICAgIGlmIChyZWwub3B0cy52YWxBeGVzICYmIHJlbC5vcHRzLnZhbEF4ZXMubGVuZ3RoID4gMSAmJiAhdXNlc1NlY29uZGFyeVZhbEF4aXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2Vjb25kYXJ5IGF4aXMgbXVzdCBiZSB1c2VkIGJ5IG9uZSBvZiB0aGUgbXVsdGlwbGUgY2hhcnRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbC5vcHRzLmNhdEF4ZXMpIHtcbiAgICAgICAgICAgIGlmICghcmVsLm9wdHMudmFsQXhlcyB8fCByZWwub3B0cy52YWxBeGVzLmxlbmd0aCAhPT0gcmVsLm9wdHMuY2F0QXhlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIG11c3QgYmUgdGhlIHNhbWUgbnVtYmVyIG9mIHZhbHVlIGFuZCBjYXRlZ29yeSBheGVzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyWG1sICs9IG1ha2VDYXRBeGlzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVsLm9wdHMpLCByZWwub3B0cy5jYXRBeGVzWzBdKSwgQVhJU19JRF9DQVRFR09SWV9QUklNQVJZLCBBWElTX0lEX1ZBTFVFX1BSSU1BUlkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RyWG1sICs9IG1ha2VDYXRBeGlzKHJlbC5vcHRzLCBBWElTX0lEX0NBVEVHT1JZX1BSSU1BUlksIEFYSVNfSURfVkFMVUVfUFJJTUFSWSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbC5vcHRzLnZhbEF4ZXMpIHtcbiAgICAgICAgICAgIHN0clhtbCArPSBtYWtlVmFsQXhpcyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlbC5vcHRzKSwgcmVsLm9wdHMudmFsQXhlc1swXSksIEFYSVNfSURfVkFMVUVfUFJJTUFSWSk7XG4gICAgICAgICAgICBpZiAocmVsLm9wdHMudmFsQXhlc1sxXSkge1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSBtYWtlVmFsQXhpcyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlbC5vcHRzKSwgcmVsLm9wdHMudmFsQXhlc1sxXSksIEFYSVNfSURfVkFMVUVfU0VDT05EQVJZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0clhtbCArPSBtYWtlVmFsQXhpcyhyZWwub3B0cywgQVhJU19JRF9WQUxVRV9QUklNQVJZKTtcbiAgICAgICAgICAgIC8vIEFkZCBzZXJpZXMgYXhpcyBmb3IgM0QgYmFyXG4gICAgICAgICAgICBpZiAocmVsLm9wdHMuX3R5cGUgPT09IENIQVJUX1RZUEUuQkFSM0QpIHtcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gbWFrZVNlckF4aXMocmVsLm9wdHMsIEFYSVNfSURfU0VSSUVTX1BSSU1BUlksIEFYSVNfSURfVkFMVUVfUFJJTUFSWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tYm8gQ2hhcnRzOiBBZGQgc2Vjb25kYXJ5IGF4ZXMgYWZ0ZXIgYWxsIHZhbHNcbiAgICAgICAgaWYgKCgoX2EgPSByZWwub3B0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhdEF4ZXMpICYmICgoX2IgPSByZWwub3B0cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhdEF4ZXNbMV0pKSB7XG4gICAgICAgICAgICBzdHJYbWwgKz0gbWFrZUNhdEF4aXMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZWwub3B0cyksIHJlbC5vcHRzLmNhdEF4ZXNbMV0pLCBBWElTX0lEX0NBVEVHT1JZX1NFQ09OREFSWSwgQVhJU19JRF9WQUxVRV9TRUNPTkRBUlkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEM6IENoYXJ0IFByb3BlcnRpZXMgYW5kIHBsb3RBcmVhIE9wdGlvbnM6IEJvcmRlciwgRGF0YSBUYWJsZSwgRmlsbCwgTGVnZW5kXG4gICAge1xuICAgICAgICAvLyBOT1RFOiBEYXRhVGFibGUgZ29lcyBiZXR3ZWVuICc8L2M6dmFsQXg+JyBhbmQgJzxjOnNwUHI+J1xuICAgICAgICBpZiAocmVsLm9wdHMuc2hvd0RhdGFUYWJsZSkge1xuICAgICAgICAgICAgc3RyWG1sICs9ICc8YzpkVGFibGU+JztcbiAgICAgICAgICAgIHN0clhtbCArPSBgICA8YzpzaG93SG9yekJvcmRlciB2YWw9XCIkeyFyZWwub3B0cy5zaG93RGF0YVRhYmxlSG9yekJvcmRlciA/IDAgOiAxfVwiLz5gO1xuICAgICAgICAgICAgc3RyWG1sICs9IGAgIDxjOnNob3dWZXJ0Qm9yZGVyIHZhbD1cIiR7IXJlbC5vcHRzLnNob3dEYXRhVGFibGVWZXJ0Qm9yZGVyID8gMCA6IDF9XCIvPmA7XG4gICAgICAgICAgICBzdHJYbWwgKz0gYCAgPGM6c2hvd091dGxpbmUgICAgdmFsPVwiJHshcmVsLm9wdHMuc2hvd0RhdGFUYWJsZU91dGxpbmUgPyAwIDogMX1cIi8+YDtcbiAgICAgICAgICAgIHN0clhtbCArPSBgICA8YzpzaG93S2V5cyAgICAgICB2YWw9XCIkeyFyZWwub3B0cy5zaG93RGF0YVRhYmxlS2V5cyA/IDAgOiAxfVwiLz5gO1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgIDxjOnNwUHI+JztcbiAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDxhOm5vRmlsbC8+JztcbiAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDxhOmxuIHc9XCI5NTI1XCIgY2FwPVwiZmxhdFwiIGNtcGQ9XCJzbmdcIiBhbGduPVwiY3RyXCI+PGE6c29saWRGaWxsPjxhOnNjaGVtZUNsciB2YWw9XCJ0eDFcIj48YTpsdW1Nb2QgdmFsPVwiMTUwMDBcIi8+PGE6bHVtT2ZmIHZhbD1cIjg1MDAwXCIvPjwvYTpzY2hlbWVDbHI+PC9hOnNvbGlkRmlsbD48YTpyb3VuZC8+PC9hOmxuPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YTplZmZlY3RMc3QvPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyAgPC9jOnNwUHI+JztcbiAgICAgICAgICAgIHN0clhtbCArPSAnICA8Yzp0eFByPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyAgIDxhOmJvZHlQciByb3Q9XCIwXCIgc3BjRmlyc3RMYXN0UGFyYT1cIjFcIiB2ZXJ0T3ZlcmZsb3c9XCJlbGxpcHNpc1wiIHZlcnQ9XCJob3J6XCIgd3JhcD1cInNxdWFyZVwiIGFuY2hvcj1cImN0clwiIGFuY2hvckN0cj1cIjFcIi8+JztcbiAgICAgICAgICAgIHN0clhtbCArPSAnICAgPGE6bHN0U3R5bGUvPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyAgIDxhOnA+JztcbiAgICAgICAgICAgIHN0clhtbCArPSAnICAgICA8YTpwUHIgcnRsPVwiMFwiPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gYCAgICAgICA8YTpkZWZSUHIgc3o9XCIke01hdGgucm91bmQoKHJlbC5vcHRzLmRhdGFUYWJsZUZvbnRTaXplIHx8IERFRl9GT05UX1NJWkUpICogMTAwKX1cIiBiPVwiMFwiIGk9XCIwXCIgdT1cIm5vbmVcIiBzdHJpa2U9XCJub1N0cmlrZVwiIGtlcm49XCIxMjAwXCIgYmFzZWxpbmU9XCIwXCI+YDtcbiAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICAgPGE6c29saWRGaWxsPjxhOnNjaGVtZUNsciB2YWw9XCJ0eDFcIj48YTpsdW1Nb2QgdmFsPVwiNjUwMDBcIi8+PGE6bHVtT2ZmIHZhbD1cIjM1MDAwXCIvPjwvYTpzY2hlbWVDbHI+PC9hOnNvbGlkRmlsbD4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgICA8YTpsYXRpbiB0eXBlZmFjZT1cIittbi1sdFwiLz4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgICA8YTplYSB0eXBlZmFjZT1cIittbi1lYVwiLz4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgICA8YTpjcyB0eXBlZmFjZT1cIittbi1jc1wiLz4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgPC9hOmRlZlJQcj4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgIDwvYTpwUHI+JztcbiAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDxhOmVuZFBhcmFSUHIgbGFuZz1cImVuLVVTXCIvPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyAgIDwvYTpwPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyA8L2M6dHhQcj4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICc8L2M6ZFRhYmxlPic7XG4gICAgICAgIH1cbiAgICAgICAgc3RyWG1sICs9ICcgIDxjOnNwUHI+JztcbiAgICAgICAgLy8gT1BUSU9OOiBGaWxsXG4gICAgICAgIHN0clhtbCArPSAoKF9jID0gcmVsLm9wdHMucGxvdEFyZWEuZmlsbCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNvbG9yKSA/IGdlblhtbENvbG9yU2VsZWN0aW9uKHJlbC5vcHRzLnBsb3RBcmVhLmZpbGwpIDogJzxhOm5vRmlsbC8+JztcbiAgICAgICAgLy8gT1BUSU9OOiBCb3JkZXJcbiAgICAgICAgc3RyWG1sICs9IHJlbC5vcHRzLnBsb3RBcmVhLmJvcmRlclxuICAgICAgICAgICAgPyBgPGE6bG4gdz1cIiR7dmFsVG9QdHMocmVsLm9wdHMucGxvdEFyZWEuYm9yZGVyLnB0KX1cIiBjYXA9XCJmbGF0XCI+JHtnZW5YbWxDb2xvclNlbGVjdGlvbihyZWwub3B0cy5wbG90QXJlYS5ib3JkZXIuY29sb3IpfTwvYTpsbj5gXG4gICAgICAgICAgICA6ICc8YTpsbj48YTpub0ZpbGwvPjwvYTpsbj4nO1xuICAgICAgICAvLyBDbG9zZSBzaGFwZVByb3AvcGxvdEFyZWEgYmVmb3JlIExlZ2VuZFxuICAgICAgICBzdHJYbWwgKz0gJyAgICA8YTplZmZlY3RMc3QvPic7XG4gICAgICAgIHN0clhtbCArPSAnICA8L2M6c3BQcj4nO1xuICAgICAgICBzdHJYbWwgKz0gJzwvYzpwbG90QXJlYT4nO1xuICAgICAgICAvLyBPUFRJT046IExlZ2VuZFxuICAgICAgICAvLyBJTVBPUlRBTlQ6IERvbnQgc3BlY2lmeSBsYXlvdXQgdG8gZW5hYmxlIGF1dG8tZml0OiBQUFQgZG9lcyBhIGdyZWF0IGpvYiBtYXhpbWl6aW5nIHNwYWNlIHdpdGggYWxsIDQgVFJCTCBsb2NhdGlvbnNcbiAgICAgICAgaWYgKHJlbC5vcHRzLnNob3dMZWdlbmQpIHtcbiAgICAgICAgICAgIHN0clhtbCArPSAnPGM6bGVnZW5kPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJzxjOmxlZ2VuZFBvcyB2YWw9XCInICsgcmVsLm9wdHMubGVnZW5kUG9zICsgJ1wiLz4nO1xuICAgICAgICAgICAgLy8gc3RyWG1sICs9ICc8YzpsYXlvdXQvPidcbiAgICAgICAgICAgIHN0clhtbCArPSAnPGM6b3ZlcmxheSB2YWw9XCIwXCIvPic7XG4gICAgICAgICAgICBpZiAocmVsLm9wdHMubGVnZW5kRm9udEZhY2UgfHwgcmVsLm9wdHMubGVnZW5kRm9udFNpemUgfHwgcmVsLm9wdHMubGVnZW5kQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxjOnR4UHI+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgPGE6Ym9keVByLz4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICA8YTpsc3RTdHlsZS8+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgPGE6cD4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDxhOnBQcj4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSByZWwub3B0cy5sZWdlbmRGb250U2l6ZSA/IGA8YTpkZWZSUHIgc3o9XCIke01hdGgucm91bmQoTnVtYmVyKHJlbC5vcHRzLmxlZ2VuZEZvbnRTaXplKSAqIDEwMCl9XCI+YCA6ICc8YTpkZWZSUHI+JztcbiAgICAgICAgICAgICAgICBpZiAocmVsLm9wdHMubGVnZW5kQ29sb3IpXG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBnZW5YbWxDb2xvclNlbGVjdGlvbihyZWwub3B0cy5sZWdlbmRDb2xvcik7XG4gICAgICAgICAgICAgICAgaWYgKHJlbC5vcHRzLmxlZ2VuZEZvbnRGYWNlKVxuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxhOmxhdGluIHR5cGVmYWNlPVwiJyArIHJlbC5vcHRzLmxlZ2VuZEZvbnRGYWNlICsgJ1wiLz4nO1xuICAgICAgICAgICAgICAgIGlmIChyZWwub3B0cy5sZWdlbmRGb250RmFjZSlcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8YTpjcyAgICB0eXBlZmFjZT1cIicgKyByZWwub3B0cy5sZWdlbmRGb250RmFjZSArICdcIi8+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgIDwvYTpkZWZSUHI+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8L2E6cFByPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPGE6ZW5kUGFyYVJQciBsYW5nPVwiZW4tVVNcIi8+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgPC9hOnA+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzwvYzp0eFByPic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJYbWwgKz0gJzwvYzpsZWdlbmQ+JztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdHJYbWwgKz0gJyAgPGM6cGxvdFZpc09ubHkgdmFsPVwiMVwiLz4nO1xuICAgIHN0clhtbCArPSAnICA8YzpkaXNwQmxhbmtzQXMgdmFsPVwiJyArIHJlbC5vcHRzLmRpc3BsYXlCbGFua3NBcyArICdcIi8+JztcbiAgICBpZiAocmVsLm9wdHMuX3R5cGUgPT09IENIQVJUX1RZUEUuU0NBVFRFUilcbiAgICAgICAgc3RyWG1sICs9ICc8YzpzaG93RExibHNPdmVyTWF4IHZhbD1cIjFcIi8+JztcbiAgICBzdHJYbWwgKz0gJzwvYzpjaGFydD4nO1xuICAgIC8vIEQ6IENIQVJUU1BBQ0UgU0hBUEUgUFJPUFNcbiAgICBzdHJYbWwgKz0gJzxjOnNwUHI+JztcbiAgICBzdHJYbWwgKz0gKChfZCA9IHJlbC5vcHRzLmNoYXJ0QXJlYS5maWxsKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY29sb3IpID8gZ2VuWG1sQ29sb3JTZWxlY3Rpb24ocmVsLm9wdHMuY2hhcnRBcmVhLmZpbGwpIDogJzxhOm5vRmlsbC8+JztcbiAgICBzdHJYbWwgKz0gcmVsLm9wdHMuY2hhcnRBcmVhLmJvcmRlclxuICAgICAgICA/IGA8YTpsbiB3PVwiJHt2YWxUb1B0cyhyZWwub3B0cy5jaGFydEFyZWEuYm9yZGVyLnB0KX1cIiBjYXA9XCJmbGF0XCI+JHtnZW5YbWxDb2xvclNlbGVjdGlvbihyZWwub3B0cy5jaGFydEFyZWEuYm9yZGVyLmNvbG9yKX08L2E6bG4+YFxuICAgICAgICA6ICc8YTpsbj48YTpub0ZpbGwvPjwvYTpsbj4nO1xuICAgIHN0clhtbCArPSAnICA8YTplZmZlY3RMc3QvPic7XG4gICAgc3RyWG1sICs9ICc8L2M6c3BQcj4nO1xuICAgIC8vIEU6IERBVEEgKEFkZCByZWxJRClcbiAgICBzdHJYbWwgKz0gJzxjOmV4dGVybmFsRGF0YSByOmlkPVwicklkMVwiPjxjOmF1dG9VcGRhdGUgdmFsPVwiMFwiLz48L2M6ZXh0ZXJuYWxEYXRhPic7XG4gICAgLy8gTEFTVDogY2hhcnRTcGFjZSBlbmRcbiAgICBzdHJYbWwgKz0gJzwvYzpjaGFydFNwYWNlPic7XG4gICAgcmV0dXJuIHN0clhtbDtcbn1cbi8qKlxuICogQ3JlYXRlIFhNTCBzdHJpbmcgZm9yIGFueSBnaXZlbiBjaGFydCB0eXBlXG4gKiBAcGFyYW0ge0NIQVJUX05BTUV9IGNoYXJ0VHlwZSBjaGFydCB0eXBlIG5hbWVcbiAqIEBwYXJhbSB7SU9wdHNDaGFydERhdGFbXX0gZGF0YSBjaGFydCBkYXRhXG4gKiBAcGFyYW0ge0lDaGFydE9wdHNMaWJ9IG9wdHMgY2hhcnQgb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IHZhbEF4aXNJZCBjaGFydCB2YWwgYXhpcyBpZFxuICogQHBhcmFtIHtzdHJpbmd9IGNhdEF4aXNJZCBjaGFydCBjYXQgYXhpcyBpZFxuICogQHBhcmFtIHtib29sZWFufSBpc011bHRpVHlwZUNoYXJ0IGlzIHRoaXMgYSBtdXRsaS10eXBlIGNoYXJ0P1xuICogQGV4YW1wbGUgJ2J1YmJsZScgcmV0dXJucyA8YzpidWJibGVDaGFydD48L2M+XG4gKiBAZXhhbXBsZSAnPGM6bGluZUNoYXJ0PidcbiAqIEByZXR1cm4ge3N0cmluZ30gWE1MIGNoYXJ0XG4gKi9cbmZ1bmN0aW9uIG1ha2VDaGFydFR5cGUoY2hhcnRUeXBlLCBkYXRhLCBvcHRzLCB2YWxBeGlzSWQsIGNhdEF4aXNJZCwgaXNNdWx0aVR5cGVDaGFydCkge1xuICAgIC8vIE5PVEU6IFwiQ2hhcnQgUmFuZ2VcIiAoYXMgc2hvd24gaW4gXCJzZWxlY3QgQ2hhcnQgQXJlYSBkaWFsb2dcIikgaXMgY2FsY3VsYXRlZC5cbiAgICAvLyAuLi4uOiBFbnN1cmUgZWFjaCBYL1kgQXhpcy9Db2wgaGFzIHNhbWUgcm93IGhlaWdodCAoZXNwLiBhcHBsaWNhYmxlIHRvIFhZIFNjYXR0ZXIgd2hlcmUgWCBjYW4gb2Z0ZW4gYmUgbGFyZ2VyIHRoYW4gWSdzKVxuICAgIGxldCBjb2xvckluZGV4ID0gLTE7IC8vIE1haW50YWluIHRoZSBjb2xvciBpbmRleCBieSByZWdpb25cbiAgICBsZXQgaWR4Q29sTHRyID0gMTtcbiAgICBsZXQgb3B0c0NoYXJ0RGF0YSA9IG51bGw7XG4gICAgbGV0IHN0clhtbCA9ICcnO1xuICAgIHN3aXRjaCAoY2hhcnRUeXBlKSB7XG4gICAgICAgIGNhc2UgQ0hBUlRfVFlQRS5BUkVBOlxuICAgICAgICBjYXNlIENIQVJUX1RZUEUuQkFSOlxuICAgICAgICBjYXNlIENIQVJUX1RZUEUuQkFSM0Q6XG4gICAgICAgIGNhc2UgQ0hBUlRfVFlQRS5MSU5FOlxuICAgICAgICBjYXNlIENIQVJUX1RZUEUuUkFEQVI6XG4gICAgICAgICAgICAvLyAxOiBTdGFydCBDaGFydFxuICAgICAgICAgICAgc3RyWG1sICs9IGA8Yzoke2NoYXJ0VHlwZX1DaGFydD5gO1xuICAgICAgICAgICAgaWYgKGNoYXJ0VHlwZSA9PT0gQ0hBUlRfVFlQRS5BUkVBICYmIG9wdHMuYmFyR3JvdXBpbmcgPT09ICdzdGFja2VkJykge1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPGM6Z3JvdXBpbmcgdmFsPVwiJyArIG9wdHMuYmFyR3JvdXBpbmcgKyAnXCIvPic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhcnRUeXBlID09PSBDSEFSVF9UWVBFLkJBUiB8fCBjaGFydFR5cGUgPT09IENIQVJUX1RZUEUuQkFSM0QpIHtcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxjOmJhckRpciB2YWw9XCInICsgb3B0cy5iYXJEaXIgKyAnXCIvPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8Yzpncm91cGluZyB2YWw9XCInICsgKG9wdHMuYmFyR3JvdXBpbmcgfHwgJ2NsdXN0ZXJlZCcpICsgJ1wiLz4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYXJ0VHlwZSA9PT0gQ0hBUlRfVFlQRS5SQURBUikge1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPGM6cmFkYXJTdHlsZSB2YWw9XCInICsgb3B0cy5yYWRhclN0eWxlICsgJ1wiLz4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyWG1sICs9ICc8Yzp2YXJ5Q29sb3JzIHZhbD1cIjBcIi8+JztcbiAgICAgICAgICAgIC8vIDI6IFwiU2VyaWVzXCIgYmxvY2sgZm9yIGV2ZXJ5IGRhdGEgcm93XG4gICAgICAgICAgICAvKiBFWDE6XG4gICAgICAgICAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgbmFtZTogJ1JlZ2lvbiAxJyxcbiAgICAgICAgICAgICAgICAgICBsYWJlbHM6IFtbJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknXV0sXG4gICAgICAgICAgICAgICAgICAgdmFsdWVzOiBbMTcsIDI2LCA1MywgOTZdXG4gICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICBuYW1lOiAnUmVnaW9uIDInLFxuICAgICAgICAgICAgICAgICAgIGxhYmVsczogW1snQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseSddXSxcbiAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IFs1NSwgNDMsIDcwLCA1OF1cbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKiBFWDI6XG4gICAgICAgICAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgbmFtZTogJ1JlZ2lvbiAxJyxcbiAgICAgICAgICAgICAgICAgICBsYWJlbHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgWydBcHJpbCcsICdNYXknLCAnSnVuZScsICdBcHJpbCcsICdNYXknLCAnSnVuZSddLFxuICAgICAgICAgICAgICAgICAgICAgICBbJzIwMjAnLCAgICAgJycsICAgICAnJywgJzIwMjEnLCAgICAgJycsICAgICAnJ11cbiAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgIHZhbHVlczogWzE3LCAyNiwgNTMsIDk2LCA0MCwgMzNdXG4gICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICBuYW1lOiAnUmVnaW9uIDInLFxuICAgICAgICAgICAgICAgICAgIGxhYmVsczogW1xuICAgICAgICAgICAgICAgICAgICAgICBbJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0FwcmlsJywgJ01heScsICdKdW5lJ10sXG4gICAgICAgICAgICAgICAgICAgICAgIFsnMjAyMCcsICAgICAnJywgICAgICcnLCAnMjAyMScsICAgICAnJywgICAgICcnXVxuICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgdmFsdWVzOiBbNTUsIDQzLCA3MCwgNTgsIDc4LCA2M11cbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZGF0YS5mb3JFYWNoKG9iaiA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGNvbG9ySW5kZXgrKztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxjOnNlcj4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSBgICA8YzppZHggdmFsPVwiJHtvYmouX2RhdGFJbmRleH1cIi8+PGM6b3JkZXIgdmFsPVwiJHtvYmouX2RhdGFJbmRleH1cIi8+YDtcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgPGM6dHg+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpzdHJSZWY+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgIDxjOmY+U2hlZXQxISQnICsgZ2V0RXhjZWxDb2xOYW1lKG9iai5fZGF0YUluZGV4ICsgb2JqLmxhYmVscy5sZW5ndGggKyAxKSArICckMTwvYzpmPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICA8YzpzdHJDYWNoZT48YzpwdENvdW50IHZhbD1cIjFcIi8+PGM6cHQgaWR4PVwiMFwiPjxjOnY+JyArIGVuY29kZVhtbEVudGl0aWVzKG9iai5uYW1lKSArICc8L2M6dj48L2M6cHQ+PC9jOnN0ckNhY2hlPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPC9jOnN0clJlZj4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICA8L2M6dHg+JztcbiAgICAgICAgICAgICAgICAvLyBGaWxsIGFuZCBCb3JkZXJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBDVVJSRU5UOiBQdWxsIzcyN1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGxldCBzZXJpZXNDb2xvciA9IG9iai5jb2xvciA/IG9iai5jb2xvciA6IG9wdHMuY2hhcnRDb2xvcnMgPyBvcHRzLmNoYXJ0Q29sb3JzW2NvbG9ySW5kZXggJSBvcHRzLmNoYXJ0Q29sb3JzLmxlbmd0aF0gOiBudWxsXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VyaWVzQ29sb3IgPSBvcHRzLmNoYXJ0Q29sb3JzID8gb3B0cy5jaGFydENvbG9yc1tjb2xvckluZGV4ICUgb3B0cy5jaGFydENvbG9ycy5sZW5ndGhdIDogbnVsbDtcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgPGM6c3BQcj4nO1xuICAgICAgICAgICAgICAgIGlmIChzZXJpZXNDb2xvciA9PT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxhOm5vRmlsbC8+JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0cy5jaGFydENvbG9yc09wYWNpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8YTpzb2xpZEZpbGw+JyArIGNyZWF0ZUNvbG9yRWxlbWVudChzZXJpZXNDb2xvciwgYDxhOmFscGhhIHZhbD1cIiR7TWF0aC5yb3VuZChvcHRzLmNoYXJ0Q29sb3JzT3BhY2l0eSAqIDEwMDApfVwiLz5gKSArICc8L2E6c29saWRGaWxsPic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxhOnNvbGlkRmlsbD4nICsgY3JlYXRlQ29sb3JFbGVtZW50KHNlcmllc0NvbG9yKSArICc8L2E6c29saWRGaWxsPic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGFydFR5cGUgPT09IENIQVJUX1RZUEUuTElORSB8fCBjaGFydFR5cGUgPT09IENIQVJUX1RZUEUuUkFEQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMubGluZVNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPGE6bG4+PGE6bm9GaWxsLz48L2E6bG4+JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBgPGE6bG4gdz1cIiR7dmFsVG9QdHMob3B0cy5saW5lU2l6ZSl9XCIgY2FwPVwiJHtjcmVhdGVMaW5lQ2FwKG9wdHMubGluZUNhcCl9XCI+PGE6c29saWRGaWxsPiR7Y3JlYXRlQ29sb3JFbGVtZW50KHNlcmllc0NvbG9yKX08L2E6c29saWRGaWxsPmA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxhOnByc3REYXNoIHZhbD1cIicgKyAob3B0cy5saW5lRGFzaCB8fCAnc29saWQnKSArICdcIi8+PGE6cm91bmQvPjwvYTpsbj4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdHMuZGF0YUJvcmRlcikge1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYDxhOmxuIHc9XCIke3ZhbFRvUHRzKG9wdHMuZGF0YUJvcmRlci5wdCl9XCIgY2FwPVwiJHtjcmVhdGVMaW5lQ2FwKG9wdHMubGluZUNhcCl9XCI+PGE6c29saWRGaWxsPiR7Y3JlYXRlQ29sb3JFbGVtZW50KG9wdHMuZGF0YUJvcmRlci5jb2xvcil9PC9hOnNvbGlkRmlsbD48YTpwcnN0RGFzaCB2YWw9XCJzb2xpZFwiLz48YTpyb3VuZC8+PC9hOmxuPmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0clhtbCArPSBjcmVhdGVTaGFkb3dFbGVtZW50KG9wdHMuc2hhZG93LCBERUZfU0hBUEVfU0hBRE9XKTtcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgPC9jOnNwUHI+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgPGM6aW52ZXJ0SWZOZWdhdGl2ZSB2YWw9XCIwXCIvPic7XG4gICAgICAgICAgICAgICAgLy8gRGF0YSBMYWJlbHMgcGVyIHNlcmllc1xuICAgICAgICAgICAgICAgIC8vIE5PVEU6IFsyMDE5MDExN10gQWRkaW5nIHRoZXNlIHRvIFJBREFSIGNoYXJ0IGNhdXNlcyB1bnJlY292ZXJhYmxlIGNvcnJ1cHRpb24hXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0VHlwZSAhPT0gQ0hBUlRfVFlQRS5SQURBUikge1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxjOmRMYmxzPic7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBgPGM6bnVtRm10IGZvcm1hdENvZGU9XCIke2VuY29kZVhtbEVudGl0aWVzKG9wdHMuZGF0YUxhYmVsRm9ybWF0Q29kZSkgfHwgJ0dlbmVyYWwnfVwiIHNvdXJjZUxpbmtlZD1cIjBcIi8+YDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuZGF0YUxhYmVsQmtncmRDb2xvcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYDxjOnNwUHI+PGE6c29saWRGaWxsPiR7Y3JlYXRlQ29sb3JFbGVtZW50KHNlcmllc0NvbG9yKX08L2E6c29saWRGaWxsPjwvYzpzcFByPmA7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPGM6dHhQcj48YTpib2R5UHIvPjxhOmxzdFN0eWxlLz48YTpwPjxhOnBQcj4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYDxhOmRlZlJQciBiPVwiJHtvcHRzLmRhdGFMYWJlbEZvbnRCb2xkID8gMSA6IDB9XCIgaT1cIiR7b3B0cy5kYXRhTGFiZWxGb250SXRhbGljID8gMSA6IDB9XCIgc3RyaWtlPVwibm9TdHJpa2VcIiBzej1cIiR7TWF0aC5yb3VuZCgob3B0cy5kYXRhTGFiZWxGb250U2l6ZSB8fCBERUZfRk9OVF9TSVpFKSAqIDEwMCl9XCIgdT1cIm5vbmVcIj5gO1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYDxhOnNvbGlkRmlsbD4ke2NyZWF0ZUNvbG9yRWxlbWVudChvcHRzLmRhdGFMYWJlbENvbG9yIHx8IERFRl9GT05UX0NPTE9SKX08L2E6c29saWRGaWxsPmA7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBgPGE6bGF0aW4gdHlwZWZhY2U9XCIke29wdHMuZGF0YUxhYmVsRm9udEZhY2UgfHwgJ0FyaWFsJ31cIi8+YDtcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8L2E6ZGVmUlByPjwvYTpwUHI+PC9hOnA+PC9jOnR4UHI+JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuZGF0YUxhYmVsUG9zaXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYDxjOmRMYmxQb3MgdmFsPVwiJHtvcHRzLmRhdGFMYWJlbFBvc2l0aW9ufVwiLz5gO1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxjOnNob3dMZWdlbmRLZXkgdmFsPVwiMFwiLz4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYDxjOnNob3dWYWwgdmFsPVwiJHtvcHRzLnNob3dWYWx1ZSA/ICcxJyA6ICcwJ31cIi8+YDtcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9IGA8YzpzaG93Q2F0TmFtZSB2YWw9XCIwXCIvPjxjOnNob3dTZXJOYW1lIHZhbD1cIiR7b3B0cy5zaG93U2VyTmFtZSA/ICcxJyA6ICcwJ31cIi8+PGM6c2hvd1BlcmNlbnQgdmFsPVwiMFwiLz48YzpzaG93QnViYmxlU2l6ZSB2YWw9XCIwXCIvPmA7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBgPGM6c2hvd0xlYWRlckxpbmVzIHZhbD1cIiR7b3B0cy5zaG93TGVhZGVyTGluZXMgPyAnMScgOiAnMCd9XCIvPmA7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPC9jOmRMYmxzPic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICdjOm1hcmtlcicgdGFnOiBgbGluZURhdGFTeW1ib2xgXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0VHlwZSA9PT0gQ0hBUlRfVFlQRS5MSU5FIHx8IGNoYXJ0VHlwZSA9PT0gQ0hBUlRfVFlQRS5SQURBUikge1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxjOm1hcmtlcj4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgPGM6c3ltYm9sIHZhbD1cIicgKyBvcHRzLmxpbmVEYXRhU3ltYm9sICsgJ1wiLz4nO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5saW5lRGF0YVN5bWJvbFNpemUpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYDxjOnNpemUgdmFsPVwiJHtvcHRzLmxpbmVEYXRhU3ltYm9sU2l6ZX1cIi8+YDsgLy8gRGVmYXVsdHMgdG8gXCJhdXRvXCIgb3RoZXJ3aXNlIChidXQgdGhpcyBpcyB1c3VhbGx5IHRvbyBzbWFsbCwgc28gdGhlcmUgaXMgYSBkZWZhdWx0KVxuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgPGM6c3BQcj4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYCAgICA8YTpzb2xpZEZpbGw+JHtjcmVhdGVDb2xvckVsZW1lbnQob3B0cy5jaGFydENvbG9yc1tvYmouX2RhdGFJbmRleCArIDEgPiBvcHRzLmNoYXJ0Q29sb3JzLmxlbmd0aCA/IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG9wdHMuY2hhcnRDb2xvcnMubGVuZ3RoKSA6IG9iai5fZGF0YUluZGV4XSl9PC9hOnNvbGlkRmlsbD5gO1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYCAgICA8YTpsbiB3PVwiJHtvcHRzLmxpbmVEYXRhU3ltYm9sTGluZVNpemV9XCIgY2FwPVwiZmxhdFwiPjxhOnNvbGlkRmlsbD4ke2NyZWF0ZUNvbG9yRWxlbWVudChvcHRzLmxpbmVEYXRhU3ltYm9sTGluZUNvbG9yIHx8IHNlcmllc0NvbG9yKX08L2E6c29saWRGaWxsPjxhOnByc3REYXNoIHZhbD1cInNvbGlkXCIvPjxhOnJvdW5kLz48L2E6bG4+YDtcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPGE6ZWZmZWN0THN0Lz4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgPC9jOnNwUHI+JztcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8L2M6bWFya2VyPic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFsbG93IHVzZXJzIHdpdGggYSBzaW5nbGUgZGF0YSBzZXQgdG8gcGFzcyB0aGVpciBvd24gYXJyYXkgb2YgY29sb3JzIChjaGVjayBmb3IgdGhpcyB1c2luZyAhPSBvdXJzKVxuICAgICAgICAgICAgICAgIC8vIENvbG9yIGNoYXJ0IGJhcnMgdmFyaW91cyBjb2xvcnMgd2hlbiA+MSBjb2xvclxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IGA8YzpkUHQ+YCBjcmVhdGVkIHdpdGggdmFyaW91cyBjb2xvcnMgd2lsbCBjaGFuZ2UgUFBUIGxlZ2VuZCBieSBkZXNpZ24gc28gZWFjaCBkYXRhUHQvY29sb3IgaXMgYW4gbGVnZW5kIGl0ZW0hXG4gICAgICAgICAgICAgICAgaWYgKChjaGFydFR5cGUgPT09IENIQVJUX1RZUEUuQkFSIHx8IGNoYXJ0VHlwZSA9PT0gQ0hBUlRfVFlQRS5CQVIzRCkgJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgKChvcHRzLmNoYXJ0Q29sb3JzICYmIG9wdHMuY2hhcnRDb2xvcnMgIT09IEJBUkNIQVJUX0NPTE9SUyAmJiBvcHRzLmNoYXJ0Q29sb3JzLmxlbmd0aCA+IDEpIHx8ICgoX2EgPSBvcHRzLmludmVydGVkQ29sb3JzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VyaWVzIERhdGEgUG9pbnQgY29sb3JzXG4gICAgICAgICAgICAgICAgICAgIG9iai52YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnJDb2xvcnMgPSB2YWx1ZSA8IDAgPyBvcHRzLmludmVydGVkQ29sb3JzIHx8IG9wdHMuY2hhcnRDb2xvcnMgfHwgQkFSQ0hBUlRfQ09MT1JTIDogb3B0cy5jaGFydENvbG9ycyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICA8YzpkUHQ+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBgICAgIDxjOmlkeCB2YWw9XCIke2luZGV4fVwiLz5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICA8YzppbnZlcnRJZk5lZ2F0aXZlIHZhbD1cIjBcIi8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDxjOmJ1YmJsZTNEIHZhbD1cIjBcIi8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDxjOnNwUHI+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmxpbmVTaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8YTpsbj48YTpub0ZpbGwvPjwvYTpsbj4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhcnRUeXBlID09PSBDSEFSVF9UWVBFLkJBUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPGE6c29saWRGaWxsPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgIDxhOnNyZ2JDbHIgdmFsPVwiJyArIGFyckNvbG9yc1tpbmRleCAlIGFyckNvbG9ycy5sZW5ndGhdICsgJ1wiLz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPC9hOnNvbGlkRmlsbD4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8YTpsbj4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICA8YTpzb2xpZEZpbGw+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgIDxhOnNyZ2JDbHIgdmFsPVwiJyArIGFyckNvbG9yc1tpbmRleCAlIGFyckNvbG9ycy5sZW5ndGhdICsgJ1wiLz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICA8L2E6c29saWRGaWxsPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8L2E6bG4+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBjcmVhdGVTaGFkb3dFbGVtZW50KG9wdHMuc2hhZG93LCBERUZfU0hBUEVfU0hBRE9XKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDwvYzpzcFByPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgPC9jOmRQdD4nO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gMjogXCJDYXRlZ29yaWVzXCJcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPGM6Y2F0Pic7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmNhdExhYmVsRm9ybWF0Q29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlICdudW1SZWYnIGFzIGNhdExhYmVsRm9ybWF0Q29kZSBpbXBsaWVzIHRoYXQgd2UgYXJlIGV4cGVjdGluZyBudW1iZXJzIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICA8YzpudW1SZWY+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBgICAgIDxjOmY+U2hlZXQxISRBJDI6JEEkJHtvYmoubGFiZWxzWzBdLmxlbmd0aCArIDF9PC9jOmY+YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDxjOm51bUNhY2hlPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgIDxjOmZvcm1hdENvZGU+JyArIChvcHRzLmNhdExhYmVsRm9ybWF0Q29kZSB8fCAnR2VuZXJhbCcpICsgJzwvYzpmb3JtYXRDb2RlPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYCAgICAgIDxjOnB0Q291bnQgdmFsPVwiJHtvYmoubGFiZWxzWzBdLmxlbmd0aH1cIi8+YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5sYWJlbHNbMF0uZm9yRWFjaCgobGFiZWwsIGlkeCkgPT4gKHN0clhtbCArPSBgPGM6cHQgaWR4PVwiJHtpZHh9XCI+PGM6dj4ke2VuY29kZVhtbEVudGl0aWVzKGxhYmVsKX08L2M6dj48L2M6cHQ+YCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPC9jOm51bUNhY2hlPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgPC9jOm51bVJlZj4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgIDxjOm11bHRpTHZsU3RyUmVmPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYCAgICA8YzpmPlNoZWV0MSEkQSQyOiQke2dldEV4Y2VsQ29sTmFtZShvYmoubGFiZWxzLmxlbmd0aCl9JCR7b2JqLmxhYmVsc1swXS5sZW5ndGggKyAxfTwvYzpmPmA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzptdWx0aUx2bFN0ckNhY2hlPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYCAgICAgIDxjOnB0Q291bnQgdmFsPVwiJHtvYmoubGFiZWxzWzBdLmxlbmd0aH1cIi8+YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5sYWJlbHMuZm9yRWFjaChsYWJlbHNHcm91cCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8Yzpsdmw+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbHNHcm91cC5mb3JFYWNoKChsYWJlbCwgaWR4KSA9PiAoc3RyWG1sICs9IGA8YzpwdCBpZHg9XCIke2lkeH1cIj48Yzp2PiR7ZW5jb2RlWG1sRW50aXRpZXMobGFiZWwpfTwvYzp2PjwvYzpwdD5gKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8L2M6bHZsPic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDwvYzptdWx0aUx2bFN0ckNhY2hlPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgPC9jOm11bHRpTHZsU3RyUmVmPic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8L2M6Y2F0Pic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIDM6IFwiVmFsdWVzXCJcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPGM6dmFsPic7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICA8YzpudW1SZWY+JztcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9IGA8YzpmPlNoZWV0MSEkJHtnZXRFeGNlbENvbE5hbWUob2JqLl9kYXRhSW5kZXggKyBvYmoubGFiZWxzLmxlbmd0aCArIDEpfSQyOiQke2dldEV4Y2VsQ29sTmFtZShvYmouX2RhdGFJbmRleCArIG9iai5sYWJlbHMubGVuZ3RoICsgMSl9JCR7b2JqLmxhYmVsc1swXS5sZW5ndGggKyAxfTwvYzpmPmA7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDxjOm51bUNhY2hlPic7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgPGM6Zm9ybWF0Q29kZT4nICsgKG9wdHMudmFsTGFiZWxGb3JtYXRDb2RlIHx8IG9wdHMuZGF0YVRhYmxlRm9ybWF0Q29kZSB8fCAnR2VuZXJhbCcpICsgJzwvYzpmb3JtYXRDb2RlPic7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBgICAgICAgPGM6cHRDb3VudCB2YWw9XCIke29iai5sYWJlbHNbMF0ubGVuZ3RofVwiLz5gO1xuICAgICAgICAgICAgICAgICAgICBvYmoudmFsdWVzLmZvckVhY2goKHZhbHVlLCBpZHgpID0+IChzdHJYbWwgKz0gYDxjOnB0IGlkeD1cIiR7aWR4fVwiPjxjOnY+JHt2YWx1ZSB8fCB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogJyd9PC9jOnY+PC9jOnB0PmApKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPC9jOm51bUNhY2hlPic7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICA8L2M6bnVtUmVmPic7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPC9jOnZhbD4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPcHRpb246IGBzbW9vdGhgXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0VHlwZSA9PT0gQ0hBUlRfVFlQRS5MSU5FKVxuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxjOnNtb290aCB2YWw9XCInICsgKG9wdHMubGluZVNtb290aCA/ICcxJyA6ICcwJykgKyAnXCIvPic7XG4gICAgICAgICAgICAgICAgLy8gNDogQ2xvc2UgXCJTRVJJRVNcIlxuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPC9jOnNlcj4nO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyAzOiBcIkRhdGEgTGFiZWxzXCJcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgPGM6ZExibHM+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYCAgICA8YzpudW1GbXQgZm9ybWF0Q29kZT1cIiR7ZW5jb2RlWG1sRW50aXRpZXMob3B0cy5kYXRhTGFiZWxGb3JtYXRDb2RlKSB8fCAnR2VuZXJhbCd9XCIgc291cmNlTGlua2VkPVwiMFwiLz5gO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDxjOnR4UHI+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgIDxhOmJvZHlQci8+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgIDxhOmxzdFN0eWxlLz4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgPGE6cD48YTpwUHI+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYCAgICAgICAgPGE6ZGVmUlByIGI9XCIke29wdHMuZGF0YUxhYmVsRm9udEJvbGQgPyAxIDogMH1cIiBpPVwiJHtvcHRzLmRhdGFMYWJlbEZvbnRJdGFsaWMgPyAxIDogMH1cIiBzdHJpa2U9XCJub1N0cmlrZVwiIHN6PVwiJHtNYXRoLnJvdW5kKChvcHRzLmRhdGFMYWJlbEZvbnRTaXplIHx8IERFRl9GT05UX1NJWkUpICogMTAwKX1cIiB1PVwibm9uZVwiPmA7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgICAgPGE6c29saWRGaWxsPicgKyBjcmVhdGVDb2xvckVsZW1lbnQob3B0cy5kYXRhTGFiZWxDb2xvciB8fCBERUZfRk9OVF9DT0xPUikgKyAnPC9hOnNvbGlkRmlsbD4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICAgIDxhOmxhdGluIHR5cGVmYWNlPVwiJyArIChvcHRzLmRhdGFMYWJlbEZvbnRGYWNlIHx8ICdBcmlhbCcpICsgJ1wiLz4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICA8L2E6ZGVmUlByPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICA8L2E6cFByPjwvYTpwPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPC9jOnR4UHI+JztcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5kYXRhTGFiZWxQb3NpdGlvbilcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgPGM6ZExibFBvcyB2YWw9XCInICsgb3B0cy5kYXRhTGFiZWxQb3NpdGlvbiArICdcIi8+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpzaG93TGVnZW5kS2V5IHZhbD1cIjBcIi8+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpzaG93VmFsIHZhbD1cIicgKyAob3B0cy5zaG93VmFsdWUgPyAnMScgOiAnMCcpICsgJ1wiLz4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDxjOnNob3dDYXROYW1lIHZhbD1cIjBcIi8+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpzaG93U2VyTmFtZSB2YWw9XCInICsgKG9wdHMuc2hvd1Nlck5hbWUgPyAnMScgOiAnMCcpICsgJ1wiLz4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDxjOnNob3dQZXJjZW50IHZhbD1cIjBcIi8+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpzaG93QnViYmxlU2l6ZSB2YWw9XCIwXCIvPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9IGAgICAgPGM6c2hvd0xlYWRlckxpbmVzIHZhbD1cIiR7b3B0cy5zaG93TGVhZGVyTGluZXMgPyAnMScgOiAnMCd9XCIvPmA7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgIDwvYzpkTGJscz4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gNDogQWRkIG1vcmUgY2hhcnQgb3B0aW9ucyAoZ2FwV2lkdGgsIGxpbmUgTWFya2VyLCBldGMuKVxuICAgICAgICAgICAgaWYgKGNoYXJ0VHlwZSA9PT0gQ0hBUlRfVFlQRS5CQVIpIHtcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYCAgPGM6Z2FwV2lkdGggdmFsPVwiJHtvcHRzLmJhckdhcFdpZHRoUGN0fVwiLz5gO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSBgICA8YzpvdmVybGFwIHZhbD1cIiR7KG9wdHMuYmFyR3JvdXBpbmcgfHwgJycpLmluY2x1ZGVzKCd0YWNrZWQnKSA/IDEwMCA6IG9wdHMuYmFyT3ZlcmxhcFBjdCA/IG9wdHMuYmFyT3ZlcmxhcFBjdCA6IDB9XCIvPmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFydFR5cGUgPT09IENIQVJUX1RZUEUuQkFSM0QpIHtcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYCAgPGM6Z2FwV2lkdGggdmFsPVwiJHtvcHRzLmJhckdhcFdpZHRoUGN0fVwiLz5gO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSBgICA8YzpnYXBEZXB0aCB2YWw9XCIke29wdHMuYmFyR2FwRGVwdGhQY3R9XCIvPmA7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgIDxjOnNoYXBlIHZhbD1cIicgKyBvcHRzLmJhcjNEU2hhcGUgKyAnXCIvPic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFydFR5cGUgPT09IENIQVJUX1RZUEUuTElORSkge1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICA8YzptYXJrZXIgdmFsPVwiMVwiLz4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gNTogQWRkIGF4aXNJZCAoTk9URTogb3JkZXIgbWF0dGVycyEgKGNhdGVnb3J5IGNvbWVzIGZpcnN0KSlcbiAgICAgICAgICAgIHN0clhtbCArPSBgPGM6YXhJZCB2YWw9XCIke2NhdEF4aXNJZH1cIi8+PGM6YXhJZCB2YWw9XCIke3ZhbEF4aXNJZH1cIi8+PGM6YXhJZCB2YWw9XCIke0FYSVNfSURfU0VSSUVTX1BSSU1BUll9XCIvPmA7XG4gICAgICAgICAgICAvLyA2OiBDbG9zZSBDaGFydCB0YWdcbiAgICAgICAgICAgIHN0clhtbCArPSBgPC9jOiR7Y2hhcnRUeXBlfUNoYXJ0PmA7XG4gICAgICAgICAgICAvLyBlbmQgc3dpdGNoXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDSEFSVF9UWVBFLlNDQVRURVI6XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIGBkYXRhYCA9IFtcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOidYLUF4aXMnLCAgICB2YWx1ZXM6WzEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyXSB9LFxuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6J1ktVmFsdWUgMScsIHZhbHVlczpbMTMsIDIwLCAyMSwgMjVdIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTonWS1WYWx1ZSAyJywgdmFsdWVzOlsgMSwgIDIsICA1LCAgOV0gfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gMTogU3RhcnQgQ2hhcnRcbiAgICAgICAgICAgIHN0clhtbCArPSAnPGM6JyArIGNoYXJ0VHlwZSArICdDaGFydD4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICc8YzpzY2F0dGVyU3R5bGUgdmFsPVwibGluZU1hcmtlclwiLz4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICc8Yzp2YXJ5Q29sb3JzIHZhbD1cIjBcIi8+JztcbiAgICAgICAgICAgIC8vIDI6IFNlcmllczogKE9uZSBmb3IgZWFjaCBZLUF4aXMpXG4gICAgICAgICAgICBjb2xvckluZGV4ID0gLTE7XG4gICAgICAgICAgICBkYXRhLmZpbHRlcigoX29iaiwgaWR4KSA9PiBpZHggPiAwKS5mb3JFYWNoKChvYmosIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbG9ySW5kZXgrKztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxjOnNlcj4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSBgICA8YzppZHggdmFsPVwiJHtpZHh9XCIvPmA7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9IGAgIDxjOm9yZGVyIHZhbD1cIiR7aWR4fVwiLz5gO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICA8Yzp0eD4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDxjOnN0clJlZj4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSBgICAgICAgPGM6Zj5TaGVldDEhJCR7Z2V0RXhjZWxDb2xOYW1lKGlkeCArIDIpfSQxPC9jOmY+YDtcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgIDxjOnN0ckNhY2hlPjxjOnB0Q291bnQgdmFsPVwiMVwiLz48YzpwdCBpZHg9XCIwXCI+PGM6dj4nICsgZW5jb2RlWG1sRW50aXRpZXMob2JqLm5hbWUpICsgJzwvYzp2PjwvYzpwdD48L2M6c3RyQ2FjaGU+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8L2M6c3RyUmVmPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgIDwvYzp0eD4nO1xuICAgICAgICAgICAgICAgIC8vICdjOnNwUHInOiBGaWxsLCBCb3JkZXIsIExpbmUsIExpbmVTdHlsZSAoZGFzaCwgZXRjLiksIFNoYWRvd1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICA8YzpzcFByPic7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0bXBTZXJDb2xvciA9IG9wdHMuY2hhcnRDb2xvcnNbY29sb3JJbmRleCAlIG9wdHMuY2hhcnRDb2xvcnMubGVuZ3RoXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRtcFNlckNvbG9yID09PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxhOm5vRmlsbC8+JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRzLmNoYXJ0Q29sb3JzT3BhY2l0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8YTpzb2xpZEZpbGw+JyArIGNyZWF0ZUNvbG9yRWxlbWVudCh0bXBTZXJDb2xvciwgJzxhOmFscGhhIHZhbD1cIicgKyBNYXRoLnJvdW5kKG9wdHMuY2hhcnRDb2xvcnNPcGFjaXR5ICogMTAwMCkudG9TdHJpbmcoKSArICdcIi8+JykgKyAnPC9hOnNvbGlkRmlsbD4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8YTpzb2xpZEZpbGw+JyArIGNyZWF0ZUNvbG9yRWxlbWVudCh0bXBTZXJDb2xvcikgKyAnPC9hOnNvbGlkRmlsbD4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmxpbmVTaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxhOmxuPjxhOm5vRmlsbC8+PC9hOmxuPic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYDxhOmxuIHc9XCIke3ZhbFRvUHRzKG9wdHMubGluZVNpemUpfVwiIGNhcD1cIiR7Y3JlYXRlTGluZUNhcChvcHRzLmxpbmVDYXApfVwiPjxhOnNvbGlkRmlsbD4ke2NyZWF0ZUNvbG9yRWxlbWVudCh0bXBTZXJDb2xvcil9PC9hOnNvbGlkRmlsbD5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9IGA8YTpwcnN0RGFzaCB2YWw9XCIke29wdHMubGluZURhc2ggfHwgJ3NvbGlkJ31cIi8+PGE6cm91bmQvPjwvYTpsbj5gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFNoYWRvd1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gY3JlYXRlU2hhZG93RWxlbWVudChvcHRzLnNoYWRvdywgREVGX1NIQVBFX1NIQURPVyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICA8L2M6c3BQcj4nO1xuICAgICAgICAgICAgICAgIC8vICdjOm1hcmtlcicgdGFnOiBgbGluZURhdGFTeW1ib2xgXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxjOm1hcmtlcj4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgPGM6c3ltYm9sIHZhbD1cIicgKyBvcHRzLmxpbmVEYXRhU3ltYm9sICsgJ1wiLz4nO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5saW5lRGF0YVN5bWJvbFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIFwiYXV0b1wiIG90aGVyd2lzZSAoYnV0IHRoaXMgaXMgdXN1YWxseSB0b28gc21hbGwsIHNvIHRoZXJlIGlzIGEgZGVmYXVsdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBgPGM6c2l6ZSB2YWw9XCIke29wdHMubGluZURhdGFTeW1ib2xTaXplfVwiLz5gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPGM6c3BQcj4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYDxhOnNvbGlkRmlsbD4ke2NyZWF0ZUNvbG9yRWxlbWVudChvcHRzLmNoYXJ0Q29sb3JzW2lkeCArIDEgPiBvcHRzLmNoYXJ0Q29sb3JzLmxlbmd0aCA/IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG9wdHMuY2hhcnRDb2xvcnMubGVuZ3RoKSA6IGlkeF0pfTwvYTpzb2xpZEZpbGw+YDtcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9IGA8YTpsbiB3PVwiJHtvcHRzLmxpbmVEYXRhU3ltYm9sTGluZVNpemV9XCIgY2FwPVwiZmxhdFwiPjxhOnNvbGlkRmlsbD4ke2NyZWF0ZUNvbG9yRWxlbWVudChvcHRzLmxpbmVEYXRhU3ltYm9sTGluZUNvbG9yIHx8IG9wdHMuY2hhcnRDb2xvcnNbY29sb3JJbmRleCAlIG9wdHMuY2hhcnRDb2xvcnMubGVuZ3RoXSl9PC9hOnNvbGlkRmlsbD48YTpwcnN0RGFzaCB2YWw9XCJzb2xpZFwiLz48YTpyb3VuZC8+PC9hOmxuPmA7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPGE6ZWZmZWN0THN0Lz4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzwvYzpzcFByPic7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPC9jOm1hcmtlcj4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPcHRpb246IHNjYXR0ZXIgZGF0YSBwb2ludCBsYWJlbHNcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5zaG93TGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhcnRVdWlkID0gZ2V0VXVpZCgnLXh4eHgteHh4eC14eHh4LXh4eHh4eHh4eHh4eCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqLmxhYmVsc1swXSAmJiAob3B0cy5kYXRhTGFiZWxGb3JtYXRTY2F0dGVyID09PSAnY3VzdG9tJyB8fCBvcHRzLmRhdGFMYWJlbEZvcm1hdFNjYXR0ZXIgPT09ICdjdXN0b21YWScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxjOmRMYmxzPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmoubGFiZWxzWzBdLmZvckVhY2goKGxhYmVsLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5kYXRhTGFiZWxGb3JtYXRTY2F0dGVyID09PSAnY3VzdG9tJyB8fCBvcHRzLmRhdGFMYWJlbEZvcm1hdFNjYXR0ZXIgPT09ICdjdXN0b21YWScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgIDxjOmRMYmw+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9IGAgICAgPGM6aWR4IHZhbD1cIiR7aWR4fVwiLz5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8Yzp0eD4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgIDxjOnJpY2g+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgICAgICA8YTpib2R5UHI+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgICAgICAgICAgPGE6c3BBdXRvRml0Lz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgICAgICAgIDwvYTpib2R5UHI+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgICAgICA8YTpsc3RTdHlsZS8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgICAgICA8YTpwPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICAgICAgICAgIDxhOnBQcj4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgICAgICAgICAgICAgICAgPGE6ZGVmUlByLz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgICAgICAgICAgICA8L2E6cFByPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICAgICAgICA8YTpyPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICAgICAgICAgICAgICA8YTpyUHIgbGFuZz1cIicgKyAob3B0cy5sYW5nIHx8ICdlbi1VUycpICsgJ1wiIGRpcnR5PVwiMFwiLz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgICAgICAgICAgICAgICAgPGE6dD4nICsgZW5jb2RlWG1sRW50aXRpZXMobGFiZWwpICsgJzwvYTp0Pic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICAgICAgICA8L2E6cj4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBYWSB2YWx1ZXMgYXQgZW5kIG9mIGN1c3RvbSBsYWJlbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgYXBwbHkgdGhlIHZhbHVlcyBpZiB0aGUgbGFiZWwgd2FzIGVtcHR5IG9yIGp1c3Qgc3BhY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIGZvciBzZWxlY3RpdmUgbGFiZWxsaW5nIHdoZXJlIHJlcXVpcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmRhdGFMYWJlbEZvcm1hdFNjYXR0ZXIgPT09ICdjdXN0b21YWScgJiYgIS9eICokLy50ZXN0KGxhYmVsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgICAgICAgIDxhOnI+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICAgICAgICAgICAgPGE6clByIGxhbmc9XCInICsgKG9wdHMubGFuZyB8fCAnZW4tVVMnKSArICdcIiBiYXNlbGluZT1cIjBcIiBkaXJ0eT1cIjBcIi8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICAgICAgICAgICAgPGE6dD4gKDwvYTp0Pic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgICAgICAgICAgPC9hOnI+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICAgICAgICA8YTpmbGQgaWQ9XCJ7JyArIGdldFV1aWQoJ3h4eHh4eHh4LXh4eHgteHh4eC14eHh4LXh4eHh4eHh4eHh4eCcpICsgJ31cIiB0eXBlPVwiWFZBTFVFXCI+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICAgICAgICAgICAgPGE6clByIGxhbmc9XCInICsgKG9wdHMubGFuZyB8fCAnZW4tVVMnKSArICdcIiBiYXNlbGluZT1cIjBcIi8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICAgICAgICAgICAgPGE6cFByPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgICAgICAgICAgICAgICAgICA8YTpkZWZSUHIvPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgICAgICAgICAgICAgIDwvYTpwUHI+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICAgICAgICAgICAgPGE6dD5bJyArIGVuY29kZVhtbEVudGl0aWVzKG9iai5uYW1lKSArICc8L2E6dD4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgICAgICAgIDwvYTpmbGQ+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICAgICAgICA8YTpyPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgICAgICAgICAgICAgIDxhOnJQciBsYW5nPVwiJyArIChvcHRzLmxhbmcgfHwgJ2VuLVVTJykgKyAnXCIgYmFzZWxpbmU9XCIwXCIgZGlydHk9XCIwXCIvPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgICAgICAgICAgICAgIDxhOnQ+LCA8L2E6dD4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgICAgICAgIDwvYTpyPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgICAgICAgICAgPGE6ZmxkIGlkPVwieycgKyBnZXRVdWlkKCd4eHh4eHh4eC14eHh4LXh4eHgteHh4eC14eHh4eHh4eHh4eHgnKSArICd9XCIgdHlwZT1cIllWQUxVRVwiPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgICAgICAgICAgICAgIDxhOnJQciBsYW5nPVwiJyArIChvcHRzLmxhbmcgfHwgJ2VuLVVTJykgKyAnXCIgYmFzZWxpbmU9XCIwXCIvPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgICAgICAgICAgICAgIDxhOnBQcj4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgICAgICAgICAgICAgICAgPGE6ZGVmUlByLz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgICAgICAgICAgICA8L2E6cFByPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgICAgICAgICAgICAgIDxhOnQ+WycgKyBlbmNvZGVYbWxFbnRpdGllcyhvYmoubmFtZSkgKyAnXTwvYTp0Pic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgICAgICAgICAgPC9hOmZsZD4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgICAgICAgIDxhOnI+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICAgICAgICAgICAgPGE6clByIGxhbmc9XCInICsgKG9wdHMubGFuZyB8fCAnZW4tVVMnKSArICdcIiBiYXNlbGluZT1cIjBcIiBkaXJ0eT1cIjBcIi8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICAgICAgICAgICAgPGE6dD4pPC9hOnQ+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICAgICAgICA8L2E6cj4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgICAgICAgIDxhOmVuZFBhcmFSUHIgbGFuZz1cIicgKyAob3B0cy5sYW5nIHx8ICdlbi1VUycpICsgJ1wiIGRpcnR5PVwiMFwiLz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICAgICAgPC9hOnA+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICA8L2M6cmljaD4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8L2M6dHg+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPGM6c3BQcj4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgICAgPGE6bm9GaWxsLz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgICAgPGE6bG4+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgICAgICA8YTpub0ZpbGwvPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICA8L2E6bG4+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgIDxhOmVmZmVjdExzdC8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPC9jOnNwUHI+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuZGF0YUxhYmVsUG9zaXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyA8YzpkTGJsUG9zIHZhbD1cIicgKyBvcHRzLmRhdGFMYWJlbFBvc2l0aW9uICsgJ1wiLz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpzaG93TGVnZW5kS2V5IHZhbD1cIjBcIi8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPGM6c2hvd1ZhbCB2YWw9XCIwXCIvPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDxjOnNob3dDYXROYW1lIHZhbD1cIjBcIi8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPGM6c2hvd1Nlck5hbWUgdmFsPVwiMFwiLz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpzaG93UGVyY2VudCB2YWw9XCIwXCIvPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDxjOnNob3dCdWJibGVTaXplIHZhbD1cIjBcIi8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgPGM6c2hvd0xlYWRlckxpbmVzIHZhbD1cIjFcIi8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPGM6ZXh0THN0Pic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgPGM6ZXh0IHVyaT1cIntDRTY1MzdBMS1ENkZDLTRmNjUtOUQ5MS03MjI0QzQ5NDU4QkJ9XCIgeG1sbnM6YzE1PVwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2UvZHJhd2luZy8yMDEyL2NoYXJ0XCIvPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgPGM6ZXh0IHVyaT1cIntDMzM4MENDNC01RDZFLTQwOUMtQkUzMi1FNzJEMjk3MzUzQ0N9XCIgeG1sbnM6YzE2PVwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2UvZHJhd2luZy8yMDE0L2NoYXJ0XCI+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9IGAgICAgICAgICAgICA8YzE2OnVuaXF1ZUlkIHZhbD1cInskeycwMDAwMDAwMCcuc3Vic3RyaW5nKDAsIDggLSAoaWR4ICsgMSkudG9TdHJpbmcoKS5sZW5ndGgpLnRvU3RyaW5nKCl9JHtpZHggKyAxfSR7Y2hhcnRVdWlkfX1cIi8+YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICA8L2M6ZXh0Pic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICA8L2M6ZXh0THN0Pic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPC9jOmRMYmw+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPC9jOmRMYmxzPic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuZGF0YUxhYmVsRm9ybWF0U2NhdHRlciA9PT0gJ1hZJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8YzpkTGJscz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPGM6c3BQcj4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgIDxhOm5vRmlsbC8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICA8YTpsbj4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgICAgICA8YTpub0ZpbGwvPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgICAgPC9hOmxuPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgICAgICA8YTplZmZlY3RMc3QvPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8L2M6c3BQcj4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPGM6dHhQcj4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgIDxhOmJvZHlQcj4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgICAgICA8YTpzcEF1dG9GaXQvPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgICAgPC9hOmJvZHlQcj4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgIDxhOmxzdFN0eWxlLz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgIDxhOnA+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICAgICAgPGE6cFByPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgICAgICAgICAgICA8YTpkZWZSUHIvPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgICAgICAgIDwvYTpwUHI+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICAgICAgPGE6ZW5kUGFyYVJQciBsYW5nPVwiZW4tVVNcIi8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICA8L2E6cD4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPC9jOnR4UHI+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmRhdGFMYWJlbFBvc2l0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnIDxjOmRMYmxQb3MgdmFsPVwiJyArIG9wdHMuZGF0YUxhYmVsUG9zaXRpb24gKyAnXCIvPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpzaG93TGVnZW5kS2V5IHZhbD1cIjBcIi8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBgIDxjOnNob3dWYWwgdmFsPVwiJHtvcHRzLnNob3dMYWJlbCA/ICcxJyA6ICcwJ31cIi8+YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBgIDxjOnNob3dDYXROYW1lIHZhbD1cIiR7b3B0cy5zaG93TGFiZWwgPyAnMScgOiAnMCd9XCIvPmA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYCA8YzpzaG93U2VyTmFtZSB2YWw9XCIke29wdHMuc2hvd1Nlck5hbWUgPyAnMScgOiAnMCd9XCIvPmA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpzaG93UGVyY2VudCB2YWw9XCIwXCIvPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpzaG93QnViYmxlU2l6ZSB2YWw9XCIwXCIvPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpleHRMc3Q+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICA8YzpleHQgdXJpPVwie0NFNjUzN0ExLUQ2RkMtNGY2NS05RDkxLTcyMjRDNDk0NThCQn1cIiB4bWxuczpjMTU9XCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9kcmF3aW5nLzIwMTIvY2hhcnRcIj4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgICAgICA8YzE1OnNob3dMZWFkZXJMaW5lcyB2YWw9XCIxXCIvPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgICAgPC9jOmV4dD4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPC9jOmV4dExzdD4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8L2M6ZExibHM+JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDb2xvciBiYXIgY2hhcnQgYmFycyB2YXJpb3VzIGNvbG9yc1xuICAgICAgICAgICAgICAgIC8vIEFsbG93IHVzZXJzIHdpdGggYSBzaW5nbGUgZGF0YSBzZXQgdG8gcGFzcyB0aGVpciBvd24gYXJyYXkgb2YgY29sb3JzIChjaGVjayBmb3IgdGhpcyB1c2luZyAhPSBvdXJzKVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMSAmJiBvcHRzLmNoYXJ0Q29sb3JzICE9PSBCQVJDSEFSVF9DT0xPUlMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VyaWVzIERhdGEgUG9pbnQgY29sb3JzXG4gICAgICAgICAgICAgICAgICAgIG9iai52YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnJDb2xvcnMgPSB2YWx1ZSA8IDAgPyBvcHRzLmludmVydGVkQ29sb3JzIHx8IG9wdHMuY2hhcnRDb2xvcnMgfHwgQkFSQ0hBUlRfQ09MT1JTIDogb3B0cy5jaGFydENvbG9ycyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICA8YzpkUHQ+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBgICAgIDxjOmlkeCB2YWw9XCIke2luZGV4fVwiLz5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICA8YzppbnZlcnRJZk5lZ2F0aXZlIHZhbD1cIjBcIi8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDxjOmJ1YmJsZTNEIHZhbD1cIjBcIi8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDxjOnNwUHI+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmxpbmVTaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8YTpsbj48YTpub0ZpbGwvPjwvYTpsbj4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8YTpzb2xpZEZpbGw+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyA8YTpzcmdiQ2xyIHZhbD1cIicgKyBhcnJDb2xvcnNbaW5kZXggJSBhcnJDb2xvcnMubGVuZ3RoXSArICdcIi8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzwvYTpzb2xpZEZpbGw+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBjcmVhdGVTaGFkb3dFbGVtZW50KG9wdHMuc2hhZG93LCBERUZfU0hBUEVfU0hBRE9XKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDwvYzpzcFByPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgPC9jOmRQdD4nO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gMzogXCJWYWx1ZXNcIjogU2NhdHRlciBDaGFydCBoYXMgMjogYHhWYWxgIGFuZCBgeVZhbGBcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFgtQXhpcyBpcyBhbHdheXMgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8Yzp4VmFsPic7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICA8YzpudW1SZWY+JztcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9IGAgICAgPGM6Zj5TaGVldDEhJEEkMjokQSQke2RhdGFbMF0udmFsdWVzLmxlbmd0aCArIDF9PC9jOmY+YDtcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPGM6bnVtQ2FjaGU+JztcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICA8Yzpmb3JtYXRDb2RlPkdlbmVyYWw8L2M6Zm9ybWF0Q29kZT4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYCAgICAgIDxjOnB0Q291bnQgdmFsPVwiJHtkYXRhWzBdLnZhbHVlcy5sZW5ndGh9XCIvPmA7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbMF0udmFsdWVzLmZvckVhY2goKHZhbHVlLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBgPGM6cHQgaWR4PVwiJHtpZHh9XCI+PGM6dj4ke3ZhbHVlIHx8IHZhbHVlID09PSAwID8gdmFsdWUgOiAnJ308L2M6dj48L2M6cHQ+YDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDwvYzpudW1DYWNoZT4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgPC9jOm51bVJlZj4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzwvYzp4VmFsPic7XG4gICAgICAgICAgICAgICAgICAgIC8vIFktQXhpcyB2YWxzIGFyZSB0aGlzIG9iamVjdCdzIGB2YWx1ZXNgXG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPGM6eVZhbD4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgPGM6bnVtUmVmPic7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBgICAgIDxjOmY+U2hlZXQxISQke2dldEV4Y2VsQ29sTmFtZShpZHggKyAyKX0kMjokJHtnZXRFeGNlbENvbE5hbWUoaWR4ICsgMil9JCR7ZGF0YVswXS52YWx1ZXMubGVuZ3RoICsgMX08L2M6Zj5gO1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpudW1DYWNoZT4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgIDxjOmZvcm1hdENvZGU+R2VuZXJhbDwvYzpmb3JtYXRDb2RlPic7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IFVzZSBwdCBjb3VudCBhbmQgaXRlcmF0ZSBvdmVyIGRhdGFbMF0gKFgtQXhpcykgYXMgdXNlciBjYW4gaGF2ZSBtb3JlIHZhbHVlcyB0aGFuIGRhdGEgKGVnOiB0aW1lbGluZSB3aGVyZSBvbmx5IGZpcnN0IGZldyBtb250aHMgYXJlIHBvcHVsYXRlZClcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9IGAgICAgICA8YzpwdENvdW50IHZhbD1cIiR7ZGF0YVswXS52YWx1ZXMubGVuZ3RofVwiLz5gO1xuICAgICAgICAgICAgICAgICAgICBkYXRhWzBdLnZhbHVlcy5mb3JFYWNoKChfdmFsdWUsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9IGA8YzpwdCBpZHg9XCIke2lkeH1cIj48Yzp2PiR7b2JqLnZhbHVlc1tpZHhdIHx8IG9iai52YWx1ZXNbaWR4XSA9PT0gMCA/IG9iai52YWx1ZXNbaWR4XSA6ICcnfTwvYzp2PjwvYzpwdD5gO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPC9jOm51bUNhY2hlPic7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICA8L2M6bnVtUmVmPic7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPC9jOnlWYWw+JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT3B0aW9uOiBgc21vb3RoYFxuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPGM6c21vb3RoIHZhbD1cIicgKyAob3B0cy5saW5lU21vb3RoID8gJzEnIDogJzAnKSArICdcIi8+JztcbiAgICAgICAgICAgICAgICAvLyA0OiBDbG9zZSBcIlNFUklFU1wiXG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8L2M6c2VyPic7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIDM6IERhdGEgTGFiZWxzXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgIDxjOmRMYmxzPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9IGAgICAgPGM6bnVtRm10IGZvcm1hdENvZGU9XCIke2VuY29kZVhtbEVudGl0aWVzKG9wdHMuZGF0YUxhYmVsRm9ybWF0Q29kZSkgfHwgJ0dlbmVyYWwnfVwiIHNvdXJjZUxpbmtlZD1cIjBcIi8+YDtcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8Yzp0eFByPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICA8YTpib2R5UHIvPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICA8YTpsc3RTdHlsZS8+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgIDxhOnA+PGE6cFByPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9IGAgICAgICAgIDxhOmRlZlJQciBiPVwiJHtvcHRzLmRhdGFMYWJlbEZvbnRCb2xkID8gJzEnIDogJzAnfVwiIGk9XCIke29wdHMuZGF0YUxhYmVsRm9udEl0YWxpYyA/ICcxJyA6ICcwJ31cIiBzdHJpa2U9XCJub1N0cmlrZVwiIHN6PVwiJHtNYXRoLnJvdW5kKChvcHRzLmRhdGFMYWJlbEZvbnRTaXplIHx8IERFRl9GT05UX1NJWkUpICogMTAwKX1cIiB1PVwibm9uZVwiPmA7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgICAgPGE6c29saWRGaWxsPicgKyBjcmVhdGVDb2xvckVsZW1lbnQob3B0cy5kYXRhTGFiZWxDb2xvciB8fCBERUZfRk9OVF9DT0xPUikgKyAnPC9hOnNvbGlkRmlsbD4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICAgIDxhOmxhdGluIHR5cGVmYWNlPVwiJyArIChvcHRzLmRhdGFMYWJlbEZvbnRGYWNlIHx8ICdBcmlhbCcpICsgJ1wiLz4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgICA8L2E6ZGVmUlByPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICA8L2E6cFByPjwvYTpwPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPC9jOnR4UHI+JztcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5kYXRhTGFiZWxQb3NpdGlvbilcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgPGM6ZExibFBvcyB2YWw9XCInICsgb3B0cy5kYXRhTGFiZWxQb3NpdGlvbiArICdcIi8+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpzaG93TGVnZW5kS2V5IHZhbD1cIjBcIi8+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpzaG93VmFsIHZhbD1cIicgKyAob3B0cy5zaG93VmFsdWUgPyAnMScgOiAnMCcpICsgJ1wiLz4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDxjOnNob3dDYXROYW1lIHZhbD1cIjBcIi8+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpzaG93U2VyTmFtZSB2YWw9XCInICsgKG9wdHMuc2hvd1Nlck5hbWUgPyAnMScgOiAnMCcpICsgJ1wiLz4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDxjOnNob3dQZXJjZW50IHZhbD1cIjBcIi8+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpzaG93QnViYmxlU2l6ZSB2YWw9XCIwXCIvPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgIDwvYzpkTGJscz4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gNDogQWRkIGF4aXMgSWQgKE5PVEU6IG9yZGVyIG1hdHRlcnMhIC0gY2F0ZWdvcnkgY29tZXMgZmlyc3QpXG4gICAgICAgICAgICBzdHJYbWwgKz0gYDxjOmF4SWQgdmFsPVwiJHtjYXRBeGlzSWR9XCIvPjxjOmF4SWQgdmFsPVwiJHt2YWxBeGlzSWR9XCIvPmA7XG4gICAgICAgICAgICAvLyA1OiBDbG9zZSBDaGFydCB0YWdcbiAgICAgICAgICAgIHN0clhtbCArPSAnPC9jOicgKyBjaGFydFR5cGUgKyAnQ2hhcnQ+JztcbiAgICAgICAgICAgIC8vIGVuZCBzd2l0Y2hcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENIQVJUX1RZUEUuQlVCQkxFOlxuICAgICAgICBjYXNlIENIQVJUX1RZUEUuQlVCQkxFM0Q6XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIGBkYXRhYCA9IFtcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOidYLUF4aXMnLCAgICAgdmFsdWVzOlsxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMl0gfSxcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOidZLVZhbHVlcyAxJywgdmFsdWVzOlsxMywgMjAsIDIxLCAyNV0sIHNpemVzOlsxMCwgNSwgMjAsIDE1XSB9LFxuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6J1ktVmFsdWVzIDInLCB2YWx1ZXM6WyAxLCAgMiwgIDUsICA5XSwgc2l6ZXM6WyA1LCAzLCAgOSwgIDNdIH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIDE6IFN0YXJ0IENoYXJ0XG4gICAgICAgICAgICBzdHJYbWwgKz0gJzxjOmJ1YmJsZUNoYXJ0Pic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJzxjOnZhcnlDb2xvcnMgdmFsPVwiMFwiLz4nO1xuICAgICAgICAgICAgLy8gMjogU2VyaWVzOiAoT25lIGZvciBlYWNoIFktQXhpcylcbiAgICAgICAgICAgIGNvbG9ySW5kZXggPSAtMTtcbiAgICAgICAgICAgIGRhdGEuZmlsdGVyKChfb2JqLCBpZHgpID0+IGlkeCA+IDApLmZvckVhY2goKG9iaiwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29sb3JJbmRleCsrO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPGM6c2VyPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9IGAgIDxjOmlkeCB2YWw9XCIke2lkeH1cIi8+YDtcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYCAgPGM6b3JkZXIgdmFsPVwiJHtpZHh9XCIvPmA7XG4gICAgICAgICAgICAgICAgLy8gQTogYDxjOnR4PmBcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgPGM6dHg+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpzdHJSZWY+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgIDxjOmY+U2hlZXQxISQnICsgZ2V0RXhjZWxDb2xOYW1lKGlkeENvbEx0ciArIDEpICsgJyQxPC9jOmY+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgIDxjOnN0ckNhY2hlPjxjOnB0Q291bnQgdmFsPVwiMVwiLz48YzpwdCBpZHg9XCIwXCI+PGM6dj4nICsgZW5jb2RlWG1sRW50aXRpZXMob2JqLm5hbWUpICsgJzwvYzp2PjwvYzpwdD48L2M6c3RyQ2FjaGU+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8L2M6c3RyUmVmPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgIDwvYzp0eD4nO1xuICAgICAgICAgICAgICAgIC8vIEI6ICc8YzpzcFByPic6IEZpbGwsIEJvcmRlciwgTGluZSwgTGluZVN0eWxlIChkYXNoLCBldGMuKSwgU2hhZG93XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxjOnNwUHI+JztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG1wU2VyQ29sb3IgPSBvcHRzLmNoYXJ0Q29sb3JzW2NvbG9ySW5kZXggJSBvcHRzLmNoYXJ0Q29sb3JzLmxlbmd0aF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0bXBTZXJDb2xvciA9PT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8YTpub0ZpbGwvPic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0cy5jaGFydENvbG9yc09wYWNpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBgPGE6c29saWRGaWxsPiR7Y3JlYXRlQ29sb3JFbGVtZW50KHRtcFNlckNvbG9yLCAnPGE6YWxwaGEgdmFsPVwiJyArIE1hdGgucm91bmQob3B0cy5jaGFydENvbG9yc09wYWNpdHkgKiAxMDAwKS50b1N0cmluZygpICsgJ1wiLz4nKX08L2E6c29saWRGaWxsPmA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxhOnNvbGlkRmlsbD4nICsgY3JlYXRlQ29sb3JFbGVtZW50KHRtcFNlckNvbG9yKSArICc8L2E6c29saWRGaWxsPic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMubGluZVNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPGE6bG4+PGE6bm9GaWxsLz48L2E6bG4+JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRzLmRhdGFCb3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBgPGE6bG4gdz1cIiR7dmFsVG9QdHMob3B0cy5kYXRhQm9yZGVyLnB0KX1cIiBjYXA9XCJmbGF0XCI+PGE6c29saWRGaWxsPiR7Y3JlYXRlQ29sb3JFbGVtZW50KG9wdHMuZGF0YUJvcmRlci5jb2xvcil9PC9hOnNvbGlkRmlsbD48YTpwcnN0RGFzaCB2YWw9XCJzb2xpZFwiLz48YTpyb3VuZC8+PC9hOmxuPmA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYDxhOmxuIHc9XCIke3ZhbFRvUHRzKG9wdHMubGluZVNpemUpfVwiIGNhcD1cImZsYXRcIj48YTpzb2xpZEZpbGw+JHtjcmVhdGVDb2xvckVsZW1lbnQodG1wU2VyQ29sb3IpfTwvYTpzb2xpZEZpbGw+YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBgPGE6cHJzdERhc2ggdmFsPVwiJHtvcHRzLmxpbmVEYXNoIHx8ICdzb2xpZCd9XCIvPjxhOnJvdW5kLz48L2E6bG4+YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTaGFkb3dcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9IGNyZWF0ZVNoYWRvd0VsZW1lbnQob3B0cy5zaGFkb3csIERFRl9TSEFQRV9TSEFET1cpO1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzwvYzpzcFByPic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEM6ICc8YzpkTGJscz4nIFwiRGF0YSBMYWJlbHNcIlxuICAgICAgICAgICAgICAgIC8vIExldCBpdCBiZSBkZWZhdWx0ZWQgZm9yIG5vd1xuICAgICAgICAgICAgICAgIC8vIEQ6ICc8Yzp4VmFsPicvJzxjOnlWYWw+JyBcIlZhbHVlc1wiOiBTY2F0dGVyIENoYXJ0IGhhcyAyOiBgeFZhbGAgYW5kIGB5VmFsYFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gWC1BeGlzIGlzIGFsd2F5cyB0aGUgc2FtZVxuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxjOnhWYWw+JztcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgIDxjOm51bVJlZj4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYCAgICA8YzpmPlNoZWV0MSEkQSQyOiRBJCR7ZGF0YVswXS52YWx1ZXMubGVuZ3RoICsgMX08L2M6Zj5gO1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpudW1DYWNoZT4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgIDxjOmZvcm1hdENvZGU+R2VuZXJhbDwvYzpmb3JtYXRDb2RlPic7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBgICAgICAgPGM6cHRDb3VudCB2YWw9XCIke2RhdGFbMF0udmFsdWVzLmxlbmd0aH1cIi8+YDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVswXS52YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9IGA8YzpwdCBpZHg9XCIke2lkeH1cIj48Yzp2PiR7dmFsdWUgfHwgdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICcnfTwvYzp2PjwvYzpwdD5gO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPC9jOm51bUNhY2hlPic7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICA8L2M6bnVtUmVmPic7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPC9jOnhWYWw+JztcbiAgICAgICAgICAgICAgICAgICAgLy8gWS1BeGlzIHZhbHMgYXJlIHRoaXMgb2JqZWN0J3MgYHZhbHVlc2BcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8Yzp5VmFsPic7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICA8YzpudW1SZWY+JztcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9IGA8YzpmPlNoZWV0MSEkJHtnZXRFeGNlbENvbE5hbWUoaWR4Q29sTHRyICsgMSl9JDI6JCR7Z2V0RXhjZWxDb2xOYW1lKGlkeENvbEx0ciArIDEpfSQke2RhdGFbMF0udmFsdWVzLmxlbmd0aCArIDF9PC9jOmY+YDtcbiAgICAgICAgICAgICAgICAgICAgaWR4Q29sTHRyKys7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDxjOm51bUNhY2hlPic7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgPGM6Zm9ybWF0Q29kZT5HZW5lcmFsPC9jOmZvcm1hdENvZGU+JztcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogVXNlIHB0IGNvdW50IGFuZCBpdGVyYXRlIG92ZXIgZGF0YVswXSAoWC1BeGlzKSBhcyB1c2VyIGNhbiBoYXZlIG1vcmUgdmFsdWVzIHRoYW4gZGF0YSAoZWc6IHRpbWVsaW5lIHdoZXJlIG9ubHkgZmlyc3QgZmV3IG1vbnRocyBhcmUgcG9wdWxhdGVkKVxuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYCAgICAgIDxjOnB0Q291bnQgdmFsPVwiJHtkYXRhWzBdLnZhbHVlcy5sZW5ndGh9XCIvPmA7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbMF0udmFsdWVzLmZvckVhY2goKF92YWx1ZSwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYDxjOnB0IGlkeD1cIiR7aWR4fVwiPjxjOnY+JHtvYmoudmFsdWVzW2lkeF0gfHwgb2JqLnZhbHVlc1tpZHhdID09PSAwID8gb2JqLnZhbHVlc1tpZHhdIDogJyd9PC9jOnY+PC9jOnB0PmA7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8L2M6bnVtQ2FjaGU+JztcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgIDwvYzpudW1SZWY+JztcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8L2M6eVZhbD4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFOiAnPGM6YnViYmxlU2l6ZT4nXG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgIDxjOmJ1YmJsZVNpemU+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpudW1SZWY+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYDxjOmY+U2hlZXQxISQke2dldEV4Y2VsQ29sTmFtZShpZHhDb2xMdHIgKyAxKX0kMjokJHtnZXRFeGNlbENvbE5hbWUoaWR4Q29sTHRyICsgMSl9JCR7b2JqLnNpemVzLmxlbmd0aCArIDF9PC9jOmY+YDtcbiAgICAgICAgICAgICAgICBpZHhDb2xMdHIrKztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgIDxjOm51bUNhY2hlPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgIDxjOmZvcm1hdENvZGU+R2VuZXJhbDwvYzpmb3JtYXRDb2RlPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9IGAgICAgICAgICAgIDxjOnB0Q291bnQgdmFsPVwiJHtvYmouc2l6ZXMubGVuZ3RofVwiLz5gO1xuICAgICAgICAgICAgICAgIG9iai5zaXplcy5mb3JFYWNoKCh2YWx1ZSwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBgPGM6cHQgaWR4PVwiJHtpZHh9XCI+PGM6dj4ke3ZhbHVlIHx8ICcnfTwvYzp2PjwvYzpwdD5gO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgPC9jOm51bUNhY2hlPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPC9jOm51bVJlZj4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICA8L2M6YnViYmxlU2l6ZT4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICA8YzpidWJibGUzRCB2YWw9XCInICsgKGNoYXJ0VHlwZSA9PT0gQ0hBUlRfVFlQRS5CVUJCTEUzRCA/ICcxJyA6ICcwJykgKyAnXCIvPic7XG4gICAgICAgICAgICAgICAgLy8gRjogQ2xvc2UgXCJTRVJJRVNcIlxuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPC9jOnNlcj4nO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyAzOiBEYXRhIExhYmVsc1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPGM6ZExibHM+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYDxjOm51bUZtdCBmb3JtYXRDb2RlPVwiJHtlbmNvZGVYbWxFbnRpdGllcyhvcHRzLmRhdGFMYWJlbEZvcm1hdENvZGUpIHx8ICdHZW5lcmFsJ31cIiBzb3VyY2VMaW5rZWQ9XCIwXCIvPmA7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8Yzp0eFByPjxhOmJvZHlQci8+PGE6bHN0U3R5bGUvPjxhOnA+PGE6cFByPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9IGA8YTpkZWZSUHIgYj1cIiR7b3B0cy5kYXRhTGFiZWxGb250Qm9sZCA/IDEgOiAwfVwiIGk9XCIke29wdHMuZGF0YUxhYmVsRm9udEl0YWxpYyA/IDEgOiAwfVwiIHN0cmlrZT1cIm5vU3RyaWtlXCIgc3o9XCIke01hdGgucm91bmQoTWF0aC5yb3VuZChvcHRzLmRhdGFMYWJlbEZvbnRTaXplIHx8IERFRl9GT05UX1NJWkUpICogMTAwKX1cIiB1PVwibm9uZVwiPmA7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9IGA8YTpzb2xpZEZpbGw+JHtjcmVhdGVDb2xvckVsZW1lbnQob3B0cy5kYXRhTGFiZWxDb2xvciB8fCBERUZfRk9OVF9DT0xPUil9PC9hOnNvbGlkRmlsbD5gO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSBgPGE6bGF0aW4gdHlwZWZhY2U9XCIke29wdHMuZGF0YUxhYmVsRm9udEZhY2UgfHwgJ0FyaWFsJ31cIi8+YDtcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzwvYTpkZWZSUHI+PC9hOnBQcj48L2E6cD48L2M6dHhQcj4nO1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLmRhdGFMYWJlbFBvc2l0aW9uKVxuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYDxjOmRMYmxQb3MgdmFsPVwiJHtvcHRzLmRhdGFMYWJlbFBvc2l0aW9ufVwiLz5gO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPGM6c2hvd0xlZ2VuZEtleSB2YWw9XCIwXCIvPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9IGA8YzpzaG93VmFsIHZhbD1cIiR7b3B0cy5zaG93VmFsdWUgPyAnMScgOiAnMCd9XCIvPmA7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9IGA8YzpzaG93Q2F0TmFtZSB2YWw9XCIwXCIvPjxjOnNob3dTZXJOYW1lIHZhbD1cIiR7b3B0cy5zaG93U2VyTmFtZSA/ICcxJyA6ICcwJ31cIi8+PGM6c2hvd1BlcmNlbnQgdmFsPVwiMFwiLz48YzpzaG93QnViYmxlU2l6ZSB2YWw9XCIwXCIvPmA7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8YzpleHRMc3Q+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgPGM6ZXh0IHVyaT1cIntDRTY1MzdBMS1ENkZDLTRmNjUtOUQ5MS03MjI0QzQ5NDU4QkJ9XCIgeG1sbnM6YzE1PVwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2UvZHJhd2luZy8yMDEyL2NoYXJ0XCI+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzE1OnNob3dMZWFkZXJMaW5lcyB2YWw9XCInICsgKG9wdHMuc2hvd0xlYWRlckxpbmVzID8gJzEnIDogJzAnKSArICdcIi8+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgPC9jOmV4dD4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPC9jOmV4dExzdD4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPC9jOmRMYmxzPic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA0OiBCdWJibGUgb3B0aW9uc1xuICAgICAgICAgICAgLy8gc3RyWG1sICs9ICcgIDxjOmJ1YmJsZVNjYWxlIHZhbD1cIjEwMFwiLz4nO1xuICAgICAgICAgICAgLy8gc3RyWG1sICs9ICcgIDxjOnNob3dOZWdCdWJibGVzIHZhbD1cIjBcIi8+JztcbiAgICAgICAgICAgIC8vIENvbW1lbnRlZCBvdXQgdG8gbGV0IGl0IGRlZmF1bHQgdG8gUFBUIHVudGlsIHdlIGNyZWF0ZSBvcHRpb25zXG4gICAgICAgICAgICAvLyA1OiBBeGlzSWQgKE5PVEU6IG9yZGVyIG1hdHRlcnMhIChjYXRlZ29yeSBjb21lcyBmaXJzdCkpXG4gICAgICAgICAgICBzdHJYbWwgKz0gYDxjOmF4SWQgdmFsPVwiJHtjYXRBeGlzSWR9XCIvPjxjOmF4SWQgdmFsPVwiJHt2YWxBeGlzSWR9XCIvPmA7XG4gICAgICAgICAgICAvLyA2OiBDbG9zZSBDaGFydCB0YWdcbiAgICAgICAgICAgIHN0clhtbCArPSAnPC9jOmJ1YmJsZUNoYXJ0Pic7XG4gICAgICAgICAgICAvLyBlbmQgc3dpdGNoXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDSEFSVF9UWVBFLkRPVUdITlVUOlxuICAgICAgICBjYXNlIENIQVJUX1RZUEUuUElFOlxuICAgICAgICAgICAgLy8gVXNlIHRoZSBzYW1lIGxldCBuYW1lIHNvIGNvZGUgYmxvY2tzIGZyb20gYmFyQ2hhcnQgYXJlIGludGVyY2hhbmdlYWJsZVxuICAgICAgICAgICAgb3B0c0NoYXJ0RGF0YSA9IGRhdGFbMF07XG4gICAgICAgICAgICAvKiBFWDpcbiAgICAgICAgICAgICAgICBkYXRhOiBbXG4gICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICBuYW1lOiAnUHJvamVjdCBTdGF0dXMnLFxuICAgICAgICAgICAgICAgICAgIGxhYmVsczogWydSZWQnLCAnQW1iZXInLCAnR3JlZW4nLCAnVW5rbm93biddLFxuICAgICAgICAgICAgICAgICAgIHZhbHVlczogWzEwLCAyMCwgMzgsIDJdXG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gMTogU3RhcnQgQ2hhcnRcbiAgICAgICAgICAgIHN0clhtbCArPSAnPGM6JyArIGNoYXJ0VHlwZSArICdDaGFydD4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgIDxjOnZhcnlDb2xvcnMgdmFsPVwiMVwiLz4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICc8YzpzZXI+JztcbiAgICAgICAgICAgIHN0clhtbCArPSAnICA8YzppZHggdmFsPVwiMFwiLz4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgIDxjOm9yZGVyIHZhbD1cIjBcIi8+JztcbiAgICAgICAgICAgIHN0clhtbCArPSAnICA8Yzp0eD4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPGM6c3RyUmVmPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgIDxjOmY+U2hlZXQxISRCJDE8L2M6Zj4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICA8YzpzdHJDYWNoZT4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgIDxjOnB0Q291bnQgdmFsPVwiMVwiLz4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgIDxjOnB0IGlkeD1cIjBcIj48Yzp2PicgKyBlbmNvZGVYbWxFbnRpdGllcyhvcHRzQ2hhcnREYXRhLm5hbWUpICsgJzwvYzp2PjwvYzpwdD4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICA8L2M6c3RyQ2FjaGU+JztcbiAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDwvYzpzdHJSZWY+JztcbiAgICAgICAgICAgIHN0clhtbCArPSAnICA8L2M6dHg+JztcbiAgICAgICAgICAgIHN0clhtbCArPSAnICA8YzpzcFByPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD1cImFjY2VudDFcIi8+PC9hOnNvbGlkRmlsbD4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPGE6bG4gdz1cIjk1MjVcIiBjYXA9XCJmbGF0XCI+PGE6c29saWRGaWxsPjxhOnNyZ2JDbHIgdmFsPVwiRjlGOUY5XCIvPjwvYTpzb2xpZEZpbGw+PGE6cHJzdERhc2ggdmFsPVwic29saWRcIi8+PGE6cm91bmQvPjwvYTpsbj4nO1xuICAgICAgICAgICAgaWYgKG9wdHMuZGF0YU5vRWZmZWN0cykge1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPGE6ZWZmZWN0THN0Lz4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9IGNyZWF0ZVNoYWRvd0VsZW1lbnQob3B0cy5zaGFkb3csIERFRl9TSEFQRV9TSEFET1cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyWG1sICs9ICcgIDwvYzpzcFByPic7XG4gICAgICAgICAgICAvLyBzdHJYbWwgKz0gJzxjOmV4cGxvc2lvbiB2YWw9XCIwXCIvPidcbiAgICAgICAgICAgIC8vIDI6IFwiRGF0YSBQb2ludFwiIGJsb2NrIGZvciBldmVyeSBkYXRhIHJvd1xuICAgICAgICAgICAgb3B0c0NoYXJ0RGF0YS5sYWJlbHNbMF0uZm9yRWFjaCgoX2xhYmVsLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxjOmRQdD4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSBgIDxjOmlkeCB2YWw9XCIke2lkeH1cIi8+YDtcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyA8YzpidWJibGUzRCB2YWw9XCIwXCIvPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgPGM6c3BQcj4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSBgPGE6c29saWRGaWxsPiR7Y3JlYXRlQ29sb3JFbGVtZW50KG9wdHMuY2hhcnRDb2xvcnNbaWR4ICsgMSA+IG9wdHMuY2hhcnRDb2xvcnMubGVuZ3RoID8gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogb3B0cy5jaGFydENvbG9ycy5sZW5ndGgpIDogaWR4XSl9PC9hOnNvbGlkRmlsbD5gO1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLmRhdGFCb3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9IGA8YTpsbiB3PVwiJHt2YWxUb1B0cyhvcHRzLmRhdGFCb3JkZXIucHQpfVwiIGNhcD1cImZsYXRcIj48YTpzb2xpZEZpbGw+JHtjcmVhdGVDb2xvckVsZW1lbnQob3B0cy5kYXRhQm9yZGVyLmNvbG9yKX08L2E6c29saWRGaWxsPjxhOnByc3REYXNoIHZhbD1cInNvbGlkXCIvPjxhOnJvdW5kLz48L2E6bG4+YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9IGNyZWF0ZVNoYWRvd0VsZW1lbnQob3B0cy5zaGFkb3csIERFRl9TSEFQRV9TSEFET1cpO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICA8L2M6c3BQcj4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPC9jOmRQdD4nO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyAzOiBcIkRhdGEgTGFiZWxcIiBibG9jayBmb3IgZXZlcnkgZGF0YSBMYWJlbFxuICAgICAgICAgICAgc3RyWG1sICs9ICc8YzpkTGJscz4nO1xuICAgICAgICAgICAgb3B0c0NoYXJ0RGF0YS5sYWJlbHNbMF0uZm9yRWFjaCgoX2xhYmVsLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxjOmRMYmw+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYCA8YzppZHggdmFsPVwiJHtpZHh9XCIvPmA7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9IGAgIDxjOm51bUZtdCBmb3JtYXRDb2RlPVwiJHtlbmNvZGVYbWxFbnRpdGllcyhvcHRzLmRhdGFMYWJlbEZvcm1hdENvZGUpIHx8ICdHZW5lcmFsJ31cIiBzb3VyY2VMaW5rZWQ9XCIwXCIvPmA7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgIDxjOnNwUHIvPjxjOnR4UHI+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgIDxhOmJvZHlQci8+PGE6bHN0U3R5bGUvPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICA8YTpwPjxhOnBQcj4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSBgICAgPGE6ZGVmUlByIHN6PVwiJHtNYXRoLnJvdW5kKChvcHRzLmRhdGFMYWJlbEZvbnRTaXplIHx8IERFRl9GT05UX1NJWkUpICogMTAwKX1cIiBiPVwiJHtvcHRzLmRhdGFMYWJlbEZvbnRCb2xkID8gMSA6IDB9XCIgaT1cIiR7b3B0cy5kYXRhTGFiZWxGb250SXRhbGljID8gMSA6IDB9XCIgdT1cIm5vbmVcIiBzdHJpa2U9XCJub1N0cmlrZVwiPmA7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPGE6c29saWRGaWxsPicgKyBjcmVhdGVDb2xvckVsZW1lbnQob3B0cy5kYXRhTGFiZWxDb2xvciB8fCBERUZfRk9OVF9DT0xPUikgKyAnPC9hOnNvbGlkRmlsbD4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSBgICAgIDxhOmxhdGluIHR5cGVmYWNlPVwiJHtvcHRzLmRhdGFMYWJlbEZvbnRGYWNlIHx8ICdBcmlhbCd9XCIvPmA7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICA8L2E6ZGVmUlByPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICA8L2E6cFByPjwvYTpwPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPC9jOnR4UHI+JztcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnRUeXBlID09PSBDSEFSVF9UWVBFLlBJRSAmJiBvcHRzLmRhdGFMYWJlbFBvc2l0aW9uKVxuICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYDxjOmRMYmxQb3MgdmFsPVwiJHtvcHRzLmRhdGFMYWJlbFBvc2l0aW9ufVwiLz5gO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDxjOnNob3dMZWdlbmRLZXkgdmFsPVwiMFwiLz4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDxjOnNob3dWYWwgdmFsPVwiJyArIChvcHRzLnNob3dWYWx1ZSA/ICcxJyA6ICcwJykgKyAnXCIvPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPGM6c2hvd0NhdE5hbWUgdmFsPVwiJyArIChvcHRzLnNob3dMYWJlbCA/ICcxJyA6ICcwJykgKyAnXCIvPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPGM6c2hvd1Nlck5hbWUgdmFsPVwiJyArIChvcHRzLnNob3dTZXJOYW1lID8gJzEnIDogJzAnKSArICdcIi8+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpzaG93UGVyY2VudCB2YWw9XCInICsgKG9wdHMuc2hvd1BlcmNlbnQgPyAnMScgOiAnMCcpICsgJ1wiLz4nO1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDxjOnNob3dCdWJibGVTaXplIHZhbD1cIjBcIi8+JztcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJyAgPC9jOmRMYmw+JztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RyWG1sICs9IGAgPGM6bnVtRm10IGZvcm1hdENvZGU9XCIke2VuY29kZVhtbEVudGl0aWVzKG9wdHMuZGF0YUxhYmVsRm9ybWF0Q29kZSkgfHwgJ0dlbmVyYWwnfVwiIHNvdXJjZUxpbmtlZD1cIjBcIi8+YDtcbiAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDxjOnR4UHI+JztcbiAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgPGE6Ym9keVByLz4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICA8YTpsc3RTdHlsZS8+JztcbiAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgPGE6cD4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgIDxhOnBQcj4nO1xuICAgICAgICAgICAgc3RyWG1sICs9IGAgICAgICAgICAgPGE6ZGVmUlByIHN6PVwiMTgwMFwiIGI9XCIke29wdHMuZGF0YUxhYmVsRm9udEJvbGQgPyAnMScgOiAnMCd9XCIgaT1cIiR7b3B0cy5kYXRhTGFiZWxGb250SXRhbGljID8gJzEnIDogJzAnfVwiIHU9XCJub25lXCIgc3RyaWtlPVwibm9TdHJpa2VcIj5gO1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICAgICAgICA8YTpzb2xpZEZpbGw+PGE6c3JnYkNsciB2YWw9XCIwMDAwMDBcIi8+PC9hOnNvbGlkRmlsbD48YTpsYXRpbiB0eXBlZmFjZT1cIkFyaWFsXCIvPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgICAgICA8L2E6ZGVmUlByPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgICAgPC9hOnBQcj4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICA8L2E6cD4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPC9jOnR4UHI+JztcbiAgICAgICAgICAgIHN0clhtbCArPSBjaGFydFR5cGUgPT09IENIQVJUX1RZUEUuUElFID8gJzxjOmRMYmxQb3MgdmFsPVwiY3RyXCIvPicgOiAnJztcbiAgICAgICAgICAgIHN0clhtbCArPSAnICAgIDxjOnNob3dMZWdlbmRLZXkgdmFsPVwiMFwiLz4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPGM6c2hvd1ZhbCB2YWw9XCIwXCIvPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpzaG93Q2F0TmFtZSB2YWw9XCIxXCIvPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpzaG93U2VyTmFtZSB2YWw9XCIwXCIvPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpzaG93UGVyY2VudCB2YWw9XCIxXCIvPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpzaG93QnViYmxlU2l6ZSB2YWw9XCIwXCIvPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gYCA8YzpzaG93TGVhZGVyTGluZXMgdmFsPVwiJHtvcHRzLnNob3dMZWFkZXJMaW5lcyA/ICcxJyA6ICcwJ31cIi8+YDtcbiAgICAgICAgICAgIHN0clhtbCArPSAnPC9jOmRMYmxzPic7XG4gICAgICAgICAgICAvLyAyOiBcIkNhdGVnb3JpZXNcIlxuICAgICAgICAgICAgc3RyWG1sICs9ICc8YzpjYXQ+JztcbiAgICAgICAgICAgIHN0clhtbCArPSAnICA8YzpzdHJSZWY+JztcbiAgICAgICAgICAgIHN0clhtbCArPSBgICAgIDxjOmY+U2hlZXQxISRBJDI6JEEkJHtvcHRzQ2hhcnREYXRhLmxhYmVsc1swXS5sZW5ndGggKyAxfTwvYzpmPmA7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8YzpzdHJDYWNoZT4nO1xuICAgICAgICAgICAgc3RyWG1sICs9IGAgICAgICAgICA8YzpwdENvdW50IHZhbD1cIiR7b3B0c0NoYXJ0RGF0YS5sYWJlbHNbMF0ubGVuZ3RofVwiLz5gO1xuICAgICAgICAgICAgb3B0c0NoYXJ0RGF0YS5sYWJlbHNbMF0uZm9yRWFjaCgobGFiZWwsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSBgPGM6cHQgaWR4PVwiJHtpZHh9XCI+PGM6dj4ke2VuY29kZVhtbEVudGl0aWVzKGxhYmVsKX08L2M6dj48L2M6cHQ+YDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPC9jOnN0ckNhY2hlPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyAgPC9jOnN0clJlZj4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICc8L2M6Y2F0Pic7XG4gICAgICAgICAgICAvLyAzOiBDcmVhdGUgdmFsc1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgIDxjOnZhbD4nO1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPGM6bnVtUmVmPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gYCAgICAgIDxjOmY+U2hlZXQxISRCJDI6JEIkJHtvcHRzQ2hhcnREYXRhLmxhYmVsc1swXS5sZW5ndGggKyAxfTwvYzpmPmA7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyAgICAgIDxjOm51bUNhY2hlPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gYCAgICAgICAgICAgPGM6cHRDb3VudCB2YWw9XCIke29wdHNDaGFydERhdGEubGFiZWxzWzBdLmxlbmd0aH1cIi8+YDtcbiAgICAgICAgICAgIG9wdHNDaGFydERhdGEudmFsdWVzLmZvckVhY2goKHZhbHVlLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYDxjOnB0IGlkeD1cIiR7aWR4fVwiPjxjOnY+JHt2YWx1ZSB8fCB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogJyd9PC9jOnY+PC9jOnB0PmA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0clhtbCArPSAnICAgICAgPC9jOm51bUNhY2hlPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyAgICA8L2M6bnVtUmVmPic7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyAgPC9jOnZhbD4nO1xuICAgICAgICAgICAgLy8gNDogQ2xvc2UgXCJTRVJJRVNcIlxuICAgICAgICAgICAgc3RyWG1sICs9ICcgIDwvYzpzZXI+JztcbiAgICAgICAgICAgIHN0clhtbCArPSBgICA8YzpmaXJzdFNsaWNlQW5nIHZhbD1cIiR7b3B0cy5maXJzdFNsaWNlQW5nID8gTWF0aC5yb3VuZChvcHRzLmZpcnN0U2xpY2VBbmcpIDogMH1cIi8+YDtcbiAgICAgICAgICAgIGlmIChjaGFydFR5cGUgPT09IENIQVJUX1RZUEUuRE9VR0hOVVQpXG4gICAgICAgICAgICAgICAgc3RyWG1sICs9IGA8Yzpob2xlU2l6ZSB2YWw9XCIke3R5cGVvZiBvcHRzLmhvbGVTaXplID09PSAnbnVtYmVyJyA/IG9wdHMuaG9sZVNpemUgOiAnNTAnfVwiLz5gO1xuICAgICAgICAgICAgc3RyWG1sICs9ICc8L2M6JyArIGNoYXJ0VHlwZSArICdDaGFydD4nO1xuICAgICAgICAgICAgLy8gRG9uZSB3aXRoIERvdWdobnV0L1BpZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHN0clhtbDtcbn1cbi8qKlxuICogQ3JlYXRlIENhdGVnb3J5IGF4aXNcbiAqIEBwYXJhbSB7SUNoYXJ0T3B0c0xpYn0gb3B0cyAtIGNoYXJ0IG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzSWQgLSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbEF4aXNJZCAtIHZhbHVlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFhNTFxuICovXG5mdW5jdGlvbiBtYWtlQ2F0QXhpcyhvcHRzLCBheGlzSWQsIHZhbEF4aXNJZCkge1xuICAgIGxldCBzdHJYbWwgPSAnJztcbiAgICAvLyBCdWlsZCBjYXQgYXhpcyB0YWdcbiAgICAvLyBOT1RFOiBTY2F0dGVyIGFuZCBCdWJibGUgY2hhcnQgbmVlZCB0d28gVmFsIGF4aXNlcyBhcyB0aGV5IGRpc3BsYXkgbnVtYmVycyBvbiB4IGF4aXNcbiAgICBpZiAob3B0cy5fdHlwZSA9PT0gQ0hBUlRfVFlQRS5TQ0FUVEVSIHx8IG9wdHMuX3R5cGUgPT09IENIQVJUX1RZUEUuQlVCQkxFIHx8IG9wdHMuX3R5cGUgPT09IENIQVJUX1RZUEUuQlVCQkxFM0QpIHtcbiAgICAgICAgc3RyWG1sICs9ICc8Yzp2YWxBeD4nO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RyWG1sICs9ICc8YzonICsgKG9wdHMuY2F0TGFiZWxGb3JtYXRDb2RlID8gJ2RhdGVBeCcgOiAnY2F0QXgnKSArICc+JztcbiAgICB9XG4gICAgc3RyWG1sICs9ICcgIDxjOmF4SWQgdmFsPVwiJyArIGF4aXNJZCArICdcIi8+JztcbiAgICBzdHJYbWwgKz0gJyAgPGM6c2NhbGluZz4nO1xuICAgIHN0clhtbCArPSAnPGM6b3JpZW50YXRpb24gdmFsPVwiJyArIChvcHRzLmNhdEF4aXNPcmllbnRhdGlvbiB8fCAob3B0cy5iYXJEaXIgPT09ICdjb2wnID8gJ21pbk1heCcgOiAnbWluTWF4JykpICsgJ1wiLz4nO1xuICAgIGlmIChvcHRzLmNhdEF4aXNNYXhWYWwgfHwgb3B0cy5jYXRBeGlzTWF4VmFsID09PSAwKVxuICAgICAgICBzdHJYbWwgKz0gYDxjOm1heCB2YWw9XCIke29wdHMuY2F0QXhpc01heFZhbH1cIi8+YDtcbiAgICBpZiAob3B0cy5jYXRBeGlzTWluVmFsIHx8IG9wdHMuY2F0QXhpc01pblZhbCA9PT0gMClcbiAgICAgICAgc3RyWG1sICs9IGA8YzptaW4gdmFsPVwiJHtvcHRzLmNhdEF4aXNNaW5WYWx9XCIvPmA7XG4gICAgc3RyWG1sICs9ICc8L2M6c2NhbGluZz4nO1xuICAgIHN0clhtbCArPSAnICA8YzpkZWxldGUgdmFsPVwiJyArIChvcHRzLmNhdEF4aXNIaWRkZW4gPyAnMScgOiAnMCcpICsgJ1wiLz4nO1xuICAgIHN0clhtbCArPSAnICA8YzpheFBvcyB2YWw9XCInICsgKG9wdHMuYmFyRGlyID09PSAnY29sJyA/ICdiJyA6ICdsJykgKyAnXCIvPic7XG4gICAgc3RyWG1sICs9IG9wdHMuY2F0R3JpZExpbmUuc3R5bGUgIT09ICdub25lJyA/IGNyZWF0ZUdyaWRMaW5lRWxlbWVudChvcHRzLmNhdEdyaWRMaW5lKSA6ICcnO1xuICAgIC8vICc8Yzp0aXRsZT4nIGNvbWVzIGJldHdlZW4gJzwvYzptYWpvckdyaWRsaW5lcz4nIGFuZCAnPGM6bnVtRm10PidcbiAgICBpZiAob3B0cy5zaG93Q2F0QXhpc1RpdGxlKSB7XG4gICAgICAgIHN0clhtbCArPSBnZW5YbWxUaXRsZSh7XG4gICAgICAgICAgICBjb2xvcjogb3B0cy5jYXRBeGlzVGl0bGVDb2xvcixcbiAgICAgICAgICAgIGZvbnRGYWNlOiBvcHRzLmNhdEF4aXNUaXRsZUZvbnRGYWNlLFxuICAgICAgICAgICAgZm9udFNpemU6IG9wdHMuY2F0QXhpc1RpdGxlRm9udFNpemUsXG4gICAgICAgICAgICB0aXRsZVJvdGF0ZTogb3B0cy5jYXRBeGlzVGl0bGVSb3RhdGUsXG4gICAgICAgICAgICB0aXRsZTogb3B0cy5jYXRBeGlzVGl0bGUgfHwgJ0F4aXMgVGl0bGUnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gTk9URTogQWRkaW5nIFZhbCBBeGlzIEZvcm1hdHRpbmcgaWYgc2NhdHRlciBvciBidWJibGUgY2hhcnRzXG4gICAgaWYgKG9wdHMuX3R5cGUgPT09IENIQVJUX1RZUEUuU0NBVFRFUiB8fCBvcHRzLl90eXBlID09PSBDSEFSVF9UWVBFLkJVQkJMRSB8fCBvcHRzLl90eXBlID09PSBDSEFSVF9UWVBFLkJVQkJMRTNEKSB7XG4gICAgICAgIHN0clhtbCArPSAnICA8YzpudW1GbXQgZm9ybWF0Q29kZT1cIicgKyAob3B0cy52YWxBeGlzTGFiZWxGb3JtYXRDb2RlID8gZW5jb2RlWG1sRW50aXRpZXMob3B0cy52YWxBeGlzTGFiZWxGb3JtYXRDb2RlKSA6ICdHZW5lcmFsJykgKyAnXCIgc291cmNlTGlua2VkPVwiMVwiLz4nO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RyWG1sICs9ICcgIDxjOm51bUZtdCBmb3JtYXRDb2RlPVwiJyArIChlbmNvZGVYbWxFbnRpdGllcyhvcHRzLmNhdExhYmVsRm9ybWF0Q29kZSkgfHwgJ0dlbmVyYWwnKSArICdcIiBzb3VyY2VMaW5rZWQ9XCIxXCIvPic7XG4gICAgfVxuICAgIGlmIChvcHRzLl90eXBlID09PSBDSEFSVF9UWVBFLlNDQVRURVIpIHtcbiAgICAgICAgc3RyWG1sICs9ICcgIDxjOm1ham9yVGlja01hcmsgdmFsPVwibm9uZVwiLz4nO1xuICAgICAgICBzdHJYbWwgKz0gJyAgPGM6bWlub3JUaWNrTWFyayB2YWw9XCJub25lXCIvPic7XG4gICAgICAgIHN0clhtbCArPSAnICA8Yzp0aWNrTGJsUG9zIHZhbD1cIm5leHRUb1wiLz4nO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RyWG1sICs9ICcgIDxjOm1ham9yVGlja01hcmsgdmFsPVwiJyArIChvcHRzLmNhdEF4aXNNYWpvclRpY2tNYXJrIHx8ICdvdXQnKSArICdcIi8+JztcbiAgICAgICAgc3RyWG1sICs9ICcgIDxjOm1pbm9yVGlja01hcmsgdmFsPVwiJyArIChvcHRzLmNhdEF4aXNNaW5vclRpY2tNYXJrIHx8ICdub25lJykgKyAnXCIvPic7XG4gICAgICAgIHN0clhtbCArPSAnICA8Yzp0aWNrTGJsUG9zIHZhbD1cIicgKyAob3B0cy5jYXRBeGlzTGFiZWxQb3MgfHwgKG9wdHMuYmFyRGlyID09PSAnY29sJyA/ICdsb3cnIDogJ25leHRUbycpKSArICdcIi8+JztcbiAgICB9XG4gICAgc3RyWG1sICs9ICcgIDxjOnNwUHI+JztcbiAgICBzdHJYbWwgKz0gYCAgICA8YTpsbiB3PVwiJHtvcHRzLmNhdEF4aXNMaW5lU2l6ZSA/IHZhbFRvUHRzKG9wdHMuY2F0QXhpc0xpbmVTaXplKSA6IE9ORVBUfVwiIGNhcD1cImZsYXRcIj5gO1xuICAgIHN0clhtbCArPSAhb3B0cy5jYXRBeGlzTGluZVNob3cgPyAnPGE6bm9GaWxsLz4nIDogJzxhOnNvbGlkRmlsbD4nICsgY3JlYXRlQ29sb3JFbGVtZW50KG9wdHMuY2F0QXhpc0xpbmVDb2xvciB8fCBERUZfQ0hBUlRfR1JJRExJTkUuY29sb3IpICsgJzwvYTpzb2xpZEZpbGw+JztcbiAgICBzdHJYbWwgKz0gJyAgICAgIDxhOnByc3REYXNoIHZhbD1cIicgKyAob3B0cy5jYXRBeGlzTGluZVN0eWxlIHx8ICdzb2xpZCcpICsgJ1wiLz4nO1xuICAgIHN0clhtbCArPSAnICAgICAgPGE6cm91bmQvPic7XG4gICAgc3RyWG1sICs9ICcgICAgPC9hOmxuPic7XG4gICAgc3RyWG1sICs9ICcgIDwvYzpzcFByPic7XG4gICAgc3RyWG1sICs9ICcgIDxjOnR4UHI+JztcbiAgICBpZiAob3B0cy5jYXRBeGlzTGFiZWxSb3RhdGUpIHtcbiAgICAgICAgc3RyWG1sICs9IGA8YTpib2R5UHIgcm90PVwiJHtjb252ZXJ0Um90YXRpb25EZWdyZWVzKG9wdHMuY2F0QXhpc0xhYmVsUm90YXRlKX1cIi8+YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE5PVEU6IGRvbid0IHNwZWNpZnkgXCJgcm90PTBcIiAtIHRoYXQgd2F5IHRoZSBvYmplY3Qgd2lsbCBiZSBhdXRvIGJlaGF2aW9yXG4gICAgICAgIHN0clhtbCArPSAnPGE6Ym9keVByLz4nO1xuICAgIH1cbiAgICBzdHJYbWwgKz0gJyAgICA8YTpsc3RTdHlsZS8+JztcbiAgICBzdHJYbWwgKz0gJyAgICA8YTpwPic7XG4gICAgc3RyWG1sICs9ICcgICAgPGE6cFByPic7XG4gICAgc3RyWG1sICs9IGAgICAgICA8YTpkZWZSUHIgc3o9XCIke01hdGgucm91bmQoKG9wdHMuY2F0QXhpc0xhYmVsRm9udFNpemUgfHwgREVGX0ZPTlRfU0laRSkgKiAxMDApfVwiIGI9XCIke29wdHMuY2F0QXhpc0xhYmVsRm9udEJvbGQgPyAxIDogMH1cIiBpPVwiJHtvcHRzLmNhdEF4aXNMYWJlbEZvbnRJdGFsaWMgPyAxIDogMH1cIiB1PVwibm9uZVwiIHN0cmlrZT1cIm5vU3RyaWtlXCI+YDtcbiAgICBzdHJYbWwgKz0gJyAgICAgIDxhOnNvbGlkRmlsbD4nICsgY3JlYXRlQ29sb3JFbGVtZW50KG9wdHMuY2F0QXhpc0xhYmVsQ29sb3IgfHwgREVGX0ZPTlRfQ09MT1IpICsgJzwvYTpzb2xpZEZpbGw+JztcbiAgICBzdHJYbWwgKz0gJyAgICAgIDxhOmxhdGluIHR5cGVmYWNlPVwiJyArIChvcHRzLmNhdEF4aXNMYWJlbEZvbnRGYWNlIHx8ICdBcmlhbCcpICsgJ1wiLz4nO1xuICAgIHN0clhtbCArPSAnICAgPC9hOmRlZlJQcj4nO1xuICAgIHN0clhtbCArPSAnICA8L2E6cFByPic7XG4gICAgc3RyWG1sICs9ICcgIDxhOmVuZFBhcmFSUHIgbGFuZz1cIicgKyAob3B0cy5sYW5nIHx8ICdlbi1VUycpICsgJ1wiLz4nO1xuICAgIHN0clhtbCArPSAnICA8L2E6cD4nO1xuICAgIHN0clhtbCArPSAnIDwvYzp0eFByPic7XG4gICAgc3RyWG1sICs9ICcgPGM6Y3Jvc3NBeCB2YWw9XCInICsgdmFsQXhpc0lkICsgJ1wiLz4nO1xuICAgIHN0clhtbCArPSBgIDxjOiR7dHlwZW9mIG9wdHMudmFsQXhpc0Nyb3NzZXNBdCA9PT0gJ251bWJlcicgPyAnY3Jvc3Nlc0F0JyA6ICdjcm9zc2VzJ30gdmFsPVwiJHtvcHRzLnZhbEF4aXNDcm9zc2VzQXQgfHwgJ2F1dG9aZXJvJ31cIi8+YDtcbiAgICBzdHJYbWwgKz0gJyA8YzphdXRvIHZhbD1cIjFcIi8+JztcbiAgICBzdHJYbWwgKz0gJyA8YzpsYmxBbGduIHZhbD1cImN0clwiLz4nO1xuICAgIHN0clhtbCArPSBgIDxjOm5vTXVsdGlMdmxMYmwgdmFsPVwiJHtvcHRzLmNhdEF4aXNNdWx0aUxldmVsTGFiZWxzID8gMCA6IDF9XCIvPmA7XG4gICAgaWYgKG9wdHMuY2F0QXhpc0xhYmVsRnJlcXVlbmN5KVxuICAgICAgICBzdHJYbWwgKz0gJyA8Yzp0aWNrTGJsU2tpcCB2YWw9XCInICsgb3B0cy5jYXRBeGlzTGFiZWxGcmVxdWVuY3kgKyAnXCIvPic7XG4gICAgLy8gSXNzdWUjMTQ5OiBQUFQgd2lsbCBhdXRvLWFkanVzdCB0aGVzZSBhcyBuZWVkZWQgYWZ0ZXIgY2FsY2luZyB0aGUgZGF0ZSBib3VuZHMsIHNvIHdlIG9ubHkgaW5jbHVkZSB0aGVtIHdoZW4gc3BlY2lmaWVkIGJ5IHVzZXJcbiAgICAvLyBBbGxvdyBtYWpvciBhbmQgbWlub3IgdW5pdHMgdG8gYmUgc2V0IGZvciBkb3VibGUgdmFsdWUgYXhpcyBjaGFydHNcbiAgICBpZiAob3B0cy5jYXRMYWJlbEZvcm1hdENvZGUgfHwgb3B0cy5fdHlwZSA9PT0gQ0hBUlRfVFlQRS5TQ0FUVEVSIHx8IG9wdHMuX3R5cGUgPT09IENIQVJUX1RZUEUuQlVCQkxFIHx8IG9wdHMuX3R5cGUgPT09IENIQVJUX1RZUEUuQlVCQkxFM0QpIHtcbiAgICAgICAgaWYgKG9wdHMuY2F0TGFiZWxGb3JtYXRDb2RlKSB7XG4gICAgICAgICAgICBbJ2NhdEF4aXNCYXNlVGltZVVuaXQnLCAnY2F0QXhpc01ham9yVGltZVVuaXQnLCAnY2F0QXhpc01pbm9yVGltZVVuaXQnXS5mb3JFYWNoKG9wdCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgaW5wdXQgYXMgcG9vcmx5IGNob3Nlbi9nYXJiYWdlIG9wdGlvbnMgd2lsbCBjYXVzZSBjaGFydCBjb3JydXB0aW9uIGFuZCBpdCB3b250IHJlbmRlciBhdCBhbGwhXG4gICAgICAgICAgICAgICAgaWYgKG9wdHNbb3B0XSAmJiAodHlwZW9mIG9wdHNbb3B0XSAhPT0gJ3N0cmluZycgfHwgIVsnZGF5cycsICdtb250aHMnLCAneWVhcnMnXS5pbmNsdWRlcyhvcHRzW29wdF0udG9Mb3dlckNhc2UoKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgXCIke29wdH1cIiBtdXN0IGJlIG9uZSBvZjogJ2RheXMnLCdtb250aHMnLCd5ZWFycycgIWApO1xuICAgICAgICAgICAgICAgICAgICBvcHRzW29wdF0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG9wdHMuY2F0QXhpc0Jhc2VUaW1lVW5pdClcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxjOmJhc2VUaW1lVW5pdCB2YWw9XCInICsgb3B0cy5jYXRBeGlzQmFzZVRpbWVVbml0LnRvTG93ZXJDYXNlKCkgKyAnXCIvPic7XG4gICAgICAgICAgICBpZiAob3B0cy5jYXRBeGlzTWFqb3JUaW1lVW5pdClcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxjOm1ham9yVGltZVVuaXQgdmFsPVwiJyArIG9wdHMuY2F0QXhpc01ham9yVGltZVVuaXQudG9Mb3dlckNhc2UoKSArICdcIi8+JztcbiAgICAgICAgICAgIGlmIChvcHRzLmNhdEF4aXNNaW5vclRpbWVVbml0KVxuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPGM6bWlub3JUaW1lVW5pdCB2YWw9XCInICsgb3B0cy5jYXRBeGlzTWlub3JUaW1lVW5pdC50b0xvd2VyQ2FzZSgpICsgJ1wiLz4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmNhdEF4aXNNYWpvclVuaXQpXG4gICAgICAgICAgICBzdHJYbWwgKz0gYDxjOm1ham9yVW5pdCB2YWw9XCIke29wdHMuY2F0QXhpc01ham9yVW5pdH1cIi8+YDtcbiAgICAgICAgaWYgKG9wdHMuY2F0QXhpc01pbm9yVW5pdClcbiAgICAgICAgICAgIHN0clhtbCArPSBgPGM6bWlub3JVbml0IHZhbD1cIiR7b3B0cy5jYXRBeGlzTWlub3JVbml0fVwiLz5gO1xuICAgIH1cbiAgICAvLyBDbG9zZSBjYXQgYXhpcyB0YWdcbiAgICAvLyBOT1RFOiBBZGRlZCBjbG9zaW5nIHRhZyBvZiB2YWwgb3IgY2F0IGF4aXMgYmFzZWQgb24gY2hhcnQgdHlwZVxuICAgIGlmIChvcHRzLl90eXBlID09PSBDSEFSVF9UWVBFLlNDQVRURVIgfHwgb3B0cy5fdHlwZSA9PT0gQ0hBUlRfVFlQRS5CVUJCTEUgfHwgb3B0cy5fdHlwZSA9PT0gQ0hBUlRfVFlQRS5CVUJCTEUzRCkge1xuICAgICAgICBzdHJYbWwgKz0gJzwvYzp2YWxBeD4nO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RyWG1sICs9ICc8L2M6JyArIChvcHRzLmNhdExhYmVsRm9ybWF0Q29kZSA/ICdkYXRlQXgnIDogJ2NhdEF4JykgKyAnPic7XG4gICAgfVxuICAgIHJldHVybiBzdHJYbWw7XG59XG4vKipcbiAqIENyZWF0ZSBWYWx1ZSBBeGlzIChVc2VkIGJ5IGBiYXIzRGApXG4gKiBAcGFyYW0ge0lDaGFydE9wdHNMaWJ9IG9wdHMgLSBjaGFydCBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsQXhpc0lkIC0gdmFsdWVcbiAqIEByZXR1cm4ge3N0cmluZ30gWE1MXG4gKi9cbmZ1bmN0aW9uIG1ha2VWYWxBeGlzKG9wdHMsIHZhbEF4aXNJZCkge1xuICAgIGxldCBheGlzUG9zID0gdmFsQXhpc0lkID09PSBBWElTX0lEX1ZBTFVFX1BSSU1BUlkgPyAob3B0cy5iYXJEaXIgPT09ICdjb2wnID8gJ2wnIDogJ2InKSA6IG9wdHMuYmFyRGlyICE9PSAnY29sJyA/ICdyJyA6ICd0JztcbiAgICBpZiAodmFsQXhpc0lkID09PSBBWElTX0lEX1ZBTFVFX1NFQ09OREFSWSlcbiAgICAgICAgYXhpc1BvcyA9ICdyJzsgLy8gZGVmYXVsdCBiZWhhdmlvciBmb3IgUFBUIGlzIHNob3dpbmcgMm5kIHZhbCBheGlzIG9uIHJpZ2h0IChwcmltYXJ5IGF4aXMgb24gbGVmdClcbiAgICBjb25zdCBjcm9zc0F4SWQgPSB2YWxBeGlzSWQgPT09IEFYSVNfSURfVkFMVUVfUFJJTUFSWSA/IEFYSVNfSURfQ0FURUdPUllfUFJJTUFSWSA6IEFYSVNfSURfQ0FURUdPUllfU0VDT05EQVJZO1xuICAgIGxldCBzdHJYbWwgPSAnJztcbiAgICBzdHJYbWwgKz0gJzxjOnZhbEF4Pic7XG4gICAgc3RyWG1sICs9ICcgIDxjOmF4SWQgdmFsPVwiJyArIHZhbEF4aXNJZCArICdcIi8+JztcbiAgICBzdHJYbWwgKz0gJyAgPGM6c2NhbGluZz4nO1xuICAgIGlmIChvcHRzLnZhbEF4aXNMb2dTY2FsZUJhc2UpXG4gICAgICAgIHN0clhtbCArPSBgPGM6bG9nQmFzZSB2YWw9XCIke29wdHMudmFsQXhpc0xvZ1NjYWxlQmFzZX1cIi8+YDtcbiAgICBzdHJYbWwgKz0gJzxjOm9yaWVudGF0aW9uIHZhbD1cIicgKyAob3B0cy52YWxBeGlzT3JpZW50YXRpb24gfHwgKG9wdHMuYmFyRGlyID09PSAnY29sJyA/ICdtaW5NYXgnIDogJ21pbk1heCcpKSArICdcIi8+JztcbiAgICBpZiAob3B0cy52YWxBeGlzTWF4VmFsIHx8IG9wdHMudmFsQXhpc01heFZhbCA9PT0gMClcbiAgICAgICAgc3RyWG1sICs9IGA8YzptYXggdmFsPVwiJHtvcHRzLnZhbEF4aXNNYXhWYWx9XCIvPmA7XG4gICAgaWYgKG9wdHMudmFsQXhpc01pblZhbCB8fCBvcHRzLnZhbEF4aXNNaW5WYWwgPT09IDApXG4gICAgICAgIHN0clhtbCArPSBgPGM6bWluIHZhbD1cIiR7b3B0cy52YWxBeGlzTWluVmFsfVwiLz5gO1xuICAgIHN0clhtbCArPSAnICA8L2M6c2NhbGluZz4nO1xuICAgIHN0clhtbCArPSBgICA8YzpkZWxldGUgdmFsPVwiJHtvcHRzLnZhbEF4aXNIaWRkZW4gPyAxIDogMH1cIi8+YDtcbiAgICBzdHJYbWwgKz0gJyAgPGM6YXhQb3MgdmFsPVwiJyArIGF4aXNQb3MgKyAnXCIvPic7XG4gICAgaWYgKG9wdHMudmFsR3JpZExpbmUuc3R5bGUgIT09ICdub25lJylcbiAgICAgICAgc3RyWG1sICs9IGNyZWF0ZUdyaWRMaW5lRWxlbWVudChvcHRzLnZhbEdyaWRMaW5lKTtcbiAgICAvLyAnPGM6dGl0bGU+JyBjb21lcyBiZXR3ZWVuICc8L2M6bWFqb3JHcmlkbGluZXM+JyBhbmQgJzxjOm51bUZtdD4nXG4gICAgaWYgKG9wdHMuc2hvd1ZhbEF4aXNUaXRsZSkge1xuICAgICAgICBzdHJYbWwgKz0gZ2VuWG1sVGl0bGUoe1xuICAgICAgICAgICAgY29sb3I6IG9wdHMudmFsQXhpc1RpdGxlQ29sb3IsXG4gICAgICAgICAgICBmb250RmFjZTogb3B0cy52YWxBeGlzVGl0bGVGb250RmFjZSxcbiAgICAgICAgICAgIGZvbnRTaXplOiBvcHRzLnZhbEF4aXNUaXRsZUZvbnRTaXplLFxuICAgICAgICAgICAgdGl0bGVSb3RhdGU6IG9wdHMudmFsQXhpc1RpdGxlUm90YXRlLFxuICAgICAgICAgICAgdGl0bGU6IG9wdHMudmFsQXhpc1RpdGxlIHx8ICdBeGlzIFRpdGxlJyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0clhtbCArPSBgPGM6bnVtRm10IGZvcm1hdENvZGU9XCIke29wdHMudmFsQXhpc0xhYmVsRm9ybWF0Q29kZSA/IGVuY29kZVhtbEVudGl0aWVzKG9wdHMudmFsQXhpc0xhYmVsRm9ybWF0Q29kZSkgOiAnR2VuZXJhbCd9XCIgc291cmNlTGlua2VkPVwiMFwiLz5gO1xuICAgIGlmIChvcHRzLl90eXBlID09PSBDSEFSVF9UWVBFLlNDQVRURVIpIHtcbiAgICAgICAgc3RyWG1sICs9ICcgIDxjOm1ham9yVGlja01hcmsgdmFsPVwibm9uZVwiLz4nO1xuICAgICAgICBzdHJYbWwgKz0gJyAgPGM6bWlub3JUaWNrTWFyayB2YWw9XCJub25lXCIvPic7XG4gICAgICAgIHN0clhtbCArPSAnICA8Yzp0aWNrTGJsUG9zIHZhbD1cIm5leHRUb1wiLz4nO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RyWG1sICs9ICcgPGM6bWFqb3JUaWNrTWFyayB2YWw9XCInICsgKG9wdHMudmFsQXhpc01ham9yVGlja01hcmsgfHwgJ291dCcpICsgJ1wiLz4nO1xuICAgICAgICBzdHJYbWwgKz0gJyA8YzptaW5vclRpY2tNYXJrIHZhbD1cIicgKyAob3B0cy52YWxBeGlzTWlub3JUaWNrTWFyayB8fCAnbm9uZScpICsgJ1wiLz4nO1xuICAgICAgICBzdHJYbWwgKz0gJyA8Yzp0aWNrTGJsUG9zIHZhbD1cIicgKyAob3B0cy52YWxBeGlzTGFiZWxQb3MgfHwgKG9wdHMuYmFyRGlyID09PSAnY29sJyA/ICduZXh0VG8nIDogJ2xvdycpKSArICdcIi8+JztcbiAgICB9XG4gICAgc3RyWG1sICs9ICcgPGM6c3BQcj4nO1xuICAgIHN0clhtbCArPSBgICAgPGE6bG4gdz1cIiR7b3B0cy52YWxBeGlzTGluZVNpemUgPyB2YWxUb1B0cyhvcHRzLnZhbEF4aXNMaW5lU2l6ZSkgOiBPTkVQVH1cIiBjYXA9XCJmbGF0XCI+YDtcbiAgICBzdHJYbWwgKz0gIW9wdHMudmFsQXhpc0xpbmVTaG93ID8gJzxhOm5vRmlsbC8+JyA6ICc8YTpzb2xpZEZpbGw+JyArIGNyZWF0ZUNvbG9yRWxlbWVudChvcHRzLnZhbEF4aXNMaW5lQ29sb3IgfHwgREVGX0NIQVJUX0dSSURMSU5FLmNvbG9yKSArICc8L2E6c29saWRGaWxsPic7XG4gICAgc3RyWG1sICs9ICcgICAgIDxhOnByc3REYXNoIHZhbD1cIicgKyAob3B0cy52YWxBeGlzTGluZVN0eWxlIHx8ICdzb2xpZCcpICsgJ1wiLz4nO1xuICAgIHN0clhtbCArPSAnICAgICA8YTpyb3VuZC8+JztcbiAgICBzdHJYbWwgKz0gJyAgIDwvYTpsbj4nO1xuICAgIHN0clhtbCArPSAnIDwvYzpzcFByPic7XG4gICAgc3RyWG1sICs9ICcgPGM6dHhQcj4nO1xuICAgIHN0clhtbCArPSBgICA8YTpib2R5UHIke29wdHMudmFsQXhpc0xhYmVsUm90YXRlID8gKCcgcm90PVwiJyArIGNvbnZlcnRSb3RhdGlvbkRlZ3JlZXMob3B0cy52YWxBeGlzTGFiZWxSb3RhdGUpLnRvU3RyaW5nKCkgKyAnXCInKSA6ICcnfS8+YDsgLy8gZG9uJ3Qgc3BlY2lmeSByb3QgMCBzbyB3ZSBnZXQgdGhlIGF1dG8gYmVoYXZpb3JcbiAgICBzdHJYbWwgKz0gJyAgPGE6bHN0U3R5bGUvPic7XG4gICAgc3RyWG1sICs9ICcgIDxhOnA+JztcbiAgICBzdHJYbWwgKz0gJyAgICA8YTpwUHI+JztcbiAgICBzdHJYbWwgKz0gYCAgICAgIDxhOmRlZlJQciBzej1cIiR7TWF0aC5yb3VuZCgob3B0cy52YWxBeGlzTGFiZWxGb250U2l6ZSB8fCBERUZfRk9OVF9TSVpFKSAqIDEwMCl9XCIgYj1cIiR7b3B0cy52YWxBeGlzTGFiZWxGb250Qm9sZCA/IDEgOiAwfVwiIGk9XCIke29wdHMudmFsQXhpc0xhYmVsRm9udEl0YWxpYyA/IDEgOiAwfVwiIHU9XCJub25lXCIgc3RyaWtlPVwibm9TdHJpa2VcIj5gO1xuICAgIHN0clhtbCArPSAnICAgICAgICA8YTpzb2xpZEZpbGw+JyArIGNyZWF0ZUNvbG9yRWxlbWVudChvcHRzLnZhbEF4aXNMYWJlbENvbG9yIHx8IERFRl9GT05UX0NPTE9SKSArICc8L2E6c29saWRGaWxsPic7XG4gICAgc3RyWG1sICs9ICcgICAgICAgIDxhOmxhdGluIHR5cGVmYWNlPVwiJyArIChvcHRzLnZhbEF4aXNMYWJlbEZvbnRGYWNlIHx8ICdBcmlhbCcpICsgJ1wiLz4nO1xuICAgIHN0clhtbCArPSAnICAgICAgPC9hOmRlZlJQcj4nO1xuICAgIHN0clhtbCArPSAnICAgIDwvYTpwUHI+JztcbiAgICBzdHJYbWwgKz0gJyAgPGE6ZW5kUGFyYVJQciBsYW5nPVwiJyArIChvcHRzLmxhbmcgfHwgJ2VuLVVTJykgKyAnXCIvPic7XG4gICAgc3RyWG1sICs9ICcgIDwvYTpwPic7XG4gICAgc3RyWG1sICs9ICcgPC9jOnR4UHI+JztcbiAgICBzdHJYbWwgKz0gJyA8Yzpjcm9zc0F4IHZhbD1cIicgKyBjcm9zc0F4SWQgKyAnXCIvPic7XG4gICAgaWYgKHR5cGVvZiBvcHRzLmNhdEF4aXNDcm9zc2VzQXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHN0clhtbCArPSBgIDxjOmNyb3NzZXNBdCB2YWw9XCIke29wdHMuY2F0QXhpc0Nyb3NzZXNBdH1cIi8+YDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9wdHMuY2F0QXhpc0Nyb3NzZXNBdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3RyWG1sICs9ICcgPGM6Y3Jvc3NlcyB2YWw9XCInICsgb3B0cy5jYXRBeGlzQ3Jvc3Nlc0F0ICsgJ1wiLz4nO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgaXNSaWdodCA9IGF4aXNQb3MgPT09ICdyJyB8fCBheGlzUG9zID09PSAndCc7XG4gICAgICAgIGNvbnN0IGNyb3NzZXMgPSBpc1JpZ2h0ID8gJ21heCcgOiAnYXV0b1plcm8nO1xuICAgICAgICBzdHJYbWwgKz0gJyA8Yzpjcm9zc2VzIHZhbD1cIicgKyBjcm9zc2VzICsgJ1wiLz4nO1xuICAgIH1cbiAgICBzdHJYbWwgKz1cbiAgICAgICAgJyA8Yzpjcm9zc0JldHdlZW4gdmFsPVwiJyArXG4gICAgICAgICAgICAob3B0cy5fdHlwZSA9PT0gQ0hBUlRfVFlQRS5TQ0FUVEVSIHx8ICghIShBcnJheS5pc0FycmF5KG9wdHMuX3R5cGUpICYmIG9wdHMuX3R5cGUuZmlsdGVyKHR5cGUgPT4gdHlwZS50eXBlID09PSBDSEFSVF9UWVBFLkFSRUEpLmxlbmd0aCA+IDApKSA/ICdtaWRDYXQnIDogJ2JldHdlZW4nKSArXG4gICAgICAgICAgICAnXCIvPic7XG4gICAgaWYgKG9wdHMudmFsQXhpc01ham9yVW5pdClcbiAgICAgICAgc3RyWG1sICs9IGAgPGM6bWFqb3JVbml0IHZhbD1cIiR7b3B0cy52YWxBeGlzTWFqb3JVbml0fVwiLz5gO1xuICAgIGlmIChvcHRzLnZhbEF4aXNEaXNwbGF5VW5pdCkge1xuICAgICAgICBzdHJYbWwgKz0gYDxjOmRpc3BVbml0cz48YzpidWlsdEluVW5pdCB2YWw9XCIke29wdHMudmFsQXhpc0Rpc3BsYXlVbml0fVwiLz4ke29wdHMudmFsQXhpc0Rpc3BsYXlVbml0TGFiZWwgPyAnPGM6ZGlzcFVuaXRzTGJsLz4nIDogJyd9PC9jOmRpc3BVbml0cz5gO1xuICAgIH1cbiAgICBzdHJYbWwgKz0gJzwvYzp2YWxBeD4nO1xuICAgIHJldHVybiBzdHJYbWw7XG59XG4vKipcbiAqIENyZWF0ZSBTZXJpZXMgQXhpcyAoVXNlZCBieSBgYmFyM0RgKVxuICogQHBhcmFtIHtJQ2hhcnRPcHRzTGlifSBvcHRzIC0gY2hhcnQgb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXNJZCAtIGF4aXMgSURcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWxBeGlzSWQgLSB2YWx1ZVxuICogQHJldHVybiB7c3RyaW5nfSBYTUxcbiAqL1xuZnVuY3Rpb24gbWFrZVNlckF4aXMob3B0cywgYXhpc0lkLCB2YWxBeGlzSWQpIHtcbiAgICBsZXQgc3RyWG1sID0gJyc7XG4gICAgLy8gQnVpbGQgc2VyIGF4aXMgdGFnXG4gICAgc3RyWG1sICs9ICc8YzpzZXJBeD4nO1xuICAgIHN0clhtbCArPSAnICA8YzpheElkIHZhbD1cIicgKyBheGlzSWQgKyAnXCIvPic7XG4gICAgc3RyWG1sICs9ICcgIDxjOnNjYWxpbmc+PGM6b3JpZW50YXRpb24gdmFsPVwiJyArIChvcHRzLnNlckF4aXNPcmllbnRhdGlvbiB8fCAob3B0cy5iYXJEaXIgPT09ICdjb2wnID8gJ21pbk1heCcgOiAnbWluTWF4JykpICsgJ1wiLz48L2M6c2NhbGluZz4nO1xuICAgIHN0clhtbCArPSAnICA8YzpkZWxldGUgdmFsPVwiJyArIChvcHRzLnNlckF4aXNIaWRkZW4gPyAnMScgOiAnMCcpICsgJ1wiLz4nO1xuICAgIHN0clhtbCArPSAnICA8YzpheFBvcyB2YWw9XCInICsgKG9wdHMuYmFyRGlyID09PSAnY29sJyA/ICdiJyA6ICdsJykgKyAnXCIvPic7XG4gICAgc3RyWG1sICs9IG9wdHMuc2VyR3JpZExpbmUuc3R5bGUgIT09ICdub25lJyA/IGNyZWF0ZUdyaWRMaW5lRWxlbWVudChvcHRzLnNlckdyaWRMaW5lKSA6ICcnO1xuICAgIC8vICc8Yzp0aXRsZT4nIGNvbWVzIGJldHdlZW4gJzwvYzptYWpvckdyaWRsaW5lcz4nIGFuZCAnPGM6bnVtRm10PidcbiAgICBpZiAob3B0cy5zaG93U2VyQXhpc1RpdGxlKSB7XG4gICAgICAgIHN0clhtbCArPSBnZW5YbWxUaXRsZSh7XG4gICAgICAgICAgICBjb2xvcjogb3B0cy5zZXJBeGlzVGl0bGVDb2xvcixcbiAgICAgICAgICAgIGZvbnRGYWNlOiBvcHRzLnNlckF4aXNUaXRsZUZvbnRGYWNlLFxuICAgICAgICAgICAgZm9udFNpemU6IG9wdHMuc2VyQXhpc1RpdGxlRm9udFNpemUsXG4gICAgICAgICAgICB0aXRsZVJvdGF0ZTogb3B0cy5zZXJBeGlzVGl0bGVSb3RhdGUsXG4gICAgICAgICAgICB0aXRsZTogb3B0cy5zZXJBeGlzVGl0bGUgfHwgJ0F4aXMgVGl0bGUnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RyWG1sICs9IGAgIDxjOm51bUZtdCBmb3JtYXRDb2RlPVwiJHtlbmNvZGVYbWxFbnRpdGllcyhvcHRzLnNlckxhYmVsRm9ybWF0Q29kZSkgfHwgJ0dlbmVyYWwnfVwiIHNvdXJjZUxpbmtlZD1cIjBcIi8+YDtcbiAgICBzdHJYbWwgKz0gJyAgPGM6bWFqb3JUaWNrTWFyayB2YWw9XCJvdXRcIi8+JztcbiAgICBzdHJYbWwgKz0gJyAgPGM6bWlub3JUaWNrTWFyayB2YWw9XCJub25lXCIvPic7XG4gICAgc3RyWG1sICs9IGAgIDxjOnRpY2tMYmxQb3MgdmFsPVwiJHtvcHRzLnNlckF4aXNMYWJlbFBvcyB8fCBvcHRzLmJhckRpciA9PT0gJ2NvbCcgPyAnbG93JyA6ICduZXh0VG8nfVwiLz5gO1xuICAgIHN0clhtbCArPSAnICA8YzpzcFByPic7XG4gICAgc3RyWG1sICs9ICcgICAgPGE6bG4gdz1cIjEyNzAwXCIgY2FwPVwiZmxhdFwiPic7XG4gICAgc3RyWG1sICs9ICFvcHRzLnNlckF4aXNMaW5lU2hvdyA/ICc8YTpub0ZpbGwvPicgOiBgPGE6c29saWRGaWxsPiR7Y3JlYXRlQ29sb3JFbGVtZW50KG9wdHMuc2VyQXhpc0xpbmVDb2xvciB8fCBERUZfQ0hBUlRfR1JJRExJTkUuY29sb3IpfTwvYTpzb2xpZEZpbGw+YDtcbiAgICBzdHJYbWwgKz0gJyAgICAgIDxhOnByc3REYXNoIHZhbD1cInNvbGlkXCIvPic7XG4gICAgc3RyWG1sICs9ICcgICAgICA8YTpyb3VuZC8+JztcbiAgICBzdHJYbWwgKz0gJyAgICA8L2E6bG4+JztcbiAgICBzdHJYbWwgKz0gJyAgPC9jOnNwUHI+JztcbiAgICBzdHJYbWwgKz0gJyAgPGM6dHhQcj4nO1xuICAgIHN0clhtbCArPSAnICAgIDxhOmJvZHlQci8+JzsgLy8gZG9uJ3Qgc3BlY2lmeSByb3QgMCBzbyB3ZSBnZXQgdGhlIGF1dG8gYmVoYXZpb3JcbiAgICBzdHJYbWwgKz0gJyAgICA8YTpsc3RTdHlsZS8+JztcbiAgICBzdHJYbWwgKz0gJyAgICA8YTpwPic7XG4gICAgc3RyWG1sICs9ICcgICAgPGE6cFByPic7XG4gICAgc3RyWG1sICs9IGAgICAgPGE6ZGVmUlByIHN6PVwiJHtNYXRoLnJvdW5kKChvcHRzLnNlckF4aXNMYWJlbEZvbnRTaXplIHx8IERFRl9GT05UX1NJWkUpICogMTAwKX1cIiBiPVwiJHtvcHRzLnNlckF4aXNMYWJlbEZvbnRCb2xkID8gJzEnIDogJzAnfVwiIGk9XCIke29wdHMuc2VyQXhpc0xhYmVsRm9udEl0YWxpYyA/ICcxJyA6ICcwJ31cIiB1PVwibm9uZVwiIHN0cmlrZT1cIm5vU3RyaWtlXCI+YDtcbiAgICBzdHJYbWwgKz0gYCAgICAgIDxhOnNvbGlkRmlsbD4ke2NyZWF0ZUNvbG9yRWxlbWVudChvcHRzLnNlckF4aXNMYWJlbENvbG9yIHx8IERFRl9GT05UX0NPTE9SKX08L2E6c29saWRGaWxsPmA7XG4gICAgc3RyWG1sICs9IGAgICAgICA8YTpsYXRpbiB0eXBlZmFjZT1cIiR7b3B0cy5zZXJBeGlzTGFiZWxGb250RmFjZSB8fCAnQXJpYWwnfVwiLz5gO1xuICAgIHN0clhtbCArPSAnICAgPC9hOmRlZlJQcj4nO1xuICAgIHN0clhtbCArPSAnICA8L2E6cFByPic7XG4gICAgc3RyWG1sICs9ICcgIDxhOmVuZFBhcmFSUHIgbGFuZz1cIicgKyAob3B0cy5sYW5nIHx8ICdlbi1VUycpICsgJ1wiLz4nO1xuICAgIHN0clhtbCArPSAnICA8L2E6cD4nO1xuICAgIHN0clhtbCArPSAnIDwvYzp0eFByPic7XG4gICAgc3RyWG1sICs9ICcgPGM6Y3Jvc3NBeCB2YWw9XCInICsgdmFsQXhpc0lkICsgJ1wiLz4nO1xuICAgIHN0clhtbCArPSAnIDxjOmNyb3NzZXMgdmFsPVwiYXV0b1plcm9cIi8+JztcbiAgICBpZiAob3B0cy5zZXJBeGlzTGFiZWxGcmVxdWVuY3kpXG4gICAgICAgIHN0clhtbCArPSAnIDxjOnRpY2tMYmxTa2lwIHZhbD1cIicgKyBvcHRzLnNlckF4aXNMYWJlbEZyZXF1ZW5jeSArICdcIi8+JztcbiAgICAvLyBJc3N1ZSMxNDk6IFBQVCB3aWxsIGF1dG8tYWRqdXN0IHRoZXNlIGFzIG5lZWRlZCBhZnRlciBjYWxjaW5nIHRoZSBkYXRlIGJvdW5kcywgc28gd2Ugb25seSBpbmNsdWRlIHRoZW0gd2hlbiBzcGVjaWZpZWQgYnkgdXNlclxuICAgIGlmIChvcHRzLnNlckxhYmVsRm9ybWF0Q29kZSkge1xuICAgICAgICBbJ3NlckF4aXNCYXNlVGltZVVuaXQnLCAnc2VyQXhpc01ham9yVGltZVVuaXQnLCAnc2VyQXhpc01pbm9yVGltZVVuaXQnXS5mb3JFYWNoKG9wdCA9PiB7XG4gICAgICAgICAgICAvLyBWYWxpZGF0ZSBpbnB1dCBhcyBwb29ybHkgY2hvc2VuL2dhcmJhZ2Ugb3B0aW9ucyB3aWxsIGNhdXNlIGNoYXJ0IGNvcnJ1cHRpb24gYW5kIGl0IHdvbnQgcmVuZGVyIGF0IGFsbCFcbiAgICAgICAgICAgIGlmIChvcHRzW29wdF0gJiYgKHR5cGVvZiBvcHRzW29wdF0gIT09ICdzdHJpbmcnIHx8ICFbJ2RheXMnLCAnbW9udGhzJywgJ3llYXJzJ10uaW5jbHVkZXMob3B0LnRvTG93ZXJDYXNlKCkpKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgXCIke29wdH1cIiBtdXN0IGJlIG9uZSBvZjogJ2RheXMnLCdtb250aHMnLCd5ZWFycycgIWApO1xuICAgICAgICAgICAgICAgIG9wdHNbb3B0XSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3B0cy5zZXJBeGlzQmFzZVRpbWVVbml0KVxuICAgICAgICAgICAgc3RyWG1sICs9IGAgPGM6YmFzZVRpbWVVbml0ICB2YWw9XCIke29wdHMuc2VyQXhpc0Jhc2VUaW1lVW5pdC50b0xvd2VyQ2FzZSgpfVwiLz5gO1xuICAgICAgICBpZiAob3B0cy5zZXJBeGlzTWFqb3JUaW1lVW5pdClcbiAgICAgICAgICAgIHN0clhtbCArPSBgIDxjOm1ham9yVGltZVVuaXQgdmFsPVwiJHtvcHRzLnNlckF4aXNNYWpvclRpbWVVbml0LnRvTG93ZXJDYXNlKCl9XCIvPmA7XG4gICAgICAgIGlmIChvcHRzLnNlckF4aXNNaW5vclRpbWVVbml0KVxuICAgICAgICAgICAgc3RyWG1sICs9IGAgPGM6bWlub3JUaW1lVW5pdCB2YWw9XCIke29wdHMuc2VyQXhpc01pbm9yVGltZVVuaXQudG9Mb3dlckNhc2UoKX1cIi8+YDtcbiAgICAgICAgaWYgKG9wdHMuc2VyQXhpc01ham9yVW5pdClcbiAgICAgICAgICAgIHN0clhtbCArPSBgIDxjOm1ham9yVW5pdCB2YWw9XCIke29wdHMuc2VyQXhpc01ham9yVW5pdH1cIi8+YDtcbiAgICAgICAgaWYgKG9wdHMuc2VyQXhpc01pbm9yVW5pdClcbiAgICAgICAgICAgIHN0clhtbCArPSBgIDxjOm1pbm9yVW5pdCB2YWw9XCIke29wdHMuc2VyQXhpc01pbm9yVW5pdH1cIi8+YDtcbiAgICB9XG4gICAgLy8gQ2xvc2Ugc2VyIGF4aXMgdGFnXG4gICAgc3RyWG1sICs9ICc8L2M6c2VyQXg+JztcbiAgICByZXR1cm4gc3RyWG1sO1xufVxuLyoqXG4gKiBDcmVhdGUgY2hhciB0aXRsZSBlbGVtZW50c1xuICogQHBhcmFtIHtJQ2hhcnRQcm9wc1RpdGxlfSBvcHRzIC0gb3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfSBYTUwgYDxjOnRpdGxlPmBcbiAqL1xuZnVuY3Rpb24gZ2VuWG1sVGl0bGUob3B0cywgY2hhcnRYLCBjaGFydFkpIHtcbiAgICBjb25zdCBhbGlnbiA9IG9wdHMudGl0bGVBbGlnbiA9PT0gJ2xlZnQnIHx8IG9wdHMudGl0bGVBbGlnbiA9PT0gJ3JpZ2h0JyA/IGA8YTpwUHIgYWxnbj1cIiR7b3B0cy50aXRsZUFsaWduLnN1YnN0cmluZygwLCAxKX1cIj5gIDogJzxhOnBQcj4nO1xuICAgIGNvbnN0IHJvdGF0ZSA9IG9wdHMudGl0bGVSb3RhdGUgPyBgPGE6Ym9keVByIHJvdD1cIiR7Y29udmVydFJvdGF0aW9uRGVncmVlcyhvcHRzLnRpdGxlUm90YXRlKX1cIi8+YCA6ICc8YTpib2R5UHIvPic7IC8vIGRvbid0IHNwZWNpZnkgcm90YXRpb24gdG8gZ2V0IGRlZmF1bHQgKGV4LiB2ZXJ0aWNhbCBmb3IgY2F0IGF4aXMpXG4gICAgY29uc3Qgc2l6ZUF0dHIgPSBvcHRzLmZvbnRTaXplID8gYHN6PVwiJHtNYXRoLnJvdW5kKG9wdHMuZm9udFNpemUgKiAxMDApfVwiYCA6ICcnOyAvLyBvbmx5IHNldCB0aGUgZm9udCBzaXplIGlmIHNwZWNpZmllZC4gIFBvd2VycG9pbnQgd2lsbCBoYW5kbGUgdGhlIGRlZmF1bHQgc2l6ZVxuICAgIGNvbnN0IHRpdGxlQm9sZCA9IG9wdHMudGl0bGVCb2xkID8gMSA6IDA7XG4gICAgbGV0IGxheW91dCA9ICc8YzpsYXlvdXQvPic7XG4gICAgaWYgKG9wdHMudGl0bGVQb3MgJiYgdHlwZW9mIG9wdHMudGl0bGVQb3MueCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9wdHMudGl0bGVQb3MueSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gTk9URTogbWFudWFsTGF5b3V0IHgveSB2YWxzIGFyZSAqcmVsYXRpdmUgdG8gZW50aXJlIHNsaWRlKlxuICAgICAgICBjb25zdCB0b3RhbFggPSBvcHRzLnRpdGxlUG9zLnggKyBjaGFydFg7XG4gICAgICAgIGNvbnN0IHRvdGFsWSA9IG9wdHMudGl0bGVQb3MueSArIGNoYXJ0WTtcbiAgICAgICAgbGV0IHZhbFggPSB0b3RhbFggPT09IDAgPyAwIDogKHRvdGFsWCAqICh0b3RhbFggLyA1KSkgLyAxMDtcbiAgICAgICAgaWYgKHZhbFggPj0gMSlcbiAgICAgICAgICAgIHZhbFggPSB2YWxYIC8gMTA7XG4gICAgICAgIGlmICh2YWxYID49IDAuMSlcbiAgICAgICAgICAgIHZhbFggPSB2YWxYIC8gMTA7XG4gICAgICAgIGxldCB2YWxZID0gdG90YWxZID09PSAwID8gMCA6ICh0b3RhbFkgKiAodG90YWxZIC8gNSkpIC8gMTA7XG4gICAgICAgIGlmICh2YWxZID49IDEpXG4gICAgICAgICAgICB2YWxZID0gdmFsWSAvIDEwO1xuICAgICAgICBpZiAodmFsWSA+PSAwLjEpXG4gICAgICAgICAgICB2YWxZID0gdmFsWSAvIDEwO1xuICAgICAgICBsYXlvdXQgPSBgPGM6bGF5b3V0PjxjOm1hbnVhbExheW91dD48Yzp4TW9kZSB2YWw9XCJlZGdlXCIvPjxjOnlNb2RlIHZhbD1cImVkZ2VcIi8+PGM6eCB2YWw9XCIke3ZhbFh9XCIvPjxjOnkgdmFsPVwiJHt2YWxZfVwiLz48L2M6bWFudWFsTGF5b3V0PjwvYzpsYXlvdXQ+YDtcbiAgICB9XG4gICAgcmV0dXJuIGA8Yzp0aXRsZT5cbiAgICAgIDxjOnR4PlxuICAgICAgICA8YzpyaWNoPlxuICAgICAgICAgICR7cm90YXRlfVxuICAgICAgICAgIDxhOmxzdFN0eWxlLz5cbiAgICAgICAgICA8YTpwPlxuICAgICAgICAgICAgJHthbGlnbn1cbiAgICAgICAgICAgIDxhOmRlZlJQciAke3NpemVBdHRyfSBiPVwiJHt0aXRsZUJvbGR9XCIgaT1cIjBcIiB1PVwibm9uZVwiIHN0cmlrZT1cIm5vU3RyaWtlXCI+XG4gICAgICAgICAgICAgIDxhOnNvbGlkRmlsbD4ke2NyZWF0ZUNvbG9yRWxlbWVudChvcHRzLmNvbG9yIHx8IERFRl9GT05UX0NPTE9SKX08L2E6c29saWRGaWxsPlxuICAgICAgICAgICAgICA8YTpsYXRpbiB0eXBlZmFjZT1cIiR7b3B0cy5mb250RmFjZSB8fCAnQXJpYWwnfVwiLz5cbiAgICAgICAgICAgIDwvYTpkZWZSUHI+XG4gICAgICAgICAgPC9hOnBQcj5cbiAgICAgICAgICA8YTpyPlxuICAgICAgICAgICAgPGE6clByICR7c2l6ZUF0dHJ9IGI9XCIke3RpdGxlQm9sZH1cIiBpPVwiMFwiIHU9XCJub25lXCIgc3RyaWtlPVwibm9TdHJpa2VcIj5cbiAgICAgICAgICAgICAgPGE6c29saWRGaWxsPiR7Y3JlYXRlQ29sb3JFbGVtZW50KG9wdHMuY29sb3IgfHwgREVGX0ZPTlRfQ09MT1IpfTwvYTpzb2xpZEZpbGw+XG4gICAgICAgICAgICAgIDxhOmxhdGluIHR5cGVmYWNlPVwiJHtvcHRzLmZvbnRGYWNlIHx8ICdBcmlhbCd9XCIvPlxuICAgICAgICAgICAgPC9hOnJQcj5cbiAgICAgICAgICAgIDxhOnQ+JHtlbmNvZGVYbWxFbnRpdGllcyhvcHRzLnRpdGxlKSB8fCAnJ308L2E6dD5cbiAgICAgICAgICA8L2E6cj5cbiAgICAgICAgPC9hOnA+XG4gICAgICAgIDwvYzpyaWNoPlxuICAgICAgPC9jOnR4PlxuICAgICAgJHtsYXlvdXR9XG4gICAgICA8YzpvdmVybGF5IHZhbD1cIjBcIi8+XG4gICAgPC9jOnRpdGxlPmA7XG59XG4vKipcbiAqIENhbGMgYW5kIHJldHVybiBleGNlbCBjb2x1bW4gbmFtZSBmb3IgYSBnaXZlbiBjb2x1bW4gbGVuZ3RoXG4gKiBAcGFyYW0gY29sSW5kZXggY29sdW1uIGluZGV4XG4gKiBAcmV0dXJuIGNvbHVtbiBuYW1lXG4gKiBAZXhhbXBsZSAxIHJldHVybnMgJ0EnXG4gKiBAZXhhbXBsZSAyNyByZXR1cm5zICdBQSdcbiAqL1xuZnVuY3Rpb24gZ2V0RXhjZWxDb2xOYW1lKGNvbEluZGV4KSB7XG4gICAgbGV0IGNvbFN0ciA9ICcnO1xuICAgIGNvbnN0IGNvbElkeCA9IGNvbEluZGV4IC0gMTsgLy8gU3VidHJhY3QgMSBzbyBgTEVUVEVSU1tjb2x1bW5JbmRleF1gIHJldHVybnMgXCJBXCIgZXRjXG4gICAgaWYgKGNvbElkeCA8PSAyNSkge1xuICAgICAgICAvLyBBLVpcbiAgICAgICAgY29sU3RyID0gTEVUVEVSU1tjb2xJZHhdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQUEtWlogKFpaID0gaW5kZXggNzAyKVxuICAgICAgICBjb2xTdHIgPSBgJHtMRVRURVJTW01hdGguZmxvb3IoY29sSWR4IC8gTEVUVEVSUy5sZW5ndGggLSAxKV19JHtMRVRURVJTW2NvbElkeCAlIExFVFRFUlMubGVuZ3RoXX1gO1xuICAgIH1cbiAgICByZXR1cm4gY29sU3RyO1xufVxuLyoqXG4gKiBDcmVhdGVzIGBhOmlubmVyU2hkd2Agb3IgYGE6b3V0ZXJTaGR3YCBkZXBlbmRpbmcgb24gcGFzcyBvcHRpb25zIGBvcHRzYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIG9wdGlvbmFsIHNoYWRvdyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdHMgZGVmYXVsdHMgZm9yIHVuc3BlY2lmaWVkIHByb3BlcnRpZXMgaW4gYG9wdHNgXG4gKiBAc2VlIGh0dHA6Ly9vZmZpY2VvcGVueG1sLmNvbS9kcndTcC1lZmZlY3RzLnBocFxuICogQGV4YW1wbGUgeyB0eXBlOiAnb3V0ZXInLCBibHVyOiAzLCBvZmZzZXQ6ICgyMzAwMCAvIDEyNzAwKSwgYW5nbGU6IDkwLCBjb2xvcjogJzAwMDAwMCcsIG9wYWNpdHk6IDAuMzUsIHJvdGF0ZVdpdGhTaGFwZTogdHJ1ZSB9O1xuICogQHJldHVybiB7c3RyaW5nfSBYTUxcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2hhZG93RWxlbWVudChvcHRpb25zLCBkZWZhdWx0cykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gJzxhOmVmZmVjdExzdC8+JztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignYHNoYWRvd2Agb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdC4gRXg6IGB7c2hhZG93OiB7dHlwZTpcXCdub25lXFwnfX1gJyk7XG4gICAgICAgIHJldHVybiAnPGE6ZWZmZWN0THN0Lz4nO1xuICAgIH1cbiAgICBsZXQgc3RyWG1sID0gJzxhOmVmZmVjdExzdD4nO1xuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzKSwgb3B0aW9ucyk7XG4gICAgY29uc3QgdHlwZSA9IG9wdHMudHlwZSB8fCAnb3V0ZXInO1xuICAgIGNvbnN0IGJsdXIgPSB2YWxUb1B0cyhvcHRzLmJsdXIpO1xuICAgIGNvbnN0IG9mZnNldCA9IHZhbFRvUHRzKG9wdHMub2Zmc2V0KTtcbiAgICBjb25zdCBhbmdsZSA9IE1hdGgucm91bmQob3B0cy5hbmdsZSAqIDYwMDAwKTtcbiAgICBjb25zdCBjb2xvciA9IG9wdHMuY29sb3I7XG4gICAgY29uc3Qgb3BhY2l0eSA9IE1hdGgucm91bmQob3B0cy5vcGFjaXR5ICogMTAwMDAwKTtcbiAgICBjb25zdCByb3RTaGFwZSA9IG9wdHMucm90YXRlV2l0aFNoYXBlID8gMSA6IDA7XG4gICAgc3RyWG1sICs9IGA8YToke3R5cGV9U2hkdyBzeD1cIjEwMDAwMFwiIHN5PVwiMTAwMDAwXCIga3g9XCIwXCIga3k9XCIwXCIgIGFsZ249XCJibFwiIGJsdXJSYWQ9XCIke2JsdXJ9XCIgcm90V2l0aFNoYXBlPVwiJHtyb3RTaGFwZX1cIiBkaXN0PVwiJHtvZmZzZXR9XCIgZGlyPVwiJHthbmdsZX1cIj5gO1xuICAgIHN0clhtbCArPSBgPGE6c3JnYkNsciB2YWw9XCIke2NvbG9yfVwiPmA7XG4gICAgc3RyWG1sICs9IGA8YTphbHBoYSB2YWw9XCIke29wYWNpdHl9XCIvPjwvYTpzcmdiQ2xyPmA7XG4gICAgc3RyWG1sICs9IGA8L2E6JHt0eXBlfVNoZHc+YDtcbiAgICBzdHJYbWwgKz0gJzwvYTplZmZlY3RMc3Q+JztcbiAgICByZXR1cm4gc3RyWG1sO1xufVxuLyoqXG4gKiBDcmVhdGUgR3JpZCBMaW5lIEVsZW1lbnRcbiAqIEBwYXJhbSB7T3B0c0NoYXJ0R3JpZExpbmV9IGdsT3B0cyB7c2l6ZSwgY29sb3IsIHN0eWxlfVxuICogQHJldHVybiB7c3RyaW5nfSBYTUxcbiAqL1xuZnVuY3Rpb24gY3JlYXRlR3JpZExpbmVFbGVtZW50KGdsT3B0cykge1xuICAgIGxldCBzdHJYbWwgPSAnPGM6bWFqb3JHcmlkbGluZXM+JztcbiAgICBzdHJYbWwgKz0gJyA8YzpzcFByPic7XG4gICAgc3RyWG1sICs9IGAgIDxhOmxuIHc9XCIke3ZhbFRvUHRzKGdsT3B0cy5zaXplIHx8IERFRl9DSEFSVF9HUklETElORS5zaXplKX1cIiBjYXA9XCIke2NyZWF0ZUxpbmVDYXAoZ2xPcHRzLmNhcCB8fCBERUZfQ0hBUlRfR1JJRExJTkUuY2FwKX1cIj5gO1xuICAgIHN0clhtbCArPSAnICA8YTpzb2xpZEZpbGw+PGE6c3JnYkNsciB2YWw9XCInICsgKGdsT3B0cy5jb2xvciB8fCBERUZfQ0hBUlRfR1JJRExJTkUuY29sb3IpICsgJ1wiLz48L2E6c29saWRGaWxsPic7IC8vIHNob3VsZCBhY2NlcHQgc2NoZW1lIGNvbG9ycyBhcyBpbXBsZW1lbnRlZCBpbiBbUHVsbCAjMTM1XVxuICAgIHN0clhtbCArPSAnICAgPGE6cHJzdERhc2ggdmFsPVwiJyArIChnbE9wdHMuc3R5bGUgfHwgREVGX0NIQVJUX0dSSURMSU5FLnN0eWxlKSArICdcIi8+PGE6cm91bmQvPic7XG4gICAgc3RyWG1sICs9ICcgIDwvYTpsbj4nO1xuICAgIHN0clhtbCArPSAnIDwvYzpzcFByPic7XG4gICAgc3RyWG1sICs9ICc8L2M6bWFqb3JHcmlkbGluZXM+JztcbiAgICByZXR1cm4gc3RyWG1sO1xufVxuZnVuY3Rpb24gY3JlYXRlTGluZUNhcChsaW5lQ2FwKSB7XG4gICAgaWYgKCFsaW5lQ2FwIHx8IGxpbmVDYXAgPT09ICdmbGF0Jykge1xuICAgICAgICByZXR1cm4gJ2ZsYXQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChsaW5lQ2FwID09PSAnc3F1YXJlJykge1xuICAgICAgICByZXR1cm4gJ3NxJztcbiAgICB9XG4gICAgZWxzZSBpZiAobGluZUNhcCA9PT0gJ3JvdW5kJykge1xuICAgICAgICByZXR1cm4gJ3JuZCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBuZXZlckxpbmVDYXAgPSBsaW5lQ2FwO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hhcnQgbGluZSBjYXA6ICR7bmV2ZXJMaW5lQ2FwfWApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBQcHR4R2VuSlM6IE1lZGlhIE1ldGhvZHNcbiAqL1xuLyoqXG4gKiBFbmNvZGUgSW1hZ2UvQXVkaW8vVmlkZW8gaW50byBiYXNlNjRcbiAqIEBwYXJhbSB7UHJlc1NsaWRlIHwgU2xpZGVMYXlvdXR9IGxheW91dCAtIHNsaWRlIGxheW91dFxuICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZVxuICovXG5mdW5jdGlvbiBlbmNvZGVTbGlkZU1lZGlhUmVscyhsYXlvdXQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIC8vIFNURVAgMTogRGV0ZWN0IHJlYWwgTm9kZSBydW50aW1lIG9uY2VcbiAgICBjb25zdCBpc05vZGUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgISEoKF9hID0gcHJvY2Vzcy52ZXJzaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vZGUpICYmICgoX2IgPSBwcm9jZXNzLnJlbGVhc2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5uYW1lKSA9PT0gJ25vZGUnO1xuICAgIC8vIFRoZXNlIHdpbGwgYmUgZmlsbGVkIG9ubHkgd2hlbiB3ZeKAmXJlIGluIE5vZGVcbiAgICBsZXQgZnM7XG4gICAgbGV0IGh0dHBzO1xuICAgIC8vIFNURVAgMjogTGF6eS1sb2FkIE5vZGUgYnVpbHQtaW5zIGlmIG5lZWRlZFxuICAgIGNvbnN0IGxvYWROb2RlRGVwcyA9IGlzTm9kZVxuICAgICAgICA/ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICh7IGRlZmF1bHQ6IGZzIH0gPSB5aWVsZCBpbXBvcnQoJ25vZGU6ZnMnKSk7XG4gICAgICAgICAgICAoeyBkZWZhdWx0OiBodHRwcyB9ID0geWllbGQgaW1wb3J0KCdub2RlOmh0dHBzJykpO1xuICAgICAgICB9KVxuICAgICAgICA6ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHsgfSk7XG4gICAgLy8gSW1tZWRpYXRlbHkgc3RhcnQgaXQgd2hlbiB3ZSBrbm93IHdl4oCZcmUgaW4gTm9kZVxuICAgIGlmIChpc05vZGUpXG4gICAgICAgIGxvYWROb2RlRGVwcygpO1xuICAgIC8vIFNURVAgMzogUHJlcGFyZSBwcm9taXNlcyBsaXN0XG4gICAgY29uc3QgaW1hZ2VQcm9tcyA9IFtdO1xuICAgIC8vIEE6IENhcHR1cmUgYWxsIGF1ZGlvL2ltYWdlL3ZpZGVvIGNhbmRpZGF0ZXMgZm9yIGVuY29kaW5nIChmaWx0ZXJpbmcgb25saW5lL3ByZS1lbmNvZGVkKVxuICAgIGNvbnN0IGNhbmRpZGF0ZVJlbHMgPSBsYXlvdXQuX3JlbHNNZWRpYS5maWx0ZXIocmVsID0+IHJlbC50eXBlICE9PSAnb25saW5lJyAmJiAhcmVsLmRhdGEgJiYgKCFyZWwucGF0aCB8fCAocmVsLnBhdGggJiYgIXJlbC5wYXRoLmluY2x1ZGVzKCdwcmVlbmNvZGVkJykpKSk7XG4gICAgLy8gQjogUEVSRjogTWFyayBkdXBlcyAoc2FtZSBgcGF0aGApIHRvIGF2b2lkIGxvYWRpbmcgdGhlIHNhbWUgbWVkaWEgb3Zlci1hbmQtb3ZlciFcbiAgICBjb25zdCB1bnFQYXRocyA9IFtdO1xuICAgIGNhbmRpZGF0ZVJlbHMuZm9yRWFjaChyZWwgPT4ge1xuICAgICAgICBpZiAoIXVucVBhdGhzLmluY2x1ZGVzKHJlbC5wYXRoKSkge1xuICAgICAgICAgICAgcmVsLmlzRHVwbGljYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB1bnFQYXRocy5wdXNoKHJlbC5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlbC5pc0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBTVEVQIDQ6IFJlYWQvRW5jb2RlIGVhY2ggdW5pcXVlIG1lZGlhIGl0ZW1cbiAgICBjYW5kaWRhdGVSZWxzXG4gICAgICAgIC5maWx0ZXIocmVsID0+ICFyZWwuaXNEdXBsaWNhdGUpXG4gICAgICAgIC5mb3JFYWNoKHJlbCA9PiB7XG4gICAgICAgIGltYWdlUHJvbXMucHVzaCgoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCFodHRwcylcbiAgICAgICAgICAgICAgICB5aWVsZCBsb2FkTm9kZURlcHMoKTtcbiAgICAgICAgICAgIC8vIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCAgTk9ERSBMT0NBTCBGSUxFICDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcbiAgICAgICAgICAgIGlmIChpc05vZGUgJiYgZnMgJiYgcmVsLnBhdGguaW5kZXhPZignaHR0cCcpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYml0bWFwID0gZnMucmVhZEZpbGVTeW5jKHJlbC5wYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVsLmRhdGEgPSBCdWZmZXIuZnJvbShiaXRtYXApLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlUmVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihkdXBlID0+IGR1cGUuaXNEdXBsaWNhdGUgJiYgZHVwZS5wYXRoID09PSByZWwucGF0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGR1cGUgPT4gKGR1cGUuZGF0YSA9IHJlbC5kYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnZG9uZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICByZWwuZGF0YSA9IElNR19CUk9LRU47XG4gICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZVJlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZHVwZSA9PiBkdXBlLmlzRHVwbGljYXRlICYmIGR1cGUucGF0aCA9PT0gcmVsLnBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChkdXBlID0+IChkdXBlLmRhdGEgPSByZWwuZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVSUk9SOiBVbmFibGUgdG8gcmVhZCBtZWRpYTogXCIke3JlbC5wYXRofVwiXFxuJHtTdHJpbmcoZXgpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCAgTk9ERSBIVFRQKFMpICDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcbiAgICAgICAgICAgIGlmIChpc05vZGUgJiYgaHR0cHMgJiYgcmVsLnBhdGguc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaHR0cHMuZ2V0KHJlbC5wYXRoLCByZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJhdyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnNldEVuY29kaW5nKCdiaW5hcnknKTsgLy8gSU1QT1JUQU5UOiBPbmx5IGJpbmFyeSBlbmNvZGluZyB3b3Jrc1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLm9uKCdkYXRhJywgY2h1bmsgPT4gKHJhdyArPSBjaHVuaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsLmRhdGEgPSBCdWZmZXIuZnJvbShyYXcsICdiaW5hcnknKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlUmVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGR1cGUgPT4gZHVwZS5pc0R1cGxpY2F0ZSAmJiBkdXBlLnBhdGggPT09IHJlbC5wYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChkdXBlID0+IChkdXBlLmRhdGEgPSByZWwuZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoJ2RvbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLm9uKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWwuZGF0YSA9IElNR19CUk9LRU47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlUmVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGR1cGUgPT4gZHVwZS5pc0R1cGxpY2F0ZSAmJiBkdXBlLnBhdGggPT09IHJlbC5wYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChkdXBlID0+IChkdXBlLmRhdGEgPSByZWwuZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEVSUk9SISBVbmFibGUgdG8gbG9hZCBpbWFnZSAoaHR0cHMuZ2V0KTogJHtyZWwucGF0aH1gKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgIEJST1dTRVIgIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgFxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBBOiBidWlsZCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgeGhyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbC5kYXRhID0gcmVhZGVyLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZVJlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGR1cGUgPT4gZHVwZS5pc0R1cGxpY2F0ZSAmJiBkdXBlLnBhdGggPT09IHJlbC5wYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGR1cGUgPT4gKGR1cGUuZGF0YSA9IHJlbC5kYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlbC5pc1N2Z1BuZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoJ2RvbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVN2Z1BuZ1ByZXZpZXcocmVsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiByZXNvbHZlKCdkb25lJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTCh4aHIucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlbC5kYXRhID0gSU1HX0JST0tFTjtcbiAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlUmVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihkdXBlID0+IGR1cGUuaXNEdXBsaWNhdGUgJiYgZHVwZS5wYXRoID09PSByZWwucGF0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGR1cGUgPT4gKGR1cGUuZGF0YSA9IHJlbC5kYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEVSUk9SISBVbmFibGUgdG8gbG9hZCBpbWFnZSAoeGhyLm9uZXJyb3IpOiAke3JlbC5wYXRofWApKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIEI6IGV4ZWN1dGUgcmVxdWVzdFxuICAgICAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCByZWwucGF0aCk7XG4gICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJztcbiAgICAgICAgICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKSgpKTtcbiAgICB9KTtcbiAgICAvLyBTVEVQIDU6IFNWRy1QTkcgcHJldmlld3NcbiAgICAvLyAuLi4uLi46IFwiU1ZHOlwiIGJhc2U2NCBkYXRhIHN0aWxsIHJlcXVpcmVzIGEgcG5nIHRvIGJlIGdlbmVyYXRlZFxuICAgIC8vIC4uLi4uLjogKGBpc1N2Z1BuZ2AgZmxhZyB0aGlzIGFzIHRoZSBwcmV2aWV3IGltYWdlLCBub3QgdGhlIFNWRyBpdHNlbGYpXG4gICAgbGF5b3V0Ll9yZWxzTWVkaWFcbiAgICAgICAgLmZpbHRlcihyZWwgPT4gcmVsLmlzU3ZnUG5nICYmIHJlbC5kYXRhKVxuICAgICAgICAuZm9yRWFjaChyZWwgPT4ge1xuICAgICAgICAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKGlzTm9kZSAmJiAhZnMpXG4gICAgICAgICAgICAgICAgeWllbGQgbG9hZE5vZGVEZXBzKCk7XG4gICAgICAgICAgICBpZiAoaXNOb2RlICYmIGZzKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1NvcnJ5LCBTVkcgaXMgbm90IHN1cHBvcnRlZCBpbiBOb2RlIChtb3JlIGluZm86IGh0dHBzOi8vZ2l0aHViLmNvbS9naXRicmVudC9QcHR4R2VuSlMvaXNzdWVzLzQwMSknKVxuICAgICAgICAgICAgICAgIHJlbC5kYXRhID0gSU1HX0JST0tFTjtcbiAgICAgICAgICAgICAgICBpbWFnZVByb21zLnB1c2goUHJvbWlzZS5yZXNvbHZlKCdkb25lJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VQcm9tcy5wdXNoKGNyZWF0ZVN2Z1BuZ1ByZXZpZXcocmVsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKSgpO1xuICAgIH0pO1xuICAgIHJldHVybiBpbWFnZVByb21zO1xufVxuLyoqXG4gKiBDcmVhdGUgU1ZHIHByZXZpZXcgaW1hZ2VcbiAqIEBwYXJhbSB7SVNsaWRlUmVsTWVkaWF9IHJlbCAtIHNsaWRlIHJlbFxuICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZVxuICovXG5mdW5jdGlvbiBjcmVhdGVTdmdQbmdQcmV2aWV3KHJlbCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHJldHVybiB5aWVsZCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyBBOiBDcmVhdGVcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAvLyBCOiBTZXQgb25sb2FkIGV2ZW50XG4gICAgICAgICAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gRmlyc3Q6IENoZWNrIGZvciBhbnkgZXJyb3JzOiBUaGlzIGlzIHRoZSBiZXN0IG1ldGhvZCAodHJ5L2NhdGNoIHdvbnQgd29yaywgZXRjLilcbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2Uud2lkdGggKyBpbWFnZS5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2Uub25lcnJvcignaC93PTAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0NBTlZBUycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgLy8gVXNlcnMgcnVubmluZyBvbiBsb2NhbCBtYWNoaW5lIHdpbGwgZ2V0IHRoZSBmb2xsb3dpbmcgZXJyb3I6XG4gICAgICAgICAgICAgICAgLy8gXCJTZWN1cml0eUVycm9yOiBGYWlsZWQgdG8gZXhlY3V0ZSAndG9EYXRhVVJMJyBvbiAnSFRNTENhbnZhc0VsZW1lbnQnOiBUYWludGVkIGNhbnZhc2VzIG1heSBub3QgYmUgZXhwb3J0ZWQuXCJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBjYW52YXMudG9EYXRhVVJMIGNhbGwgZXhlY3V0ZXMgYmVsb3cuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVsLmRhdGEgPSBjYW52YXMudG9EYXRhVVJMKHJlbC50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgnZG9uZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2Uub25lcnJvcihleC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FudmFzID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWFnZS5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlbC5kYXRhID0gSU1HX0JST0tFTjtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBFUlJPUiEgVW5hYmxlIHRvIGxvYWQgaW1hZ2UgKGltYWdlLm9uZXJyb3IpOiAke3JlbC5wYXRofWApKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBDOiBMb2FkIGltYWdlXG4gICAgICAgICAgICBpbWFnZS5zcmMgPSB0eXBlb2YgcmVsLmRhdGEgPT09ICdzdHJpbmcnID8gcmVsLmRhdGEgOiBJTUdfQlJPS0VOO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8qKlxuICogRklYTUU6IFRPRE86IGN1cnJlbnRseSB1bnVzZWRcbiAqIFRPRE86IFNob3VsZCByZXR1cm4gYSBQcm9taXNlXG4gKi9cbi8qXG5mdW5jdGlvbiBnZXRTaXplRnJvbUltYWdlIChpbkltZ1VybDogc3RyaW5nKTogeyB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9IHtcbiAgICBjb25zdCBzaXplT2YgPSB0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcgPyByZXF1aXJlKCdzaXplb2YnKSA6IG51bGwgLy8gTm9kZUpTXG5cbiAgICBpZiAoc2l6ZU9mKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkaW1lbnNpb25zID0gc2l6ZU9mKGluSW1nVXJsKVxuICAgICAgICAgICAgcmV0dXJuIHsgd2lkdGg6IGRpbWVuc2lvbnMud2lkdGgsIGhlaWdodDogZGltZW5zaW9ucy5oZWlnaHQgfVxuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRVJST1I6IHNpemVPZjogVW5hYmxlIHRvIGxvYWQgaW1hZ2U6ICcgKyBpbkltZ1VybClcbiAgICAgICAgICAgIHJldHVybiB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChJbWFnZSAmJiB0eXBlb2YgSW1hZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gQTogQ3JlYXRlXG4gICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKClcblxuICAgICAgICAvLyBCOiBTZXQgb25sb2FkIGV2ZW50XG4gICAgICAgIGltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIEZJUlNUOiBDaGVjayBmb3IgYW55IGVycm9yczogVGhpcyBpcyB0aGUgYmVzdCBtZXRob2QgKHRyeS9jYXRjaCB3b250IHdvcmssIGV0Yy4pXG4gICAgICAgICAgICBpZiAoaW1hZ2Uud2lkdGggKyBpbWFnZS5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHsgd2lkdGg6IGltYWdlLndpZHRoLCBoZWlnaHQ6IGltYWdlLmhlaWdodCB9XG4gICAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgIH1cbiAgICAgICAgaW1hZ2Uub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVSUk9SOiBpbWFnZS5vbmxvYWQ6IFVuYWJsZSB0byBsb2FkIGltYWdlOiAke2luSW1nVXJsfWApXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDOiBMb2FkIGltYWdlXG4gICAgICAgIGltYWdlLnNyYyA9IGluSW1nVXJsXG4gICAgfVxufVxuKi9cblxuLyoqXG4gKiBQcHR4R2VuSlM6IFhNTCBHZW5lcmF0aW9uXG4gKi9cbmNvbnN0IEltYWdlU2l6aW5nWG1sID0ge1xuICAgIGNvdmVyOiBmdW5jdGlvbiAoaW1nU2l6ZSwgYm94RGltKSB7XG4gICAgICAgIGNvbnN0IGltZ1JhdGlvID0gaW1nU2l6ZS5oIC8gaW1nU2l6ZS53O1xuICAgICAgICBjb25zdCBib3hSYXRpbyA9IGJveERpbS5oIC8gYm94RGltLnc7XG4gICAgICAgIGNvbnN0IGlzQm94QmFzZWQgPSBib3hSYXRpbyA+IGltZ1JhdGlvO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGlzQm94QmFzZWQgPyBib3hEaW0uaCAvIGltZ1JhdGlvIDogYm94RGltLnc7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGlzQm94QmFzZWQgPyBib3hEaW0uaCA6IGJveERpbS53ICogaW1nUmF0aW87XG4gICAgICAgIGNvbnN0IGh6UGVyYyA9IE1hdGgucm91bmQoMWU1ICogMC41ICogKDEgLSBib3hEaW0udyAvIHdpZHRoKSk7XG4gICAgICAgIGNvbnN0IHZ6UGVyYyA9IE1hdGgucm91bmQoMWU1ICogMC41ICogKDEgLSBib3hEaW0uaCAvIGhlaWdodCkpO1xuICAgICAgICByZXR1cm4gYDxhOnNyY1JlY3QgbD1cIiR7aHpQZXJjfVwiIHI9XCIke2h6UGVyY31cIiB0PVwiJHt2elBlcmN9XCIgYj1cIiR7dnpQZXJjfVwiLz48YTpzdHJldGNoLz5gO1xuICAgIH0sXG4gICAgY29udGFpbjogZnVuY3Rpb24gKGltZ1NpemUsIGJveERpbSkge1xuICAgICAgICBjb25zdCBpbWdSYXRpbyA9IGltZ1NpemUuaCAvIGltZ1NpemUudztcbiAgICAgICAgY29uc3QgYm94UmF0aW8gPSBib3hEaW0uaCAvIGJveERpbS53O1xuICAgICAgICBjb25zdCB3aWR0aEJhc2VkID0gYm94UmF0aW8gPiBpbWdSYXRpbztcbiAgICAgICAgY29uc3Qgd2lkdGggPSB3aWR0aEJhc2VkID8gYm94RGltLncgOiBib3hEaW0uaCAvIGltZ1JhdGlvO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB3aWR0aEJhc2VkID8gYm94RGltLncgKiBpbWdSYXRpbyA6IGJveERpbS5oO1xuICAgICAgICBjb25zdCBoelBlcmMgPSBNYXRoLnJvdW5kKDFlNSAqIDAuNSAqICgxIC0gYm94RGltLncgLyB3aWR0aCkpO1xuICAgICAgICBjb25zdCB2elBlcmMgPSBNYXRoLnJvdW5kKDFlNSAqIDAuNSAqICgxIC0gYm94RGltLmggLyBoZWlnaHQpKTtcbiAgICAgICAgcmV0dXJuIGA8YTpzcmNSZWN0IGw9XCIke2h6UGVyY31cIiByPVwiJHtoelBlcmN9XCIgdD1cIiR7dnpQZXJjfVwiIGI9XCIke3Z6UGVyY31cIi8+PGE6c3RyZXRjaC8+YDtcbiAgICB9LFxuICAgIGNyb3A6IGZ1bmN0aW9uIChpbWdTaXplLCBib3hEaW0pIHtcbiAgICAgICAgY29uc3QgbCA9IGJveERpbS54O1xuICAgICAgICBjb25zdCByID0gaW1nU2l6ZS53IC0gKGJveERpbS54ICsgYm94RGltLncpO1xuICAgICAgICBjb25zdCB0ID0gYm94RGltLnk7XG4gICAgICAgIGNvbnN0IGIgPSBpbWdTaXplLmggLSAoYm94RGltLnkgKyBib3hEaW0uaCk7XG4gICAgICAgIGNvbnN0IGxQZXJjID0gTWF0aC5yb3VuZCgxZTUgKiAobCAvIGltZ1NpemUudykpO1xuICAgICAgICBjb25zdCByUGVyYyA9IE1hdGgucm91bmQoMWU1ICogKHIgLyBpbWdTaXplLncpKTtcbiAgICAgICAgY29uc3QgdFBlcmMgPSBNYXRoLnJvdW5kKDFlNSAqICh0IC8gaW1nU2l6ZS5oKSk7XG4gICAgICAgIGNvbnN0IGJQZXJjID0gTWF0aC5yb3VuZCgxZTUgKiAoYiAvIGltZ1NpemUuaCkpO1xuICAgICAgICByZXR1cm4gYDxhOnNyY1JlY3QgbD1cIiR7bFBlcmN9XCIgcj1cIiR7clBlcmN9XCIgdD1cIiR7dFBlcmN9XCIgYj1cIiR7YlBlcmN9XCIvPjxhOnN0cmV0Y2gvPmA7XG4gICAgfSxcbn07XG4vKipcbiAqIFRyYW5zZm9ybXMgYSBzbGlkZSBvciBzbGlkZUxheW91dCB0byByZXN1bHRpbmcgWE1MIHN0cmluZyAtIENyZWF0ZXMgYHBwdC9zbGlkZSoueG1sYFxuICogQHBhcmFtIHtQcmVzU2xpZGV8U2xpZGVMYXlvdXR9IHNsaWRlT2JqZWN0IC0gc2xpZGUgb2JqZWN0IGNyZWF0ZWQgd2l0aGluIGNyZWF0ZVNsaWRlT2JqZWN0XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFhNTCBzdHJpbmcgd2l0aCA8cDpjU2xkPiBhcyB0aGUgcm9vdFxuICovXG5mdW5jdGlvbiBzbGlkZU9iamVjdFRvWG1sKHNsaWRlKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBzdHJTbGlkZVhtbCA9IHNsaWRlLl9uYW1lID8gJzxwOmNTbGQgbmFtZT1cIicgKyBzbGlkZS5fbmFtZSArICdcIj4nIDogJzxwOmNTbGQ+JztcbiAgICBsZXQgaW50VGFibGVOdW0gPSAxO1xuICAgIC8vIFNURVAgMTogQWRkIGJhY2tncm91bmQgY29sb3IvaW1hZ2UgKGVuc3VyZSBvbmx5IGEgc2luZ2xlIGA8cDpiZz5gIHRhZyBpcyBjcmVhdGVkLCBleDogd2hlbiBtYXN0ZXItYmFza2dyb3VuZCBoYXMgYm90aCBgY29sb3JgIGFuZCBgcGF0aGApXG4gICAgaWYgKHNsaWRlLl9ia2dkSW1nUmlkKSB7XG4gICAgICAgIHN0clNsaWRlWG1sICs9IGA8cDpiZz48cDpiZ1ByPjxhOmJsaXBGaWxsIGRwaT1cIjBcIiByb3RXaXRoU2hhcGU9XCIxXCI+PGE6YmxpcCByOmVtYmVkPVwicklkJHtzbGlkZS5fYmtnZEltZ1JpZH1cIj48YTpsdW0vPjwvYTpibGlwPjxhOnNyY1JlY3QvPjxhOnN0cmV0Y2g+PGE6ZmlsbFJlY3QvPjwvYTpzdHJldGNoPjwvYTpibGlwRmlsbD48YTplZmZlY3RMc3QvPjwvcDpiZ1ByPjwvcDpiZz5gO1xuICAgIH1cbiAgICBlbHNlIGlmICgoX2EgPSBzbGlkZS5iYWNrZ3JvdW5kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29sb3IpIHtcbiAgICAgICAgc3RyU2xpZGVYbWwgKz0gYDxwOmJnPjxwOmJnUHI+JHtnZW5YbWxDb2xvclNlbGVjdGlvbihzbGlkZS5iYWNrZ3JvdW5kKX08L3A6YmdQcj48L3A6Ymc+YDtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXNsaWRlLmJrZ2QgJiYgc2xpZGUuX25hbWUgJiYgc2xpZGUuX25hbWUgPT09IERFRl9QUkVTX0xBWU9VVF9OQU1FKSB7XG4gICAgICAgIC8vIE5PVEU6IERlZmF1bHQgW3doaXRlXSBiYWNrZ3JvdW5kIGlzIG5lZWRlZCBvbiBzbGlkZU1hc3RlcjEueG1sIHRvIGF2b2lkIGdyYXkgYmFja2dyb3VuZCBpbiBLZXlub3RlIChhbmQgRmluZGVyIHByZXZpZXdzKVxuICAgICAgICBzdHJTbGlkZVhtbCArPSAnPHA6Ymc+PHA6YmdSZWYgaWR4PVwiMTAwMVwiPjxhOnNjaGVtZUNsciB2YWw9XCJiZzFcIi8+PC9wOmJnUmVmPjwvcDpiZz4nO1xuICAgIH1cbiAgICAvLyBTVEVQIDI6IENvbnRpbnVlIHNsaWRlIGJ5IHN0YXJ0aW5nIHNwVHJlZSBub2RlXG4gICAgc3RyU2xpZGVYbWwgKz0gJzxwOnNwVHJlZT4nO1xuICAgIHN0clNsaWRlWG1sICs9ICc8cDpudkdycFNwUHI+PHA6Y052UHIgaWQ9XCIxXCIgbmFtZT1cIlwiLz48cDpjTnZHcnBTcFByLz48cDpudlByLz48L3A6bnZHcnBTcFByPic7XG4gICAgc3RyU2xpZGVYbWwgKz0gJzxwOmdycFNwUHI+PGE6eGZybT48YTpvZmYgeD1cIjBcIiB5PVwiMFwiLz48YTpleHQgY3g9XCIwXCIgY3k9XCIwXCIvPic7XG4gICAgc3RyU2xpZGVYbWwgKz0gJzxhOmNoT2ZmIHg9XCIwXCIgeT1cIjBcIi8+PGE6Y2hFeHQgY3g9XCIwXCIgY3k9XCIwXCIvPjwvYTp4ZnJtPjwvcDpncnBTcFByPic7XG4gICAgLy8gU1RFUCAzOiBMb29wIG92ZXIgYWxsIFNsaWRlLmRhdGEgb2JqZWN0cyBhbmQgYWRkIHRoZW0gdG8gdGhpcyBzbGlkZVxuICAgIHNsaWRlLl9zbGlkZU9iamVjdHMuZm9yRWFjaCgoc2xpZGVJdGVtT2JqLCBpZHgpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgbGV0IHggPSAwO1xuICAgICAgICBsZXQgeSA9IDA7XG4gICAgICAgIGxldCBjeCA9IGdldFNtYXJ0UGFyc2VOdW1iZXIoJzc1JScsICdYJywgc2xpZGUuX3ByZXNMYXlvdXQpO1xuICAgICAgICBsZXQgY3kgPSAwO1xuICAgICAgICBsZXQgcGxhY2Vob2xkZXJPYmo7XG4gICAgICAgIGxldCBsb2NhdGlvbkF0dHIgPSAnJztcbiAgICAgICAgbGV0IGFyclRhYlJvd3MgPSBudWxsO1xuICAgICAgICBsZXQgb2JqVGFiT3B0cyA9IG51bGw7XG4gICAgICAgIGxldCBpbnRDb2xDbnQgPSAwO1xuICAgICAgICBsZXQgaW50Q29sVyA9IDA7XG4gICAgICAgIGxldCBjZWxsT3B0cyA9IG51bGw7XG4gICAgICAgIGxldCBzdHJYbWwgPSBudWxsO1xuICAgICAgICBjb25zdCBzaXppbmcgPSAoX2EgPSBzbGlkZUl0ZW1PYmoub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpemluZztcbiAgICAgICAgY29uc3Qgcm91bmRpbmcgPSAoX2IgPSBzbGlkZUl0ZW1PYmoub3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJvdW5kaW5nO1xuICAgICAgICBpZiAoc2xpZGUuX3NsaWRlTGF5b3V0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHNsaWRlLl9zbGlkZUxheW91dC5fc2xpZGVPYmplY3RzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHNsaWRlSXRlbU9iai5vcHRpb25zICYmXG4gICAgICAgICAgICBzbGlkZUl0ZW1PYmoub3B0aW9ucy5wbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgcGxhY2Vob2xkZXJPYmogPSBzbGlkZS5fc2xpZGVMYXlvdXQuX3NsaWRlT2JqZWN0cy5maWx0ZXIoKG9iamVjdCkgPT4gb2JqZWN0Lm9wdGlvbnMucGxhY2Vob2xkZXIgPT09IHNsaWRlSXRlbU9iai5vcHRpb25zLnBsYWNlaG9sZGVyKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBOiBTZXQgb3B0aW9uIHZhcnNcbiAgICAgICAgc2xpZGVJdGVtT2JqLm9wdGlvbnMgPSBzbGlkZUl0ZW1PYmoub3B0aW9ucyB8fCB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBzbGlkZUl0ZW1PYmoub3B0aW9ucy54ICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIHggPSBnZXRTbWFydFBhcnNlTnVtYmVyKHNsaWRlSXRlbU9iai5vcHRpb25zLngsICdYJywgc2xpZGUuX3ByZXNMYXlvdXQpO1xuICAgICAgICBpZiAodHlwZW9mIHNsaWRlSXRlbU9iai5vcHRpb25zLnkgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgeSA9IGdldFNtYXJ0UGFyc2VOdW1iZXIoc2xpZGVJdGVtT2JqLm9wdGlvbnMueSwgJ1knLCBzbGlkZS5fcHJlc0xheW91dCk7XG4gICAgICAgIGlmICh0eXBlb2Ygc2xpZGVJdGVtT2JqLm9wdGlvbnMudyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICBjeCA9IGdldFNtYXJ0UGFyc2VOdW1iZXIoc2xpZGVJdGVtT2JqLm9wdGlvbnMudywgJ1gnLCBzbGlkZS5fcHJlc0xheW91dCk7XG4gICAgICAgIGlmICh0eXBlb2Ygc2xpZGVJdGVtT2JqLm9wdGlvbnMuaCAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICBjeSA9IGdldFNtYXJ0UGFyc2VOdW1iZXIoc2xpZGVJdGVtT2JqLm9wdGlvbnMuaCwgJ1knLCBzbGlkZS5fcHJlc0xheW91dCk7XG4gICAgICAgIC8vIFNldCB3L2ggbm93IHRoYXQgc21hcnQgcGFyc2UgaXMgZG9uZVxuICAgICAgICBsZXQgaW1nV2lkdGggPSBjeDtcbiAgICAgICAgbGV0IGltZ0hlaWdodCA9IGN5O1xuICAgICAgICAvLyBJZiB1c2luZyBhIHBsYWNlaG9sZGVyIHRoZW4gaW5oZXJpdCBpdCdzIHBvc2l0aW9uXG4gICAgICAgIGlmIChwbGFjZWhvbGRlck9iaikge1xuICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyT2JqLm9wdGlvbnMueCB8fCBwbGFjZWhvbGRlck9iai5vcHRpb25zLnggPT09IDApXG4gICAgICAgICAgICAgICAgeCA9IGdldFNtYXJ0UGFyc2VOdW1iZXIocGxhY2Vob2xkZXJPYmoub3B0aW9ucy54LCAnWCcsIHNsaWRlLl9wcmVzTGF5b3V0KTtcbiAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlck9iai5vcHRpb25zLnkgfHwgcGxhY2Vob2xkZXJPYmoub3B0aW9ucy55ID09PSAwKVxuICAgICAgICAgICAgICAgIHkgPSBnZXRTbWFydFBhcnNlTnVtYmVyKHBsYWNlaG9sZGVyT2JqLm9wdGlvbnMueSwgJ1knLCBzbGlkZS5fcHJlc0xheW91dCk7XG4gICAgICAgICAgICBpZiAocGxhY2Vob2xkZXJPYmoub3B0aW9ucy53IHx8IHBsYWNlaG9sZGVyT2JqLm9wdGlvbnMudyA9PT0gMClcbiAgICAgICAgICAgICAgICBjeCA9IGdldFNtYXJ0UGFyc2VOdW1iZXIocGxhY2Vob2xkZXJPYmoub3B0aW9ucy53LCAnWCcsIHNsaWRlLl9wcmVzTGF5b3V0KTtcbiAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlck9iai5vcHRpb25zLmggfHwgcGxhY2Vob2xkZXJPYmoub3B0aW9ucy5oID09PSAwKVxuICAgICAgICAgICAgICAgIGN5ID0gZ2V0U21hcnRQYXJzZU51bWJlcihwbGFjZWhvbGRlck9iai5vcHRpb25zLmgsICdZJywgc2xpZGUuX3ByZXNMYXlvdXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vXG4gICAgICAgIGlmIChzbGlkZUl0ZW1PYmoub3B0aW9ucy5mbGlwSClcbiAgICAgICAgICAgIGxvY2F0aW9uQXR0ciArPSAnIGZsaXBIPVwiMVwiJztcbiAgICAgICAgaWYgKHNsaWRlSXRlbU9iai5vcHRpb25zLmZsaXBWKVxuICAgICAgICAgICAgbG9jYXRpb25BdHRyICs9ICcgZmxpcFY9XCIxXCInO1xuICAgICAgICBpZiAoc2xpZGVJdGVtT2JqLm9wdGlvbnMucm90YXRlKVxuICAgICAgICAgICAgbG9jYXRpb25BdHRyICs9IGAgcm90PVwiJHtjb252ZXJ0Um90YXRpb25EZWdyZWVzKHNsaWRlSXRlbU9iai5vcHRpb25zLnJvdGF0ZSl9XCJgO1xuICAgICAgICAvLyBCOiBBZGQgT0JKRUNUIHRvIHRoZSBjdXJyZW50IFNsaWRlXG4gICAgICAgIHN3aXRjaCAoc2xpZGVJdGVtT2JqLl90eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFNMSURFX09CSkVDVF9UWVBFUy50YWJsZTpcbiAgICAgICAgICAgICAgICBhcnJUYWJSb3dzID0gc2xpZGVJdGVtT2JqLmFyclRhYlJvd3M7XG4gICAgICAgICAgICAgICAgb2JqVGFiT3B0cyA9IHNsaWRlSXRlbU9iai5vcHRpb25zO1xuICAgICAgICAgICAgICAgIGludENvbENudCA9IDA7XG4gICAgICAgICAgICAgICAgaW50Q29sVyA9IDA7XG4gICAgICAgICAgICAgICAgLy8gQ2FsYyBudW1iZXIgb2YgY29sdW1uc1xuICAgICAgICAgICAgICAgIC8vIE5PVEU6IENlbGxzIG1heSBoYXZlIGEgY29sc3Bhbiwgc28gbWVyZWx5IHRha2luZyB0aGUgbGVuZ3RoIG9mIHRoZSBbMF0gKG9yIGFueSBvdGhlcikgcm93IGlzIG5vdFxuICAgICAgICAgICAgICAgIC8vIC4uLi46IHN1ZmZpY2llbnQgdG8gZGV0ZXJtaW5lIGNvbHVtbiBjb3VudC4gVGhlcmVmb3JlLCBjaGVjayBlYWNoIGNlbGwgZm9yIGEgY29sc3BhbiBhbmQgdG90YWwgY29scyBhcyByZXFkXG4gICAgICAgICAgICAgICAgYXJyVGFiUm93c1swXS5mb3JFYWNoKGNlbGwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjZWxsT3B0cyA9IGNlbGwub3B0aW9ucyB8fCBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpbnRDb2xDbnQgKz0gKGNlbGxPcHRzID09PSBudWxsIHx8IGNlbGxPcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjZWxsT3B0cy5jb2xzcGFuKSA/IE51bWJlcihjZWxsT3B0cy5jb2xzcGFuKSA6IDE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gU1RFUCAxOiBTdGFydCBUYWJsZSBYTUxcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBOb24tbnVtZXJpYyBjTnZQciBpZCB2YWx1ZXMgd2lsbCB0cmlnZ2VyIFwicHJlc2VudGF0aW9uIG5lZWRzIHJlcGFpclwiIHR5cGUgd2FybmluZyBpbiBNUy1QUFQtMjAxM1xuICAgICAgICAgICAgICAgIHN0clhtbCA9IGA8cDpncmFwaGljRnJhbWU+PHA6bnZHcmFwaGljRnJhbWVQcj48cDpjTnZQciBpZD1cIiR7aW50VGFibGVOdW0gKiBzbGlkZS5fc2xpZGVOdW0gKyAxfVwiIG5hbWU9XCIke3NsaWRlSXRlbU9iai5vcHRpb25zLm9iamVjdE5hbWV9XCIvPmA7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9XG4gICAgICAgICAgICAgICAgICAgICc8cDpjTnZHcmFwaGljRnJhbWVQcj48YTpncmFwaGljRnJhbWVMb2NrcyBub0dycD1cIjFcIi8+PC9wOmNOdkdyYXBoaWNGcmFtZVByPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAgPHA6bnZQcj48cDpleHRMc3Q+PHA6ZXh0IHVyaT1cIntENDJBMjdEQi1CRDMxLTRCOEMtODNBMS1GNkVFQ0YyNDQzMjF9XCI+PHAxNDptb2RJZCB4bWxuczpwMTQ9XCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9wb3dlcnBvaW50LzIwMTAvbWFpblwiIHZhbD1cIjE1NzkwMTE5MzVcIi8+PC9wOmV4dD48L3A6ZXh0THN0PjwvcDpudlByPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzwvcDpudkdyYXBoaWNGcmFtZVByPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9IGA8cDp4ZnJtPjxhOm9mZiB4PVwiJHt4IHx8ICh4ID09PSAwID8gMCA6IEVNVSl9XCIgeT1cIiR7eSB8fCAoeSA9PT0gMCA/IDAgOiBFTVUpfVwiLz48YTpleHQgY3g9XCIke2N4IHx8IChjeCA9PT0gMCA/IDAgOiBFTVUpfVwiIGN5PVwiJHtjeSB8fCBFTVV9XCIvPjwvcDp4ZnJtPmA7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8YTpncmFwaGljPjxhOmdyYXBoaWNEYXRhIHVyaT1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9kcmF3aW5nbWwvMjAwNi90YWJsZVwiPjxhOnRibD48YTp0YmxQci8+JztcbiAgICAgICAgICAgICAgICAvLyArICcgICAgICAgIDxhOnRibFByIGJhbmRSb3c9XCIxXCIvPic7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogU3VwcG9ydCBiYW5kZWQgcm93cywgZmlyc3QvbGFzdCByb3csIGV0Yy5cbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBCYW5kaW5nLCBldGMuIG9ubHkgc2hvd3Mgd2hlbiB1c2luZyBhIHRhYmxlIHN0eWxlISAob3Igc2V0IGFsdCByb3cgY29sb3IgaWYgYmFuZGluZylcbiAgICAgICAgICAgICAgICAvLyA8YTp0YmxQciBmaXJzdENvbD1cIjBcIiBmaXJzdFJvdz1cIjBcIiBsYXN0Q29sPVwiMFwiIGxhc3RSb3c9XCIwXCIgYmFuZENvbD1cIjBcIiBiYW5kUm93PVwiMVwiPlxuICAgICAgICAgICAgICAgIC8vIFNURVAgMjogU2V0IGNvbHVtbiB3aWR0aHNcbiAgICAgICAgICAgICAgICAvLyBFdmVubHkgZGlzdHJpYnV0ZSBjb2xzL3Jvd3MgYWNyb3NzIHNpemUgcHJvdmlkZWQgd2hlbiBhcHBsaWNhYmxlIChjYWxjIHRoZW0gaWYgb25seSBvdmVyYWxsIGRpbWVuc2lvbnMgd2VyZSBwcm92aWRlZClcbiAgICAgICAgICAgICAgICAvLyBBOiBDb2wgd2lkdGhzIHByb3ZpZGVkP1xuICAgICAgICAgICAgICAgIC8vIEI6IFRhYmxlIFdpZHRoIHByb3ZpZGVkIHdpdGhvdXQgY29sVz8gVGhlbiBkaXN0cmlidXRlIGNvbHNcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpUYWJPcHRzLmNvbFcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPGE6dGJsR3JpZD4nO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBpbnRDb2xDbnQ7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdyA9IGluY2gyRW11KG9ialRhYk9wdHMuY29sV1tjb2xdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3ID09IG51bGwgfHwgaXNOYU4odykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ID0gKHR5cGVvZiBzbGlkZUl0ZW1PYmoub3B0aW9ucy53ID09PSAnbnVtYmVyJyA/IHNsaWRlSXRlbU9iai5vcHRpb25zLncgOiAxKSAvIGludENvbENudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBgPGE6Z3JpZENvbCB3PVwiJHtNYXRoLnJvdW5kKHcpfVwiLz5gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPC9hOnRibEdyaWQ+JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGludENvbFcgPSBvYmpUYWJPcHRzLmNvbFcgPyBvYmpUYWJPcHRzLmNvbFcgOiBFTVU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbGlkZUl0ZW1PYmoub3B0aW9ucy53ICYmICFvYmpUYWJPcHRzLmNvbFcpXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRDb2xXID0gTWF0aC5yb3VuZCgodHlwZW9mIHNsaWRlSXRlbU9iai5vcHRpb25zLncgPT09ICdudW1iZXInID8gc2xpZGVJdGVtT2JqLm9wdGlvbnMudyA6IDEpIC8gaW50Q29sQ250KTtcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8YTp0YmxHcmlkPic7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbHcgPSAwOyBjb2x3IDwgaW50Q29sQ250OyBjb2x3KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBgPGE6Z3JpZENvbCB3PVwiJHtpbnRDb2xXfVwiLz5gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPC9hOnRibEdyaWQ+JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU1RFUCAzOiBCdWlsZCBvdXIgcm93IGFycmF5cyBpbnRvIGFuIGFjdHVhbCBncmlkIHRvIG1hdGNoIHRoZSBYTUwgd2Ugd2lsbCBiZSBidWlsZGluZyBuZXh0IChJU1NVRSAjMzYpXG4gICAgICAgICAgICAgICAgLy8gTm90ZSByb3cgYXJyYXlzIGNhbiBhcnJpdmUgXCJsb3BzaWRlZFwiIGFzIGluIHJvdzE6WzEsMiwzXSByb3cyOlszXSB3aGVuIGZpcnN0IHR3byBjb2xzIHJvd3NwYW4hLFxuICAgICAgICAgICAgICAgIC8vIHNvIGEgc2ltcGxlIGxvb3AgYmVsb3cgaW4gWE1MIGJ1aWxkaW5nIHdvbnQgc3VmZmljZSB0byBidWlsZCB0YWJsZSBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBidWlsZCBhbiBhY3R1YWwgZ3JpZCBub3dcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICBFWDogKEEwOnJvd3NwYW49MywgQjE6cm93c3Bhbj0yLCBDMTpjb2xzcGFuPTIpXG5cbiAgICAgICAgICAgICAgICAgICAgLy0tLS0tLXwtLS0tLS18LS0tLS0tfC0tLS0tLVxcXG4gICAgICAgICAgICAgICAgICAgIHwgIEEwICB8ICBCMCAgfCAgQzAgIHwgIEQwICB8XG4gICAgICAgICAgICAgICAgICAgIHwgICAgICB8ICBCMSAgfCAgQzEgIHwgICAgICB8XG4gICAgICAgICAgICAgICAgICAgIHwgICAgICB8ICAgICAgfCAgQzIgIHwgIEQyICB8XG4gICAgICAgICAgICAgICAgICAgIFxcLS0tLS0tfC0tLS0tLXwtLS0tLS18LS0tLS0tL1xuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLy8gQTogYWRkIF9obWVyZ2UgY2VsbCBmb3IgY29sc3Bhbi4gc2hvdWxkIHJlc2VydmUgcm93c3BhblxuICAgICAgICAgICAgICAgIGFyclRhYlJvd3MuZm9yRWFjaChjZWxscyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNJZHggPSAwOyBjSWR4IDwgY2VsbHMubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IGNlbGxzW2NJZHhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sc3BhbiA9IChfYSA9IGNlbGwub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbHNwYW47XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb3dzcGFuID0gKF9iID0gY2VsbC5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iucm93c3BhbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xzcGFuICYmIGNvbHNwYW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgdk1lcmdlQ2VsbHMgPSBuZXcgQXJyYXkoY29sc3BhbiAtIDEpLmZpbGwodW5kZWZpbmVkKS5tYXAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBfdHlwZTogU0xJREVfT0JKRUNUX1RZUEVTLnRhYmxlY2VsbCwgb3B0aW9uczogeyByb3dzcGFuIH0sIF9obWVyZ2U6IHRydWUgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxscy5zcGxpY2UoY0lkeCArIDEsIDAsIC4uLnZNZXJnZUNlbGxzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjSWR4ICs9IGNvbHNwYW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjSWR4ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBCOiBhZGQgX3ZtZXJnZSBjZWxsIGZvciByb3dzcGFuLiBzaG91bGQgcmVzZXJ2ZSBjb2xzcGFuL19obWVyZ2VcbiAgICAgICAgICAgICAgICBhcnJUYWJSb3dzLmZvckVhY2goKGNlbGxzLCBySWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRSb3cgPSBhcnJUYWJSb3dzW3JJZHggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0Um93KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBjZWxscy5mb3JFYWNoKChjZWxsLCBjSWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93c3BhbiA9IGNlbGwuX3Jvd0NvbnRpbnVlIHx8ICgoX2EgPSBjZWxsLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yb3dzcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbHNwYW4gPSAoX2IgPSBjZWxsLm9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb2xzcGFuO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgX2htZXJnZSA9IGNlbGwuX2htZXJnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3dzcGFuICYmIHJvd3NwYW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaE1lcmdlQ2VsbCA9IHsgX3R5cGU6IFNMSURFX09CSkVDVF9UWVBFUy50YWJsZWNlbGwsIG9wdGlvbnM6IHsgY29sc3BhbiB9LCBfcm93Q29udGludWU6IHJvd3NwYW4gLSAxLCBfdm1lcmdlOiB0cnVlLCBfaG1lcmdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFJvdy5zcGxpY2UoY0lkeCwgMCwgaE1lcmdlQ2VsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFNURVAgNDogQnVpbGQgdGFibGUgcm93cy9jZWxsc1xuICAgICAgICAgICAgICAgIGFyclRhYlJvd3MuZm9yRWFjaCgoY2VsbHMsIHJJZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQTogVGFibGUgSGVpZ2h0IHByb3ZpZGVkIHdpdGhvdXQgcm93SD8gVGhlbiBkaXN0cmlidXRlIHJvd3NcbiAgICAgICAgICAgICAgICAgICAgbGV0IGludFJvd0ggPSAwOyAvLyBJTVBPUlRBTlQ6IERlZmF1bHQgbXVzdCBiZSB6ZXJvIGZvciBhdXRvLXNpemluZyB0byB3b3JrXG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialRhYk9wdHMucm93SCkgJiYgb2JqVGFiT3B0cy5yb3dIW3JJZHhdKVxuICAgICAgICAgICAgICAgICAgICAgICAgaW50Um93SCA9IGluY2gyRW11KE51bWJlcihvYmpUYWJPcHRzLnJvd0hbcklkeF0pKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob2JqVGFiT3B0cy5yb3dIICYmICFpc05hTihOdW1iZXIob2JqVGFiT3B0cy5yb3dIKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRSb3dIID0gaW5jaDJFbXUoTnVtYmVyKG9ialRhYk9wdHMucm93SCkpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzbGlkZUl0ZW1PYmoub3B0aW9ucy5jeSB8fCBzbGlkZUl0ZW1PYmoub3B0aW9ucy5oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRSb3dIID0gTWF0aC5yb3VuZCgoc2xpZGVJdGVtT2JqLm9wdGlvbnMuaCA/IGluY2gyRW11KHNsaWRlSXRlbU9iai5vcHRpb25zLmgpIDogdHlwZW9mIHNsaWRlSXRlbU9iai5vcHRpb25zLmN5ID09PSAnbnVtYmVyJyA/IHNsaWRlSXRlbU9iai5vcHRpb25zLmN5IDogMSkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyclRhYlJvd3MubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBCOiBTdGFydCByb3dcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9IGA8YTp0ciBoPVwiJHtpbnRSb3dIfVwiPmA7XG4gICAgICAgICAgICAgICAgICAgIC8vIEM6IExvb3Agb3ZlciBlYWNoIENFTExcbiAgICAgICAgICAgICAgICAgICAgY2VsbHMuZm9yRWFjaChjZWxsT2JqID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gY2VsbE9iajtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxTcGFuQXR0cnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93U3BhbjogKChfYSA9IGNlbGwub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJvd3NwYW4pID4gMSA/IGNlbGwub3B0aW9ucy5yb3dzcGFuIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRTcGFuOiAoKF9iID0gY2VsbC5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29sc3BhbikgPiAxID8gY2VsbC5vcHRpb25zLmNvbHNwYW4gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdk1lcmdlOiBjZWxsLl92bWVyZ2UgPyAxIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhNZXJnZTogY2VsbC5faG1lcmdlID8gMSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2VsbFNwYW5BdHRyU3RyID0gT2JqZWN0LmtleXMoY2VsbFNwYW5BdHRycylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGsgPT4gW2ssIGNlbGxTcGFuQXR0cnNba11dKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKFssIHZdKSA9PiAhIXYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoW2ssIHZdKSA9PiBgJHtTdHJpbmcoayl9PVwiJHtTdHJpbmcodil9XCJgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbFNwYW5BdHRyU3RyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxTcGFuQXR0clN0ciA9ICcgJyArIGNlbGxTcGFuQXR0clN0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDE6IENPTFNQQU4vUk9XU1BBTjogQWRkIGR1bW15IGNlbGxzIGZvciBhbnkgYWN0aXZlIGNvbHNwYW4vcm93c3BhblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwuX2htZXJnZSB8fCBjZWxsLl92bWVyZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYDxhOnRjJHtjZWxsU3BhbkF0dHJTdHJ9PjxhOnRjUHIvPjwvYTp0Yz5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDI6IE9QVElPTlM6IEJ1aWxkL3NldCBjZWxsIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxPcHRzID0gY2VsbC5vcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5vcHRpb25zID0gY2VsbE9wdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBbJ2FsaWduJywgJ2JvbGQnLCAnYm9yZGVyJywgJ2NvbG9yJywgJ2ZpbGwnLCAnZm9udEZhY2UnLCAnZm9udFNpemUnLCAnbWFyZ2luJywgJ3RleHREaXJlY3Rpb24nLCAndW5kZXJsaW5lJywgJ3ZhbGlnbiddLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ialRhYk9wdHNbbmFtZV0gJiYgIWNlbGxPcHRzW25hbWVdICYmIGNlbGxPcHRzW25hbWVdICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsT3B0c1tuYW1lXSA9IG9ialRhYk9wdHNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxWYWxpZ24gPSBjZWxsT3B0cy52YWxpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGAgYW5jaG9yPVwiJHtjZWxsT3B0cy52YWxpZ24ucmVwbGFjZSgvXmMkL2ksICdjdHInKS5yZXBsYWNlKC9ebSQvaSwgJ2N0cicpLnJlcGxhY2UoJ2NlbnRlcicsICdjdHInKS5yZXBsYWNlKCdtaWRkbGUnLCAnY3RyJykucmVwbGFjZSgndG9wJywgJ3QnKS5yZXBsYWNlKCdidG0nLCAnYicpLnJlcGxhY2UoJ2JvdHRvbScsICdiJyl9XCJgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxUZXh0RGlyID0gKGNlbGxPcHRzLnRleHREaXJlY3Rpb24gJiYgY2VsbE9wdHMudGV4dERpcmVjdGlvbiAhPT0gJ2hvcnonKSA/IGAgdmVydD1cIiR7Y2VsbE9wdHMudGV4dERpcmVjdGlvbn1cImAgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWxsQ29sb3IgPSAoKF9kID0gKF9jID0gY2VsbC5fb3B0SW1wKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZmlsbCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNvbG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY2VsbC5fb3B0SW1wLmZpbGwuY29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICgoX2UgPSBjZWxsLl9vcHRJbXApID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5maWxsKSAmJiB0eXBlb2YgY2VsbC5fb3B0SW1wLmZpbGwgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY2VsbC5fb3B0SW1wLmZpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvciA9IGZpbGxDb2xvciB8fCBjZWxsT3B0cy5maWxsID8gY2VsbE9wdHMuZmlsbCA6ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbEZpbGwgPSBmaWxsQ29sb3IgPyBnZW5YbWxDb2xvclNlbGVjdGlvbihmaWxsQ29sb3IpIDogJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2VsbE1hcmdpbiA9IGNlbGxPcHRzLm1hcmdpbiA9PT0gMCB8fCBjZWxsT3B0cy5tYXJnaW4gPyBjZWxsT3B0cy5tYXJnaW4gOiBERUZfQ0VMTF9NQVJHSU5fSU47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2VsbE1hcmdpbikgJiYgdHlwZW9mIGNlbGxNYXJnaW4gPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxNYXJnaW4gPSBbY2VsbE1hcmdpbiwgY2VsbE1hcmdpbiwgY2VsbE1hcmdpbiwgY2VsbE1hcmdpbl07XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiogRlVUVVJFOiBERVBSRUNBVEVEOlxuICAgICAgICAgICAgICAgICAgICAgICAgICogLSBCYWNrd2FyZHMtQ29tcGF0OiBPb3BzISBEaXNjb3ZlcmVkIHdlIHdlcmUgc3RpbGwgdXNpbmcgcG9pbnRzIGZvciBjZWxsIG1hcmdpbiBiZWZvcmUgdjMuOC4wIChVR0ghKVxuICAgICAgICAgICAgICAgICAgICAgICAgICogLSBXZSBjYW50IGludHJvZHVjZSBhIGJyZWFraW5nIGNoYW5nZSBiZWZvcmUgdjQuMCwgc28uLi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNlbGxNYXJnaW5YbWwgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsTWFyZ2luWzBdID49IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsTWFyZ2luWG1sID0gYCBtYXJMPVwiJHt2YWxUb1B0cyhjZWxsTWFyZ2luWzNdKX1cIiBtYXJSPVwiJHt2YWxUb1B0cyhjZWxsTWFyZ2luWzFdKX1cIiBtYXJUPVwiJHt2YWxUb1B0cyhjZWxsTWFyZ2luWzBdKX1cIiBtYXJCPVwiJHt2YWxUb1B0cyhjZWxsTWFyZ2luWzJdKX1cImA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsTWFyZ2luWG1sID0gYCBtYXJMPVwiJHtpbmNoMkVtdShjZWxsTWFyZ2luWzNdKX1cIiBtYXJSPVwiJHtpbmNoMkVtdShjZWxsTWFyZ2luWzFdKX1cIiBtYXJUPVwiJHtpbmNoMkVtdShjZWxsTWFyZ2luWzBdKX1cIiBtYXJCPVwiJHtpbmNoMkVtdShjZWxsTWFyZ2luWzJdKX1cImA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGVVRVUkU6IENlbGwgTk9XUkFQIHByb3BlcnR5ICh0ZXh0d3JhcDogYWRkIHRvIGE6dGNQciAoaG9yek92ZXJmbG93PVwib3ZlcmZsb3dcIiBvciB3aGF0ZXZlciBvcHRpb25zIGV4aXN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gNDogU2V0IENFTEwgY29udGVudCBhbmQgcHJvcGVydGllcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYDxhOnRjJHtjZWxsU3BhbkF0dHJTdHJ9PiR7Z2VuWG1sVGV4dEJvZHkoY2VsbCl9PGE6dGNQciR7Y2VsbE1hcmdpblhtbH0ke2NlbGxWYWxpZ259JHtjZWxsVGV4dERpcn0+YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0clhtbCArPSBgPGE6dGMke2NlbGxDb2xzcGFufSR7Y2VsbFJvd3NwYW59PiR7Z2VuWG1sVGV4dEJvZHkoY2VsbCl9PGE6dGNQciR7Y2VsbE1hcmdpblhtbH0ke2NlbGxWYWxpZ259JHtjZWxsVGV4dERpcn0+YFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IDIwMjAwNTI1OiBeXl5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxhOnRjUHIgbWFyTD1cIjM4MTAwXCIgbWFyUj1cIjM4MTAwXCIgbWFyVD1cIjM4MTAwXCIgbWFyQj1cIjM4MTAwXCIgdmVydD1cInZlcnQyNzBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDU6IEJvcmRlcnM6IEFkZCBhbnkgYm9yZGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxPcHRzLmJvcmRlciAmJiBBcnJheS5pc0FycmF5KGNlbGxPcHRzLmJvcmRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiAqKiogSU1QT1JUQU5UISAqKiogTFJUQiBvcmRlciBtYXR0ZXJzISAoUmVvcmRlciBhIGxpbmUgYmVsb3cgdG8gd2F0Y2ggdGhlIGJvcmRlcnMgZ28gd29ua3kgaW4gTVMtUFBULTIwMTMhISlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaWR4OiAzLCBuYW1lOiAnbG5MJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGlkeDogMSwgbmFtZTogJ2xuUicgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpZHg6IDAsIG5hbWU6ICdsblQnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaWR4OiAyLCBuYW1lOiAnbG5CJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0uZm9yRWFjaChvYmogPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbE9wdHMuYm9yZGVyW29iai5pZHhdLnR5cGUgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9IGA8YToke29iai5uYW1lfSB3PVwiJHt2YWxUb1B0cyhjZWxsT3B0cy5ib3JkZXJbb2JqLmlkeF0ucHQpfVwiIGNhcD1cImZsYXRcIiBjbXBkPVwic25nXCIgYWxnbj1cImN0clwiPmA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYDxhOnNvbGlkRmlsbD4ke2NyZWF0ZUNvbG9yRWxlbWVudChjZWxsT3B0cy5ib3JkZXJbb2JqLmlkeF0uY29sb3IpfTwvYTpzb2xpZEZpbGw+YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBgPGE6cHJzdERhc2ggdmFsPVwiJHtjZWxsT3B0cy5ib3JkZXJbb2JqLmlkeF0udHlwZSA9PT0gJ2Rhc2gnID8gJ3N5c0Rhc2gnIDogJ3NvbGlkJ31cIi8+PGE6cm91bmQvPjxhOmhlYWRFbmQgdHlwZT1cIm5vbmVcIiB3PVwibWVkXCIgbGVuPVwibWVkXCIvPjxhOnRhaWxFbmQgdHlwZT1cIm5vbmVcIiB3PVwibWVkXCIgbGVuPVwibWVkXCIvPmA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYDwvYToke29iai5uYW1lfT5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9IGA8YToke29iai5uYW1lfSB3PVwiMFwiIGNhcD1cImZsYXRcIiBjbXBkPVwic25nXCIgYWxnbj1cImN0clwiPjxhOm5vRmlsbC8+PC9hOiR7b2JqLm5hbWV9PmA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDY6IENsb3NlIGNlbGwgUHJvcGVydGllcyAmIENlbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSBjZWxsRmlsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clhtbCArPSAnICA8L2E6dGNQcj4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgPC9hOnRjPic7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBEOiBDb21wbGV0ZSByb3dcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8L2E6dHI+JztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBTVEVQIDU6IENvbXBsZXRlIHRhYmxlXG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgICA8L2E6dGJsPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgICAgPC9hOmdyYXBoaWNEYXRhPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICcgIDwvYTpncmFwaGljPic7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8L3A6Z3JhcGhpY0ZyYW1lPic7XG4gICAgICAgICAgICAgICAgLy8gU1RFUCA2OiBTZXQgdGFibGUgWE1MXG4gICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gc3RyWG1sO1xuICAgICAgICAgICAgICAgIC8vIExBU1Q6IEluY3JlbWVudCBjb3VudGVyXG4gICAgICAgICAgICAgICAgaW50VGFibGVOdW0rKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU0xJREVfT0JKRUNUX1RZUEVTLnRleHQ6XG4gICAgICAgICAgICBjYXNlIFNMSURFX09CSkVDVF9UWVBFUy5wbGFjZWhvbGRlcjpcbiAgICAgICAgICAgICAgICAvLyBMaW5lcyBjYW4gaGF2ZSB6ZXJvIGN5LCBidXQgdGV4dCBzaG91bGQgbm90XG4gICAgICAgICAgICAgICAgaWYgKCFzbGlkZUl0ZW1PYmoub3B0aW9ucy5saW5lICYmIGN5ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICBjeSA9IEVNVSAqIDAuMztcbiAgICAgICAgICAgICAgICAvLyBNYXJnaW4vUGFkZGluZy9JbnNldCBmb3IgdGV4dGJveGVzXG4gICAgICAgICAgICAgICAgaWYgKCFzbGlkZUl0ZW1PYmoub3B0aW9ucy5fYm9keVByb3ApXG4gICAgICAgICAgICAgICAgICAgIHNsaWRlSXRlbU9iai5vcHRpb25zLl9ib2R5UHJvcCA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChzbGlkZUl0ZW1PYmoub3B0aW9ucy5tYXJnaW4gJiYgQXJyYXkuaXNBcnJheShzbGlkZUl0ZW1PYmoub3B0aW9ucy5tYXJnaW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlSXRlbU9iai5vcHRpb25zLl9ib2R5UHJvcC5sSW5zID0gdmFsVG9QdHMoc2xpZGVJdGVtT2JqLm9wdGlvbnMubWFyZ2luWzBdIHx8IDApO1xuICAgICAgICAgICAgICAgICAgICBzbGlkZUl0ZW1PYmoub3B0aW9ucy5fYm9keVByb3AucklucyA9IHZhbFRvUHRzKHNsaWRlSXRlbU9iai5vcHRpb25zLm1hcmdpblsxXSB8fCAwKTtcbiAgICAgICAgICAgICAgICAgICAgc2xpZGVJdGVtT2JqLm9wdGlvbnMuX2JvZHlQcm9wLmJJbnMgPSB2YWxUb1B0cyhzbGlkZUl0ZW1PYmoub3B0aW9ucy5tYXJnaW5bMl0gfHwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlSXRlbU9iai5vcHRpb25zLl9ib2R5UHJvcC50SW5zID0gdmFsVG9QdHMoc2xpZGVJdGVtT2JqLm9wdGlvbnMubWFyZ2luWzNdIHx8IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2xpZGVJdGVtT2JqLm9wdGlvbnMubWFyZ2luID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBzbGlkZUl0ZW1PYmoub3B0aW9ucy5fYm9keVByb3AubElucyA9IHZhbFRvUHRzKHNsaWRlSXRlbU9iai5vcHRpb25zLm1hcmdpbik7XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlSXRlbU9iai5vcHRpb25zLl9ib2R5UHJvcC5ySW5zID0gdmFsVG9QdHMoc2xpZGVJdGVtT2JqLm9wdGlvbnMubWFyZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgc2xpZGVJdGVtT2JqLm9wdGlvbnMuX2JvZHlQcm9wLmJJbnMgPSB2YWxUb1B0cyhzbGlkZUl0ZW1PYmoub3B0aW9ucy5tYXJnaW4pO1xuICAgICAgICAgICAgICAgICAgICBzbGlkZUl0ZW1PYmoub3B0aW9ucy5fYm9keVByb3AudElucyA9IHZhbFRvUHRzKHNsaWRlSXRlbU9iai5vcHRpb25zLm1hcmdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEE6IFN0YXJ0IFNIQVBFID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnPHA6c3A+JztcbiAgICAgICAgICAgICAgICAvLyBCOiBUaGUgYWRkaXRpb24gb2YgdGhlIFwidHhCb3hcIiBhdHRyaWJ1dGUgaXMgdGhlIHNvbGUgZGV0ZXJtaW5lciBvZiBpZiBhbiBvYmplY3QgaXMgYSBzaGFwZSBvciB0ZXh0Ym94XG4gICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYDxwOm52U3BQcj48cDpjTnZQciBpZD1cIiR7aWR4ICsgMn1cIiBuYW1lPVwiJHtzbGlkZUl0ZW1PYmoub3B0aW9ucy5vYmplY3ROYW1lfVwiPmA7XG4gICAgICAgICAgICAgICAgLy8gPEh5cGVybGluaz5cbiAgICAgICAgICAgICAgICBpZiAoKF9jID0gc2xpZGVJdGVtT2JqLm9wdGlvbnMuaHlwZXJsaW5rKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9IGA8YTpobGlua0NsaWNrIHI6aWQ9XCJySWQke3NsaWRlSXRlbU9iai5vcHRpb25zLmh5cGVybGluay5fcklkfVwiIHRvb2x0aXA9XCIke3NsaWRlSXRlbU9iai5vcHRpb25zLmh5cGVybGluay50b29sdGlwID8gZW5jb2RlWG1sRW50aXRpZXMoc2xpZGVJdGVtT2JqLm9wdGlvbnMuaHlwZXJsaW5rLnRvb2x0aXApIDogJyd9XCIvPmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoX2QgPSBzbGlkZUl0ZW1PYmoub3B0aW9ucy5oeXBlcmxpbmspID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5zbGlkZSkge1xuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgPGE6aGxpbmtDbGljayByOmlkPVwicklkJHtzbGlkZUl0ZW1PYmoub3B0aW9ucy5oeXBlcmxpbmsuX3JJZH1cIiB0b29sdGlwPVwiJHtzbGlkZUl0ZW1PYmoub3B0aW9ucy5oeXBlcmxpbmsudG9vbHRpcCA/IGVuY29kZVhtbEVudGl0aWVzKHNsaWRlSXRlbU9iai5vcHRpb25zLmh5cGVybGluay50b29sdGlwKSA6ICcnfVwiIGFjdGlvbj1cInBwYWN0aW9uOi8vaGxpbmtzbGRqdW1wXCIvPmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIDwvSHlwZXJsaW5rPlxuICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICc8L3A6Y052UHI+JztcbiAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnPHA6Y052U3BQcicgKyAoKChfZSA9IHNsaWRlSXRlbU9iai5vcHRpb25zKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuaXNUZXh0Qm94KSA/ICcgdHhCb3g9XCIxXCIvPicgOiAnLz4nKTtcbiAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgPHA6bnZQcj4ke3NsaWRlSXRlbU9iai5fdHlwZSA9PT0gJ3BsYWNlaG9sZGVyJyA/IGdlblhtbFBsYWNlaG9sZGVyKHNsaWRlSXRlbU9iaikgOiBnZW5YbWxQbGFjZWhvbGRlcihwbGFjZWhvbGRlck9iail9PC9wOm52UHI+YDtcbiAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnPC9wOm52U3BQcj48cDpzcFByPic7XG4gICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYDxhOnhmcm0ke2xvY2F0aW9uQXR0cn0+YDtcbiAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgPGE6b2ZmIHg9XCIke3h9XCIgeT1cIiR7eX1cIi8+YDtcbiAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgPGE6ZXh0IGN4PVwiJHtjeH1cIiBjeT1cIiR7Y3l9XCIvPjwvYTp4ZnJtPmA7XG4gICAgICAgICAgICAgICAgaWYgKHNsaWRlSXRlbU9iai5zaGFwZSA9PT0gJ2N1c3RHZW9tJykge1xuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnPGE6Y3VzdEdlb20+PGE6YXZMc3QgLz4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnPGE6Z2RMc3Q+JztcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJzwvYTpnZExzdD4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnPGE6YWhMc3QgLz4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnPGE6Y3huTHN0Pic7XG4gICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICc8L2E6Y3huTHN0Pic7XG4gICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICc8YTpyZWN0IGw9XCJsXCIgdD1cInRcIiByPVwiclwiIGI9XCJiXCIgLz4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnPGE6cGF0aExzdD4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgPGE6cGF0aCB3PVwiJHtjeH1cIiBoPVwiJHtjeX1cIj5gO1xuICAgICAgICAgICAgICAgICAgICAoX2YgPSBzbGlkZUl0ZW1PYmoub3B0aW9ucy5wb2ludHMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5mb3JFYWNoKChwb2ludCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdjdXJ2ZScgaW4gcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHBvaW50LmN1cnZlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXJjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9IGA8YTphcmNUbyBoUj1cIiR7Z2V0U21hcnRQYXJzZU51bWJlcihwb2ludC5jdXJ2ZS5oUiwgJ1knLCBzbGlkZS5fcHJlc0xheW91dCl9XCIgd1I9XCIke2dldFNtYXJ0UGFyc2VOdW1iZXIocG9pbnQuY3VydmUud1IsICdYJywgc2xpZGUuX3ByZXNMYXlvdXQpfVwiIHN0QW5nPVwiJHtjb252ZXJ0Um90YXRpb25EZWdyZWVzKHBvaW50LmN1cnZlLnN0QW5nKX1cIiBzd0FuZz1cIiR7Y29udmVydFJvdGF0aW9uRGVncmVlcyhwb2ludC5jdXJ2ZS5zd0FuZyl9XCIgLz5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2N1YmljJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9IGA8YTpjdWJpY0JlelRvPlxuXHRcdFx0XHRcdFx0XHRcdFx0PGE6cHQgeD1cIiR7Z2V0U21hcnRQYXJzZU51bWJlcihwb2ludC5jdXJ2ZS54MSwgJ1gnLCBzbGlkZS5fcHJlc0xheW91dCl9XCIgeT1cIiR7Z2V0U21hcnRQYXJzZU51bWJlcihwb2ludC5jdXJ2ZS55MSwgJ1knLCBzbGlkZS5fcHJlc0xheW91dCl9XCIgLz5cblx0XHRcdFx0XHRcdFx0XHRcdDxhOnB0IHg9XCIke2dldFNtYXJ0UGFyc2VOdW1iZXIocG9pbnQuY3VydmUueDIsICdYJywgc2xpZGUuX3ByZXNMYXlvdXQpfVwiIHk9XCIke2dldFNtYXJ0UGFyc2VOdW1iZXIocG9pbnQuY3VydmUueTIsICdZJywgc2xpZGUuX3ByZXNMYXlvdXQpfVwiIC8+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8YTpwdCB4PVwiJHtnZXRTbWFydFBhcnNlTnVtYmVyKHBvaW50LngsICdYJywgc2xpZGUuX3ByZXNMYXlvdXQpfVwiIHk9XCIke2dldFNtYXJ0UGFyc2VOdW1iZXIocG9pbnQueSwgJ1knLCBzbGlkZS5fcHJlc0xheW91dCl9XCIgLz5cblx0XHRcdFx0XHRcdFx0XHRcdDwvYTpjdWJpY0JlelRvPmA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncXVhZHJhdGljJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9IGA8YTpxdWFkQmV6VG8+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8YTpwdCB4PVwiJHtnZXRTbWFydFBhcnNlTnVtYmVyKHBvaW50LmN1cnZlLngxLCAnWCcsIHNsaWRlLl9wcmVzTGF5b3V0KX1cIiB5PVwiJHtnZXRTbWFydFBhcnNlTnVtYmVyKHBvaW50LmN1cnZlLnkxLCAnWScsIHNsaWRlLl9wcmVzTGF5b3V0KX1cIiAvPlxuXHRcdFx0XHRcdFx0XHRcdFx0PGE6cHQgeD1cIiR7Z2V0U21hcnRQYXJzZU51bWJlcihwb2ludC54LCAnWCcsIHNsaWRlLl9wcmVzTGF5b3V0KX1cIiB5PVwiJHtnZXRTbWFydFBhcnNlTnVtYmVyKHBvaW50LnksICdZJywgc2xpZGUuX3ByZXNMYXlvdXQpfVwiIC8+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8L2E6cXVhZEJlelRvPmA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgnY2xvc2UnIGluIHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJzxhOmNsb3NlIC8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBvaW50Lm1vdmVUbyB8fCBpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYDxhOm1vdmVUbz48YTpwdCB4PVwiJHtnZXRTbWFydFBhcnNlTnVtYmVyKHBvaW50LngsICdYJywgc2xpZGUuX3ByZXNMYXlvdXQpfVwiIHk9XCIke2dldFNtYXJ0UGFyc2VOdW1iZXIocG9pbnQueSwgJ1knLCBzbGlkZS5fcHJlc0xheW91dCl9XCIgLz48L2E6bW92ZVRvPmA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgPGE6bG5Ubz48YTpwdCB4PVwiJHtnZXRTbWFydFBhcnNlTnVtYmVyKHBvaW50LngsICdYJywgc2xpZGUuX3ByZXNMYXlvdXQpfVwiIHk9XCIke2dldFNtYXJ0UGFyc2VOdW1iZXIocG9pbnQueSwgJ1knLCBzbGlkZS5fcHJlc0xheW91dCl9XCIgLz48L2E6bG5Ubz5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJzwvYTpwYXRoPic7XG4gICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICc8L2E6cGF0aExzdD4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnPC9hOmN1c3RHZW9tPic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnPGE6cHJzdEdlb20gcHJzdD1cIicgKyBzbGlkZUl0ZW1PYmouc2hhcGUgKyAnXCI+PGE6YXZMc3Q+JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNsaWRlSXRlbU9iai5vcHRpb25zLnJlY3RSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9IGA8YTpnZCBuYW1lPVwiYWRqXCIgZm1sYT1cInZhbCAke01hdGgucm91bmQoKHNsaWRlSXRlbU9iai5vcHRpb25zLnJlY3RSYWRpdXMgKiBFTVUgKiAxMDAwMDApIC8gTWF0aC5taW4oY3gsIGN5KSl9XCIvPmA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2xpZGVJdGVtT2JqLm9wdGlvbnMuYW5nbGVSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhbmdsZSA9IHNsaWRlSXRlbU9iai5vcHRpb25zLmFuZ2xlUmFuZ2VbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYDxhOmdkIG5hbWU9XCJhZGoke2kgKyAxfVwiIGZtbGE9XCJ2YWwgJHtjb252ZXJ0Um90YXRpb25EZWdyZWVzKGFuZ2xlKX1cIiAvPmA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xpZGVJdGVtT2JqLm9wdGlvbnMuYXJjVGhpY2tuZXNzUmF0aW8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgPGE6Z2QgbmFtZT1cImFkajNcIiBmbWxhPVwidmFsICR7TWF0aC5yb3VuZChzbGlkZUl0ZW1PYmoub3B0aW9ucy5hcmNUaGlja25lc3NSYXRpbyAqIDUwMDAwKX1cIiAvPmA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJzwvYTphdkxzdD48L2E6cHJzdEdlb20+JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT3B0aW9uOiBGSUxMXG4gICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gc2xpZGVJdGVtT2JqLm9wdGlvbnMuZmlsbCA/IGdlblhtbENvbG9yU2VsZWN0aW9uKHNsaWRlSXRlbU9iai5vcHRpb25zLmZpbGwpIDogJzxhOm5vRmlsbC8+JztcbiAgICAgICAgICAgICAgICAvLyBzaGFwZSBUeXBlOiBMSU5FOiBsaW5lIGNvbG9yXG4gICAgICAgICAgICAgICAgaWYgKHNsaWRlSXRlbU9iai5vcHRpb25zLmxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gc2xpZGVJdGVtT2JqLm9wdGlvbnMubGluZS53aWR0aCA/IGA8YTpsbiB3PVwiJHt2YWxUb1B0cyhzbGlkZUl0ZW1PYmoub3B0aW9ucy5saW5lLndpZHRoKX1cIj5gIDogJzxhOmxuPic7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbGlkZUl0ZW1PYmoub3B0aW9ucy5saW5lLmNvbG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gZ2VuWG1sQ29sb3JTZWxlY3Rpb24oc2xpZGVJdGVtT2JqLm9wdGlvbnMubGluZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbGlkZUl0ZW1PYmoub3B0aW9ucy5saW5lLmRhc2hUeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYDxhOnByc3REYXNoIHZhbD1cIiR7c2xpZGVJdGVtT2JqLm9wdGlvbnMubGluZS5kYXNoVHlwZX1cIi8+YDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNsaWRlSXRlbU9iai5vcHRpb25zLmxpbmUuYmVnaW5BcnJvd1R5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgPGE6aGVhZEVuZCB0eXBlPVwiJHtzbGlkZUl0ZW1PYmoub3B0aW9ucy5saW5lLmJlZ2luQXJyb3dUeXBlfVwiLz5gO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2xpZGVJdGVtT2JqLm9wdGlvbnMubGluZS5lbmRBcnJvd1R5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgPGE6dGFpbEVuZCB0eXBlPVwiJHtzbGlkZUl0ZW1PYmoub3B0aW9ucy5saW5lLmVuZEFycm93VHlwZX1cIi8+YDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRlVUVVJFOiBgZW5kQXJyb3dTaXplYCA8IGE6IGhlYWRFbmQgdHlwZSA9IFwiYXJyb3dcIiB3ID0gXCJsZ1wiIGxlbiA9IFwibGdcIiAvPiAnc20nIHwgJ21lZCcgfCAnbGcnKHZhbHVlcyBhcmUgMSAtIDksIG1ha2luZyBhIDN4MyBncmlkIG9mIHcgLyBsZW4gcG9zc2liaWxpdGllcylcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJzwvYTpsbj4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFRkZFQ1RTID4gU0hBRE9XOiBSRUY6IEBzZWUgaHR0cDovL29mZmljZW9wZW54bWwuY29tL2Ryd1NwLWVmZmVjdHMucGhwXG4gICAgICAgICAgICAgICAgaWYgKHNsaWRlSXRlbU9iai5vcHRpb25zLnNoYWRvdyAmJiBzbGlkZUl0ZW1PYmoub3B0aW9ucy5zaGFkb3cudHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlSXRlbU9iai5vcHRpb25zLnNoYWRvdy50eXBlID0gc2xpZGVJdGVtT2JqLm9wdGlvbnMuc2hhZG93LnR5cGUgfHwgJ291dGVyJztcbiAgICAgICAgICAgICAgICAgICAgc2xpZGVJdGVtT2JqLm9wdGlvbnMuc2hhZG93LmJsdXIgPSB2YWxUb1B0cyhzbGlkZUl0ZW1PYmoub3B0aW9ucy5zaGFkb3cuYmx1ciB8fCA4KTtcbiAgICAgICAgICAgICAgICAgICAgc2xpZGVJdGVtT2JqLm9wdGlvbnMuc2hhZG93Lm9mZnNldCA9IHZhbFRvUHRzKHNsaWRlSXRlbU9iai5vcHRpb25zLnNoYWRvdy5vZmZzZXQgfHwgNCk7XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlSXRlbU9iai5vcHRpb25zLnNoYWRvdy5hbmdsZSA9IE1hdGgucm91bmQoKHNsaWRlSXRlbU9iai5vcHRpb25zLnNoYWRvdy5hbmdsZSB8fCAyNzApICogNjAwMDApO1xuICAgICAgICAgICAgICAgICAgICBzbGlkZUl0ZW1PYmoub3B0aW9ucy5zaGFkb3cub3BhY2l0eSA9IE1hdGgucm91bmQoKHNsaWRlSXRlbU9iai5vcHRpb25zLnNoYWRvdy5vcGFjaXR5IHx8IDAuNzUpICogMTAwMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgc2xpZGVJdGVtT2JqLm9wdGlvbnMuc2hhZG93LmNvbG9yID0gc2xpZGVJdGVtT2JqLm9wdGlvbnMuc2hhZG93LmNvbG9yIHx8IERFRl9URVhUX1NIQURPVy5jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJzxhOmVmZmVjdExzdD4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgIDxhOiR7c2xpZGVJdGVtT2JqLm9wdGlvbnMuc2hhZG93LnR5cGV9U2hkdyAke3NsaWRlSXRlbU9iai5vcHRpb25zLnNoYWRvdy50eXBlID09PSAnb3V0ZXInID8gJ3N4PVwiMTAwMDAwXCIgc3k9XCIxMDAwMDBcIiBreD1cIjBcIiBreT1cIjBcIiBhbGduPVwiYmxcIiByb3RXaXRoU2hhcGU9XCIwXCInIDogJyd9IGJsdXJSYWQ9XCIke3NsaWRlSXRlbU9iai5vcHRpb25zLnNoYWRvdy5ibHVyfVwiIGRpc3Q9XCIke3NsaWRlSXRlbU9iai5vcHRpb25zLnNoYWRvdy5vZmZzZXR9XCIgZGlyPVwiJHtzbGlkZUl0ZW1PYmoub3B0aW9ucy5zaGFkb3cuYW5nbGV9XCI+YDtcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYCA8YTpzcmdiQ2xyIHZhbD1cIiR7c2xpZGVJdGVtT2JqLm9wdGlvbnMuc2hhZG93LmNvbG9yfVwiPmA7XG4gICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9IGAgPGE6YWxwaGEgdmFsPVwiJHtzbGlkZUl0ZW1PYmoub3B0aW9ucy5zaGFkb3cub3BhY2l0eX1cIi8+PC9hOnNyZ2JDbHI+YDtcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJyA8L2E6b3V0ZXJTaGR3Pic7XG4gICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICc8L2E6ZWZmZWN0THN0Pic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIFRPRE86IEZVVFVSRTogVGV4dCB3cmFwcGluZyAoY29waWVkIGZyb20gTVMtUFBUWCBleHBvcnQpXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbW1lbnRlZCBvdXQgYi9jIGknbSBub3QgZXZlbiBzdXJlIHRoaXMgd29ya3MgLSBjdXJyZW50IGNvZGUgcHJvZHVjZXMgdGV4dCB0aGF0IHdyYXBzIGluIHNoYXBlcyBhbmQgdGV4dGJveGVzLCBzby4uLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNsaWRlSXRlbU9iai5vcHRpb25zLnRleHRXcmFwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJzxhOmV4dExzdD4nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICc8YTpleHQgdXJpPVwie0M1NzJBNzU5LTZBNTEtNDEwOC1BQTAyLURGQTBBMDRGQzk0Qn1cIj4nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICc8bWExNDp3cmFwcGluZ1RleHRCb3hGbGFnIHhtbG5zOm1hMTQ9XCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9tYWMvZHJhd2luZ21sLzIwMTEvbWFpblwiIHZhbD1cIjFcIi8+J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnPC9hOmV4dD4nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICc8L2E6ZXh0THN0Pic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIC8vIEI6IENsb3NlIHNoYXBlIFByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnPC9wOnNwUHI+JztcbiAgICAgICAgICAgICAgICAvLyBDOiBBZGQgZm9ybWF0dGVkIHRleHQgKHRleHQgYm9keSBcImJvZHlQclwiKVxuICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9IGdlblhtbFRleHRCb2R5KHNsaWRlSXRlbU9iaik7XG4gICAgICAgICAgICAgICAgLy8gTEFTVDogQ2xvc2UgU0hBUEUgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICc8L3A6c3A+JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU0xJREVfT0JKRUNUX1RZUEVTLmltYWdlOlxuICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICc8cDpwaWM+JztcbiAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnICA8cDpudlBpY1ByPic7XG4gICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYDxwOmNOdlByIGlkPVwiJHtpZHggKyAyfVwiIG5hbWU9XCIke3NsaWRlSXRlbU9iai5vcHRpb25zLm9iamVjdE5hbWV9XCIgZGVzY3I9XCIke2VuY29kZVhtbEVudGl0aWVzKHNsaWRlSXRlbU9iai5vcHRpb25zLmFsdFRleHQgfHwgc2xpZGVJdGVtT2JqLmltYWdlKX1cIj5gO1xuICAgICAgICAgICAgICAgIGlmICgoX2cgPSBzbGlkZUl0ZW1PYmouaHlwZXJsaW5rKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cudXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9IGA8YTpobGlua0NsaWNrIHI6aWQ9XCJySWQke3NsaWRlSXRlbU9iai5oeXBlcmxpbmsuX3JJZH1cIiB0b29sdGlwPVwiJHtzbGlkZUl0ZW1PYmouaHlwZXJsaW5rLnRvb2x0aXAgPyBlbmNvZGVYbWxFbnRpdGllcyhzbGlkZUl0ZW1PYmouaHlwZXJsaW5rLnRvb2x0aXApIDogJyd9XCIvPmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoX2ggPSBzbGlkZUl0ZW1PYmouaHlwZXJsaW5rKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guc2xpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYDxhOmhsaW5rQ2xpY2sgcjppZD1cInJJZCR7c2xpZGVJdGVtT2JqLmh5cGVybGluay5fcklkfVwiIHRvb2x0aXA9XCIke3NsaWRlSXRlbU9iai5oeXBlcmxpbmsudG9vbHRpcCA/IGVuY29kZVhtbEVudGl0aWVzKHNsaWRlSXRlbU9iai5oeXBlcmxpbmsudG9vbHRpcCkgOiAnJ31cIiBhY3Rpb249XCJwcGFjdGlvbjovL2hsaW5rc2xkanVtcFwiLz5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnICAgIDwvcDpjTnZQcj4nO1xuICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICcgICAgPHA6Y052UGljUHI+PGE6cGljTG9ja3Mgbm9DaGFuZ2VBc3BlY3Q9XCIxXCIvPjwvcDpjTnZQaWNQcj4nO1xuICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICcgICAgPHA6bnZQcj4nICsgZ2VuWG1sUGxhY2Vob2xkZXIocGxhY2Vob2xkZXJPYmopICsgJzwvcDpudlByPic7XG4gICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJyAgPC9wOm52UGljUHI+JztcbiAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnPHA6YmxpcEZpbGw+JztcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBUaGlzIHdvcmtzIGZvciBib3RoIGNhc2VzOiBlaXRoZXIgYHBhdGhgIG9yIGBkYXRhYCBjb250YWlucyB0aGUgU1ZHXG4gICAgICAgICAgICAgICAgaWYgKChzbGlkZS5fcmVsc01lZGlhIHx8IFtdKS5maWx0ZXIocmVsID0+IHJlbC5ySWQgPT09IHNsaWRlSXRlbU9iai5pbWFnZVJpZClbMF0gJiZcbiAgICAgICAgICAgICAgICAgICAgKHNsaWRlLl9yZWxzTWVkaWEgfHwgW10pLmZpbHRlcihyZWwgPT4gcmVsLnJJZCA9PT0gc2xpZGVJdGVtT2JqLmltYWdlUmlkKVswXS5leHRuID09PSAnc3ZnJykge1xuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgPGE6YmxpcCByOmVtYmVkPVwicklkJHtzbGlkZUl0ZW1PYmouaW1hZ2VSaWQgLSAxfVwiPmA7XG4gICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9IHNsaWRlSXRlbU9iai5vcHRpb25zLnRyYW5zcGFyZW5jeSA/IGAgPGE6YWxwaGFNb2RGaXggYW10PVwiJHtNYXRoLnJvdW5kKCgxMDAgLSBzbGlkZUl0ZW1PYmoub3B0aW9ucy50cmFuc3BhcmVuY3kpICogMTAwMCl9XCIvPmAgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJyA8YTpleHRMc3Q+JztcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJyAgPGE6ZXh0IHVyaT1cIns5NkRBQzU0MS03QjdBLTQzRDMtOEI3OS0zN0Q2MzNCODQ2RjF9XCI+JztcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYCAgIDxhc3ZnOnN2Z0JsaXAgeG1sbnM6YXN2Zz1cImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL2RyYXdpbmcvMjAxNi9TVkcvbWFpblwiIHI6ZW1iZWQ9XCJySWQke3NsaWRlSXRlbU9iai5pbWFnZVJpZH1cIi8+YDtcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJyAgPC9hOmV4dD4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnIDwvYTpleHRMc3Q+JztcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJzwvYTpibGlwPic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgPGE6YmxpcCByOmVtYmVkPVwicklkJHtzbGlkZUl0ZW1PYmouaW1hZ2VSaWR9XCI+YDtcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gc2xpZGVJdGVtT2JqLm9wdGlvbnMudHJhbnNwYXJlbmN5ID8gYDxhOmFscGhhTW9kRml4IGFtdD1cIiR7TWF0aC5yb3VuZCgoMTAwIC0gc2xpZGVJdGVtT2JqLm9wdGlvbnMudHJhbnNwYXJlbmN5KSAqIDEwMDApfVwiLz5gIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICc8L2E6YmxpcD4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2l6aW5nID09PSBudWxsIHx8IHNpemluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2l6aW5nLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm94VyA9IHNpemluZy53ID8gZ2V0U21hcnRQYXJzZU51bWJlcihzaXppbmcudywgJ1gnLCBzbGlkZS5fcHJlc0xheW91dCkgOiBjeDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm94SCA9IHNpemluZy5oID8gZ2V0U21hcnRQYXJzZU51bWJlcihzaXppbmcuaCwgJ1knLCBzbGlkZS5fcHJlc0xheW91dCkgOiBjeTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm94WCA9IGdldFNtYXJ0UGFyc2VOdW1iZXIoc2l6aW5nLnggfHwgMCwgJ1gnLCBzbGlkZS5fcHJlc0xheW91dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJveFkgPSBnZXRTbWFydFBhcnNlTnVtYmVyKHNpemluZy55IHx8IDAsICdZJywgc2xpZGUuX3ByZXNMYXlvdXQpO1xuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBJbWFnZVNpemluZ1htbFtzaXppbmcudHlwZV0oeyB3OiBpbWdXaWR0aCwgaDogaW1nSGVpZ2h0IH0sIHsgdzogYm94VywgaDogYm94SCwgeDogYm94WCwgeTogYm94WSB9KTtcbiAgICAgICAgICAgICAgICAgICAgaW1nV2lkdGggPSBib3hXO1xuICAgICAgICAgICAgICAgICAgICBpbWdIZWlnaHQgPSBib3hIO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJyAgPGE6c3RyZXRjaD48YTpmaWxsUmVjdC8+PC9hOnN0cmV0Y2g+JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJzwvcDpibGlwRmlsbD4nO1xuICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICc8cDpzcFByPic7XG4gICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJyA8YTp4ZnJtJyArIGxvY2F0aW9uQXR0ciArICc+JztcbiAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgICA8YTpvZmYgeD1cIiR7eH1cIiB5PVwiJHt5fVwiLz5gO1xuICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9IGAgIDxhOmV4dCBjeD1cIiR7aW1nV2lkdGh9XCIgY3k9XCIke2ltZ0hlaWdodH1cIi8+YDtcbiAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnIDwvYTp4ZnJtPic7XG4gICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYCA8YTpwcnN0R2VvbSBwcnN0PVwiJHtyb3VuZGluZyA/ICdlbGxpcHNlJyA6ICdyZWN0J31cIj48YTphdkxzdC8+PC9hOnByc3RHZW9tPmA7XG4gICAgICAgICAgICAgICAgLy8gRUZGRUNUUyA+IFNIQURPVzogUkVGOiBAc2VlIGh0dHA6Ly9vZmZpY2VvcGVueG1sLmNvbS9kcndTcC1lZmZlY3RzLnBocFxuICAgICAgICAgICAgICAgIGlmIChzbGlkZUl0ZW1PYmoub3B0aW9ucy5zaGFkb3cgJiYgc2xpZGVJdGVtT2JqLm9wdGlvbnMuc2hhZG93LnR5cGUgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICAgICBzbGlkZUl0ZW1PYmoub3B0aW9ucy5zaGFkb3cudHlwZSA9IHNsaWRlSXRlbU9iai5vcHRpb25zLnNoYWRvdy50eXBlIHx8ICdvdXRlcic7XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlSXRlbU9iai5vcHRpb25zLnNoYWRvdy5ibHVyID0gdmFsVG9QdHMoc2xpZGVJdGVtT2JqLm9wdGlvbnMuc2hhZG93LmJsdXIgfHwgOCk7XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlSXRlbU9iai5vcHRpb25zLnNoYWRvdy5vZmZzZXQgPSB2YWxUb1B0cyhzbGlkZUl0ZW1PYmoub3B0aW9ucy5zaGFkb3cub2Zmc2V0IHx8IDQpO1xuICAgICAgICAgICAgICAgICAgICBzbGlkZUl0ZW1PYmoub3B0aW9ucy5zaGFkb3cuYW5nbGUgPSBNYXRoLnJvdW5kKChzbGlkZUl0ZW1PYmoub3B0aW9ucy5zaGFkb3cuYW5nbGUgfHwgMjcwKSAqIDYwMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgc2xpZGVJdGVtT2JqLm9wdGlvbnMuc2hhZG93Lm9wYWNpdHkgPSBNYXRoLnJvdW5kKChzbGlkZUl0ZW1PYmoub3B0aW9ucy5zaGFkb3cub3BhY2l0eSB8fCAwLjc1KSAqIDEwMDAwMCk7XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlSXRlbU9iai5vcHRpb25zLnNoYWRvdy5jb2xvciA9IHNsaWRlSXRlbU9iai5vcHRpb25zLnNoYWRvdy5jb2xvciB8fCBERUZfVEVYVF9TSEFET1cuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICc8YTplZmZlY3RMc3Q+JztcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYDxhOiR7c2xpZGVJdGVtT2JqLm9wdGlvbnMuc2hhZG93LnR5cGV9U2hkdyAke3NsaWRlSXRlbU9iai5vcHRpb25zLnNoYWRvdy50eXBlID09PSAnb3V0ZXInID8gJ3N4PVwiMTAwMDAwXCIgc3k9XCIxMDAwMDBcIiBreD1cIjBcIiBreT1cIjBcIiBhbGduPVwiYmxcIiByb3RXaXRoU2hhcGU9XCIwXCInIDogJyd9IGJsdXJSYWQ9XCIke3NsaWRlSXRlbU9iai5vcHRpb25zLnNoYWRvdy5ibHVyfVwiIGRpc3Q9XCIke3NsaWRlSXRlbU9iai5vcHRpb25zLnNoYWRvdy5vZmZzZXR9XCIgZGlyPVwiJHtzbGlkZUl0ZW1PYmoub3B0aW9ucy5zaGFkb3cuYW5nbGV9XCI+YDtcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYDxhOnNyZ2JDbHIgdmFsPVwiJHtzbGlkZUl0ZW1PYmoub3B0aW9ucy5zaGFkb3cuY29sb3J9XCI+YDtcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYDxhOmFscGhhIHZhbD1cIiR7c2xpZGVJdGVtT2JqLm9wdGlvbnMuc2hhZG93Lm9wYWNpdHl9XCIvPjwvYTpzcmdiQ2xyPmA7XG4gICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9IGA8L2E6JHtzbGlkZUl0ZW1PYmoub3B0aW9ucy5zaGFkb3cudHlwZX1TaGR3PmA7XG4gICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICc8L2E6ZWZmZWN0THN0Pic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICc8L3A6c3BQcj4nO1xuICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICc8L3A6cGljPic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNMSURFX09CSkVDVF9UWVBFUy5tZWRpYTpcbiAgICAgICAgICAgICAgICBpZiAoc2xpZGVJdGVtT2JqLm10eXBlID09PSAnb25saW5lJykge1xuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnPHA6cGljPic7XG4gICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICcgPHA6bnZQaWNQcj4nO1xuICAgICAgICAgICAgICAgICAgICAvLyBJTVBPUlRBTlQ6IDxwOmNOdlByIGlkPVwiXCIgdmFsdWUgaXMgY3JpdGljYWwgLSBpZiBpdHMgbm90IHRoZSBzYW1lIG51bWJlciBhcyBwcmV2aWV3IGltYWdlIGBySWRgLCBQb3dlclBvaW50IHRocm93cyBlcnJvciFcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYDxwOmNOdlByIGlkPVwiJHtzbGlkZUl0ZW1PYmoubWVkaWFSaWQgKyAyfVwiIG5hbWU9XCIke3NsaWRlSXRlbU9iai5vcHRpb25zLm9iamVjdE5hbWV9XCIvPmA7XG4gICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICcgPHA6Y052UGljUHIvPic7XG4gICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICcgPHA6bnZQcj4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgICA8YTp2aWRlb0ZpbGUgcjpsaW5rPVwicklkJHtzbGlkZUl0ZW1PYmoubWVkaWFSaWR9XCIvPmA7XG4gICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICcgPC9wOm52UHI+JztcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJyA8L3A6bnZQaWNQcj4nO1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBgYmxpcGAgaXMgZGlmZXJlbnQgdGhhbiB2aWRlb3M7IGFsc28gdGhlcmUncyBubyBwcmV2aWV3IFwicDpleHRMc3RcIiBhYm92ZSBidXQgZXhpc3RzIGluIHZpZGVvc1xuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgIDxwOmJsaXBGaWxsPjxhOmJsaXAgcjplbWJlZD1cInJJZCR7c2xpZGVJdGVtT2JqLm1lZGlhUmlkICsgMX1cIi8+PGE6c3RyZXRjaD48YTpmaWxsUmVjdC8+PC9hOnN0cmV0Y2g+PC9wOmJsaXBGaWxsPmA7IC8vIE5PVEU6IFByZXZpZXcgaW1hZ2UgaXMgcmVxdWlyZWQhXG4gICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICcgPHA6c3BQcj4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgICA8YTp4ZnJtJHtsb2NhdGlvbkF0dHJ9PjxhOm9mZiB4PVwiJHt4fVwiIHk9XCIke3l9XCIvPjxhOmV4dCBjeD1cIiR7Y3h9XCIgY3k9XCIke2N5fVwiLz48L2E6eGZybT5gO1xuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnICA8YTpwcnN0R2VvbSBwcnN0PVwicmVjdFwiPjxhOmF2THN0Lz48L2E6cHJzdEdlb20+JztcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJyA8L3A6c3BQcj4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnPC9wOnBpYz4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJzxwOnBpYz4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnIDxwOm52UGljUHI+JztcbiAgICAgICAgICAgICAgICAgICAgLy8gSU1QT1JUQU5UOiA8cDpjTnZQciBpZD1cIlwiIHZhbHVlIGlzIGNyaXRpY2FsIC0gaWYgbm90IHRoZSBzYW1lIG51bWJlciBhcyBwcmVpZXcgaW1hZ2UgcklkLCBQb3dlclBvaW50IHRocm93cyBlcnJvciFcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYDxwOmNOdlByIGlkPVwiJHtzbGlkZUl0ZW1PYmoubWVkaWFSaWQgKyAyfVwiIG5hbWU9XCIke3NsaWRlSXRlbU9iai5vcHRpb25zLm9iamVjdE5hbWV9XCI+PGE6aGxpbmtDbGljayByOmlkPVwiXCIgYWN0aW9uPVwicHBhY3Rpb246Ly9tZWRpYVwiLz48L3A6Y052UHI+YDtcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJyA8cDpjTnZQaWNQcj48YTpwaWNMb2NrcyBub0NoYW5nZUFzcGVjdD1cIjFcIi8+PC9wOmNOdlBpY1ByPic7XG4gICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICcgPHA6bnZQcj4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgICA8YTp2aWRlb0ZpbGUgcjpsaW5rPVwicklkJHtzbGlkZUl0ZW1PYmoubWVkaWFSaWR9XCIvPmA7XG4gICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICcgIDxwOmV4dExzdD4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnICAgPHA6ZXh0IHVyaT1cIntEQUE0QjRENC02RDcxLTQ4NDEtOUM5NC0zREU3RkNGQjkyMzB9XCI+JztcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYCAgICA8cDE0Om1lZGlhIHhtbG5zOnAxND1cImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3Bvd2VycG9pbnQvMjAxMC9tYWluXCIgcjplbWJlZD1cInJJZCR7c2xpZGVJdGVtT2JqLm1lZGlhUmlkICsgMX1cIi8+YDtcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJyAgIDwvcDpleHQ+JztcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJyAgPC9wOmV4dExzdD4nO1xuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnIDwvcDpudlByPic7XG4gICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICcgPC9wOm52UGljUHI+JztcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYCA8cDpibGlwRmlsbD48YTpibGlwIHI6ZW1iZWQ9XCJySWQke3NsaWRlSXRlbU9iai5tZWRpYVJpZCArIDJ9XCIvPjxhOnN0cmV0Y2g+PGE6ZmlsbFJlY3QvPjwvYTpzdHJldGNoPjwvcDpibGlwRmlsbD5gOyAvLyBOT1RFOiBQcmV2aWV3IGltYWdlIGlzIHJlcXVpcmVkIVxuICAgICAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnIDxwOnNwUHI+JztcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYCAgPGE6eGZybSR7bG9jYXRpb25BdHRyfT48YTpvZmYgeD1cIiR7eH1cIiB5PVwiJHt5fVwiLz48YTpleHQgY3g9XCIke2N4fVwiIGN5PVwiJHtjeX1cIi8+PC9hOnhmcm0+YDtcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJyAgPGE6cHJzdEdlb20gcHJzdD1cInJlY3RcIj48YTphdkxzdC8+PC9hOnByc3RHZW9tPic7XG4gICAgICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICcgPC9wOnNwUHI+JztcbiAgICAgICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJzwvcDpwaWM+JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNMSURFX09CSkVDVF9UWVBFUy5jaGFydDpcbiAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnPHA6Z3JhcGhpY0ZyYW1lPic7XG4gICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJyA8cDpudkdyYXBoaWNGcmFtZVByPic7XG4gICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYCAgIDxwOmNOdlByIGlkPVwiJHtpZHggKyAyfVwiIG5hbWU9XCIke3NsaWRlSXRlbU9iai5vcHRpb25zLm9iamVjdE5hbWV9XCIgZGVzY3I9XCIke2VuY29kZVhtbEVudGl0aWVzKHNsaWRlSXRlbU9iai5vcHRpb25zLmFsdFRleHQgfHwgJycpfVwiLz5gO1xuICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICcgICA8cDpjTnZHcmFwaGljRnJhbWVQci8+JztcbiAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgICAgPHA6bnZQcj4ke2dlblhtbFBsYWNlaG9sZGVyKHBsYWNlaG9sZGVyT2JqKX08L3A6bnZQcj5gO1xuICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICcgPC9wOm52R3JhcGhpY0ZyYW1lUHI+JztcbiAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgIDxwOnhmcm0+PGE6b2ZmIHg9XCIke3h9XCIgeT1cIiR7eX1cIi8+PGE6ZXh0IGN4PVwiJHtjeH1cIiBjeT1cIiR7Y3l9XCIvPjwvcDp4ZnJtPmA7XG4gICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJyA8YTpncmFwaGljIHhtbG5zOmE9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvZHJhd2luZ21sLzIwMDYvbWFpblwiPic7XG4gICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJyAgPGE6Z3JhcGhpY0RhdGEgdXJpPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL2RyYXdpbmdtbC8yMDA2L2NoYXJ0XCI+JztcbiAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgICAgPGM6Y2hhcnQgcjppZD1cInJJZCR7c2xpZGVJdGVtT2JqLmNoYXJ0UmlkfVwiIHhtbG5zOmM9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvZHJhd2luZ21sLzIwMDYvY2hhcnRcIi8+YDtcbiAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnICA8L2E6Z3JhcGhpY0RhdGE+JztcbiAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnIDwvYTpncmFwaGljPic7XG4gICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJzwvcDpncmFwaGljRnJhbWU+JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBTVEVQIDQ6IEFkZCBzbGlkZSBudW1iZXJzIChpZiBhbnkpIGxhc3RcbiAgICBpZiAoc2xpZGUuX3NsaWRlTnVtYmVyUHJvcHMpIHtcbiAgICAgICAgLy8gU2V0IHNvbWUgZGVmYXVsdHMgKGRvbmUgaGVyZSBiL2MgU2xpZGVOdW1iZXIgY2FuYmUgYWRkZWQgdG8gbWFzdGVycyBvciBzbGlkZXMgYW5kIGhhcyBudW1lcm91cyBlbnRyeSBwb2ludHMpXG4gICAgICAgIGlmICghc2xpZGUuX3NsaWRlTnVtYmVyUHJvcHMuYWxpZ24pXG4gICAgICAgICAgICBzbGlkZS5fc2xpZGVOdW1iZXJQcm9wcy5hbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgc3RyU2xpZGVYbWwgKz0gJzxwOnNwPic7XG4gICAgICAgIHN0clNsaWRlWG1sICs9ICcgPHA6bnZTcFByPic7XG4gICAgICAgIHN0clNsaWRlWG1sICs9ICcgIDxwOmNOdlByIGlkPVwiMjVcIiBuYW1lPVwiU2xpZGUgTnVtYmVyIFBsYWNlaG9sZGVyIDBcIi8+PHA6Y052U3BQcj48YTpzcExvY2tzIG5vR3JwPVwiMVwiLz48L3A6Y052U3BQcj4nO1xuICAgICAgICBzdHJTbGlkZVhtbCArPSAnICA8cDpudlByPjxwOnBoIHR5cGU9XCJzbGROdW1cIiBzej1cInF1YXJ0ZXJcIiBpZHg9XCI0Mjk0OTY3Mjk1XCIvPjwvcDpudlByPic7XG4gICAgICAgIHN0clNsaWRlWG1sICs9ICcgPC9wOm52U3BQcj4nO1xuICAgICAgICBzdHJTbGlkZVhtbCArPSAnIDxwOnNwUHI+JztcbiAgICAgICAgc3RyU2xpZGVYbWwgKz0gJzxhOnhmcm0+JyArXG4gICAgICAgICAgICBgPGE6b2ZmIHg9XCIke2dldFNtYXJ0UGFyc2VOdW1iZXIoc2xpZGUuX3NsaWRlTnVtYmVyUHJvcHMueCwgJ1gnLCBzbGlkZS5fcHJlc0xheW91dCl9XCIgeT1cIiR7Z2V0U21hcnRQYXJzZU51bWJlcihzbGlkZS5fc2xpZGVOdW1iZXJQcm9wcy55LCAnWScsIHNsaWRlLl9wcmVzTGF5b3V0KX1cIi8+YCArXG4gICAgICAgICAgICBgPGE6ZXh0IGN4PVwiJHtzbGlkZS5fc2xpZGVOdW1iZXJQcm9wcy53ID8gZ2V0U21hcnRQYXJzZU51bWJlcihzbGlkZS5fc2xpZGVOdW1iZXJQcm9wcy53LCAnWCcsIHNsaWRlLl9wcmVzTGF5b3V0KSA6ICc4MDAwMDAnfVwiIGN5PVwiJHtzbGlkZS5fc2xpZGVOdW1iZXJQcm9wcy5oID8gZ2V0U21hcnRQYXJzZU51bWJlcihzbGlkZS5fc2xpZGVOdW1iZXJQcm9wcy5oLCAnWScsIHNsaWRlLl9wcmVzTGF5b3V0KSA6ICczMDAwMDAnfVwiLz5gICtcbiAgICAgICAgICAgICc8L2E6eGZybT4nICtcbiAgICAgICAgICAgICcgPGE6cHJzdEdlb20gcHJzdD1cInJlY3RcIj48YTphdkxzdC8+PC9hOnByc3RHZW9tPicgK1xuICAgICAgICAgICAgJyA8YTpleHRMc3Q+PGE6ZXh0IHVyaT1cIntDNTcyQTc1OS02QTUxLTQxMDgtQUEwMi1ERkEwQTA0RkM5NEJ9XCI+PG1hMTQ6d3JhcHBpbmdUZXh0Qm94RmxhZyB2YWw9XCIwXCIgeG1sbnM6bWExND1cImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL21hYy9kcmF3aW5nbWwvMjAxMS9tYWluXCIvPjwvYTpleHQ+PC9hOmV4dExzdD4nICtcbiAgICAgICAgICAgICc8L3A6c3BQcj4nO1xuICAgICAgICBzdHJTbGlkZVhtbCArPSAnPHA6dHhCb2R5Pic7XG4gICAgICAgIHN0clNsaWRlWG1sICs9ICc8YTpib2R5UHInO1xuICAgICAgICBpZiAoc2xpZGUuX3NsaWRlTnVtYmVyUHJvcHMubWFyZ2luICYmIEFycmF5LmlzQXJyYXkoc2xpZGUuX3NsaWRlTnVtYmVyUHJvcHMubWFyZ2luKSkge1xuICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYCBsSW5zPVwiJHt2YWxUb1B0cyhzbGlkZS5fc2xpZGVOdW1iZXJQcm9wcy5tYXJnaW5bM10gfHwgMCl9XCJgO1xuICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYCB0SW5zPVwiJHt2YWxUb1B0cyhzbGlkZS5fc2xpZGVOdW1iZXJQcm9wcy5tYXJnaW5bMF0gfHwgMCl9XCJgO1xuICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYCBySW5zPVwiJHt2YWxUb1B0cyhzbGlkZS5fc2xpZGVOdW1iZXJQcm9wcy5tYXJnaW5bMV0gfHwgMCl9XCJgO1xuICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYCBiSW5zPVwiJHt2YWxUb1B0cyhzbGlkZS5fc2xpZGVOdW1iZXJQcm9wcy5tYXJnaW5bMl0gfHwgMCl9XCJgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzbGlkZS5fc2xpZGVOdW1iZXJQcm9wcy5tYXJnaW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgIGxJbnM9XCIke3ZhbFRvUHRzKHNsaWRlLl9zbGlkZU51bWJlclByb3BzLm1hcmdpbiB8fCAwKX1cImA7XG4gICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgIHRJbnM9XCIke3ZhbFRvUHRzKHNsaWRlLl9zbGlkZU51bWJlclByb3BzLm1hcmdpbiB8fCAwKX1cImA7XG4gICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgIHJJbnM9XCIke3ZhbFRvUHRzKHNsaWRlLl9zbGlkZU51bWJlclByb3BzLm1hcmdpbiB8fCAwKX1cImA7XG4gICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgIGJJbnM9XCIke3ZhbFRvUHRzKHNsaWRlLl9zbGlkZU51bWJlclByb3BzLm1hcmdpbiB8fCAwKX1cImA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNsaWRlLl9zbGlkZU51bWJlclByb3BzLnZhbGlnbikge1xuICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYCBhbmNob3I9XCIke3NsaWRlLl9zbGlkZU51bWJlclByb3BzLnZhbGlnbi5yZXBsYWNlKCd0b3AnLCAndCcpLnJlcGxhY2UoJ21pZGRsZScsICdjdHInKS5yZXBsYWNlKCdib3R0b20nLCAnYicpfVwiYDtcbiAgICAgICAgfVxuICAgICAgICBzdHJTbGlkZVhtbCArPSAnLz4nO1xuICAgICAgICBzdHJTbGlkZVhtbCArPSAnICA8YTpsc3RTdHlsZT48YTpsdmwxcFByPic7XG4gICAgICAgIGlmIChzbGlkZS5fc2xpZGVOdW1iZXJQcm9wcy5mb250RmFjZSB8fCBzbGlkZS5fc2xpZGVOdW1iZXJQcm9wcy5mb250U2l6ZSB8fCBzbGlkZS5fc2xpZGVOdW1iZXJQcm9wcy5jb2xvcikge1xuICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYDxhOmRlZlJQciBzej1cIiR7TWF0aC5yb3VuZCgoc2xpZGUuX3NsaWRlTnVtYmVyUHJvcHMuZm9udFNpemUgfHwgMTIpICogMTAwKX1cIj5gO1xuICAgICAgICAgICAgaWYgKHNsaWRlLl9zbGlkZU51bWJlclByb3BzLmNvbG9yKVxuICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9IGdlblhtbENvbG9yU2VsZWN0aW9uKHNsaWRlLl9zbGlkZU51bWJlclByb3BzLmNvbG9yKTtcbiAgICAgICAgICAgIGlmIChzbGlkZS5fc2xpZGVOdW1iZXJQcm9wcy5mb250RmFjZSkge1xuICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9IGA8YTpsYXRpbiB0eXBlZmFjZT1cIiR7c2xpZGUuX3NsaWRlTnVtYmVyUHJvcHMuZm9udEZhY2V9XCIvPjxhOmVhIHR5cGVmYWNlPVwiJHtzbGlkZS5fc2xpZGVOdW1iZXJQcm9wcy5mb250RmFjZX1cIi8+PGE6Y3MgdHlwZWZhY2U9XCIke3NsaWRlLl9zbGlkZU51bWJlclByb3BzLmZvbnRGYWNlfVwiLz5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJzwvYTpkZWZSUHI+JztcbiAgICAgICAgfVxuICAgICAgICBzdHJTbGlkZVhtbCArPSAnPC9hOmx2bDFwUHI+PC9hOmxzdFN0eWxlPic7XG4gICAgICAgIHN0clNsaWRlWG1sICs9ICc8YTpwPic7XG4gICAgICAgIGlmIChzbGlkZS5fc2xpZGVOdW1iZXJQcm9wcy5hbGlnbi5zdGFydHNXaXRoKCdsJykpXG4gICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnPGE6cFByIGFsZ249XCJsXCIvPic7XG4gICAgICAgIGVsc2UgaWYgKHNsaWRlLl9zbGlkZU51bWJlclByb3BzLmFsaWduLnN0YXJ0c1dpdGgoJ2MnKSlcbiAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICc8YTpwUHIgYWxnbj1cImN0clwiLz4nO1xuICAgICAgICBlbHNlIGlmIChzbGlkZS5fc2xpZGVOdW1iZXJQcm9wcy5hbGlnbi5zdGFydHNXaXRoKCdyJykpXG4gICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnPGE6cFByIGFsZ249XCJyXCIvPic7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICc8YTpwUHIgYWxnbj1cImxcIi8+JztcbiAgICAgICAgc3RyU2xpZGVYbWwgKz0gYDxhOmZsZCBpZD1cIiR7U0xETlVNRkxESUR9XCIgdHlwZT1cInNsaWRlbnVtXCI+PGE6clByIGI9XCIke3NsaWRlLl9zbGlkZU51bWJlclByb3BzLmJvbGQgPyAxIDogMH1cIiBsYW5nPVwiZW4tVVNcIi8+YDtcbiAgICAgICAgc3RyU2xpZGVYbWwgKz0gYDxhOnQ+JHtzbGlkZS5fc2xpZGVOdW19PC9hOnQ+PC9hOmZsZD48YTplbmRQYXJhUlByIGxhbmc9XCJlbi1VU1wiLz48L2E6cD5gO1xuICAgICAgICBzdHJTbGlkZVhtbCArPSAnPC9wOnR4Qm9keT48L3A6c3A+JztcbiAgICB9XG4gICAgLy8gU1RFUCA1OiBDbG9zZSBzcFRyZWUgYW5kIGZpbmFsaXplIHNsaWRlIFhNTFxuICAgIHN0clNsaWRlWG1sICs9ICc8L3A6c3BUcmVlPic7XG4gICAgc3RyU2xpZGVYbWwgKz0gJzwvcDpjU2xkPic7XG4gICAgLy8gTEFTVDogUmV0dXJuXG4gICAgcmV0dXJuIHN0clNsaWRlWG1sO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIHNsaWRlIHJlbGF0aW9ucyB0byBYTUwgc3RyaW5nLlxuICogRXh0cmEgcmVsYXRpb25zIHRoYXQgYXJlIG5vdCBkeW5hbWljIGNhbiBiZSBwYXNzZWQgdXNpbmcgdGhlIDJuZCBhcmcgKGUuZy4gdGhlbWUgcmVsYXRpb24gaW4gbWFzdGVyIGZpbGUpLlxuICogVGhlc2UgcmVsYXRpb25zIHVzZSBySWQgc2VyaWVzIHRoYXQgc3RhcnRzIHdpdGggMS1pbmNyZWFzZWQgbWF4aW11bSBvZiBySWRzIHVzZWQgZm9yIGR5bmFtaWMgcmVsYXRpb25zLlxuICogQHBhcmFtIHtQcmVzU2xpZGUgfCBTbGlkZUxheW91dH0gc2xpZGUgLSBzbGlkZSBvYmplY3Qgd2hvc2UgcmVsYXRpb25zIGFyZSBiZWluZyB0cmFuc2Zvcm1lZFxuICogQHBhcmFtIHt7IHRhcmdldDogc3RyaW5nOyB0eXBlOiBzdHJpbmcgfVtdfSBkZWZhdWx0UmVscyAtIGFycmF5IG9mIGRlZmF1bHQgcmVsYXRpb25zXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFhNTFxuICovXG5mdW5jdGlvbiBzbGlkZU9iamVjdFJlbGF0aW9uc1RvWG1sKHNsaWRlLCBkZWZhdWx0UmVscykge1xuICAgIGxldCBsYXN0UmlkID0gMDsgLy8gc3RvcmVzIG1heGltdW0gcklkIHVzZWQgZm9yIGR5bmFtaWMgcmVsYXRpb25zXG4gICAgbGV0IHN0clhtbCA9ICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiIHN0YW5kYWxvbmU9XCJ5ZXNcIj8+JyArIENSTEYgKyAnPFJlbGF0aW9uc2hpcHMgeG1sbnM9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvcGFja2FnZS8yMDA2L3JlbGF0aW9uc2hpcHNcIj4nO1xuICAgIC8vIFNURVAgMTogQWRkIGFsbCByZWxzIGZvciB0aGlzIFNsaWRlXG4gICAgc2xpZGUuX3JlbHMuZm9yRWFjaCgocmVsKSA9PiB7XG4gICAgICAgIGxhc3RSaWQgPSBNYXRoLm1heChsYXN0UmlkLCByZWwucklkKTtcbiAgICAgICAgaWYgKHJlbC50eXBlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2h5cGVybGluaycpKSB7XG4gICAgICAgICAgICBpZiAocmVsLmRhdGEgPT09ICdzbGlkZScpIHtcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYDxSZWxhdGlvbnNoaXAgSWQ9XCJySWQke3JlbC5ySWR9XCIgVHlwZT1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHMvc2xpZGVcIiBUYXJnZXQ9XCJzbGlkZSR7cmVsLlRhcmdldH0ueG1sXCIvPmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gYDxSZWxhdGlvbnNoaXAgSWQ9XCJySWQke3JlbC5ySWR9XCIgVHlwZT1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHMvaHlwZXJsaW5rXCIgVGFyZ2V0PVwiJHtyZWwuVGFyZ2V0fVwiIFRhcmdldE1vZGU9XCJFeHRlcm5hbFwiLz5gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlbC50eXBlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ25vdGVzU2xpZGUnKSkge1xuICAgICAgICAgICAgc3RyWG1sICs9IGA8UmVsYXRpb25zaGlwIElkPVwicklkJHtyZWwucklkfVwiIFRhcmdldD1cIiR7cmVsLlRhcmdldH1cIiBUeXBlPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcy9ub3Rlc1NsaWRlXCIvPmA7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAoc2xpZGUuX3JlbHNDaGFydCB8fCBbXSkuZm9yRWFjaCgocmVsKSA9PiB7XG4gICAgICAgIGxhc3RSaWQgPSBNYXRoLm1heChsYXN0UmlkLCByZWwucklkKTtcbiAgICAgICAgc3RyWG1sICs9IGA8UmVsYXRpb25zaGlwIElkPVwicklkJHtyZWwucklkfVwiIFR5cGU9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL2NoYXJ0XCIgVGFyZ2V0PVwiJHtyZWwuVGFyZ2V0fVwiLz5gO1xuICAgIH0pO1xuICAgIChzbGlkZS5fcmVsc01lZGlhIHx8IFtdKS5mb3JFYWNoKChyZWwpID0+IHtcbiAgICAgICAgY29uc3QgcmVsUmlkID0gcmVsLnJJZC50b1N0cmluZygpO1xuICAgICAgICBsYXN0UmlkID0gTWF0aC5tYXgobGFzdFJpZCwgcmVsLnJJZCk7XG4gICAgICAgIGlmIChyZWwudHlwZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdpbWFnZScpKSB7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJzxSZWxhdGlvbnNoaXAgSWQ9XCJySWQnICsgcmVsUmlkICsgJ1wiIFR5cGU9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL2ltYWdlXCIgVGFyZ2V0PVwiJyArIHJlbC5UYXJnZXQgKyAnXCIvPic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVsLnR5cGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnYXVkaW8nKSkge1xuICAgICAgICAgICAgLy8gQXMgbWVkaWEgaGFzICpUV08qIHJlbCBlbnRyaWVzIHBlciBpdGVtLCBjaGVjayBmb3IgZmlyc3Qgb25lLCBpZiBmb3VuZCBhZGQgc2Vjb25kIHJlbCB3aXRoIGFsdCBzdHlsZVxuICAgICAgICAgICAgaWYgKHN0clhtbC5pbmNsdWRlcygnIFRhcmdldD1cIicgKyByZWwuVGFyZ2V0ICsgJ1wiJykpIHtcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxSZWxhdGlvbnNoaXAgSWQ9XCJySWQnICsgcmVsUmlkICsgJ1wiIFR5cGU9XCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS8yMDA3L3JlbGF0aW9uc2hpcHMvbWVkaWFcIiBUYXJnZXQ9XCInICsgcmVsLlRhcmdldCArICdcIi8+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPFJlbGF0aW9uc2hpcCBJZD1cInJJZCcgKyByZWxSaWQgKyAnXCIgVHlwZT1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHMvYXVkaW9cIiBUYXJnZXQ9XCInICsgcmVsLlRhcmdldCArICdcIi8+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWwudHlwZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCd2aWRlbycpKSB7XG4gICAgICAgICAgICAvLyBBcyBtZWRpYSBoYXMgKlRXTyogcmVsIGVudHJpZXMgcGVyIGl0ZW0sIGNoZWNrIGZvciBmaXJzdCBvbmUsIGlmIGZvdW5kIGFkZCBzZWNvbmQgcmVsIHdpdGggYWx0IHN0eWxlXG4gICAgICAgICAgICBpZiAoc3RyWG1sLmluY2x1ZGVzKCcgVGFyZ2V0PVwiJyArIHJlbC5UYXJnZXQgKyAnXCInKSkge1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPFJlbGF0aW9uc2hpcCBJZD1cInJJZCcgKyByZWxSaWQgKyAnXCIgVHlwZT1cImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlLzIwMDcvcmVsYXRpb25zaGlwcy9tZWRpYVwiIFRhcmdldD1cIicgKyByZWwuVGFyZ2V0ICsgJ1wiLz4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8UmVsYXRpb25zaGlwIElkPVwicklkJyArIHJlbFJpZCArICdcIiBUeXBlPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcy92aWRlb1wiIFRhcmdldD1cIicgKyByZWwuVGFyZ2V0ICsgJ1wiLz4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlbC50eXBlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ29ubGluZScpKSB7XG4gICAgICAgICAgICAvLyBBcyBtZWRpYSBoYXMgKlRXTyogcmVsIGVudHJpZXMgcGVyIGl0ZW0sIGNoZWNrIGZvciBmaXJzdCBvbmUsIGlmIGZvdW5kIGFkZCBzZWNvbmQgcmVsIHdpdGggYWx0IHN0eWxlXG4gICAgICAgICAgICBpZiAoc3RyWG1sLmluY2x1ZGVzKCcgVGFyZ2V0PVwiJyArIHJlbC5UYXJnZXQgKyAnXCInKSkge1xuICAgICAgICAgICAgICAgIHN0clhtbCArPSAnPFJlbGF0aW9uc2hpcCBJZD1cInJJZCcgKyByZWxSaWQgKyAnXCIgVHlwZT1cImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlLzIwMDcvcmVsYXRpb25zaGlwcy9pbWFnZVwiIFRhcmdldD1cIicgKyByZWwuVGFyZ2V0ICsgJ1wiLz4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyWG1sICs9ICc8UmVsYXRpb25zaGlwIElkPVwicklkJyArIHJlbFJpZCArICdcIiBUYXJnZXQ9XCInICsgcmVsLlRhcmdldCArICdcIiBUYXJnZXRNb2RlPVwiRXh0ZXJuYWxcIiBUeXBlPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcy92aWRlb1wiLz4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gU1RFUCAyOiBBZGQgZGVmYXVsdCByZWxzXG4gICAgZGVmYXVsdFJlbHMuZm9yRWFjaCgocmVsLCBpZHgpID0+IHtcbiAgICAgICAgc3RyWG1sICs9IGA8UmVsYXRpb25zaGlwIElkPVwicklkJHtsYXN0UmlkICsgaWR4ICsgMX1cIiBUeXBlPVwiJHtyZWwudHlwZX1cIiBUYXJnZXQ9XCIke3JlbC50YXJnZXR9XCIvPmA7XG4gICAgfSk7XG4gICAgc3RyWG1sICs9ICc8L1JlbGF0aW9uc2hpcHM+JztcbiAgICByZXR1cm4gc3RyWG1sO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBYTUwgUGFyYWdyYXBoIFByb3BlcnRpZXNcbiAqIEBwYXJhbSB7SVNsaWRlT2JqZWN0fFRleHRQcm9wc30gdGV4dE9iaiAtIHRleHQgb2JqZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzRGVmYXVsdCAtIGFycmF5IG9mIGRlZmF1bHQgcmVsYXRpb25zXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFhNTFxuICovXG5mdW5jdGlvbiBnZW5YbWxQYXJhZ3JhcGhQcm9wZXJ0aWVzKHRleHRPYmosIGlzRGVmYXVsdCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgbGV0IHN0clhtbEJ1bGxldCA9ICcnO1xuICAgIGxldCBzdHJYbWxMblNwYyA9ICcnO1xuICAgIGxldCBzdHJYbWxQYXJhU3BjID0gJyc7XG4gICAgbGV0IHN0clhtbFRhYlN0b3BzID0gJyc7XG4gICAgY29uc3QgdGFnID0gaXNEZWZhdWx0ID8gJ2E6bHZsMXBQcicgOiAnYTpwUHInO1xuICAgIGxldCBidWxsZXRNYXJMID0gdmFsVG9QdHMoREVGX0JVTExFVF9NQVJHSU4pO1xuICAgIGxldCBwYXJhZ3JhcGhQcm9wWG1sID0gYDwke3RhZ30ke3RleHRPYmoub3B0aW9ucy5ydGxNb2RlID8gJyBydGw9XCIxXCIgJyA6ICcnfWA7XG4gICAgLy8gQTogQnVpbGQgcGFyYWdyYXBoUHJvcGVydGllc1xuICAgIHtcbiAgICAgICAgLy8gT1BUSU9OOiBhbGlnblxuICAgICAgICBpZiAodGV4dE9iai5vcHRpb25zLmFsaWduKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRleHRPYmoub3B0aW9ucy5hbGlnbikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICBwYXJhZ3JhcGhQcm9wWG1sICs9ICcgYWxnbj1cImxcIic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgcGFyYWdyYXBoUHJvcFhtbCArPSAnIGFsZ249XCJyXCInO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgICAgICBwYXJhZ3JhcGhQcm9wWG1sICs9ICcgYWxnbj1cImN0clwiJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnanVzdGlmeSc6XG4gICAgICAgICAgICAgICAgICAgIHBhcmFncmFwaFByb3BYbWwgKz0gJyBhbGduPVwianVzdFwiJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcGFyYWdyYXBoUHJvcFhtbCArPSAnJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHRPYmoub3B0aW9ucy5saW5lU3BhY2luZykge1xuICAgICAgICAgICAgc3RyWG1sTG5TcGMgPSBgPGE6bG5TcGM+PGE6c3BjUHRzIHZhbD1cIiR7TWF0aC5yb3VuZCh0ZXh0T2JqLm9wdGlvbnMubGluZVNwYWNpbmcgKiAxMDApfVwiLz48L2E6bG5TcGM+YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXh0T2JqLm9wdGlvbnMubGluZVNwYWNpbmdNdWx0aXBsZSkge1xuICAgICAgICAgICAgc3RyWG1sTG5TcGMgPSBgPGE6bG5TcGM+PGE6c3BjUGN0IHZhbD1cIiR7TWF0aC5yb3VuZCh0ZXh0T2JqLm9wdGlvbnMubGluZVNwYWNpbmdNdWx0aXBsZSAqIDEwMDAwMCl9XCIvPjwvYTpsblNwYz5gO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9QVElPTjogaW5kZW50XG4gICAgICAgIGlmICh0ZXh0T2JqLm9wdGlvbnMuaW5kZW50TGV2ZWwgJiYgIWlzTmFOKE51bWJlcih0ZXh0T2JqLm9wdGlvbnMuaW5kZW50TGV2ZWwpKSAmJiB0ZXh0T2JqLm9wdGlvbnMuaW5kZW50TGV2ZWwgPiAwKSB7XG4gICAgICAgICAgICBwYXJhZ3JhcGhQcm9wWG1sICs9IGAgbHZsPVwiJHt0ZXh0T2JqLm9wdGlvbnMuaW5kZW50TGV2ZWx9XCJgO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9QVElPTjogUGFyYWdyYXBoIFNwYWNpbmc6IEJlZm9yZS9BZnRlclxuICAgICAgICBpZiAodGV4dE9iai5vcHRpb25zLnBhcmFTcGFjZUJlZm9yZSAmJiAhaXNOYU4oTnVtYmVyKHRleHRPYmoub3B0aW9ucy5wYXJhU3BhY2VCZWZvcmUpKSAmJiB0ZXh0T2JqLm9wdGlvbnMucGFyYVNwYWNlQmVmb3JlID4gMCkge1xuICAgICAgICAgICAgc3RyWG1sUGFyYVNwYyArPSBgPGE6c3BjQmVmPjxhOnNwY1B0cyB2YWw9XCIke01hdGgucm91bmQodGV4dE9iai5vcHRpb25zLnBhcmFTcGFjZUJlZm9yZSAqIDEwMCl9XCIvPjwvYTpzcGNCZWY+YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dE9iai5vcHRpb25zLnBhcmFTcGFjZUFmdGVyICYmICFpc05hTihOdW1iZXIodGV4dE9iai5vcHRpb25zLnBhcmFTcGFjZUFmdGVyKSkgJiYgdGV4dE9iai5vcHRpb25zLnBhcmFTcGFjZUFmdGVyID4gMCkge1xuICAgICAgICAgICAgc3RyWG1sUGFyYVNwYyArPSBgPGE6c3BjQWZ0PjxhOnNwY1B0cyB2YWw9XCIke01hdGgucm91bmQodGV4dE9iai5vcHRpb25zLnBhcmFTcGFjZUFmdGVyICogMTAwKX1cIi8+PC9hOnNwY0FmdD5gO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9QVElPTjogYnVsbGV0XG4gICAgICAgIC8vIE5PVEU6IE9PWE1MIHVzZXMgdGhlIHVuaWNvZGUgY2hhcmFjdGVyIHNldCBmb3IgQnVsbGV0c1xuICAgICAgICAvLyBFWDogVW5pY29kZSBDaGFyYWN0ZXIgJ0JVTExFVCcgKFUrMjAyMikgPT0+ICc8YTpidUNoYXIgY2hhcj1cIiYjeDIwMjI7XCIvPidcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXh0T2JqLm9wdGlvbnMuYnVsbGV0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKChfYiA9IChfYSA9IHRleHRPYmogPT09IG51bGwgfHwgdGV4dE9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGV4dE9iai5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYnVsbGV0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW5kZW50KVxuICAgICAgICAgICAgICAgIGJ1bGxldE1hckwgPSB2YWxUb1B0cyh0ZXh0T2JqLm9wdGlvbnMuYnVsbGV0LmluZGVudCk7XG4gICAgICAgICAgICBpZiAodGV4dE9iai5vcHRpb25zLmJ1bGxldC50eXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRleHRPYmoub3B0aW9ucy5idWxsZXQudHlwZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFncmFwaFByb3BYbWwgKz0gYCBtYXJMPVwiJHt0ZXh0T2JqLm9wdGlvbnMuaW5kZW50TGV2ZWwgJiYgdGV4dE9iai5vcHRpb25zLmluZGVudExldmVsID4gMCA/IGJ1bGxldE1hckwgKyBidWxsZXRNYXJMICogdGV4dE9iai5vcHRpb25zLmluZGVudExldmVsIDogYnVsbGV0TWFyTH1cIiBpbmRlbnQ9XCItJHtidWxsZXRNYXJMfVwiYDtcbiAgICAgICAgICAgICAgICAgICAgc3RyWG1sQnVsbGV0ID0gYDxhOmJ1U3pQY3QgdmFsPVwiMTAwMDAwXCIvPjxhOmJ1Rm9udCB0eXBlZmFjZT1cIittai1sdFwiLz48YTpidUF1dG9OdW0gdHlwZT1cIiR7dGV4dE9iai5vcHRpb25zLmJ1bGxldC5zdHlsZSB8fCAnYXJhYmljUGVyaW9kJ31cIiBzdGFydEF0PVwiJHt0ZXh0T2JqLm9wdGlvbnMuYnVsbGV0Lm51bWJlclN0YXJ0QXQgfHwgdGV4dE9iai5vcHRpb25zLmJ1bGxldC5zdGFydEF0IHx8ICcxJ31cIi8+YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0ZXh0T2JqLm9wdGlvbnMuYnVsbGV0LmNoYXJhY3RlckNvZGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgYnVsbGV0Q29kZSA9IGAmI3gke3RleHRPYmoub3B0aW9ucy5idWxsZXQuY2hhcmFjdGVyQ29kZX07YDtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB2YWx1ZSBmb3IgaGV4LW5lc3MgKHMvYiA0IGNoYXIgaGV4KVxuICAgICAgICAgICAgICAgIGlmICghL15bMC05QS1GYS1mXXs0fSQvLnRlc3QodGV4dE9iai5vcHRpb25zLmJ1bGxldC5jaGFyYWN0ZXJDb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IGBidWxsZXQuY2hhcmFjdGVyQ29kZSBzaG91bGQgYmUgYSA0LWRpZ2l0IHVuaWNvZGUgY2hhcmF0Y2VyIChleDogMjJBQilgIScpO1xuICAgICAgICAgICAgICAgICAgICBidWxsZXRDb2RlID0gQlVMTEVUX1RZUEVTLkRFRkFVTFQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmFncmFwaFByb3BYbWwgKz0gYCBtYXJMPVwiJHt0ZXh0T2JqLm9wdGlvbnMuaW5kZW50TGV2ZWwgJiYgdGV4dE9iai5vcHRpb25zLmluZGVudExldmVsID4gMCA/IGJ1bGxldE1hckwgKyBidWxsZXRNYXJMICogdGV4dE9iai5vcHRpb25zLmluZGVudExldmVsIDogYnVsbGV0TWFyTH1cIiBpbmRlbnQ9XCItJHtidWxsZXRNYXJMfVwiYDtcbiAgICAgICAgICAgICAgICBzdHJYbWxCdWxsZXQgPSAnPGE6YnVTelBjdCB2YWw9XCIxMDAwMDBcIi8+PGE6YnVDaGFyIGNoYXI9XCInICsgYnVsbGV0Q29kZSArICdcIi8+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRleHRPYmoub3B0aW9ucy5idWxsZXQuY29kZSkge1xuICAgICAgICAgICAgICAgIC8vIEBkZXByZWNhdGVkIGBidWxsZXQuY29kZWAgdjMuMy4wXG4gICAgICAgICAgICAgICAgbGV0IGJ1bGxldENvZGUgPSBgJiN4JHt0ZXh0T2JqLm9wdGlvbnMuYnVsbGV0LmNvZGV9O2A7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdmFsdWUgZm9yIGhleC1uZXNzIChzL2IgNCBjaGFyIGhleClcbiAgICAgICAgICAgICAgICBpZiAoIS9eWzAtOUEtRmEtZl17NH0kLy50ZXN0KHRleHRPYmoub3B0aW9ucy5idWxsZXQuY29kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdXYXJuaW5nOiBgYnVsbGV0LmNvZGUgc2hvdWxkIGJlIGEgNC1kaWdpdCBoZXggY29kZSAoZXg6IDIyQUIpYCEnKTtcbiAgICAgICAgICAgICAgICAgICAgYnVsbGV0Q29kZSA9IEJVTExFVF9UWVBFUy5ERUZBVUxUO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhZ3JhcGhQcm9wWG1sICs9IGAgbWFyTD1cIiR7dGV4dE9iai5vcHRpb25zLmluZGVudExldmVsICYmIHRleHRPYmoub3B0aW9ucy5pbmRlbnRMZXZlbCA+IDAgPyBidWxsZXRNYXJMICsgYnVsbGV0TWFyTCAqIHRleHRPYmoub3B0aW9ucy5pbmRlbnRMZXZlbCA6IGJ1bGxldE1hckx9XCIgaW5kZW50PVwiLSR7YnVsbGV0TWFyTH1cImA7XG4gICAgICAgICAgICAgICAgc3RyWG1sQnVsbGV0ID0gJzxhOmJ1U3pQY3QgdmFsPVwiMTAwMDAwXCIvPjxhOmJ1Q2hhciBjaGFyPVwiJyArIGJ1bGxldENvZGUgKyAnXCIvPic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhZ3JhcGhQcm9wWG1sICs9IGAgbWFyTD1cIiR7dGV4dE9iai5vcHRpb25zLmluZGVudExldmVsICYmIHRleHRPYmoub3B0aW9ucy5pbmRlbnRMZXZlbCA+IDAgPyBidWxsZXRNYXJMICsgYnVsbGV0TWFyTCAqIHRleHRPYmoub3B0aW9ucy5pbmRlbnRMZXZlbCA6IGJ1bGxldE1hckx9XCIgaW5kZW50PVwiLSR7YnVsbGV0TWFyTH1cImA7XG4gICAgICAgICAgICAgICAgc3RyWG1sQnVsbGV0ID0gYDxhOmJ1U3pQY3QgdmFsPVwiMTAwMDAwXCIvPjxhOmJ1Q2hhciBjaGFyPVwiJHtCVUxMRVRfVFlQRVMuREVGQVVMVH1cIi8+YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXh0T2JqLm9wdGlvbnMuYnVsbGV0KSB7XG4gICAgICAgICAgICBwYXJhZ3JhcGhQcm9wWG1sICs9IGAgbWFyTD1cIiR7dGV4dE9iai5vcHRpb25zLmluZGVudExldmVsICYmIHRleHRPYmoub3B0aW9ucy5pbmRlbnRMZXZlbCA+IDAgPyBidWxsZXRNYXJMICsgYnVsbGV0TWFyTCAqIHRleHRPYmoub3B0aW9ucy5pbmRlbnRMZXZlbCA6IGJ1bGxldE1hckx9XCIgaW5kZW50PVwiLSR7YnVsbGV0TWFyTH1cImA7XG4gICAgICAgICAgICBzdHJYbWxCdWxsZXQgPSBgPGE6YnVTelBjdCB2YWw9XCIxMDAwMDBcIi8+PGE6YnVDaGFyIGNoYXI9XCIke0JVTExFVF9UWVBFUy5ERUZBVUxUfVwiLz5gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0ZXh0T2JqLm9wdGlvbnMuYnVsbGV0KSB7XG4gICAgICAgICAgICAvLyBXZSBvbmx5IGFkZCB0aGlzIHdoZW4gdGhlIHVzZXIgZXhwbGljaXRlbHkgYXNrcyBmb3Igbm8gYnVsbGV0LCBvdGhlcndpc2UsIGl0IGNhbiBvdmVycmlkZSB0aGUgbWFzdGVyIGRlZmF1bHRzIVxuICAgICAgICAgICAgcGFyYWdyYXBoUHJvcFhtbCArPSAnIGluZGVudD1cIjBcIiBtYXJMPVwiMFwiJzsgLy8gRklYOiBJU1NVRSM1ODkgLSBzcGVjaWZ5IHplcm8gaW5kZW50IGFuZCBtYXJMIG9yIGRlZmF1bHQgd2lsbCBiZSBoYW5naW5nIHBhcmFncmFwaFxuICAgICAgICAgICAgc3RyWG1sQnVsbGV0ID0gJzxhOmJ1Tm9uZS8+JztcbiAgICAgICAgfVxuICAgICAgICAvLyBPUFRJT046IHRhYlN0b3BzXG4gICAgICAgIGlmICh0ZXh0T2JqLm9wdGlvbnMudGFiU3RvcHMgJiYgQXJyYXkuaXNBcnJheSh0ZXh0T2JqLm9wdGlvbnMudGFiU3RvcHMpKSB7XG4gICAgICAgICAgICBjb25zdCB0YWJTdG9wc1htbCA9IHRleHRPYmoub3B0aW9ucy50YWJTdG9wcy5tYXAoc3RvcCA9PiBgPGE6dGFiIHBvcz1cIiR7aW5jaDJFbXUoc3RvcC5wb3NpdGlvbiB8fCAxKX1cIiBhbGduPVwiJHtzdG9wLmFsaWdubWVudCB8fCAnbCd9XCIvPmApLmpvaW4oJycpO1xuICAgICAgICAgICAgc3RyWG1sVGFiU3RvcHMgPSBgPGE6dGFiTHN0PiR7dGFiU3RvcHNYbWx9PC9hOnRhYkxzdD5gO1xuICAgICAgICB9XG4gICAgICAgIC8vIEI6IENsb3NlIFBhcmFncmFwaC1Qcm9wZXJ0aWVzXG4gICAgICAgIC8vIElNUE9SVEFOVDogc3RyWG1sTG5TcGMsIHN0clhtbFBhcmFTcGMsIGFuZCBzdHJYbWxCdWxsZXQgcmVxdWlyZSBzdHJpY3Qgb3JkZXJpbmcgLSBhbnl0aGluZyBvdXQgb2Ygb3JkZXIgaXMgaWdub3JlZC4gKFBQVC1PbmxpbmUsIFBQVCBmb3IgTWFjKVxuICAgICAgICBwYXJhZ3JhcGhQcm9wWG1sICs9ICc+JyArIHN0clhtbExuU3BjICsgc3RyWG1sUGFyYVNwYyArIHN0clhtbEJ1bGxldCArIHN0clhtbFRhYlN0b3BzO1xuICAgICAgICBpZiAoaXNEZWZhdWx0KVxuICAgICAgICAgICAgcGFyYWdyYXBoUHJvcFhtbCArPSBnZW5YbWxUZXh0UnVuUHJvcGVydGllcyh0ZXh0T2JqLm9wdGlvbnMsIHRydWUpO1xuICAgICAgICBwYXJhZ3JhcGhQcm9wWG1sICs9ICc8LycgKyB0YWcgKyAnPic7XG4gICAgfVxuICAgIHJldHVybiBwYXJhZ3JhcGhQcm9wWG1sO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBYTUwgVGV4dCBSdW4gUHJvcGVydGllcyAoYGE6clByYClcbiAqIEBwYXJhbSB7T2JqZWN0T3B0aW9uc3xUZXh0UHJvcHNPcHRpb25zfSBvcHRzIC0gdGV4dCBvcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzRGVmYXVsdCAtIHdoZXRoZXIgdGhlc2UgYXJlIHRoZSBkZWZhdWx0IHRleHQgcnVuIHByb3BlcnRpZXNcbiAqIEByZXR1cm4ge3N0cmluZ30gWE1MXG4gKi9cbmZ1bmN0aW9uIGdlblhtbFRleHRSdW5Qcm9wZXJ0aWVzKG9wdHMsIGlzRGVmYXVsdCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgcnVuUHJvcHMgPSAnJztcbiAgICBjb25zdCBydW5Qcm9wc1RhZyA9IGlzRGVmYXVsdCA/ICdhOmRlZlJQcicgOiAnYTpyUHInO1xuICAgIC8vIEJFR0lOIHJ1blByb3BlcnRpZXMgKGV4OiBgPGE6clByIGxhbmc9XCJlbi1VU1wiIHN6PVwiMTYwMFwiIGI9XCIxXCIgZGlydHk9XCIwXCI+YClcbiAgICBydW5Qcm9wcyArPSAnPCcgKyBydW5Qcm9wc1RhZyArICcgbGFuZz1cIicgKyAob3B0cy5sYW5nID8gb3B0cy5sYW5nIDogJ2VuLVVTJykgKyAnXCInICsgKG9wdHMubGFuZyA/ICcgYWx0TGFuZz1cImVuLVVTXCInIDogJycpO1xuICAgIHJ1blByb3BzICs9IG9wdHMuZm9udFNpemUgPyBgIHN6PVwiJHtNYXRoLnJvdW5kKG9wdHMuZm9udFNpemUgKiAxMDApfVwiYCA6ICcnOyAvLyBOT1RFOiBVc2Ugcm91bmQgc28gc2l6ZXMgbGlrZSAnNy41JyB3b250IGNhdXNlIGNvcnJ1cHQgcHJlc2VudGF0aW9uc1xuICAgIHJ1blByb3BzICs9IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuYm9sZCkgPyBgIGI9XCIke29wdHMuYm9sZCA/ICcxJyA6ICcwJ31cImAgOiAnJztcbiAgICBydW5Qcm9wcyArPSAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLml0YWxpYykgPyBgIGk9XCIke29wdHMuaXRhbGljID8gJzEnIDogJzAnfVwiYCA6ICcnO1xuICAgIHJ1blByb3BzICs9IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc3RyaWtlKSA/IGAgc3RyaWtlPVwiJHt0eXBlb2Ygb3B0cy5zdHJpa2UgPT09ICdzdHJpbmcnID8gb3B0cy5zdHJpa2UgOiAnc25nU3RyaWtlJ31cImAgOiAnJztcbiAgICBpZiAodHlwZW9mIG9wdHMudW5kZXJsaW5lID09PSAnb2JqZWN0JyAmJiAoKF9hID0gb3B0cy51bmRlcmxpbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdHlsZSkpIHtcbiAgICAgICAgcnVuUHJvcHMgKz0gYCB1PVwiJHtvcHRzLnVuZGVybGluZS5zdHlsZX1cImA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRzLnVuZGVybGluZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gREVQUkVDQVRFRDogb3B0cy51bmRlcmxpbmUgaXMgYW4gb2JqZWN0IGFzIG9mIHYzLjUuMFxuICAgICAgICBydW5Qcm9wcyArPSBgIHU9XCIke1N0cmluZyhvcHRzLnVuZGVybGluZSl9XCJgO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRzLmh5cGVybGluaykge1xuICAgICAgICBydW5Qcm9wcyArPSAnIHU9XCJzbmdcIic7XG4gICAgfVxuICAgIGlmIChvcHRzLmJhc2VsaW5lKSB7XG4gICAgICAgIHJ1blByb3BzICs9IGAgYmFzZWxpbmU9XCIke01hdGgucm91bmQob3B0cy5iYXNlbGluZSAqIDUwKX1cImA7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdHMuc3Vic2NyaXB0KSB7XG4gICAgICAgIHJ1blByb3BzICs9ICcgYmFzZWxpbmU9XCItNDAwMDBcIic7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdHMuc3VwZXJzY3JpcHQpIHtcbiAgICAgICAgcnVuUHJvcHMgKz0gJyBiYXNlbGluZT1cIjMwMDAwXCInO1xuICAgIH1cbiAgICBydW5Qcm9wcyArPSBvcHRzLmNoYXJTcGFjaW5nID8gYCBzcGM9XCIke01hdGgucm91bmQob3B0cy5jaGFyU3BhY2luZyAqIDEwMCl9XCIga2Vybj1cIjBcImAgOiAnJzsgLy8gSU1QT1JUQU5UOiBBbHNvIGRpc2FibGUga2VybmluZzsgb3RoZXJ3aXNlIHRleHQgd29uJ3QgYWN0dWFsbHkgZXhwYW5kXG4gICAgcnVuUHJvcHMgKz0gJyBkaXJ0eT1cIjBcIj4nO1xuICAgIC8vIENvbG9yIC8gRm9udCAvIEhpZ2hsaWdodCAvIE91dGxpbmUgYXJlIGNoaWxkcmVuIG9mIDxhOnJQcj4sIHNvIGFkZCB0aGVtIG5vdyBiZWZvcmUgY2xvc2luZyB0aGUgcnVuUHJvcGVydGllcyB0YWdcbiAgICBpZiAob3B0cy5jb2xvciB8fCBvcHRzLmZvbnRGYWNlIHx8IG9wdHMub3V0bGluZSB8fCAodHlwZW9mIG9wdHMudW5kZXJsaW5lID09PSAnb2JqZWN0JyAmJiBvcHRzLnVuZGVybGluZS5jb2xvcikpIHtcbiAgICAgICAgaWYgKG9wdHMub3V0bGluZSAmJiB0eXBlb2Ygb3B0cy5vdXRsaW5lID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcnVuUHJvcHMgKz0gYDxhOmxuIHc9XCIke3ZhbFRvUHRzKG9wdHMub3V0bGluZS5zaXplIHx8IDAuNzUpfVwiPiR7Z2VuWG1sQ29sb3JTZWxlY3Rpb24ob3B0cy5vdXRsaW5lLmNvbG9yIHx8ICdGRkZGRkYnKX08L2E6bG4+YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5jb2xvcilcbiAgICAgICAgICAgIHJ1blByb3BzICs9IGdlblhtbENvbG9yU2VsZWN0aW9uKHsgY29sb3I6IG9wdHMuY29sb3IsIHRyYW5zcGFyZW5jeTogb3B0cy50cmFuc3BhcmVuY3kgfSk7XG4gICAgICAgIGlmIChvcHRzLmhpZ2hsaWdodClcbiAgICAgICAgICAgIHJ1blByb3BzICs9IGA8YTpoaWdobGlnaHQ+JHtjcmVhdGVDb2xvckVsZW1lbnQob3B0cy5oaWdobGlnaHQpfTwvYTpoaWdobGlnaHQ+YDtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLnVuZGVybGluZSA9PT0gJ29iamVjdCcgJiYgb3B0cy51bmRlcmxpbmUuY29sb3IpXG4gICAgICAgICAgICBydW5Qcm9wcyArPSBgPGE6dUZpbGw+JHtnZW5YbWxDb2xvclNlbGVjdGlvbihvcHRzLnVuZGVybGluZS5jb2xvcil9PC9hOnVGaWxsPmA7XG4gICAgICAgIGlmIChvcHRzLmdsb3cpXG4gICAgICAgICAgICBydW5Qcm9wcyArPSBgPGE6ZWZmZWN0THN0PiR7Y3JlYXRlR2xvd0VsZW1lbnQob3B0cy5nbG93LCBERUZfVEVYVF9HTE9XKX08L2E6ZWZmZWN0THN0PmA7XG4gICAgICAgIGlmIChvcHRzLmZvbnRGYWNlKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiAnY3MnID0gQ29tcGxleCBTY3JpcHQsICdlYScgPSBFYXN0IEFzaWFuICh1c2UgXCItMTIwXCIgaW5zdGVhZCBvZiBcIjBcIiAtIHBlciBJc3N1ZSAjMTc0KTsgZWEgbXVzdCBjb21lIGZpcnN0IChJc3N1ZSAjMTc0KVxuICAgICAgICAgICAgcnVuUHJvcHMgKz0gYDxhOmxhdGluIHR5cGVmYWNlPVwiJHtvcHRzLmZvbnRGYWNlfVwiIHBpdGNoRmFtaWx5PVwiMzRcIiBjaGFyc2V0PVwiMFwiLz48YTplYSB0eXBlZmFjZT1cIiR7b3B0cy5mb250RmFjZX1cIiBwaXRjaEZhbWlseT1cIjM0XCIgY2hhcnNldD1cIi0xMjJcIi8+PGE6Y3MgdHlwZWZhY2U9XCIke29wdHMuZm9udEZhY2V9XCIgcGl0Y2hGYW1pbHk9XCIzNFwiIGNoYXJzZXQ9XCItMTIwXCIvPmA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSHlwZXJsaW5rIHN1cHBvcnRcbiAgICBpZiAob3B0cy5oeXBlcmxpbmspIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLmh5cGVybGluayAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VSUk9SOiB0ZXh0IGBoeXBlcmxpbmtgIG9wdGlvbiBzaG91bGQgYmUgYW4gb2JqZWN0LiBFeDogYGh5cGVybGluazp7dXJsOlxcJ2h0dHBzOi8vZ2l0aHViLmNvbVxcJ31gICcpO1xuICAgICAgICBlbHNlIGlmICghb3B0cy5oeXBlcmxpbmsudXJsICYmICFvcHRzLmh5cGVybGluay5zbGlkZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRVJST1I6IFxcJ2h5cGVybGluayByZXF1aXJlcyBlaXRoZXIgYHVybGAgb3IgYHNsaWRlYFxcJycpO1xuICAgICAgICBlbHNlIGlmIChvcHRzLmh5cGVybGluay51cmwpIHtcbiAgICAgICAgICAgIC8vIHJ1blByb3BzICs9ICc8YTp1RmlsbD4nKyBnZW5YbWxDb2xvclNlbGVjdGlvbignMDAwMEZGJykgKyc8L2E6dUZpbGw+JzsgLy8gQnJlYWtzIFBQVDIwMTAhIChJc3N1ZSM3NClcbiAgICAgICAgICAgIHJ1blByb3BzICs9IGA8YTpobGlua0NsaWNrIHI6aWQ9XCJySWQke29wdHMuaHlwZXJsaW5rLl9ySWR9XCIgaW52YWxpZFVybD1cIlwiIGFjdGlvbj1cIlwiIHRndEZyYW1lPVwiXCIgdG9vbHRpcD1cIiR7b3B0cy5oeXBlcmxpbmsudG9vbHRpcCA/IGVuY29kZVhtbEVudGl0aWVzKG9wdHMuaHlwZXJsaW5rLnRvb2x0aXApIDogJyd9XCIgaGlzdG9yeT1cIjFcIiBoaWdobGlnaHRDbGljaz1cIjBcIiBlbmRTbmQ9XCIwXCIke29wdHMuY29sb3IgPyAnPicgOiAnLz4nfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0cy5oeXBlcmxpbmsuc2xpZGUpIHtcbiAgICAgICAgICAgIHJ1blByb3BzICs9IGA8YTpobGlua0NsaWNrIHI6aWQ9XCJySWQke29wdHMuaHlwZXJsaW5rLl9ySWR9XCIgYWN0aW9uPVwicHBhY3Rpb246Ly9obGlua3NsZGp1bXBcIiB0b29sdGlwPVwiJHtvcHRzLmh5cGVybGluay50b29sdGlwID8gZW5jb2RlWG1sRW50aXRpZXMob3B0cy5oeXBlcmxpbmsudG9vbHRpcCkgOiAnJ31cIiR7b3B0cy5jb2xvciA/ICc+JyA6ICcvPid9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5jb2xvcikge1xuICAgICAgICAgICAgcnVuUHJvcHMgKz0gJyA8YTpleHRMc3Q+JztcbiAgICAgICAgICAgIHJ1blByb3BzICs9ICcgIDxhOmV4dCB1cmk9XCJ7QTEyRkEwMDEtQUM0Ri00MThELUFFMTktNjI3MDZFMDIzNzAzfVwiPic7XG4gICAgICAgICAgICBydW5Qcm9wcyArPSAnICAgPGFoeXA6aGxpbmtDbHIgeG1sbnM6YWh5cD1cImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL2RyYXdpbmcvMjAxOC9oeXBlcmxpbmtjb2xvclwiIHZhbD1cInR4XCIvPic7XG4gICAgICAgICAgICBydW5Qcm9wcyArPSAnICA8L2E6ZXh0Pic7XG4gICAgICAgICAgICBydW5Qcm9wcyArPSAnIDwvYTpleHRMc3Q+JztcbiAgICAgICAgICAgIHJ1blByb3BzICs9ICc8L2E6aGxpbmtDbGljaz4nO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEVORCBydW5Qcm9wZXJ0aWVzXG4gICAgcnVuUHJvcHMgKz0gYDwvJHtydW5Qcm9wc1RhZ30+YDtcbiAgICByZXR1cm4gcnVuUHJvcHM7XG59XG4vKipcbiAqIEJ1aWxkIHRleHRCb2R5IHRleHQgcnVucyBbYDxhOnI+PC9hOnI+YF0gZm9yIHBhcmFncmFwaHMgW2A8YTpwPmBdXG4gKiBAcGFyYW0ge1RleHRQcm9wc30gdGV4dE9iaiAtIFRleHQgb2JqZWN0XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFhNTCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZ2VuWG1sVGV4dFJ1bih0ZXh0T2JqKSB7XG4gICAgLy8gTk9URTogRG9udCBjcmVhdGUgZnVsbCByUHIgcnVuUHJvcHMgZm9yIGVtcHR5IFtsaW5lQnJlYWtdIHJ1bnNcbiAgICAvLyBXaHk/IFRoZSBzaXplIG9mIHRoZSBsaW5lQnJlYWsgd29udCBtYXRjaCAoZWc6IGJlbG93IGl0IHdpbGwgYmUgMThweCBpbnN0ZWFkIG9mIHRoZSBjb3JyZWN0IDM2cHgpXG4gICAgLy8gRG8gdGhpczpcbiAgICAvKlxuICAgICAgICA8YTpwPlxuICAgICAgICAgICAgPGE6cFByIGFsZ249XCJyXCIvPlxuICAgICAgICAgICAgPGE6ZW5kUGFyYVJQciBsYW5nPVwiZW4tVVNcIiBzej1cIjM2MDBcIiBkaXJ0eT1cIjBcIi8+XG4gICAgICAgIDwvYTpwPlxuICAgICovXG4gICAgLy8gTk9UIHRoaXM6XG4gICAgLypcbiAgICAgICAgPGE6cD5cbiAgICAgICAgICAgIDxhOnBQciBhbGduPVwiclwiLz5cbiAgICAgICAgICAgIDxhOnI+XG4gICAgICAgICAgICAgICAgPGE6clByIGxhbmc9XCJlbi1VU1wiIHN6PVwiMzYwMFwiIGRpcnR5PVwiMFwiPlxuICAgICAgICAgICAgICAgICAgICA8YTpzb2xpZEZpbGw+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YTpzY2hlbWVDbHIgdmFsPVwiYWNjZW50NVwiLz5cbiAgICAgICAgICAgICAgICAgICAgPC9hOnNvbGlkRmlsbD5cbiAgICAgICAgICAgICAgICAgICAgPGE6bGF0aW4gdHlwZWZhY2U9XCJUaW1lc1wiIHBpdGNoRmFtaWx5PVwiMzRcIiBjaGFyc2V0PVwiMFwiLz5cbiAgICAgICAgICAgICAgICAgICAgPGE6ZWEgdHlwZWZhY2U9XCJUaW1lc1wiIHBpdGNoRmFtaWx5PVwiMzRcIiBjaGFyc2V0PVwiLTEyMlwiLz5cbiAgICAgICAgICAgICAgICAgICAgPGE6Y3MgdHlwZWZhY2U9XCJUaW1lc1wiIHBpdGNoRmFtaWx5PVwiMzRcIiBjaGFyc2V0PVwiLTEyMFwiLz5cbiAgICAgICAgICAgICAgICA8L2E6clByPlxuICAgICAgICAgICAgICAgIDxhOnQ+PC9hOnQ+XG4gICAgICAgICAgICA8L2E6cj5cbiAgICAgICAgICAgIDxhOmVuZFBhcmFSUHIgbGFuZz1cImVuLVVTXCIgZGlydHk9XCIwXCIvPlxuICAgICAgICA8L2E6cD5cbiAgICAqL1xuICAgIC8vIFJldHVybiBwYXJhZ3JhcGggd2l0aCB0ZXh0IHJ1blxuICAgIHJldHVybiB0ZXh0T2JqLnRleHQgPyBgPGE6cj4ke2dlblhtbFRleHRSdW5Qcm9wZXJ0aWVzKHRleHRPYmoub3B0aW9ucywgZmFsc2UpfTxhOnQ+JHtlbmNvZGVYbWxFbnRpdGllcyh0ZXh0T2JqLnRleHQpfTwvYTp0PjwvYTpyPmAgOiAnJztcbn1cbi8qKlxuICogQnVpbGRzIGA8YTpib2R5UHI+PC9hOmJvZHlQcj5gIHRhZyBmb3IgXCJnZW5YbWxUZXh0Qm9keSgpXCJcbiAqIEBwYXJhbSB7SVNsaWRlT2JqZWN0IHwgVGFibGVDZWxsfSBzbGlkZU9iamVjdCAtIHZhcmlvdXMgb3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfSBYTUwgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGdlblhtbEJvZHlQcm9wZXJ0aWVzKHNsaWRlT2JqZWN0KSB7XG4gICAgbGV0IGJvZHlQcm9wZXJ0aWVzID0gJzxhOmJvZHlQcic7XG4gICAgaWYgKHNsaWRlT2JqZWN0ICYmIHNsaWRlT2JqZWN0Ll90eXBlID09PSBTTElERV9PQkpFQ1RfVFlQRVMudGV4dCAmJiBzbGlkZU9iamVjdC5vcHRpb25zLl9ib2R5UHJvcCkge1xuICAgICAgICAvLyBQUFQtMjAxOSBFWDogPGE6Ym9keVByIHdyYXA9XCJzcXVhcmVcIiBsSW5zPVwiMTI3MFwiIHRJbnM9XCIxMjcwXCIgcklucz1cIjEyNzBcIiBiSW5zPVwiMTI3MFwiIHJ0bENvbD1cIjBcIiBhbmNob3I9XCJjdHJcIi8+XG4gICAgICAgIC8vIEE6IEVuYWJsZSBvciBkaXNhYmxlIHRleHR3cmFwcGluZyBub25lIG9yIHNxdWFyZVxuICAgICAgICBib2R5UHJvcGVydGllcyArPSBzbGlkZU9iamVjdC5vcHRpb25zLl9ib2R5UHJvcC53cmFwID8gJyB3cmFwPVwic3F1YXJlXCInIDogJyB3cmFwPVwibm9uZVwiJztcbiAgICAgICAgLy8gQjogVGV4dGJveCBtYXJnaW5zIFtwYWRkaW5nXVxuICAgICAgICBpZiAoc2xpZGVPYmplY3Qub3B0aW9ucy5fYm9keVByb3AubElucyB8fCBzbGlkZU9iamVjdC5vcHRpb25zLl9ib2R5UHJvcC5sSW5zID09PSAwKVxuICAgICAgICAgICAgYm9keVByb3BlcnRpZXMgKz0gYCBsSW5zPVwiJHtzbGlkZU9iamVjdC5vcHRpb25zLl9ib2R5UHJvcC5sSW5zfVwiYDtcbiAgICAgICAgaWYgKHNsaWRlT2JqZWN0Lm9wdGlvbnMuX2JvZHlQcm9wLnRJbnMgfHwgc2xpZGVPYmplY3Qub3B0aW9ucy5fYm9keVByb3AudElucyA9PT0gMClcbiAgICAgICAgICAgIGJvZHlQcm9wZXJ0aWVzICs9IGAgdElucz1cIiR7c2xpZGVPYmplY3Qub3B0aW9ucy5fYm9keVByb3AudEluc31cImA7XG4gICAgICAgIGlmIChzbGlkZU9iamVjdC5vcHRpb25zLl9ib2R5UHJvcC5ySW5zIHx8IHNsaWRlT2JqZWN0Lm9wdGlvbnMuX2JvZHlQcm9wLnJJbnMgPT09IDApXG4gICAgICAgICAgICBib2R5UHJvcGVydGllcyArPSBgIHJJbnM9XCIke3NsaWRlT2JqZWN0Lm9wdGlvbnMuX2JvZHlQcm9wLnJJbnN9XCJgO1xuICAgICAgICBpZiAoc2xpZGVPYmplY3Qub3B0aW9ucy5fYm9keVByb3AuYklucyB8fCBzbGlkZU9iamVjdC5vcHRpb25zLl9ib2R5UHJvcC5iSW5zID09PSAwKVxuICAgICAgICAgICAgYm9keVByb3BlcnRpZXMgKz0gYCBiSW5zPVwiJHtzbGlkZU9iamVjdC5vcHRpb25zLl9ib2R5UHJvcC5iSW5zfVwiYDtcbiAgICAgICAgLy8gQzogQWRkIHJ0bCBhZnRlciBtYXJnaW5zXG4gICAgICAgIGJvZHlQcm9wZXJ0aWVzICs9ICcgcnRsQ29sPVwiMFwiJztcbiAgICAgICAgLy8gRDogQWRkIGFuY2hvclBvaW50c1xuICAgICAgICBpZiAoc2xpZGVPYmplY3Qub3B0aW9ucy5fYm9keVByb3AuYW5jaG9yKVxuICAgICAgICAgICAgYm9keVByb3BlcnRpZXMgKz0gJyBhbmNob3I9XCInICsgc2xpZGVPYmplY3Qub3B0aW9ucy5fYm9keVByb3AuYW5jaG9yICsgJ1wiJzsgLy8gVkFMUzogW3QsY3RyLGJdXG4gICAgICAgIGlmIChzbGlkZU9iamVjdC5vcHRpb25zLl9ib2R5UHJvcC52ZXJ0KVxuICAgICAgICAgICAgYm9keVByb3BlcnRpZXMgKz0gJyB2ZXJ0PVwiJyArIHNsaWRlT2JqZWN0Lm9wdGlvbnMuX2JvZHlQcm9wLnZlcnQgKyAnXCInOyAvLyBWQUxTOiBbZWFWZXJ0LGhvcnosbW9uZ29saWFuVmVydCx2ZXJ0LHZlcnQyNzAsd29yZEFydFZlcnQsd29yZEFydFZlcnRSdGxdXG4gICAgICAgIC8vIEU6IENsb3NlIDxhOmJvZHlQciBlbGVtZW50XG4gICAgICAgIGJvZHlQcm9wZXJ0aWVzICs9ICc+JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEY6IFRleHQgRml0L0F1dG9GaXQvU2hyaW5rIG9wdGlvblxuICAgICAgICAgKiBAc2VlOiBodHRwOi8vb2ZmaWNlb3BlbnhtbC5jb20vZHJ3U3AtdGV4dC1ib2R5UHItZml0LnBocFxuICAgICAgICAgKiBAc2VlOiBodHRwOi8vd3d3LmRhdHlwaWMuY29tL3NjL29veG1sL2ctYV9FR19UZXh0QXV0b2ZpdC5odG1sXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoc2xpZGVPYmplY3Qub3B0aW9ucy5maXQpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IFVzZSBvZiAnPGE6bm9BdXRvZml0Lz4nIGluc3RlYWQgb2YgJycgY2F1c2VzIGlzc3VlcyBpbiBQUFQtMjAxMyFcbiAgICAgICAgICAgIGlmIChzbGlkZU9iamVjdC5vcHRpb25zLmZpdCA9PT0gJ25vbmUnKVxuICAgICAgICAgICAgICAgIGJvZHlQcm9wZXJ0aWVzICs9ICcnO1xuICAgICAgICAgICAgLy8gTk9URTogU2hyaW5rIGRvZXMgbm90IHdvcmsgYXV0b21hdGljYWxseSAtIFBvd2VyUG9pbnQgY2FsY3VsYXRlcyB0aGUgYGZvbnRTY2FsZWAgdmFsdWUgZHluYW1pY2FsbHkgdXBvbiByZXNpemVcbiAgICAgICAgICAgIC8vIGVsc2UgaWYgKHNsaWRlT2JqZWN0Lm9wdGlvbnMuZml0ID09PSAnc2hyaW5rJykgYm9keVByb3BlcnRpZXMgKz0gJzxhOm5vcm1BdXRvZml0IGZvbnRTY2FsZT1cIjg1MDAwXCIgbG5TcGNSZWR1Y3Rpb249XCIyMDAwMFwiLz4nIC8vIE1TLVBQVCA+IEZvcm1hdCBzaGFwZSA+IFRleHQgT3B0aW9uczogXCJTaHJpbmsgdGV4dCBvbiBvdmVyZmxvd1wiXG4gICAgICAgICAgICBlbHNlIGlmIChzbGlkZU9iamVjdC5vcHRpb25zLmZpdCA9PT0gJ3NocmluaycpXG4gICAgICAgICAgICAgICAgYm9keVByb3BlcnRpZXMgKz0gJzxhOm5vcm1BdXRvZml0Lz4nO1xuICAgICAgICAgICAgZWxzZSBpZiAoc2xpZGVPYmplY3Qub3B0aW9ucy5maXQgPT09ICdyZXNpemUnKVxuICAgICAgICAgICAgICAgIGJvZHlQcm9wZXJ0aWVzICs9ICc8YTpzcEF1dG9GaXQvPic7XG4gICAgICAgIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gREVQUkVDQVRFRDogYmVsb3cgKEBkZXByZWNhdGVkIHYzLjMuMClcbiAgICAgICAgaWYgKHNsaWRlT2JqZWN0Lm9wdGlvbnMuc2hyaW5rVGV4dClcbiAgICAgICAgICAgIGJvZHlQcm9wZXJ0aWVzICs9ICc8YTpub3JtQXV0b2ZpdC8+JzsgLy8gTVMtUFBUID4gRm9ybWF0IHNoYXBlID4gVGV4dCBPcHRpb25zOiBcIlNocmluayB0ZXh0IG9uIG92ZXJmbG93XCJcbiAgICAgICAgLyogREVQUkVDQVRFRDogYmVsb3cgKEBkZXByZWNhdGVkIHYzLjMuMClcbiAgICAgICAgICogTVMtUFBUID4gRm9ybWF0IHNoYXBlID4gVGV4dCBPcHRpb25zOiBcIlJlc2l6ZSBzaGFwZSB0byBmaXQgdGV4dFwiIFtzcEF1dG9GaXRdXG4gICAgICAgICAqIE5PVEU6IFVzZSBvZiAnPGE6bm9BdXRvZml0Lz4nIGluIGxpZXUgb2YgJycgYmVsb3cgY2F1c2VzIGlzc3VlcyBpbiBQUFQtMjAxM1xuICAgICAgICAgKi9cbiAgICAgICAgYm9keVByb3BlcnRpZXMgKz0gc2xpZGVPYmplY3Qub3B0aW9ucy5fYm9keVByb3AuYXV0b0ZpdCA/ICc8YTpzcEF1dG9GaXQvPicgOiAnJztcbiAgICAgICAgLy8gTEFTVDogQ2xvc2UgX2JvZHlQcm9wXG4gICAgICAgIGJvZHlQcm9wZXJ0aWVzICs9ICc8L2E6Ym9keVByPic7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBERUZBVUxUOlxuICAgICAgICBib2R5UHJvcGVydGllcyArPSAnIHdyYXA9XCJzcXVhcmVcIiBydGxDb2w9XCIwXCI+JztcbiAgICAgICAgYm9keVByb3BlcnRpZXMgKz0gJzwvYTpib2R5UHI+JztcbiAgICB9XG4gICAgLy8gTEFTVDogUmV0dXJuIENsb3NlIF9ib2R5UHJvcFxuICAgIHJldHVybiBzbGlkZU9iamVjdC5fdHlwZSA9PT0gU0xJREVfT0JKRUNUX1RZUEVTLnRhYmxlY2VsbCA/ICc8YTpib2R5UHIvPicgOiBib2R5UHJvcGVydGllcztcbn1cbi8qKlxuICogR2VuZXJhdGUgdGhlIFhNTCBmb3IgdGV4dCBhbmQgaXRzIG9wdGlvbnMgKGJvbGQsIGJ1bGxldCwgZXRjKSBpbmNsdWRpbmcgdGV4dCBydW5zICh3b3JkLWxldmVsIGZvcm1hdHRpbmcpXG4gKiBAcGFyYW0ge0lTbGlkZU9iamVjdHxUYWJsZUNlbGx9IHNsaWRlT2JqIC0gc2xpZGVPYmogb3IgdGFibGVDZWxsXG4gKiBAbm90ZSBQUFQgdGV4dCBsaW5lcyBbbGluZXMgZm9sbG93ZWQgYnkgbGluZS1icmVha3NdIGFyZSBjcmVhdGVkIHVzaW5nIDxwPi1hcmFncmFwaCdzXG4gKiBAbm90ZSBCdWxsZXRzIGFyZSBhIHBhcmFncmFnaC1sZXZlbCBmb3JtYXR0aW5nIGRldmljZVxuICogQHRlbXBsYXRlXG4gKiAgICA8cDp0eEJvZHk+XG4gKiAgICAgICAgPGE6Ym9keVByIHdyYXA9XCJzcXVhcmVcIiBydGxDb2w9XCIwXCI+XG4gKiAgICAgICAgICAgIDxhOnNwQXV0b0ZpdC8+XG4gKiAgICAgICAgPC9hOmJvZHlQcj5cbiAqICAgICAgICA8YTpsc3RTdHlsZS8+XG4gKiAgICAgICAgPGE6cD5cbiAqICAgICAgICAgICAgPGE6cFByIGFsZ249XCJjdHJcIi8+XG4gKiAgICAgICAgICAgIDxhOnI+XG4gKiAgICAgICAgICAgICAgICA8YTpyUHIgbGFuZz1cImVuLVVTXCIgZGlydHk9XCIwXCIgZXJyPVwiMVwiLz5cbiAqICAgICAgICAgICAgICAgIDxhOnQ+dGV4dGJveCB0ZXh0PC9hOnQ+XG4gKiAgICAgICAgICAgIDwvYTpyPlxuICogICAgICAgICAgICA8YTplbmRQYXJhUlByIGxhbmc9XCJlbi1VU1wiIGRpcnR5PVwiMFwiLz5cbiAqICAgICAgICA8L2E6cD5cbiAqICAgIDwvcDp0eEJvZHk+XG4gKiBAcmV0dXJucyBYTUwgY29udGFpbmluZyB0aGUgcGFyYW0gb2JqZWN0J3MgdGV4dCBhbmQgZm9ybWF0dGluZ1xuICovXG5mdW5jdGlvbiBnZW5YbWxUZXh0Qm9keShzbGlkZU9iaikge1xuICAgIGNvbnN0IG9wdHMgPSBzbGlkZU9iai5vcHRpb25zIHx8IHt9O1xuICAgIGxldCB0bXBUZXh0T2JqZWN0cyA9IFtdO1xuICAgIGNvbnN0IGFyclRleHRPYmplY3RzID0gW107XG4gICAgLy8gRklSU1Q6IFNoYXBlcyB3aXRob3V0IHRleHQsIGV0Yy4gbWF5IGJlIHNlbnQgaGVyZSBkdXJpbmcgYnVpbGQsIGJ1dCBoYXZlIG5vIHRleHQgdG8gcmVuZGVyIHNvIHJldHVybiBhbiBlbXB0eSBzdHJpbmdcbiAgICBpZiAob3B0cyAmJiBzbGlkZU9iai5fdHlwZSAhPT0gU0xJREVfT0JKRUNUX1RZUEVTLnRhYmxlY2VsbCAmJiAodHlwZW9mIHNsaWRlT2JqLnRleHQgPT09ICd1bmRlZmluZWQnIHx8IHNsaWRlT2JqLnRleHQgPT09IG51bGwpKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgLy8gU1RFUCAxOiBTdGFydCB0ZXh0Qm9keVxuICAgIGxldCBzdHJTbGlkZVhtbCA9IHNsaWRlT2JqLl90eXBlID09PSBTTElERV9PQkpFQ1RfVFlQRVMudGFibGVjZWxsID8gJzxhOnR4Qm9keT4nIDogJzxwOnR4Qm9keT4nO1xuICAgIC8vIFNURVAgMjogQWRkIGJvZHlQcm9wZXJ0aWVzXG4gICAge1xuICAgICAgICAvLyBBOiAnYm9keVByJ1xuICAgICAgICBzdHJTbGlkZVhtbCArPSBnZW5YbWxCb2R5UHJvcGVydGllcyhzbGlkZU9iaik7XG4gICAgICAgIC8vIEI6ICdsc3RTdHlsZSdcbiAgICAgICAgLy8gTk9URTogc2hhcGUgdHlwZSAnTElORScgaGFzIGRpZmZlcmVudCB0ZXh0IGFsaWduIG5lZWRzIChhIGxzdFN0eWxlLmx2bDFwUHIgYmV0d2VlbiBib2R5UHIgYW5kIHApXG4gICAgICAgIC8vIEZJWE1FOiBMSU5FIGhvcml6LWFsaWduIGRvZXNudCB3b3JrICh0ZXh0IGlzIGFsd2F5cyB0byB0aGUgbGVmdCBpbnNpZGUgbGluZSkgKEZZSTogdGhlIFBQVCBjb2RlIGRpZmYgaXMgc3Vic3RhbnRpYWwhKVxuICAgICAgICBpZiAob3B0cy5oID09PSAwICYmIG9wdHMubGluZSAmJiBvcHRzLmFsaWduKVxuICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gJzxhOmxzdFN0eWxlPjxhOmx2bDFwUHIgYWxnbj1cImxcIi8+PC9hOmxzdFN0eWxlPic7XG4gICAgICAgIGVsc2UgaWYgKHNsaWRlT2JqLl90eXBlID09PSAncGxhY2Vob2xkZXInKVxuICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYDxhOmxzdFN0eWxlPiR7Z2VuWG1sUGFyYWdyYXBoUHJvcGVydGllcyhzbGlkZU9iaiwgdHJ1ZSl9PC9hOmxzdFN0eWxlPmA7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICc8YTpsc3RTdHlsZS8+JztcbiAgICB9XG4gICAgLyogU1RFUCAzOiBNb2RpZnkgc2xpZGVPYmoudGV4dCB0byBhcnJheVxuICAgICAgICBDQVNFUzpcbiAgICAgICAgYWRkVGV4dCggJ3N0cmluZycgKSAvLyBzdHJpbmdcbiAgICAgICAgYWRkVGV4dCggJ2xpbmUxXFxuIGxpbmUyJyApIC8vIHN0cmluZyB3aXRoIGxpbmVCcmVha1xuICAgICAgICBhZGRUZXh0KCB7dGV4dDond29yZDEnfSApIC8vIFRleHRQcm9wcyBvYmplY3RcbiAgICAgICAgYWRkVGV4dCggWydiYXJyeScsJ2FsbGVuJ10gKSAvLyBhcnJheSBvZiBzdHJpbmdzXG4gICAgICAgIGFkZFRleHQoIFt7dGV4dDond29yZDEnfSwge3RleHQ6J3dvcmQyJ31dICkgLy8gVGV4dFByb3BzIG9iamVjdCBhcnJheVxuICAgICAgICBhZGRUZXh0KCBbe3RleHQ6J2xpbmUxXFxuIGxpbmUyJ30sIHt0ZXh0OidlbmQgd29yZCd9XSApIC8vIFRleHRQcm9wcyBvYmplY3QgYXJyYXkgd2l0aCBsaW5lQnJlYWtcbiAgICAqL1xuICAgIGlmICh0eXBlb2Ygc2xpZGVPYmoudGV4dCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHNsaWRlT2JqLnRleHQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIEhhbmRsZSBjYXNlcyAxLDJcbiAgICAgICAgdG1wVGV4dE9iamVjdHMucHVzaCh7IHRleHQ6IHNsaWRlT2JqLnRleHQudG9TdHJpbmcoKSwgb3B0aW9uczogb3B0cyB8fCB7fSB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2xpZGVPYmoudGV4dCAmJiAhQXJyYXkuaXNBcnJheShzbGlkZU9iai50ZXh0KSAmJiB0eXBlb2Ygc2xpZGVPYmoudGV4dCA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMoc2xpZGVPYmoudGV4dCkuaW5jbHVkZXMoJ3RleHQnKSkge1xuICAgICAgICAvLyB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHNsaWRlT2JqLnRleHQpICYmIHNsaWRlT2JqLnRleHQhLmhhc093blByb3BlcnR5KCd0ZXh0JykpIHsgLy8gMjAyMTA3MDY6IHJlcGxhY2VkIHdpdGggYmVsb3cgYXMgdHMgY29tcGlsZXIgcmVqZWN0ZWQgaXRcbiAgICAgICAgLy8gSGFuZGxlIGNhc2UgM1xuICAgICAgICB0bXBUZXh0T2JqZWN0cy5wdXNoKHsgdGV4dDogc2xpZGVPYmoudGV4dCB8fCAnJywgb3B0aW9uczogc2xpZGVPYmoub3B0aW9ucyB8fCB7fSB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzbGlkZU9iai50ZXh0KSkge1xuICAgICAgICAvLyBIYW5kbGUgY2FzZXMgNCw1LDZcbiAgICAgICAgLy8gTk9URTogdXNlIGNhc3QgYXMgdGV4dCBpcyBUZXh0UHJvcHNbXXxUYWJsZUNlbGxbXSBhbmQgdGhlaXIgYG9wdGlvbnNgIGRvbnQgb3ZlcmxhcCAodGhleSBzaGFyZSB0aGUgc2FtZSBUZXh0QmFzZVByb3BzIHRob3VnaClcbiAgICAgICAgdG1wVGV4dE9iamVjdHMgPSBzbGlkZU9iai50ZXh0Lm1hcChpdGVtID0+ICh7IHRleHQ6IGl0ZW0udGV4dCwgb3B0aW9uczogaXRlbS5vcHRpb25zIH0pKTtcbiAgICB9XG4gICAgLy8gU1RFUCA0OiBJdGVyYXRlIG92ZXIgdGV4dCBvYmplY3RzLCBzZXQgdGV4dC9vcHRpb25zLCBicmVhayBpbnRvIHBpZWNlcyBpZiAnXFxuJy9icmVha0xpbmUgZm91bmRcbiAgICB0bXBUZXh0T2JqZWN0cy5mb3JFYWNoKChpdGV4dCwgaWR4KSA9PiB7XG4gICAgICAgIGlmICghaXRleHQudGV4dClcbiAgICAgICAgICAgIGl0ZXh0LnRleHQgPSAnJztcbiAgICAgICAgLy8gQTogU2V0IG9wdGlvbnNcbiAgICAgICAgaXRleHQub3B0aW9ucyA9IGl0ZXh0Lm9wdGlvbnMgfHwgb3B0cyB8fCB7fTtcbiAgICAgICAgaWYgKGlkeCA9PT0gMCAmJiBpdGV4dC5vcHRpb25zICYmICFpdGV4dC5vcHRpb25zLmJ1bGxldCAmJiBvcHRzLmJ1bGxldClcbiAgICAgICAgICAgIGl0ZXh0Lm9wdGlvbnMuYnVsbGV0ID0gb3B0cy5idWxsZXQ7XG4gICAgICAgIC8vIEI6IENhc3QgdG8gdGV4dC1vYmplY3QgYW5kIGZpeCBsaW5lLWJyZWFrcyAoaWYgbmVlZGVkKVxuICAgICAgICBpZiAodHlwZW9mIGl0ZXh0LnRleHQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBpdGV4dC50ZXh0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gMTogQ29udmVydCBcIlxcblwiIG9yIGFueSB2YXJpYXRpb24gaW50byBDUkxGXG4gICAgICAgICAgICBpdGV4dC50ZXh0ID0gaXRleHQudGV4dC50b1N0cmluZygpLnJlcGxhY2UoL1xccipcXG4vZywgQ1JMRik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQzogSWYgdGV4dCBzdHJpbmcgaGFzIGxpbmUtYnJlYWtzLCB0aGVuIGNyZWF0ZSBhIHNlcGFyYXRlIHRleHQtb2JqZWN0IGZvciBlYWNoIChtdWNoIGVhc2llciB0aGFuIGRlYWxpbmcgd2l0aCBzcGxpdCBpbnNpZGUgYSBsb29wIGJlbG93KVxuICAgICAgICAvLyBOT1RFOiBGaWx0ZXIgZm9yIHRyYWlsaW5nIGxpbmVCcmVhayBwcmV2ZW50cyB0aGUgY3JlYXRpb24gb2YgYW4gZW1wdHkgdGV4dE9iaiBhcyB0aGUgbGFzdCBpdGVtXG4gICAgICAgIGlmIChpdGV4dC50ZXh0LmluY2x1ZGVzKENSTEYpICYmIGl0ZXh0LnRleHQubWF0Y2goL1xcbiQvZykgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGl0ZXh0LnRleHQuc3BsaXQoQ1JMRikuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgICAgICAgICBpdGV4dC5vcHRpb25zLmJyZWFrTGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXJyVGV4dE9iamVjdHMucHVzaCh7IHRleHQ6IGxpbmUsIG9wdGlvbnM6IGl0ZXh0Lm9wdGlvbnMgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFyclRleHRPYmplY3RzLnB1c2goaXRleHQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gU1RFUCA1OiBHcm91cCB0ZXh0T2JqIGludG8gbGluZXMgYnkgY2hlY2tpbmcgZm9yIGxpbmVCcmVhaywgYnVsbGV0cywgYWxpZ25tZW50IGNoYW5nZSwgZXRjLlxuICAgIGNvbnN0IGFyckxpbmVzID0gW107XG4gICAgbGV0IGFyclRleHRzID0gW107XG4gICAgYXJyVGV4dE9iamVjdHMuZm9yRWFjaCgodGV4dE9iaiwgaWR4KSA9PiB7XG4gICAgICAgIC8vIEE6IEFsaWduIG9yIEJ1bGxldCB0cmlnZ2VyIG5ldyBsaW5lXG4gICAgICAgIGlmIChhcnJUZXh0cy5sZW5ndGggPiAwICYmICh0ZXh0T2JqLm9wdGlvbnMuYWxpZ24gfHwgb3B0cy5hbGlnbikpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgc3RhcnQgYSBuZXcgcGFyYWdyYXBoIHdoZW4gYWxpZ24gKmNoYW5nZXMqXG4gICAgICAgICAgICBpZiAodGV4dE9iai5vcHRpb25zLmFsaWduICE9PSBhcnJUZXh0T2JqZWN0c1tpZHggLSAxXS5vcHRpb25zLmFsaWduKSB7XG4gICAgICAgICAgICAgICAgYXJyTGluZXMucHVzaChhcnJUZXh0cyk7XG4gICAgICAgICAgICAgICAgYXJyVGV4dHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcnJUZXh0cy5sZW5ndGggPiAwICYmIHRleHRPYmoub3B0aW9ucy5idWxsZXQgJiYgYXJyVGV4dHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYXJyTGluZXMucHVzaChhcnJUZXh0cyk7XG4gICAgICAgICAgICBhcnJUZXh0cyA9IFtdO1xuICAgICAgICAgICAgdGV4dE9iai5vcHRpb25zLmJyZWFrTGluZSA9IGZhbHNlOyAvLyBGb3IgY2FzZXMgd2l0aCBib3RoIGBidWxsZXRgIGFuZCBgYnJla2FMaW5lYCAtIHByZXZlbnQgZG91YmxlIGxpbmVCcmVha1xuICAgICAgICB9XG4gICAgICAgIC8vIEI6IEFkZCB0aGlzIHRleHQgdG8gY3VycmVudCBsaW5lXG4gICAgICAgIGFyclRleHRzLnB1c2godGV4dE9iaik7XG4gICAgICAgIC8vIEM6IEJyZWFrTGluZSBiZWdpbnMgbmV3IGxpbmUgKiphZnRlcioqIGFkZGluZyBjdXJyZW50IHRleHRcbiAgICAgICAgaWYgKGFyclRleHRzLmxlbmd0aCA+IDAgJiYgdGV4dE9iai5vcHRpb25zLmJyZWFrTGluZSkge1xuICAgICAgICAgICAgLy8gQXZvaWQgc3RhcnRpbmcgYSBwYXJhIHJpZ2h0IGFzIGxvb3AgaXMgZXhoYXVzdGVkXG4gICAgICAgICAgICBpZiAoaWR4ICsgMSA8IGFyclRleHRPYmplY3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFyckxpbmVzLnB1c2goYXJyVGV4dHMpO1xuICAgICAgICAgICAgICAgIGFyclRleHRzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRDogRmx1c2ggYnVmZmVyXG4gICAgICAgIGlmIChpZHggKyAxID09PSBhcnJUZXh0T2JqZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICBhcnJMaW5lcy5wdXNoKGFyclRleHRzKTtcbiAgICB9KTtcbiAgICAvLyBTVEVQIDY6IExvb3Agb3ZlciBlYWNoIGxpbmUgYW5kIGNyZWF0ZSBwYXJhZ3JhcGggcHJvcHMsIHRleHQgcnVuLCBldGMuXG4gICAgYXJyTGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgcmVxc0Nsb3NpbmdGb250U2l6ZSA9IGZhbHNlO1xuICAgICAgICAvLyBBOiBTdGFydCBwYXJhZ3JhcGgsIGFkZCBwYXJhUHJvcHNcbiAgICAgICAgc3RyU2xpZGVYbWwgKz0gJzxhOnA+JztcbiAgICAgICAgLy8gTk9URTogYHJ0bE1vZGVgIGlzIGxpa2Ugb3RoZXIgb3B0cywgaXRzIHByb3BhZ2F0ZWQgdXAgdG8gZWFjaCB0ZXh0Om9wdGlvbnMsIHNvIGp1c3QgY2hlY2sgdGhlIDFzdCBvbmVcbiAgICAgICAgbGV0IHBhcmFncmFwaFByb3BYbWwgPSBgPGE6cFByICR7KChfYSA9IGxpbmVbMF0ub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJ0bE1vZGUpID8gJyBydGw9XCIxXCIgJyA6ICcnfWA7XG4gICAgICAgIC8vIEI6IFN0YXJ0IHBhcmFncmFwaCwgbG9vcCBvdmVyIGxpbmVzIGFuZCBhZGQgdGV4dCBydW5zXG4gICAgICAgIGxpbmUuZm9yRWFjaCgodGV4dE9iaiwgaWR4KSA9PiB7XG4gICAgICAgICAgICAvLyBBOiBTZXQgbGluZSBpbmRleFxuICAgICAgICAgICAgdGV4dE9iai5vcHRpb25zLl9saW5lSWR4ID0gaWR4O1xuICAgICAgICAgICAgLy8gQS4xOiBBZGQgc29mdCBicmVhayBpZiBub3QgdGhlIGZpcnN0IHJ1biBvZiB0aGUgbGluZS5cbiAgICAgICAgICAgIGlmIChpZHggPiAwICYmIHRleHRPYmoub3B0aW9ucy5zb2Z0QnJlYWtCZWZvcmUpIHtcbiAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSAnPGE6YnIvPic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCOiBJbmhlcml0IHBQci10eXBlIG9wdGlvbnMgZnJvbSBwYXJlbnQgc2hhcGUncyBgb3B0aW9uc2BcbiAgICAgICAgICAgIHRleHRPYmoub3B0aW9ucy5hbGlnbiA9IHRleHRPYmoub3B0aW9ucy5hbGlnbiB8fCBvcHRzLmFsaWduO1xuICAgICAgICAgICAgdGV4dE9iai5vcHRpb25zLmxpbmVTcGFjaW5nID0gdGV4dE9iai5vcHRpb25zLmxpbmVTcGFjaW5nIHx8IG9wdHMubGluZVNwYWNpbmc7XG4gICAgICAgICAgICB0ZXh0T2JqLm9wdGlvbnMubGluZVNwYWNpbmdNdWx0aXBsZSA9IHRleHRPYmoub3B0aW9ucy5saW5lU3BhY2luZ011bHRpcGxlIHx8IG9wdHMubGluZVNwYWNpbmdNdWx0aXBsZTtcbiAgICAgICAgICAgIHRleHRPYmoub3B0aW9ucy5pbmRlbnRMZXZlbCA9IHRleHRPYmoub3B0aW9ucy5pbmRlbnRMZXZlbCB8fCBvcHRzLmluZGVudExldmVsO1xuICAgICAgICAgICAgdGV4dE9iai5vcHRpb25zLnBhcmFTcGFjZUJlZm9yZSA9IHRleHRPYmoub3B0aW9ucy5wYXJhU3BhY2VCZWZvcmUgfHwgb3B0cy5wYXJhU3BhY2VCZWZvcmU7XG4gICAgICAgICAgICB0ZXh0T2JqLm9wdGlvbnMucGFyYVNwYWNlQWZ0ZXIgPSB0ZXh0T2JqLm9wdGlvbnMucGFyYVNwYWNlQWZ0ZXIgfHwgb3B0cy5wYXJhU3BhY2VBZnRlcjtcbiAgICAgICAgICAgIHBhcmFncmFwaFByb3BYbWwgPSBnZW5YbWxQYXJhZ3JhcGhQcm9wZXJ0aWVzKHRleHRPYmosIGZhbHNlKTtcbiAgICAgICAgICAgIHN0clNsaWRlWG1sICs9IHBhcmFncmFwaFByb3BYbWwucmVwbGFjZSgnPGE6cFByPjwvYTpwUHI+JywgJycpOyAvLyBJTVBPUlRBTlQ6IEVtcHR5IFwicFByXCIgYmxvY2tzIHdpbGwgZ2VuZXJhdGUgbmVlZHMtcmVwYWlyL2NvcnJ1cHQgbXNnXG4gICAgICAgICAgICAvLyBDOiBJbmhlcml0IGFueSBtYWluIG9wdGlvbnMgKGNvbG9yLCBmb250U2l6ZSwgZXRjLilcbiAgICAgICAgICAgIC8vIE5PVEU6IFdlIG9ubHkgcGFzcyB0aGUgdGV4dC5vcHRpb25zIHRvIGdlblhtbFRleHRSdW4gKG5vdCB0aGUgU2xpZGUub3B0aW9ucyksXG4gICAgICAgICAgICAvLyBzbyB0aGUgcnVuIGJ1aWxkaW5nIGZ1bmN0aW9uIGNhbnQganVzdCBmYWxsYmFjayB0byBTbGlkZS5jb2xvciwgdGhlcmVmb3JlLCB3ZSBuZWVkIHRvIGRvIHRoYXQgaGVyZSBiZWZvcmUgcGFzc2luZyBvcHRpb25zIGJlbG93LlxuICAgICAgICAgICAgLy8gRklMVEVSIFJVTEU6IEh5cGVybGlua3Mgc2hvdWxkIG5vdCBpbmhlcml0IGBjb2xvcmAgZnJvbSBtYWluIG9wdGlvbnMgKGxldCBQUFQgZGVmYXVsdCB0byBsb2NhbCBjb2xvciwgZWc6IGJsdWUgb24gTWFjT1MpXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhvcHRzKS5maWx0ZXIoKFtrZXldKSA9PiAhKHRleHRPYmoub3B0aW9ucy5oeXBlcmxpbmsgJiYga2V5ID09PSAnY29sb3InKSkuZm9yRWFjaCgoW2tleSwgdmFsXSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGlmICh0ZXh0T2JqLm9wdGlvbnMuaHlwZXJsaW5rICYmIGtleSA9PT0gJ2NvbG9yJykgbnVsbFxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IFRoaXMgbG9vcCB3aWxsIHBpY2sgdXAgdW5lY2Vzc2FyeSBrZXlzIChgeGAsIGV0Yy4pLCBidXQgaXQgZG9lc250IGh1cnQgYW55dGhpbmdcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnYnVsbGV0JyAmJiAhdGV4dE9iai5vcHRpb25zW2tleV0pXG4gICAgICAgICAgICAgICAgICAgIHRleHRPYmoub3B0aW9uc1trZXldID0gdmFsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBEOiBBZGQgZm9ybWF0dGVkIHRleHRydW5cbiAgICAgICAgICAgIHN0clNsaWRlWG1sICs9IGdlblhtbFRleHRSdW4odGV4dE9iaik7XG4gICAgICAgICAgICAvLyBFOiBGbGFnIGNsb3NlIGZvbnRTaXplIGZvciBlbXB0eSBbbGluZUJyZWFrXSBlbGVtZW50c1xuICAgICAgICAgICAgaWYgKCghdGV4dE9iai50ZXh0ICYmIG9wdHMuZm9udFNpemUpIHx8IHRleHRPYmoub3B0aW9ucy5mb250U2l6ZSkge1xuICAgICAgICAgICAgICAgIHJlcXNDbG9zaW5nRm9udFNpemUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG9wdHMuZm9udFNpemUgPSBvcHRzLmZvbnRTaXplIHx8IHRleHRPYmoub3B0aW9ucy5mb250U2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8qIEM6IEFwcGVuZCAnZW5kUGFyYVJQcicgKHdoZW4gbmVlZGVkKSBhbmQgY2xvc2UgY3VycmVudCBvcGVuIHBhcmFncmFwaFxuICAgICAgICAgKiBOT1RFOiAoSVNTVUUjMjAsIElTU1VFIzE5Myk6IEFkZCAnZW5kUGFyYVJQcicgd2l0aCBmb250L3NpemUgcHJvcHMgb3IgUFBUIGRlZmF1bHQgKEFyaWFsLzE4cHQgZW4tdXMpIGlzIHVzZWQgbWFraW5nIHJvdyBcInRvbyB0YWxsXCIvbm90IGhvbm9yaW5nIG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIGlmIChzbGlkZU9iai5fdHlwZSA9PT0gU0xJREVfT0JKRUNUX1RZUEVTLnRhYmxlY2VsbCAmJiAob3B0cy5mb250U2l6ZSB8fCBvcHRzLmZvbnRGYWNlKSkge1xuICAgICAgICAgICAgaWYgKG9wdHMuZm9udEZhY2UpIHtcbiAgICAgICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgPGE6ZW5kUGFyYVJQciBsYW5nPVwiJHtvcHRzLmxhbmcgfHwgJ2VuLVVTJ31cImAgKyAob3B0cy5mb250U2l6ZSA/IGAgc3o9XCIke01hdGgucm91bmQob3B0cy5mb250U2l6ZSAqIDEwMCl9XCJgIDogJycpICsgJyBkaXJ0eT1cIjBcIj4nO1xuICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9IGA8YTpsYXRpbiB0eXBlZmFjZT1cIiR7b3B0cy5mb250RmFjZX1cIiBjaGFyc2V0PVwiMFwiLz5gO1xuICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9IGA8YTplYSB0eXBlZmFjZT1cIiR7b3B0cy5mb250RmFjZX1cIiBjaGFyc2V0PVwiMFwiLz5gO1xuICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9IGA8YTpjcyB0eXBlZmFjZT1cIiR7b3B0cy5mb250RmFjZX1cIiBjaGFyc2V0PVwiMFwiLz5gO1xuICAgICAgICAgICAgICAgIHN0clNsaWRlWG1sICs9ICc8L2E6ZW5kUGFyYVJQcj4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYDxhOmVuZFBhcmFSUHIgbGFuZz1cIiR7b3B0cy5sYW5nIHx8ICdlbi1VUyd9XCJgICsgKG9wdHMuZm9udFNpemUgPyBgIHN6PVwiJHtNYXRoLnJvdW5kKG9wdHMuZm9udFNpemUgKiAxMDApfVwiYCA6ICcnKSArICcgZGlydHk9XCIwXCIvPic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVxc0Nsb3NpbmdGb250U2l6ZSkge1xuICAgICAgICAgICAgLy8gRW1wdHkgW2xpbmVCcmVha10gbGluZXMgc2hvdWxkIG5vdCBjb250YWluIHJ1blByb3AsIGhvd2V2ZXIsIHRoZXkgbmVlZCB0byBzcGVjaWZ5IGZvbnRTaXplIGluIGBlbmRQYXJhUlByYFxuICAgICAgICAgICAgc3RyU2xpZGVYbWwgKz0gYDxhOmVuZFBhcmFSUHIgbGFuZz1cIiR7b3B0cy5sYW5nIHx8ICdlbi1VUyd9XCJgICsgKG9wdHMuZm9udFNpemUgPyBgIHN6PVwiJHtNYXRoLnJvdW5kKG9wdHMuZm9udFNpemUgKiAxMDApfVwiYCA6ICcnKSArICcgZGlydHk9XCIwXCIvPic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJTbGlkZVhtbCArPSBgPGE6ZW5kUGFyYVJQciBsYW5nPVwiJHtvcHRzLmxhbmcgfHwgJ2VuLVVTJ31cIiBkaXJ0eT1cIjBcIi8+YDsgLy8gQWRkZWQgMjAxODAxMDEgdG8gYWRkcmVzcyBQUFQtMjAwNyBpc3N1ZXNcbiAgICAgICAgfVxuICAgICAgICAvLyBEOiBFbmQgcGFyYWdyYXBoXG4gICAgICAgIHN0clNsaWRlWG1sICs9ICc8L2E6cD4nO1xuICAgIH0pO1xuICAgIC8vIElNUE9SVEFOVDogQW4gZW1wdHkgdHhCb2R5IHdpbGwgY2F1c2UgXCJuZWVkcyByZXBhaXJcIiBlcnJvciEgQWRkIDxwPiBjb250ZW50IGlmIG1pc3NpbmcuXG4gICAgLy8gW0ZJWEVEIGluIHYzLjEzLjBdOiBUaGlzIGZpeGVzIGlzc3VlIHdpdGggdGFibGUgYXV0by1wYWdpbmcgd2hlcmUgc29tZSBjZWxscyB3L2IgZW1wdHkgb24gc3Vic2VxdWVudCBwYWdlcy5cbiAgICAvKlxuICAgICAgICA8YTp0eEJvZHk+XG4gICAgICAgICAgICA8YTpib2R5UHIvPlxuICAgICAgICAgICAgPGE6bHN0U3R5bGUvPlxuICAgICAgICA8L2E6dHhCb2R5PlxuICAgICovXG4gICAgaWYgKHN0clNsaWRlWG1sLmluZGV4T2YoJzxhOnA+JykgPT09IC0xKSB7XG4gICAgICAgIHN0clNsaWRlWG1sICs9ICc8YTpwPjxhOmVuZFBhcmFSUHIvPjwvYTpwPic7XG4gICAgfVxuICAgIC8vIFNURVAgNzogQ2xvc2UgdGhlIHRleHRCb2R5XG4gICAgc3RyU2xpZGVYbWwgKz0gc2xpZGVPYmouX3R5cGUgPT09IFNMSURFX09CSkVDVF9UWVBFUy50YWJsZWNlbGwgPyAnPC9hOnR4Qm9keT4nIDogJzwvcDp0eEJvZHk+JztcbiAgICAvLyBMQVNUOiBSZXR1cm4gWE1MXG4gICAgcmV0dXJuIHN0clNsaWRlWG1sO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBhbiBYTUwgUGxhY2Vob2xkZXJcbiAqIEBwYXJhbSB7SVNsaWRlT2JqZWN0fSBwbGFjZWhvbGRlck9ialxuICogQHJldHVybnMgWE1MXG4gKi9cbmZ1bmN0aW9uIGdlblhtbFBsYWNlaG9sZGVyKHBsYWNlaG9sZGVyT2JqKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoIXBsYWNlaG9sZGVyT2JqKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgY29uc3QgcGxhY2Vob2xkZXJJZHggPSAoKF9hID0gcGxhY2Vob2xkZXJPYmoub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9wbGFjZWhvbGRlcklkeCkgPyBwbGFjZWhvbGRlck9iai5vcHRpb25zLl9wbGFjZWhvbGRlcklkeCA6ICcnO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyVHlwID0gKChfYiA9IHBsYWNlaG9sZGVyT2JqLm9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5fcGxhY2Vob2xkZXJUeXBlKSA/IHBsYWNlaG9sZGVyT2JqLm9wdGlvbnMuX3BsYWNlaG9sZGVyVHlwZSA6ICcnO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyVHlwZSA9IHBsYWNlaG9sZGVyVHlwICYmIFBMQUNFSE9MREVSX1RZUEVTW3BsYWNlaG9sZGVyVHlwXSA/IChQTEFDRUhPTERFUl9UWVBFU1twbGFjZWhvbGRlclR5cF0pLnRvU3RyaW5nKCkgOiAnJztcbiAgICByZXR1cm4gYDxwOnBoXG5cdFx0JHtwbGFjZWhvbGRlcklkeCA/ICcgaWR4PVwiJyArIHBsYWNlaG9sZGVySWR4LnRvU3RyaW5nKCkgKyAnXCInIDogJyd9XG5cdFx0JHtwbGFjZWhvbGRlclR5cGUgJiYgUExBQ0VIT0xERVJfVFlQRVNbcGxhY2Vob2xkZXJUeXBlXSA/IGAgdHlwZT1cIiR7cGxhY2Vob2xkZXJUeXBlfVwiYCA6ICcnfVxuXHRcdCR7cGxhY2Vob2xkZXJPYmoudGV4dCAmJiBwbGFjZWhvbGRlck9iai50ZXh0Lmxlbmd0aCA+IDAgPyAnIGhhc0N1c3RvbVByb21wdD1cIjFcIicgOiAnJ31cblx0XHQvPmA7XG59XG4vLyBYTUwtR0VOOiBGaXJzdCA2IGZ1bmN0aW9ucyBjcmVhdGUgdGhlIGJhc2UgL3BwdCBmaWxlc1xuLyoqXG4gKiBHZW5lcmF0ZSBYTUwgQ29udGVudFR5cGVcbiAqIEBwYXJhbSB7UHJlc1NsaWRlW119IHNsaWRlcyAtIHNsaWRlc1xuICogQHBhcmFtIHtTbGlkZUxheW91dFtdfSBzbGlkZUxheW91dHMgLSBzbGlkZSBsYXlvdXRzXG4gKiBAcGFyYW0ge1ByZXNTbGlkZX0gbWFzdGVyU2xpZGUgLSBtYXN0ZXIgc2xpZGVcbiAqIEByZXR1cm5zIFhNTFxuICovXG5mdW5jdGlvbiBtYWtlWG1sQ29udFR5cGVzKHNsaWRlcywgc2xpZGVMYXlvdXRzLCBtYXN0ZXJTbGlkZSkge1xuICAgIGxldCBzdHJYbWwgPSAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIiBzdGFuZGFsb25lPVwieWVzXCI/PicgKyBDUkxGO1xuICAgIHN0clhtbCArPSAnPFR5cGVzIHhtbG5zPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3BhY2thZ2UvMjAwNi9jb250ZW50LXR5cGVzXCI+JztcbiAgICBzdHJYbWwgKz0gJzxEZWZhdWx0IEV4dGVuc2lvbj1cInhtbFwiIENvbnRlbnRUeXBlPVwiYXBwbGljYXRpb24veG1sXCIvPic7XG4gICAgc3RyWG1sICs9ICc8RGVmYXVsdCBFeHRlbnNpb249XCJyZWxzXCIgQ29udGVudFR5cGU9XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtcGFja2FnZS5yZWxhdGlvbnNoaXBzK3htbFwiLz4nO1xuICAgIHN0clhtbCArPSAnPERlZmF1bHQgRXh0ZW5zaW9uPVwianBlZ1wiIENvbnRlbnRUeXBlPVwiaW1hZ2UvanBlZ1wiLz4nO1xuICAgIHN0clhtbCArPSAnPERlZmF1bHQgRXh0ZW5zaW9uPVwianBnXCIgQ29udGVudFR5cGU9XCJpbWFnZS9qcGdcIi8+JztcbiAgICBzdHJYbWwgKz0gJzxEZWZhdWx0IEV4dGVuc2lvbj1cInN2Z1wiIENvbnRlbnRUeXBlPVwiaW1hZ2Uvc3ZnK3htbFwiLz4nO1xuICAgIC8vIFNURVAgMTogQWRkIHN0YW5kYXJkL2FueSBtZWRpYSB0eXBlcyB1c2VkIGluIFByZXNlbnRhdGlvblxuICAgIHN0clhtbCArPSAnPERlZmF1bHQgRXh0ZW5zaW9uPVwicG5nXCIgQ29udGVudFR5cGU9XCJpbWFnZS9wbmdcIi8+JztcbiAgICBzdHJYbWwgKz0gJzxEZWZhdWx0IEV4dGVuc2lvbj1cImdpZlwiIENvbnRlbnRUeXBlPVwiaW1hZ2UvZ2lmXCIvPic7XG4gICAgc3RyWG1sICs9ICc8RGVmYXVsdCBFeHRlbnNpb249XCJtNHZcIiBDb250ZW50VHlwZT1cInZpZGVvL21wNFwiLz4nOyAvLyBOT1RFOiBIYXJkLUNvZGUgdGhpcyBleHRlbnNpb24gYXMgaXQgd29udCBiZSBjcmVhdGVkIGluIGxvb3AgYmVsb3cgKGFzIGV4dG4gIT09IHR5cGUpXG4gICAgc3RyWG1sICs9ICc8RGVmYXVsdCBFeHRlbnNpb249XCJtcDRcIiBDb250ZW50VHlwZT1cInZpZGVvL21wNFwiLz4nOyAvLyBOT1RFOiBIYXJkLUNvZGUgdGhpcyBleHRlbnNpb24gYXMgaXQgd29udCBiZSBjcmVhdGVkIGluIGxvb3AgYmVsb3cgKGFzIGV4dG4gIT09IHR5cGUpXG4gICAgc2xpZGVzLmZvckVhY2goc2xpZGUgPT4ge1xuICAgICAgICAoc2xpZGUuX3JlbHNNZWRpYSB8fCBbXSkuZm9yRWFjaChyZWwgPT4ge1xuICAgICAgICAgICAgaWYgKHJlbC50eXBlICE9PSAnaW1hZ2UnICYmIHJlbC50eXBlICE9PSAnb25saW5lJyAmJiByZWwudHlwZSAhPT0gJ2NoYXJ0JyAmJiByZWwuZXh0biAhPT0gJ200dicgJiYgIXN0clhtbC5pbmNsdWRlcyhyZWwudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBzdHJYbWwgKz0gJzxEZWZhdWx0IEV4dGVuc2lvbj1cIicgKyByZWwuZXh0biArICdcIiBDb250ZW50VHlwZT1cIicgKyByZWwudHlwZSArICdcIi8+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgc3RyWG1sICs9ICc8RGVmYXVsdCBFeHRlbnNpb249XCJ2bWxcIiBDb250ZW50VHlwZT1cImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC52bWxEcmF3aW5nXCIvPic7XG4gICAgc3RyWG1sICs9ICc8RGVmYXVsdCBFeHRlbnNpb249XCJ4bHN4XCIgQ29udGVudFR5cGU9XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5zaGVldFwiLz4nO1xuICAgIC8vIFNURVAgMjogQWRkIHByZXNlbnRhdGlvbiBhbmQgc2xpZGUgbWFzdGVyKHMpL3NsaWRlKHMpXG4gICAgc3RyWG1sICs9ICc8T3ZlcnJpZGUgUGFydE5hbWU9XCIvcHB0L3ByZXNlbnRhdGlvbi54bWxcIiBDb250ZW50VHlwZT1cImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5wcmVzZW50YXRpb24ubWFpbit4bWxcIi8+JztcbiAgICBzdHJYbWwgKz0gJzxPdmVycmlkZSBQYXJ0TmFtZT1cIi9wcHQvbm90ZXNNYXN0ZXJzL25vdGVzTWFzdGVyMS54bWxcIiBDb250ZW50VHlwZT1cImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5ub3Rlc01hc3Rlcit4bWxcIi8+JztcbiAgICBzbGlkZXMuZm9yRWFjaCgoc2xpZGUsIGlkeCkgPT4ge1xuICAgICAgICBzdHJYbWwgKz0gYDxPdmVycmlkZSBQYXJ0TmFtZT1cIi9wcHQvc2xpZGVNYXN0ZXJzL3NsaWRlTWFzdGVyJHtpZHggKyAxfS54bWxcIiBDb250ZW50VHlwZT1cImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5zbGlkZU1hc3Rlcit4bWxcIi8+YDtcbiAgICAgICAgc3RyWG1sICs9IGA8T3ZlcnJpZGUgUGFydE5hbWU9XCIvcHB0L3NsaWRlcy9zbGlkZSR7aWR4ICsgMX0ueG1sXCIgQ29udGVudFR5cGU9XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwuc2xpZGUreG1sXCIvPmA7XG4gICAgICAgIC8vIEFkZCBjaGFydHMgaWYgYW55XG4gICAgICAgIHNsaWRlLl9yZWxzQ2hhcnQuZm9yRWFjaChyZWwgPT4ge1xuICAgICAgICAgICAgc3RyWG1sICs9IGA8T3ZlcnJpZGUgUGFydE5hbWU9XCIke3JlbC5UYXJnZXR9XCIgQ29udGVudFR5cGU9XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuZHJhd2luZ21sLmNoYXJ0K3htbFwiLz5gO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBTVEVQIDM6IENvcmUgUFBUXG4gICAgc3RyWG1sICs9ICc8T3ZlcnJpZGUgUGFydE5hbWU9XCIvcHB0L3ByZXNQcm9wcy54bWxcIiBDb250ZW50VHlwZT1cImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5wcmVzUHJvcHMreG1sXCIvPic7XG4gICAgc3RyWG1sICs9ICc8T3ZlcnJpZGUgUGFydE5hbWU9XCIvcHB0L3ZpZXdQcm9wcy54bWxcIiBDb250ZW50VHlwZT1cImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC52aWV3UHJvcHMreG1sXCIvPic7XG4gICAgc3RyWG1sICs9ICc8T3ZlcnJpZGUgUGFydE5hbWU9XCIvcHB0L3RoZW1lL3RoZW1lMS54bWxcIiBDb250ZW50VHlwZT1cImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC50aGVtZSt4bWxcIi8+JztcbiAgICBzdHJYbWwgKz0gJzxPdmVycmlkZSBQYXJ0TmFtZT1cIi9wcHQvdGFibGVTdHlsZXMueG1sXCIgQ29udGVudFR5cGU9XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwudGFibGVTdHlsZXMreG1sXCIvPic7XG4gICAgLy8gU1RFUCA0OiBBZGQgU2xpZGUgTGF5b3V0c1xuICAgIHNsaWRlTGF5b3V0cy5mb3JFYWNoKChsYXlvdXQsIGlkeCkgPT4ge1xuICAgICAgICBzdHJYbWwgKz0gYDxPdmVycmlkZSBQYXJ0TmFtZT1cIi9wcHQvc2xpZGVMYXlvdXRzL3NsaWRlTGF5b3V0JHtpZHggKyAxfS54bWxcIiBDb250ZW50VHlwZT1cImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5zbGlkZUxheW91dCt4bWxcIi8+YDtcbiAgICAgICAgKGxheW91dC5fcmVsc0NoYXJ0IHx8IFtdKS5mb3JFYWNoKHJlbCA9PiB7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJyA8T3ZlcnJpZGUgUGFydE5hbWU9XCInICsgcmVsLlRhcmdldCArICdcIiBDb250ZW50VHlwZT1cImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5kcmF3aW5nbWwuY2hhcnQreG1sXCIvPic7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIFNURVAgNTogQWRkIG5vdGVzIHNsaWRlKHMpXG4gICAgc2xpZGVzLmZvckVhY2goKF9zbGlkZSwgaWR4KSA9PiB7XG4gICAgICAgIHN0clhtbCArPSBgPE92ZXJyaWRlIFBhcnROYW1lPVwiL3BwdC9ub3Rlc1NsaWRlcy9ub3Rlc1NsaWRlJHtpZHggKyAxfS54bWxcIiBDb250ZW50VHlwZT1cImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5ub3Rlc1NsaWRlK3htbFwiLz5gO1xuICAgIH0pO1xuICAgIC8vIFNURVAgNjogQWRkIHJlbHNcbiAgICBtYXN0ZXJTbGlkZS5fcmVsc0NoYXJ0LmZvckVhY2gocmVsID0+IHtcbiAgICAgICAgc3RyWG1sICs9ICcgPE92ZXJyaWRlIFBhcnROYW1lPVwiJyArIHJlbC5UYXJnZXQgKyAnXCIgQ29udGVudFR5cGU9XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuZHJhd2luZ21sLmNoYXJ0K3htbFwiLz4nO1xuICAgIH0pO1xuICAgIG1hc3RlclNsaWRlLl9yZWxzTWVkaWEuZm9yRWFjaChyZWwgPT4ge1xuICAgICAgICBpZiAocmVsLnR5cGUgIT09ICdpbWFnZScgJiYgcmVsLnR5cGUgIT09ICdvbmxpbmUnICYmIHJlbC50eXBlICE9PSAnY2hhcnQnICYmIHJlbC5leHRuICE9PSAnbTR2JyAmJiAhc3RyWG1sLmluY2x1ZGVzKHJlbC50eXBlKSkge1xuICAgICAgICAgICAgc3RyWG1sICs9ICcgPERlZmF1bHQgRXh0ZW5zaW9uPVwiJyArIHJlbC5leHRuICsgJ1wiIENvbnRlbnRUeXBlPVwiJyArIHJlbC50eXBlICsgJ1wiLz4nO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gTEFTVDogRmluaXNoIFhNTCAoUmVzdW1lIGNvcmUpXG4gICAgc3RyWG1sICs9ICcgPE92ZXJyaWRlIFBhcnROYW1lPVwiL2RvY1Byb3BzL2NvcmUueG1sXCIgQ29udGVudFR5cGU9XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtcGFja2FnZS5jb3JlLXByb3BlcnRpZXMreG1sXCIvPic7XG4gICAgc3RyWG1sICs9ICcgPE92ZXJyaWRlIFBhcnROYW1lPVwiL2RvY1Byb3BzL2FwcC54bWxcIiBDb250ZW50VHlwZT1cImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5leHRlbmRlZC1wcm9wZXJ0aWVzK3htbFwiLz4nO1xuICAgIHN0clhtbCArPSAnPC9UeXBlcz4nO1xuICAgIHJldHVybiBzdHJYbWw7XG59XG4vKipcbiAqIENyZWF0ZXMgYF9yZWxzLy5yZWxzYFxuICogQHJldHVybnMgWE1MXG4gKi9cbmZ1bmN0aW9uIG1ha2VYbWxSb290UmVscygpIHtcbiAgICByZXR1cm4gYDw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCIgc3RhbmRhbG9uZT1cInllc1wiPz4ke0NSTEZ9PFJlbGF0aW9uc2hpcHMgeG1sbnM9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvcGFja2FnZS8yMDA2L3JlbGF0aW9uc2hpcHNcIj5cblx0XHQ8UmVsYXRpb25zaGlwIElkPVwicklkMVwiIFR5cGU9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL2V4dGVuZGVkLXByb3BlcnRpZXNcIiBUYXJnZXQ9XCJkb2NQcm9wcy9hcHAueG1sXCIvPlxuXHRcdDxSZWxhdGlvbnNoaXAgSWQ9XCJySWQyXCIgVHlwZT1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9wYWNrYWdlLzIwMDYvcmVsYXRpb25zaGlwcy9tZXRhZGF0YS9jb3JlLXByb3BlcnRpZXNcIiBUYXJnZXQ9XCJkb2NQcm9wcy9jb3JlLnhtbFwiLz5cblx0XHQ8UmVsYXRpb25zaGlwIElkPVwicklkM1wiIFR5cGU9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL29mZmljZURvY3VtZW50XCIgVGFyZ2V0PVwicHB0L3ByZXNlbnRhdGlvbi54bWxcIi8+XG5cdFx0PC9SZWxhdGlvbnNoaXBzPmA7XG59XG4vKipcbiAqIENyZWF0ZXMgYGRvY1Byb3BzL2FwcC54bWxgXG4gKiBAcGFyYW0ge1ByZXNTbGlkZVtdfSBzbGlkZXMgLSBQcmVzZW5hdGlvbiBTbGlkZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wYW55IC0gXCJDb21wYW55XCIgbWV0YWRhdGFcbiAqIEByZXR1cm5zIFhNTFxuICovXG5mdW5jdGlvbiBtYWtlWG1sQXBwKHNsaWRlcywgY29tcGFueSkge1xuICAgIHJldHVybiBgPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIiBzdGFuZGFsb25lPVwieWVzXCI/PiR7Q1JMRn08UHJvcGVydGllcyB4bWxucz1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L2V4dGVuZGVkLXByb3BlcnRpZXNcIiB4bWxuczp2dD1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L2RvY1Byb3BzVlR5cGVzXCI+XG5cdDxUb3RhbFRpbWU+MDwvVG90YWxUaW1lPlxuXHQ8V29yZHM+MDwvV29yZHM+XG5cdDxBcHBsaWNhdGlvbj5NaWNyb3NvZnQgT2ZmaWNlIFBvd2VyUG9pbnQ8L0FwcGxpY2F0aW9uPlxuXHQ8UHJlc2VudGF0aW9uRm9ybWF0Pk9uLXNjcmVlbiBTaG93ICgxNjo5KTwvUHJlc2VudGF0aW9uRm9ybWF0PlxuXHQ8UGFyYWdyYXBocz4wPC9QYXJhZ3JhcGhzPlxuXHQ8U2xpZGVzPiR7c2xpZGVzLmxlbmd0aH08L1NsaWRlcz5cblx0PE5vdGVzPiR7c2xpZGVzLmxlbmd0aH08L05vdGVzPlxuXHQ8SGlkZGVuU2xpZGVzPjA8L0hpZGRlblNsaWRlcz5cblx0PE1NQ2xpcHM+MDwvTU1DbGlwcz5cblx0PFNjYWxlQ3JvcD5mYWxzZTwvU2NhbGVDcm9wPlxuXHQ8SGVhZGluZ1BhaXJzPlxuXHRcdDx2dDp2ZWN0b3Igc2l6ZT1cIjZcIiBiYXNlVHlwZT1cInZhcmlhbnRcIj5cblx0XHRcdDx2dDp2YXJpYW50Pjx2dDpscHN0cj5Gb250cyBVc2VkPC92dDpscHN0cj48L3Z0OnZhcmlhbnQ+XG5cdFx0XHQ8dnQ6dmFyaWFudD48dnQ6aTQ+MjwvdnQ6aTQ+PC92dDp2YXJpYW50PlxuXHRcdFx0PHZ0OnZhcmlhbnQ+PHZ0Omxwc3RyPlRoZW1lPC92dDpscHN0cj48L3Z0OnZhcmlhbnQ+XG5cdFx0XHQ8dnQ6dmFyaWFudD48dnQ6aTQ+MTwvdnQ6aTQ+PC92dDp2YXJpYW50PlxuXHRcdFx0PHZ0OnZhcmlhbnQ+PHZ0Omxwc3RyPlNsaWRlIFRpdGxlczwvdnQ6bHBzdHI+PC92dDp2YXJpYW50PlxuXHRcdFx0PHZ0OnZhcmlhbnQ+PHZ0Omk0PiR7c2xpZGVzLmxlbmd0aH08L3Z0Omk0PjwvdnQ6dmFyaWFudD5cblx0XHQ8L3Z0OnZlY3Rvcj5cblx0PC9IZWFkaW5nUGFpcnM+XG5cdDxUaXRsZXNPZlBhcnRzPlxuXHRcdDx2dDp2ZWN0b3Igc2l6ZT1cIiR7c2xpZGVzLmxlbmd0aCArIDEgKyAyfVwiIGJhc2VUeXBlPVwibHBzdHJcIj5cblx0XHRcdDx2dDpscHN0cj5BcmlhbDwvdnQ6bHBzdHI+XG5cdFx0XHQ8dnQ6bHBzdHI+Q2FsaWJyaTwvdnQ6bHBzdHI+XG5cdFx0XHQ8dnQ6bHBzdHI+T2ZmaWNlIFRoZW1lPC92dDpscHN0cj5cblx0XHRcdCR7c2xpZGVzLm1hcCgoX3NsaWRlT2JqLCBpZHgpID0+IGA8dnQ6bHBzdHI+U2xpZGUgJHtpZHggKyAxfTwvdnQ6bHBzdHI+YCkuam9pbignJyl9XG5cdFx0PC92dDp2ZWN0b3I+XG5cdDwvVGl0bGVzT2ZQYXJ0cz5cblx0PENvbXBhbnk+JHtjb21wYW55fTwvQ29tcGFueT5cblx0PExpbmtzVXBUb0RhdGU+ZmFsc2U8L0xpbmtzVXBUb0RhdGU+XG5cdDxTaGFyZWREb2M+ZmFsc2U8L1NoYXJlZERvYz5cblx0PEh5cGVybGlua3NDaGFuZ2VkPmZhbHNlPC9IeXBlcmxpbmtzQ2hhbmdlZD5cblx0PEFwcFZlcnNpb24+MTYuMDAwMDwvQXBwVmVyc2lvbj5cblx0PC9Qcm9wZXJ0aWVzPmA7XG59XG4vKipcbiAqIENyZWF0ZXMgYGRvY1Byb3BzL2NvcmUueG1sYFxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlIC0gbWV0YWRhdGEgZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IHN1YmplY3QgLSBtZXRhZGF0YSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gYXV0aG9yIC0gbWV0YWRhdGEgdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXZpc2lvbiAtIG1ldGFkYXRhIHZhbHVlXG4gKiBAcmV0dXJucyBYTUxcbiAqL1xuZnVuY3Rpb24gbWFrZVhtbENvcmUodGl0bGUsIHN1YmplY3QsIGF1dGhvciwgcmV2aXNpb24pIHtcbiAgICByZXR1cm4gYDw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCIgc3RhbmRhbG9uZT1cInllc1wiPz5cblx0PGNwOmNvcmVQcm9wZXJ0aWVzIHhtbG5zOmNwPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3BhY2thZ2UvMjAwNi9tZXRhZGF0YS9jb3JlLXByb3BlcnRpZXNcIiB4bWxuczpkYz1cImh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvXCIgeG1sbnM6ZGN0ZXJtcz1cImh0dHA6Ly9wdXJsLm9yZy9kYy90ZXJtcy9cIiB4bWxuczpkY21pdHlwZT1cImh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9cIiB4bWxuczp4c2k9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYS1pbnN0YW5jZVwiPlxuXHRcdDxkYzp0aXRsZT4ke2VuY29kZVhtbEVudGl0aWVzKHRpdGxlKX08L2RjOnRpdGxlPlxuXHRcdDxkYzpzdWJqZWN0PiR7ZW5jb2RlWG1sRW50aXRpZXMoc3ViamVjdCl9PC9kYzpzdWJqZWN0PlxuXHRcdDxkYzpjcmVhdG9yPiR7ZW5jb2RlWG1sRW50aXRpZXMoYXV0aG9yKX08L2RjOmNyZWF0b3I+XG5cdFx0PGNwOmxhc3RNb2RpZmllZEJ5PiR7ZW5jb2RlWG1sRW50aXRpZXMoYXV0aG9yKX08L2NwOmxhc3RNb2RpZmllZEJ5PlxuXHRcdDxjcDpyZXZpc2lvbj4ke3JldmlzaW9ufTwvY3A6cmV2aXNpb24+XG5cdFx0PGRjdGVybXM6Y3JlYXRlZCB4c2k6dHlwZT1cImRjdGVybXM6VzNDRFRGXCI+JHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvXFwuXFxkXFxkXFxkWi8sICdaJyl9PC9kY3Rlcm1zOmNyZWF0ZWQ+XG5cdFx0PGRjdGVybXM6bW9kaWZpZWQgeHNpOnR5cGU9XCJkY3Rlcm1zOlczQ0RURlwiPiR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpLnJlcGxhY2UoL1xcLlxcZFxcZFxcZFovLCAnWicpfTwvZGN0ZXJtczptb2RpZmllZD5cblx0PC9jcDpjb3JlUHJvcGVydGllcz5gO1xufVxuLyoqXG4gKiBDcmVhdGVzIGBwcHQvX3JlbHMvcHJlc2VudGF0aW9uLnhtbC5yZWxzYFxuICogQHBhcmFtIHtQcmVzU2xpZGVbXX0gc2xpZGVzIC0gUHJlc2VuYXRpb24gU2xpZGVzXG4gKiBAcmV0dXJucyBYTUxcbiAqL1xuZnVuY3Rpb24gbWFrZVhtbFByZXNlbnRhdGlvblJlbHMoc2xpZGVzKSB7XG4gICAgbGV0IGludFJlbE51bSA9IDE7XG4gICAgbGV0IHN0clhtbCA9ICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiIHN0YW5kYWxvbmU9XCJ5ZXNcIj8+JyArIENSTEY7XG4gICAgc3RyWG1sICs9ICc8UmVsYXRpb25zaGlwcyB4bWxucz1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9wYWNrYWdlLzIwMDYvcmVsYXRpb25zaGlwc1wiPic7XG4gICAgc3RyWG1sICs9ICc8UmVsYXRpb25zaGlwIElkPVwicklkMVwiIFR5cGU9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL3NsaWRlTWFzdGVyXCIgVGFyZ2V0PVwic2xpZGVNYXN0ZXJzL3NsaWRlTWFzdGVyMS54bWxcIi8+JztcbiAgICBmb3IgKGxldCBpZHggPSAxOyBpZHggPD0gc2xpZGVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgc3RyWG1sICs9IGA8UmVsYXRpb25zaGlwIElkPVwicklkJHsrK2ludFJlbE51bX1cIiBUeXBlPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcy9zbGlkZVwiIFRhcmdldD1cInNsaWRlcy9zbGlkZSR7aWR4fS54bWxcIi8+YDtcbiAgICB9XG4gICAgaW50UmVsTnVtKys7XG4gICAgc3RyWG1sICs9XG4gICAgICAgIGA8UmVsYXRpb25zaGlwIElkPVwicklkJHtpbnRSZWxOdW0gKyAwfVwiIFR5cGU9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL25vdGVzTWFzdGVyXCIgVGFyZ2V0PVwibm90ZXNNYXN0ZXJzL25vdGVzTWFzdGVyMS54bWxcIi8+YCArXG4gICAgICAgICAgICBgPFJlbGF0aW9uc2hpcCBJZD1cInJJZCR7aW50UmVsTnVtICsgMX1cIiBUeXBlPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcy9wcmVzUHJvcHNcIiBUYXJnZXQ9XCJwcmVzUHJvcHMueG1sXCIvPmAgK1xuICAgICAgICAgICAgYDxSZWxhdGlvbnNoaXAgSWQ9XCJySWQke2ludFJlbE51bSArIDJ9XCIgVHlwZT1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHMvdmlld1Byb3BzXCIgVGFyZ2V0PVwidmlld1Byb3BzLnhtbFwiLz5gICtcbiAgICAgICAgICAgIGA8UmVsYXRpb25zaGlwIElkPVwicklkJHtpbnRSZWxOdW0gKyAzfVwiIFR5cGU9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL3RoZW1lXCIgVGFyZ2V0PVwidGhlbWUvdGhlbWUxLnhtbFwiLz5gICtcbiAgICAgICAgICAgIGA8UmVsYXRpb25zaGlwIElkPVwicklkJHtpbnRSZWxOdW0gKyA0fVwiIFR5cGU9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL3RhYmxlU3R5bGVzXCIgVGFyZ2V0PVwidGFibGVTdHlsZXMueG1sXCIvPmAgK1xuICAgICAgICAgICAgJzwvUmVsYXRpb25zaGlwcz4nO1xuICAgIHJldHVybiBzdHJYbWw7XG59XG4vLyBYTUwtR0VOOiBGdW5jdGlvbnMgdGhhdCBydW4gMS1OIHRpbWVzIChvbmNlIGZvciBlYWNoIFNsaWRlKVxuLyoqXG4gKiBHZW5lcmF0ZXMgWE1MIGZvciB0aGUgc2xpZGUgZmlsZSAoYHBwdC9zbGlkZXMvc2xpZGUxLnhtbGApXG4gKiBAcGFyYW0ge1ByZXNTbGlkZX0gc2xpZGUgLSB0aGUgc2xpZGUgb2JqZWN0IHRvIHRyYW5zZm9ybSBpbnRvIFhNTFxuICogQHJldHVybiB7c3RyaW5nfSBYTUxcbiAqL1xuZnVuY3Rpb24gbWFrZVhtbFNsaWRlKHNsaWRlKSB7XG4gICAgcmV0dXJuIChgPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIiBzdGFuZGFsb25lPVwieWVzXCI/PiR7Q1JMRn1gICtcbiAgICAgICAgJzxwOnNsZCB4bWxuczphPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL2RyYXdpbmdtbC8yMDA2L21haW5cIiB4bWxuczpyPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwc1wiICcgK1xuICAgICAgICAneG1sbnM6cD1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9wcmVzZW50YXRpb25tbC8yMDA2L21haW5cIicgK1xuICAgICAgICBgJHsoc2xpZGUgPT09IG51bGwgfHwgc2xpZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNsaWRlLmhpZGRlbikgPyAnIHNob3c9XCIwXCInIDogJyd9PmAgK1xuICAgICAgICBgJHtzbGlkZU9iamVjdFRvWG1sKHNsaWRlKX1gICtcbiAgICAgICAgJzxwOmNsck1hcE92cj48YTptYXN0ZXJDbHJNYXBwaW5nLz48L3A6Y2xyTWFwT3ZyPjwvcDpzbGQ+Jyk7XG59XG4vKipcbiAqIEdldCB0ZXh0IGNvbnRlbnQgb2YgTm90ZXMgZnJvbSBTbGlkZVxuICogQHBhcmFtIHtQcmVzU2xpZGV9IHNsaWRlIC0gdGhlIHNsaWRlIG9iamVjdCB0byB0cmFuc2Zvcm0gaW50byBYTUxcbiAqIEByZXR1cm4ge3N0cmluZ30gbm90ZXMgdGV4dFxuICovXG5mdW5jdGlvbiBnZXROb3Rlc0Zyb21TbGlkZShzbGlkZSkge1xuICAgIGxldCBub3Rlc1RleHQgPSAnJztcbiAgICBzbGlkZS5fc2xpZGVPYmplY3RzLmZvckVhY2goZGF0YSA9PiB7XG4gICAgICAgIGlmIChkYXRhLl90eXBlID09PSBTTElERV9PQkpFQ1RfVFlQRVMubm90ZXMpXG4gICAgICAgICAgICBub3Rlc1RleHQgKz0gKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS50ZXh0KSAmJiBkYXRhLnRleHRbMF0gPyBkYXRhLnRleHRbMF0udGV4dCA6ICcnO1xuICAgIH0pO1xuICAgIHJldHVybiBub3Rlc1RleHQucmVwbGFjZSgvXFxyKlxcbi9nLCBDUkxGKTtcbn1cbi8qKlxuICogR2VuZXJhdGUgWE1MIGZvciBOb3RlcyBNYXN0ZXIgKG5vdGVzTWFzdGVyMS54bWwpXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBYTUxcbiAqL1xuZnVuY3Rpb24gbWFrZVhtbE5vdGVzTWFzdGVyKCkge1xuICAgIHJldHVybiBgPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIiBzdGFuZGFsb25lPVwieWVzXCI/PiR7Q1JMRn08cDpub3Rlc01hc3RlciB4bWxuczphPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL2RyYXdpbmdtbC8yMDA2L21haW5cIiB4bWxuczpyPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwc1wiIHhtbG5zOnA9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvcHJlc2VudGF0aW9ubWwvMjAwNi9tYWluXCI+PHA6Y1NsZD48cDpiZz48cDpiZ1JlZiBpZHg9XCIxMDAxXCI+PGE6c2NoZW1lQ2xyIHZhbD1cImJnMVwiLz48L3A6YmdSZWY+PC9wOmJnPjxwOnNwVHJlZT48cDpudkdycFNwUHI+PHA6Y052UHIgaWQ9XCIxXCIgbmFtZT1cIlwiLz48cDpjTnZHcnBTcFByLz48cDpudlByLz48L3A6bnZHcnBTcFByPjxwOmdycFNwUHI+PGE6eGZybT48YTpvZmYgeD1cIjBcIiB5PVwiMFwiLz48YTpleHQgY3g9XCIwXCIgY3k9XCIwXCIvPjxhOmNoT2ZmIHg9XCIwXCIgeT1cIjBcIi8+PGE6Y2hFeHQgY3g9XCIwXCIgY3k9XCIwXCIvPjwvYTp4ZnJtPjwvcDpncnBTcFByPjxwOnNwPjxwOm52U3BQcj48cDpjTnZQciBpZD1cIjJcIiBuYW1lPVwiSGVhZGVyIFBsYWNlaG9sZGVyIDFcIi8+PHA6Y052U3BQcj48YTpzcExvY2tzIG5vR3JwPVwiMVwiLz48L3A6Y052U3BQcj48cDpudlByPjxwOnBoIHR5cGU9XCJoZHJcIiBzej1cInF1YXJ0ZXJcIi8+PC9wOm52UHI+PC9wOm52U3BQcj48cDpzcFByPjxhOnhmcm0+PGE6b2ZmIHg9XCIwXCIgeT1cIjBcIi8+PGE6ZXh0IGN4PVwiMjk3MTgwMFwiIGN5PVwiNDU4Nzg4XCIvPjwvYTp4ZnJtPjxhOnByc3RHZW9tIHByc3Q9XCJyZWN0XCI+PGE6YXZMc3QvPjwvYTpwcnN0R2VvbT48L3A6c3BQcj48cDp0eEJvZHk+PGE6Ym9keVByIHZlcnQ9XCJob3J6XCIgbElucz1cIjkxNDQwXCIgdElucz1cIjQ1NzIwXCIgcklucz1cIjkxNDQwXCIgYklucz1cIjQ1NzIwXCIgcnRsQ29sPVwiMFwiLz48YTpsc3RTdHlsZT48YTpsdmwxcFByIGFsZ249XCJsXCI+PGE6ZGVmUlByIHN6PVwiMTIwMFwiLz48L2E6bHZsMXBQcj48L2E6bHN0U3R5bGU+PGE6cD48YTplbmRQYXJhUlByIGxhbmc9XCJlbi1VU1wiLz48L2E6cD48L3A6dHhCb2R5PjwvcDpzcD48cDpzcD48cDpudlNwUHI+PHA6Y052UHIgaWQ9XCIzXCIgbmFtZT1cIkRhdGUgUGxhY2Vob2xkZXIgMlwiLz48cDpjTnZTcFByPjxhOnNwTG9ja3Mgbm9HcnA9XCIxXCIvPjwvcDpjTnZTcFByPjxwOm52UHI+PHA6cGggdHlwZT1cImR0XCIgaWR4PVwiMVwiLz48L3A6bnZQcj48L3A6bnZTcFByPjxwOnNwUHI+PGE6eGZybT48YTpvZmYgeD1cIjM4ODQ2MTNcIiB5PVwiMFwiLz48YTpleHQgY3g9XCIyOTcxODAwXCIgY3k9XCI0NTg3ODhcIi8+PC9hOnhmcm0+PGE6cHJzdEdlb20gcHJzdD1cInJlY3RcIj48YTphdkxzdC8+PC9hOnByc3RHZW9tPjwvcDpzcFByPjxwOnR4Qm9keT48YTpib2R5UHIgdmVydD1cImhvcnpcIiBsSW5zPVwiOTE0NDBcIiB0SW5zPVwiNDU3MjBcIiBySW5zPVwiOTE0NDBcIiBiSW5zPVwiNDU3MjBcIiBydGxDb2w9XCIwXCIvPjxhOmxzdFN0eWxlPjxhOmx2bDFwUHIgYWxnbj1cInJcIj48YTpkZWZSUHIgc3o9XCIxMjAwXCIvPjwvYTpsdmwxcFByPjwvYTpsc3RTdHlsZT48YTpwPjxhOmZsZCBpZD1cIns1MjgyRjE1My0zRjM3LTBGNDUtOUU5Ny03M0FDRkExMzIzMEN9XCIgdHlwZT1cImRhdGV0aW1lRmlndXJlT3V0XCI+PGE6clByIGxhbmc9XCJlbi1VU1wiLz48YTp0PjcvMjMvMTk8L2E6dD48L2E6ZmxkPjxhOmVuZFBhcmFSUHIgbGFuZz1cImVuLVVTXCIvPjwvYTpwPjwvcDp0eEJvZHk+PC9wOnNwPjxwOnNwPjxwOm52U3BQcj48cDpjTnZQciBpZD1cIjRcIiBuYW1lPVwiU2xpZGUgSW1hZ2UgUGxhY2Vob2xkZXIgM1wiLz48cDpjTnZTcFByPjxhOnNwTG9ja3Mgbm9HcnA9XCIxXCIgbm9Sb3Q9XCIxXCIgbm9DaGFuZ2VBc3BlY3Q9XCIxXCIvPjwvcDpjTnZTcFByPjxwOm52UHI+PHA6cGggdHlwZT1cInNsZEltZ1wiIGlkeD1cIjJcIi8+PC9wOm52UHI+PC9wOm52U3BQcj48cDpzcFByPjxhOnhmcm0+PGE6b2ZmIHg9XCI2ODU4MDBcIiB5PVwiMTE0MzAwMFwiLz48YTpleHQgY3g9XCI1NDg2NDAwXCIgY3k9XCIzMDg2MTAwXCIvPjwvYTp4ZnJtPjxhOnByc3RHZW9tIHByc3Q9XCJyZWN0XCI+PGE6YXZMc3QvPjwvYTpwcnN0R2VvbT48YTpub0ZpbGwvPjxhOmxuIHc9XCIxMjcwMFwiPjxhOnNvbGlkRmlsbD48YTpwcnN0Q2xyIHZhbD1cImJsYWNrXCIvPjwvYTpzb2xpZEZpbGw+PC9hOmxuPjwvcDpzcFByPjxwOnR4Qm9keT48YTpib2R5UHIgdmVydD1cImhvcnpcIiBsSW5zPVwiOTE0NDBcIiB0SW5zPVwiNDU3MjBcIiBySW5zPVwiOTE0NDBcIiBiSW5zPVwiNDU3MjBcIiBydGxDb2w9XCIwXCIgYW5jaG9yPVwiY3RyXCIvPjxhOmxzdFN0eWxlLz48YTpwPjxhOmVuZFBhcmFSUHIgbGFuZz1cImVuLVVTXCIvPjwvYTpwPjwvcDp0eEJvZHk+PC9wOnNwPjxwOnNwPjxwOm52U3BQcj48cDpjTnZQciBpZD1cIjVcIiBuYW1lPVwiTm90ZXMgUGxhY2Vob2xkZXIgNFwiLz48cDpjTnZTcFByPjxhOnNwTG9ja3Mgbm9HcnA9XCIxXCIvPjwvcDpjTnZTcFByPjxwOm52UHI+PHA6cGggdHlwZT1cImJvZHlcIiBzej1cInF1YXJ0ZXJcIiBpZHg9XCIzXCIvPjwvcDpudlByPjwvcDpudlNwUHI+PHA6c3BQcj48YTp4ZnJtPjxhOm9mZiB4PVwiNjg1ODAwXCIgeT1cIjQ0MDA1NTBcIi8+PGE6ZXh0IGN4PVwiNTQ4NjQwMFwiIGN5PVwiMzYwMDQ1MFwiLz48L2E6eGZybT48YTpwcnN0R2VvbSBwcnN0PVwicmVjdFwiPjxhOmF2THN0Lz48L2E6cHJzdEdlb20+PC9wOnNwUHI+PHA6dHhCb2R5PjxhOmJvZHlQciB2ZXJ0PVwiaG9yelwiIGxJbnM9XCI5MTQ0MFwiIHRJbnM9XCI0NTcyMFwiIHJJbnM9XCI5MTQ0MFwiIGJJbnM9XCI0NTcyMFwiIHJ0bENvbD1cIjBcIi8+PGE6bHN0U3R5bGUvPjxhOnA+PGE6cFByIGx2bD1cIjBcIi8+PGE6cj48YTpyUHIgbGFuZz1cImVuLVVTXCIvPjxhOnQ+Q2xpY2sgdG8gZWRpdCBNYXN0ZXIgdGV4dCBzdHlsZXM8L2E6dD48L2E6cj48L2E6cD48YTpwPjxhOnBQciBsdmw9XCIxXCIvPjxhOnI+PGE6clByIGxhbmc9XCJlbi1VU1wiLz48YTp0PlNlY29uZCBsZXZlbDwvYTp0PjwvYTpyPjwvYTpwPjxhOnA+PGE6cFByIGx2bD1cIjJcIi8+PGE6cj48YTpyUHIgbGFuZz1cImVuLVVTXCIvPjxhOnQ+VGhpcmQgbGV2ZWw8L2E6dD48L2E6cj48L2E6cD48YTpwPjxhOnBQciBsdmw9XCIzXCIvPjxhOnI+PGE6clByIGxhbmc9XCJlbi1VU1wiLz48YTp0PkZvdXJ0aCBsZXZlbDwvYTp0PjwvYTpyPjwvYTpwPjxhOnA+PGE6cFByIGx2bD1cIjRcIi8+PGE6cj48YTpyUHIgbGFuZz1cImVuLVVTXCIvPjxhOnQ+RmlmdGggbGV2ZWw8L2E6dD48L2E6cj48L2E6cD48L3A6dHhCb2R5PjwvcDpzcD48cDpzcD48cDpudlNwUHI+PHA6Y052UHIgaWQ9XCI2XCIgbmFtZT1cIkZvb3RlciBQbGFjZWhvbGRlciA1XCIvPjxwOmNOdlNwUHI+PGE6c3BMb2NrcyBub0dycD1cIjFcIi8+PC9wOmNOdlNwUHI+PHA6bnZQcj48cDpwaCB0eXBlPVwiZnRyXCIgc3o9XCJxdWFydGVyXCIgaWR4PVwiNFwiLz48L3A6bnZQcj48L3A6bnZTcFByPjxwOnNwUHI+PGE6eGZybT48YTpvZmYgeD1cIjBcIiB5PVwiODY4NTIxM1wiLz48YTpleHQgY3g9XCIyOTcxODAwXCIgY3k9XCI0NTg3ODdcIi8+PC9hOnhmcm0+PGE6cHJzdEdlb20gcHJzdD1cInJlY3RcIj48YTphdkxzdC8+PC9hOnByc3RHZW9tPjwvcDpzcFByPjxwOnR4Qm9keT48YTpib2R5UHIgdmVydD1cImhvcnpcIiBsSW5zPVwiOTE0NDBcIiB0SW5zPVwiNDU3MjBcIiBySW5zPVwiOTE0NDBcIiBiSW5zPVwiNDU3MjBcIiBydGxDb2w9XCIwXCIgYW5jaG9yPVwiYlwiLz48YTpsc3RTdHlsZT48YTpsdmwxcFByIGFsZ249XCJsXCI+PGE6ZGVmUlByIHN6PVwiMTIwMFwiLz48L2E6bHZsMXBQcj48L2E6bHN0U3R5bGU+PGE6cD48YTplbmRQYXJhUlByIGxhbmc9XCJlbi1VU1wiLz48L2E6cD48L3A6dHhCb2R5PjwvcDpzcD48cDpzcD48cDpudlNwUHI+PHA6Y052UHIgaWQ9XCI3XCIgbmFtZT1cIlNsaWRlIE51bWJlciBQbGFjZWhvbGRlciA2XCIvPjxwOmNOdlNwUHI+PGE6c3BMb2NrcyBub0dycD1cIjFcIi8+PC9wOmNOdlNwUHI+PHA6bnZQcj48cDpwaCB0eXBlPVwic2xkTnVtXCIgc3o9XCJxdWFydGVyXCIgaWR4PVwiNVwiLz48L3A6bnZQcj48L3A6bnZTcFByPjxwOnNwUHI+PGE6eGZybT48YTpvZmYgeD1cIjM4ODQ2MTNcIiB5PVwiODY4NTIxM1wiLz48YTpleHQgY3g9XCIyOTcxODAwXCIgY3k9XCI0NTg3ODdcIi8+PC9hOnhmcm0+PGE6cHJzdEdlb20gcHJzdD1cInJlY3RcIj48YTphdkxzdC8+PC9hOnByc3RHZW9tPjwvcDpzcFByPjxwOnR4Qm9keT48YTpib2R5UHIgdmVydD1cImhvcnpcIiBsSW5zPVwiOTE0NDBcIiB0SW5zPVwiNDU3MjBcIiBySW5zPVwiOTE0NDBcIiBiSW5zPVwiNDU3MjBcIiBydGxDb2w9XCIwXCIgYW5jaG9yPVwiYlwiLz48YTpsc3RTdHlsZT48YTpsdmwxcFByIGFsZ249XCJyXCI+PGE6ZGVmUlByIHN6PVwiMTIwMFwiLz48L2E6bHZsMXBQcj48L2E6bHN0U3R5bGU+PGE6cD48YTpmbGQgaWQ9XCJ7Q0U1RTlDQzEtQzcwNi0wRjQ5LTkyRDYtRTU3MUNDNUVFQThGfVwiIHR5cGU9XCJzbGlkZW51bVwiPjxhOnJQciBsYW5nPVwiZW4tVVNcIi8+PGE6dD7igLkj4oC6PC9hOnQ+PC9hOmZsZD48YTplbmRQYXJhUlByIGxhbmc9XCJlbi1VU1wiLz48L2E6cD48L3A6dHhCb2R5PjwvcDpzcD48L3A6c3BUcmVlPjxwOmV4dExzdD48cDpleHQgdXJpPVwie0JCOTYyQzhCLUIxNEYtNEQ5Ny1BRjY1LUY1MzQ0Q0I4QUMzRX1cIj48cDE0OmNyZWF0aW9uSWQgeG1sbnM6cDE0PVwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2UvcG93ZXJwb2ludC8yMDEwL21haW5cIiB2YWw9XCIxMDI0MDg2OTkxXCIvPjwvcDpleHQ+PC9wOmV4dExzdD48L3A6Y1NsZD48cDpjbHJNYXAgYmcxPVwibHQxXCIgdHgxPVwiZGsxXCIgYmcyPVwibHQyXCIgdHgyPVwiZGsyXCIgYWNjZW50MT1cImFjY2VudDFcIiBhY2NlbnQyPVwiYWNjZW50MlwiIGFjY2VudDM9XCJhY2NlbnQzXCIgYWNjZW50ND1cImFjY2VudDRcIiBhY2NlbnQ1PVwiYWNjZW50NVwiIGFjY2VudDY9XCJhY2NlbnQ2XCIgaGxpbms9XCJobGlua1wiIGZvbEhsaW5rPVwiZm9sSGxpbmtcIi8+PHA6bm90ZXNTdHlsZT48YTpsdmwxcFByIG1hckw9XCIwXCIgYWxnbj1cImxcIiBkZWZUYWJTej1cIjkxNDQwMFwiIHJ0bD1cIjBcIiBlYUxuQnJrPVwiMVwiIGxhdGluTG5Ccms9XCIwXCIgaGFuZ2luZ1B1bmN0PVwiMVwiPjxhOmRlZlJQciBzej1cIjEyMDBcIiBrZXJuPVwiMTIwMFwiPjxhOnNvbGlkRmlsbD48YTpzY2hlbWVDbHIgdmFsPVwidHgxXCIvPjwvYTpzb2xpZEZpbGw+PGE6bGF0aW4gdHlwZWZhY2U9XCIrbW4tbHRcIi8+PGE6ZWEgdHlwZWZhY2U9XCIrbW4tZWFcIi8+PGE6Y3MgdHlwZWZhY2U9XCIrbW4tY3NcIi8+PC9hOmRlZlJQcj48L2E6bHZsMXBQcj48YTpsdmwycFByIG1hckw9XCI0NTcyMDBcIiBhbGduPVwibFwiIGRlZlRhYlN6PVwiOTE0NDAwXCIgcnRsPVwiMFwiIGVhTG5Ccms9XCIxXCIgbGF0aW5MbkJyaz1cIjBcIiBoYW5naW5nUHVuY3Q9XCIxXCI+PGE6ZGVmUlByIHN6PVwiMTIwMFwiIGtlcm49XCIxMjAwXCI+PGE6c29saWRGaWxsPjxhOnNjaGVtZUNsciB2YWw9XCJ0eDFcIi8+PC9hOnNvbGlkRmlsbD48YTpsYXRpbiB0eXBlZmFjZT1cIittbi1sdFwiLz48YTplYSB0eXBlZmFjZT1cIittbi1lYVwiLz48YTpjcyB0eXBlZmFjZT1cIittbi1jc1wiLz48L2E6ZGVmUlByPjwvYTpsdmwycFByPjxhOmx2bDNwUHIgbWFyTD1cIjkxNDQwMFwiIGFsZ249XCJsXCIgZGVmVGFiU3o9XCI5MTQ0MDBcIiBydGw9XCIwXCIgZWFMbkJyaz1cIjFcIiBsYXRpbkxuQnJrPVwiMFwiIGhhbmdpbmdQdW5jdD1cIjFcIj48YTpkZWZSUHIgc3o9XCIxMjAwXCIga2Vybj1cIjEyMDBcIj48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD1cInR4MVwiLz48L2E6c29saWRGaWxsPjxhOmxhdGluIHR5cGVmYWNlPVwiK21uLWx0XCIvPjxhOmVhIHR5cGVmYWNlPVwiK21uLWVhXCIvPjxhOmNzIHR5cGVmYWNlPVwiK21uLWNzXCIvPjwvYTpkZWZSUHI+PC9hOmx2bDNwUHI+PGE6bHZsNHBQciBtYXJMPVwiMTM3MTYwMFwiIGFsZ249XCJsXCIgZGVmVGFiU3o9XCI5MTQ0MDBcIiBydGw9XCIwXCIgZWFMbkJyaz1cIjFcIiBsYXRpbkxuQnJrPVwiMFwiIGhhbmdpbmdQdW5jdD1cIjFcIj48YTpkZWZSUHIgc3o9XCIxMjAwXCIga2Vybj1cIjEyMDBcIj48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD1cInR4MVwiLz48L2E6c29saWRGaWxsPjxhOmxhdGluIHR5cGVmYWNlPVwiK21uLWx0XCIvPjxhOmVhIHR5cGVmYWNlPVwiK21uLWVhXCIvPjxhOmNzIHR5cGVmYWNlPVwiK21uLWNzXCIvPjwvYTpkZWZSUHI+PC9hOmx2bDRwUHI+PGE6bHZsNXBQciBtYXJMPVwiMTgyODgwMFwiIGFsZ249XCJsXCIgZGVmVGFiU3o9XCI5MTQ0MDBcIiBydGw9XCIwXCIgZWFMbkJyaz1cIjFcIiBsYXRpbkxuQnJrPVwiMFwiIGhhbmdpbmdQdW5jdD1cIjFcIj48YTpkZWZSUHIgc3o9XCIxMjAwXCIga2Vybj1cIjEyMDBcIj48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD1cInR4MVwiLz48L2E6c29saWRGaWxsPjxhOmxhdGluIHR5cGVmYWNlPVwiK21uLWx0XCIvPjxhOmVhIHR5cGVmYWNlPVwiK21uLWVhXCIvPjxhOmNzIHR5cGVmYWNlPVwiK21uLWNzXCIvPjwvYTpkZWZSUHI+PC9hOmx2bDVwUHI+PGE6bHZsNnBQciBtYXJMPVwiMjI4NjAwMFwiIGFsZ249XCJsXCIgZGVmVGFiU3o9XCI5MTQ0MDBcIiBydGw9XCIwXCIgZWFMbkJyaz1cIjFcIiBsYXRpbkxuQnJrPVwiMFwiIGhhbmdpbmdQdW5jdD1cIjFcIj48YTpkZWZSUHIgc3o9XCIxMjAwXCIga2Vybj1cIjEyMDBcIj48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD1cInR4MVwiLz48L2E6c29saWRGaWxsPjxhOmxhdGluIHR5cGVmYWNlPVwiK21uLWx0XCIvPjxhOmVhIHR5cGVmYWNlPVwiK21uLWVhXCIvPjxhOmNzIHR5cGVmYWNlPVwiK21uLWNzXCIvPjwvYTpkZWZSUHI+PC9hOmx2bDZwUHI+PGE6bHZsN3BQciBtYXJMPVwiMjc0MzIwMFwiIGFsZ249XCJsXCIgZGVmVGFiU3o9XCI5MTQ0MDBcIiBydGw9XCIwXCIgZWFMbkJyaz1cIjFcIiBsYXRpbkxuQnJrPVwiMFwiIGhhbmdpbmdQdW5jdD1cIjFcIj48YTpkZWZSUHIgc3o9XCIxMjAwXCIga2Vybj1cIjEyMDBcIj48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD1cInR4MVwiLz48L2E6c29saWRGaWxsPjxhOmxhdGluIHR5cGVmYWNlPVwiK21uLWx0XCIvPjxhOmVhIHR5cGVmYWNlPVwiK21uLWVhXCIvPjxhOmNzIHR5cGVmYWNlPVwiK21uLWNzXCIvPjwvYTpkZWZSUHI+PC9hOmx2bDdwUHI+PGE6bHZsOHBQciBtYXJMPVwiMzIwMDQwMFwiIGFsZ249XCJsXCIgZGVmVGFiU3o9XCI5MTQ0MDBcIiBydGw9XCIwXCIgZWFMbkJyaz1cIjFcIiBsYXRpbkxuQnJrPVwiMFwiIGhhbmdpbmdQdW5jdD1cIjFcIj48YTpkZWZSUHIgc3o9XCIxMjAwXCIga2Vybj1cIjEyMDBcIj48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD1cInR4MVwiLz48L2E6c29saWRGaWxsPjxhOmxhdGluIHR5cGVmYWNlPVwiK21uLWx0XCIvPjxhOmVhIHR5cGVmYWNlPVwiK21uLWVhXCIvPjxhOmNzIHR5cGVmYWNlPVwiK21uLWNzXCIvPjwvYTpkZWZSUHI+PC9hOmx2bDhwUHI+PGE6bHZsOXBQciBtYXJMPVwiMzY1NzYwMFwiIGFsZ249XCJsXCIgZGVmVGFiU3o9XCI5MTQ0MDBcIiBydGw9XCIwXCIgZWFMbkJyaz1cIjFcIiBsYXRpbkxuQnJrPVwiMFwiIGhhbmdpbmdQdW5jdD1cIjFcIj48YTpkZWZSUHIgc3o9XCIxMjAwXCIga2Vybj1cIjEyMDBcIj48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD1cInR4MVwiLz48L2E6c29saWRGaWxsPjxhOmxhdGluIHR5cGVmYWNlPVwiK21uLWx0XCIvPjxhOmVhIHR5cGVmYWNlPVwiK21uLWVhXCIvPjxhOmNzIHR5cGVmYWNlPVwiK21uLWNzXCIvPjwvYTpkZWZSUHI+PC9hOmx2bDlwUHI+PC9wOm5vdGVzU3R5bGU+PC9wOm5vdGVzTWFzdGVyPmA7XG59XG4vKipcbiAqIENyZWF0ZXMgTm90ZXMgU2xpZGUgKGBwcHQvbm90ZXNTbGlkZXMvbm90ZXNTbGlkZTEueG1sYClcbiAqIEBwYXJhbSB7UHJlc1NsaWRlfSBzbGlkZSAtIHRoZSBzbGlkZSBvYmplY3QgdG8gdHJhbnNmb3JtIGludG8gWE1MXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFhNTFxuICovXG5mdW5jdGlvbiBtYWtlWG1sTm90ZXNTbGlkZShzbGlkZSkge1xuICAgIHJldHVybiAoYDw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCIgc3RhbmRhbG9uZT1cInllc1wiPz4ke0NSTEZ9PHA6bm90ZXMgeG1sbnM6YT1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9kcmF3aW5nbWwvMjAwNi9tYWluXCIgeG1sbnM6cj1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHNcIiB4bWxuczpwPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3ByZXNlbnRhdGlvbm1sLzIwMDYvbWFpblwiPjxwOmNTbGQ+PHA6c3BUcmVlPjxwOm52R3JwU3BQcj48cDpjTnZQciBpZD1cIjFcIiBuYW1lPVwiXCIvPjxwOmNOdkdycFNwUHIvPjxwOm52UHIvPjwvcDpudkdycFNwUHI+PHA6Z3JwU3BQcj48YTp4ZnJtPjxhOm9mZiB4PVwiMFwiIHk9XCIwXCIvPjxhOmV4dCBjeD1cIjBcIiBjeT1cIjBcIi8+PGE6Y2hPZmYgeD1cIjBcIiB5PVwiMFwiLz48YTpjaEV4dCBjeD1cIjBcIiBjeT1cIjBcIi8+PC9hOnhmcm0+PC9wOmdycFNwUHI+PHA6c3A+PHA6bnZTcFByPjxwOmNOdlByIGlkPVwiMlwiIG5hbWU9XCJTbGlkZSBJbWFnZSBQbGFjZWhvbGRlciAxXCIvPjxwOmNOdlNwUHI+PGE6c3BMb2NrcyBub0dycD1cIjFcIiBub1JvdD1cIjFcIiBub0NoYW5nZUFzcGVjdD1cIjFcIi8+PC9wOmNOdlNwUHI+PHA6bnZQcj48cDpwaCB0eXBlPVwic2xkSW1nXCIvPjwvcDpudlByPjwvcDpudlNwUHI+PHA6c3BQci8+PC9wOnNwPjxwOnNwPjxwOm52U3BQcj48cDpjTnZQciBpZD1cIjNcIiBuYW1lPVwiTm90ZXMgUGxhY2Vob2xkZXIgMlwiLz48cDpjTnZTcFByPjxhOnNwTG9ja3Mgbm9HcnA9XCIxXCIvPjwvcDpjTnZTcFByPjxwOm52UHI+PHA6cGggdHlwZT1cImJvZHlcIiBpZHg9XCIxXCIvPjwvcDpudlByPjwvcDpudlNwUHI+PHA6c3BQci8+PHA6dHhCb2R5PjxhOmJvZHlQci8+PGE6bHN0U3R5bGUvPjxhOnA+PGE6cj48YTpyUHIgbGFuZz1cImVuLVVTXCIgZGlydHk9XCIwXCIvPjxhOnQ+JHtlbmNvZGVYbWxFbnRpdGllcyhnZXROb3Rlc0Zyb21TbGlkZShzbGlkZSkpfTwvYTp0PjwvYTpyPjxhOmVuZFBhcmFSUHIgbGFuZz1cImVuLVVTXCIgZGlydHk9XCIwXCIvPjwvYTpwPjwvcDp0eEJvZHk+PC9wOnNwPjxwOnNwPjxwOm52U3BQcj48cDpjTnZQciBpZD1cIjRcIiBuYW1lPVwiU2xpZGUgTnVtYmVyIFBsYWNlaG9sZGVyIDNcIi8+PHA6Y052U3BQcj48YTpzcExvY2tzIG5vR3JwPVwiMVwiLz48L3A6Y052U3BQcj48cDpudlByPjxwOnBoIHR5cGU9XCJzbGROdW1cIiBzej1cInF1YXJ0ZXJcIiBpZHg9XCIxMFwiLz48L3A6bnZQcj48L3A6bnZTcFByPjxwOnNwUHIvPjxwOnR4Qm9keT48YTpib2R5UHIvPjxhOmxzdFN0eWxlLz48YTpwPjxhOmZsZCBpZD1cIiR7U0xETlVNRkxESUR9XCIgdHlwZT1cInNsaWRlbnVtXCI+PGE6clByIGxhbmc9XCJlbi1VU1wiLz48YTp0PiR7c2xpZGUuX3NsaWRlTnVtfTwvYTp0PjwvYTpmbGQ+PGE6ZW5kUGFyYVJQciBsYW5nPVwiZW4tVVNcIi8+PC9hOnA+PC9wOnR4Qm9keT48L3A6c3A+PC9wOnNwVHJlZT48cDpleHRMc3Q+PHA6ZXh0IHVyaT1cIntCQjk2MkM4Qi1CMTRGLTREOTctQUY2NS1GNTM0NENCOEFDM0V9XCI+PHAxNDpjcmVhdGlvbklkIHhtbG5zOnAxND1cImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3Bvd2VycG9pbnQvMjAxMC9tYWluXCIgdmFsPVwiMTAyNDA4Njk5MVwiLz48L3A6ZXh0PjwvcDpleHRMc3Q+PC9wOmNTbGQ+PHA6Y2xyTWFwT3ZyPjxhOm1hc3RlckNsck1hcHBpbmcvPjwvcDpjbHJNYXBPdnI+PC9wOm5vdGVzPmApO1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgdGhlIFhNTCBsYXlvdXQgcmVzb3VyY2UgZnJvbSBhIGxheW91dCBvYmplY3RcbiAqIEBwYXJhbSB7U2xpZGVMYXlvdXR9IGxheW91dCAtIHNsaWRlIGxheW91dCAobWFzdGVyKVxuICogQHJldHVybiB7c3RyaW5nfSBYTUxcbiAqL1xuZnVuY3Rpb24gbWFrZVhtbExheW91dChsYXlvdXQpIHtcbiAgICByZXR1cm4gYDw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCIgc3RhbmRhbG9uZT1cInllc1wiPz5cblx0XHQ8cDpzbGRMYXlvdXQgeG1sbnM6YT1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9kcmF3aW5nbWwvMjAwNi9tYWluXCIgeG1sbnM6cj1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHNcIiB4bWxuczpwPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3ByZXNlbnRhdGlvbm1sLzIwMDYvbWFpblwiIHByZXNlcnZlPVwiMVwiPlxuXHRcdCR7c2xpZGVPYmplY3RUb1htbChsYXlvdXQpfVxuXHRcdDxwOmNsck1hcE92cj48YTptYXN0ZXJDbHJNYXBwaW5nLz48L3A6Y2xyTWFwT3ZyPjwvcDpzbGRMYXlvdXQ+YDtcbn1cbi8qKlxuICogQ3JlYXRlcyBTbGlkZSBNYXN0ZXIgMSAoYHBwdC9zbGlkZU1hc3RlcnMvc2xpZGVNYXN0ZXIxLnhtbGApXG4gKiBAcGFyYW0ge1ByZXNTbGlkZX0gc2xpZGUgLSBzbGlkZSBvYmplY3QgdGhhdCByZXByZXNlbnRzIG1hc3RlciBzbGlkZSBsYXlvdXRcbiAqIEBwYXJhbSB7U2xpZGVMYXlvdXRbXX0gbGF5b3V0cyAtIHNsaWRlIGxheW91dHNcbiAqIEByZXR1cm4ge3N0cmluZ30gWE1MXG4gKi9cbmZ1bmN0aW9uIG1ha2VYbWxNYXN0ZXIoc2xpZGUsIGxheW91dHMpIHtcbiAgICAvLyBOT1RFOiBQYXNzIGxheW91dHMgYXMgc3RhdGljIHJlbHMgYmVjYXVzZSB0aGV5IGFyZSBub3QgcmVmZXJlbmNlZCBhbnkgdGltZVxuICAgIGNvbnN0IGxheW91dERlZnMgPSBsYXlvdXRzLm1hcCgoX2xheW91dERlZiwgaWR4KSA9PiBgPHA6c2xkTGF5b3V0SWQgaWQ9XCIke0xBWU9VVF9JRFhfU0VSSUVTX0JBU0UgKyBpZHh9XCIgcjppZD1cInJJZCR7c2xpZGUuX3JlbHMubGVuZ3RoICsgaWR4ICsgMX1cIi8+YCk7XG4gICAgbGV0IHN0clhtbCA9ICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiIHN0YW5kYWxvbmU9XCJ5ZXNcIj8+JyArIENSTEY7XG4gICAgc3RyWG1sICs9XG4gICAgICAgICc8cDpzbGRNYXN0ZXIgeG1sbnM6YT1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9kcmF3aW5nbWwvMjAwNi9tYWluXCIgeG1sbnM6cj1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHNcIiB4bWxuczpwPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3ByZXNlbnRhdGlvbm1sLzIwMDYvbWFpblwiPic7XG4gICAgc3RyWG1sICs9IHNsaWRlT2JqZWN0VG9YbWwoc2xpZGUpO1xuICAgIHN0clhtbCArPVxuICAgICAgICAnPHA6Y2xyTWFwIGJnMT1cImx0MVwiIHR4MT1cImRrMVwiIGJnMj1cImx0MlwiIHR4Mj1cImRrMlwiIGFjY2VudDE9XCJhY2NlbnQxXCIgYWNjZW50Mj1cImFjY2VudDJcIiBhY2NlbnQzPVwiYWNjZW50M1wiIGFjY2VudDQ9XCJhY2NlbnQ0XCIgYWNjZW50NT1cImFjY2VudDVcIiBhY2NlbnQ2PVwiYWNjZW50NlwiIGhsaW5rPVwiaGxpbmtcIiBmb2xIbGluaz1cImZvbEhsaW5rXCIvPic7XG4gICAgc3RyWG1sICs9ICc8cDpzbGRMYXlvdXRJZExzdD4nICsgbGF5b3V0RGVmcy5qb2luKCcnKSArICc8L3A6c2xkTGF5b3V0SWRMc3Q+JztcbiAgICBzdHJYbWwgKz0gJzxwOmhmIHNsZE51bT1cIjBcIiBoZHI9XCIwXCIgZnRyPVwiMFwiIGR0PVwiMFwiLz4nO1xuICAgIHN0clhtbCArPVxuICAgICAgICAnPHA6dHhTdHlsZXM+JyArXG4gICAgICAgICAgICAnIDxwOnRpdGxlU3R5bGU+JyArXG4gICAgICAgICAgICAnICA8YTpsdmwxcFByIGFsZ249XCJjdHJcIiBkZWZUYWJTej1cIjkxNDQwMFwiIHJ0bD1cIjBcIiBlYUxuQnJrPVwiMVwiIGxhdGluTG5Ccms9XCIwXCIgaGFuZ2luZ1B1bmN0PVwiMVwiPjxhOnNwY0JlZj48YTpzcGNQY3QgdmFsPVwiMFwiLz48L2E6c3BjQmVmPjxhOmJ1Tm9uZS8+PGE6ZGVmUlByIHN6PVwiNDQwMFwiIGtlcm49XCIxMjAwXCI+PGE6c29saWRGaWxsPjxhOnNjaGVtZUNsciB2YWw9XCJ0eDFcIi8+PC9hOnNvbGlkRmlsbD48YTpsYXRpbiB0eXBlZmFjZT1cIittai1sdFwiLz48YTplYSB0eXBlZmFjZT1cIittai1lYVwiLz48YTpjcyB0eXBlZmFjZT1cIittai1jc1wiLz48L2E6ZGVmUlByPjwvYTpsdmwxcFByPicgK1xuICAgICAgICAgICAgJyA8L3A6dGl0bGVTdHlsZT4nICtcbiAgICAgICAgICAgICcgPHA6Ym9keVN0eWxlPicgK1xuICAgICAgICAgICAgJyAgPGE6bHZsMXBQciBtYXJMPVwiMzQyOTAwXCIgaW5kZW50PVwiLTM0MjkwMFwiIGFsZ249XCJsXCIgZGVmVGFiU3o9XCI5MTQ0MDBcIiBydGw9XCIwXCIgZWFMbkJyaz1cIjFcIiBsYXRpbkxuQnJrPVwiMFwiIGhhbmdpbmdQdW5jdD1cIjFcIj48YTpzcGNCZWY+PGE6c3BjUGN0IHZhbD1cIjIwMDAwXCIvPjwvYTpzcGNCZWY+PGE6YnVGb250IHR5cGVmYWNlPVwiQXJpYWxcIiBwaXRjaEZhbWlseT1cIjM0XCIgY2hhcnNldD1cIjBcIi8+PGE6YnVDaGFyIGNoYXI9XCLigKJcIi8+PGE6ZGVmUlByIHN6PVwiMzIwMFwiIGtlcm49XCIxMjAwXCI+PGE6c29saWRGaWxsPjxhOnNjaGVtZUNsciB2YWw9XCJ0eDFcIi8+PC9hOnNvbGlkRmlsbD48YTpsYXRpbiB0eXBlZmFjZT1cIittbi1sdFwiLz48YTplYSB0eXBlZmFjZT1cIittbi1lYVwiLz48YTpjcyB0eXBlZmFjZT1cIittbi1jc1wiLz48L2E6ZGVmUlByPjwvYTpsdmwxcFByPicgK1xuICAgICAgICAgICAgJyAgPGE6bHZsMnBQciBtYXJMPVwiNzQyOTUwXCIgaW5kZW50PVwiLTI4NTc1MFwiIGFsZ249XCJsXCIgZGVmVGFiU3o9XCI5MTQ0MDBcIiBydGw9XCIwXCIgZWFMbkJyaz1cIjFcIiBsYXRpbkxuQnJrPVwiMFwiIGhhbmdpbmdQdW5jdD1cIjFcIj48YTpzcGNCZWY+PGE6c3BjUGN0IHZhbD1cIjIwMDAwXCIvPjwvYTpzcGNCZWY+PGE6YnVGb250IHR5cGVmYWNlPVwiQXJpYWxcIiBwaXRjaEZhbWlseT1cIjM0XCIgY2hhcnNldD1cIjBcIi8+PGE6YnVDaGFyIGNoYXI9XCLigJNcIi8+PGE6ZGVmUlByIHN6PVwiMjgwMFwiIGtlcm49XCIxMjAwXCI+PGE6c29saWRGaWxsPjxhOnNjaGVtZUNsciB2YWw9XCJ0eDFcIi8+PC9hOnNvbGlkRmlsbD48YTpsYXRpbiB0eXBlZmFjZT1cIittbi1sdFwiLz48YTplYSB0eXBlZmFjZT1cIittbi1lYVwiLz48YTpjcyB0eXBlZmFjZT1cIittbi1jc1wiLz48L2E6ZGVmUlByPjwvYTpsdmwycFByPicgK1xuICAgICAgICAgICAgJyAgPGE6bHZsM3BQciBtYXJMPVwiMTE0MzAwMFwiIGluZGVudD1cIi0yMjg2MDBcIiBhbGduPVwibFwiIGRlZlRhYlN6PVwiOTE0NDAwXCIgcnRsPVwiMFwiIGVhTG5Ccms9XCIxXCIgbGF0aW5MbkJyaz1cIjBcIiBoYW5naW5nUHVuY3Q9XCIxXCI+PGE6c3BjQmVmPjxhOnNwY1BjdCB2YWw9XCIyMDAwMFwiLz48L2E6c3BjQmVmPjxhOmJ1Rm9udCB0eXBlZmFjZT1cIkFyaWFsXCIgcGl0Y2hGYW1pbHk9XCIzNFwiIGNoYXJzZXQ9XCIwXCIvPjxhOmJ1Q2hhciBjaGFyPVwi4oCiXCIvPjxhOmRlZlJQciBzej1cIjI0MDBcIiBrZXJuPVwiMTIwMFwiPjxhOnNvbGlkRmlsbD48YTpzY2hlbWVDbHIgdmFsPVwidHgxXCIvPjwvYTpzb2xpZEZpbGw+PGE6bGF0aW4gdHlwZWZhY2U9XCIrbW4tbHRcIi8+PGE6ZWEgdHlwZWZhY2U9XCIrbW4tZWFcIi8+PGE6Y3MgdHlwZWZhY2U9XCIrbW4tY3NcIi8+PC9hOmRlZlJQcj48L2E6bHZsM3BQcj4nICtcbiAgICAgICAgICAgICcgIDxhOmx2bDRwUHIgbWFyTD1cIjE2MDAyMDBcIiBpbmRlbnQ9XCItMjI4NjAwXCIgYWxnbj1cImxcIiBkZWZUYWJTej1cIjkxNDQwMFwiIHJ0bD1cIjBcIiBlYUxuQnJrPVwiMVwiIGxhdGluTG5Ccms9XCIwXCIgaGFuZ2luZ1B1bmN0PVwiMVwiPjxhOnNwY0JlZj48YTpzcGNQY3QgdmFsPVwiMjAwMDBcIi8+PC9hOnNwY0JlZj48YTpidUZvbnQgdHlwZWZhY2U9XCJBcmlhbFwiIHBpdGNoRmFtaWx5PVwiMzRcIiBjaGFyc2V0PVwiMFwiLz48YTpidUNoYXIgY2hhcj1cIuKAk1wiLz48YTpkZWZSUHIgc3o9XCIyMDAwXCIga2Vybj1cIjEyMDBcIj48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD1cInR4MVwiLz48L2E6c29saWRGaWxsPjxhOmxhdGluIHR5cGVmYWNlPVwiK21uLWx0XCIvPjxhOmVhIHR5cGVmYWNlPVwiK21uLWVhXCIvPjxhOmNzIHR5cGVmYWNlPVwiK21uLWNzXCIvPjwvYTpkZWZSUHI+PC9hOmx2bDRwUHI+JyArXG4gICAgICAgICAgICAnICA8YTpsdmw1cFByIG1hckw9XCIyMDU3NDAwXCIgaW5kZW50PVwiLTIyODYwMFwiIGFsZ249XCJsXCIgZGVmVGFiU3o9XCI5MTQ0MDBcIiBydGw9XCIwXCIgZWFMbkJyaz1cIjFcIiBsYXRpbkxuQnJrPVwiMFwiIGhhbmdpbmdQdW5jdD1cIjFcIj48YTpzcGNCZWY+PGE6c3BjUGN0IHZhbD1cIjIwMDAwXCIvPjwvYTpzcGNCZWY+PGE6YnVGb250IHR5cGVmYWNlPVwiQXJpYWxcIiBwaXRjaEZhbWlseT1cIjM0XCIgY2hhcnNldD1cIjBcIi8+PGE6YnVDaGFyIGNoYXI9XCLCu1wiLz48YTpkZWZSUHIgc3o9XCIyMDAwXCIga2Vybj1cIjEyMDBcIj48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD1cInR4MVwiLz48L2E6c29saWRGaWxsPjxhOmxhdGluIHR5cGVmYWNlPVwiK21uLWx0XCIvPjxhOmVhIHR5cGVmYWNlPVwiK21uLWVhXCIvPjxhOmNzIHR5cGVmYWNlPVwiK21uLWNzXCIvPjwvYTpkZWZSUHI+PC9hOmx2bDVwUHI+JyArXG4gICAgICAgICAgICAnICA8YTpsdmw2cFByIG1hckw9XCIyNTE0NjAwXCIgaW5kZW50PVwiLTIyODYwMFwiIGFsZ249XCJsXCIgZGVmVGFiU3o9XCI5MTQ0MDBcIiBydGw9XCIwXCIgZWFMbkJyaz1cIjFcIiBsYXRpbkxuQnJrPVwiMFwiIGhhbmdpbmdQdW5jdD1cIjFcIj48YTpzcGNCZWY+PGE6c3BjUGN0IHZhbD1cIjIwMDAwXCIvPjwvYTpzcGNCZWY+PGE6YnVGb250IHR5cGVmYWNlPVwiQXJpYWxcIiBwaXRjaEZhbWlseT1cIjM0XCIgY2hhcnNldD1cIjBcIi8+PGE6YnVDaGFyIGNoYXI9XCLigKJcIi8+PGE6ZGVmUlByIHN6PVwiMjAwMFwiIGtlcm49XCIxMjAwXCI+PGE6c29saWRGaWxsPjxhOnNjaGVtZUNsciB2YWw9XCJ0eDFcIi8+PC9hOnNvbGlkRmlsbD48YTpsYXRpbiB0eXBlZmFjZT1cIittbi1sdFwiLz48YTplYSB0eXBlZmFjZT1cIittbi1lYVwiLz48YTpjcyB0eXBlZmFjZT1cIittbi1jc1wiLz48L2E6ZGVmUlByPjwvYTpsdmw2cFByPicgK1xuICAgICAgICAgICAgJyAgPGE6bHZsN3BQciBtYXJMPVwiMjk3MTgwMFwiIGluZGVudD1cIi0yMjg2MDBcIiBhbGduPVwibFwiIGRlZlRhYlN6PVwiOTE0NDAwXCIgcnRsPVwiMFwiIGVhTG5Ccms9XCIxXCIgbGF0aW5MbkJyaz1cIjBcIiBoYW5naW5nUHVuY3Q9XCIxXCI+PGE6c3BjQmVmPjxhOnNwY1BjdCB2YWw9XCIyMDAwMFwiLz48L2E6c3BjQmVmPjxhOmJ1Rm9udCB0eXBlZmFjZT1cIkFyaWFsXCIgcGl0Y2hGYW1pbHk9XCIzNFwiIGNoYXJzZXQ9XCIwXCIvPjxhOmJ1Q2hhciBjaGFyPVwi4oCiXCIvPjxhOmRlZlJQciBzej1cIjIwMDBcIiBrZXJuPVwiMTIwMFwiPjxhOnNvbGlkRmlsbD48YTpzY2hlbWVDbHIgdmFsPVwidHgxXCIvPjwvYTpzb2xpZEZpbGw+PGE6bGF0aW4gdHlwZWZhY2U9XCIrbW4tbHRcIi8+PGE6ZWEgdHlwZWZhY2U9XCIrbW4tZWFcIi8+PGE6Y3MgdHlwZWZhY2U9XCIrbW4tY3NcIi8+PC9hOmRlZlJQcj48L2E6bHZsN3BQcj4nICtcbiAgICAgICAgICAgICcgIDxhOmx2bDhwUHIgbWFyTD1cIjM0MjkwMDBcIiBpbmRlbnQ9XCItMjI4NjAwXCIgYWxnbj1cImxcIiBkZWZUYWJTej1cIjkxNDQwMFwiIHJ0bD1cIjBcIiBlYUxuQnJrPVwiMVwiIGxhdGluTG5Ccms9XCIwXCIgaGFuZ2luZ1B1bmN0PVwiMVwiPjxhOnNwY0JlZj48YTpzcGNQY3QgdmFsPVwiMjAwMDBcIi8+PC9hOnNwY0JlZj48YTpidUZvbnQgdHlwZWZhY2U9XCJBcmlhbFwiIHBpdGNoRmFtaWx5PVwiMzRcIiBjaGFyc2V0PVwiMFwiLz48YTpidUNoYXIgY2hhcj1cIuKAolwiLz48YTpkZWZSUHIgc3o9XCIyMDAwXCIga2Vybj1cIjEyMDBcIj48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD1cInR4MVwiLz48L2E6c29saWRGaWxsPjxhOmxhdGluIHR5cGVmYWNlPVwiK21uLWx0XCIvPjxhOmVhIHR5cGVmYWNlPVwiK21uLWVhXCIvPjxhOmNzIHR5cGVmYWNlPVwiK21uLWNzXCIvPjwvYTpkZWZSUHI+PC9hOmx2bDhwUHI+JyArXG4gICAgICAgICAgICAnICA8YTpsdmw5cFByIG1hckw9XCIzODg2MjAwXCIgaW5kZW50PVwiLTIyODYwMFwiIGFsZ249XCJsXCIgZGVmVGFiU3o9XCI5MTQ0MDBcIiBydGw9XCIwXCIgZWFMbkJyaz1cIjFcIiBsYXRpbkxuQnJrPVwiMFwiIGhhbmdpbmdQdW5jdD1cIjFcIj48YTpzcGNCZWY+PGE6c3BjUGN0IHZhbD1cIjIwMDAwXCIvPjwvYTpzcGNCZWY+PGE6YnVGb250IHR5cGVmYWNlPVwiQXJpYWxcIiBwaXRjaEZhbWlseT1cIjM0XCIgY2hhcnNldD1cIjBcIi8+PGE6YnVDaGFyIGNoYXI9XCLigKJcIi8+PGE6ZGVmUlByIHN6PVwiMjAwMFwiIGtlcm49XCIxMjAwXCI+PGE6c29saWRGaWxsPjxhOnNjaGVtZUNsciB2YWw9XCJ0eDFcIi8+PC9hOnNvbGlkRmlsbD48YTpsYXRpbiB0eXBlZmFjZT1cIittbi1sdFwiLz48YTplYSB0eXBlZmFjZT1cIittbi1lYVwiLz48YTpjcyB0eXBlZmFjZT1cIittbi1jc1wiLz48L2E6ZGVmUlByPjwvYTpsdmw5cFByPicgK1xuICAgICAgICAgICAgJyA8L3A6Ym9keVN0eWxlPicgK1xuICAgICAgICAgICAgJyA8cDpvdGhlclN0eWxlPicgK1xuICAgICAgICAgICAgJyAgPGE6ZGVmUFByPjxhOmRlZlJQciBsYW5nPVwiZW4tVVNcIi8+PC9hOmRlZlBQcj4nICtcbiAgICAgICAgICAgICcgIDxhOmx2bDFwUHIgbWFyTD1cIjBcIiBhbGduPVwibFwiIGRlZlRhYlN6PVwiOTE0NDAwXCIgcnRsPVwiMFwiIGVhTG5Ccms9XCIxXCIgbGF0aW5MbkJyaz1cIjBcIiBoYW5naW5nUHVuY3Q9XCIxXCI+PGE6ZGVmUlByIHN6PVwiMTgwMFwiIGtlcm49XCIxMjAwXCI+PGE6c29saWRGaWxsPjxhOnNjaGVtZUNsciB2YWw9XCJ0eDFcIi8+PC9hOnNvbGlkRmlsbD48YTpsYXRpbiB0eXBlZmFjZT1cIittbi1sdFwiLz48YTplYSB0eXBlZmFjZT1cIittbi1lYVwiLz48YTpjcyB0eXBlZmFjZT1cIittbi1jc1wiLz48L2E6ZGVmUlByPjwvYTpsdmwxcFByPicgK1xuICAgICAgICAgICAgJyAgPGE6bHZsMnBQciBtYXJMPVwiNDU3MjAwXCIgYWxnbj1cImxcIiBkZWZUYWJTej1cIjkxNDQwMFwiIHJ0bD1cIjBcIiBlYUxuQnJrPVwiMVwiIGxhdGluTG5Ccms9XCIwXCIgaGFuZ2luZ1B1bmN0PVwiMVwiPjxhOmRlZlJQciBzej1cIjE4MDBcIiBrZXJuPVwiMTIwMFwiPjxhOnNvbGlkRmlsbD48YTpzY2hlbWVDbHIgdmFsPVwidHgxXCIvPjwvYTpzb2xpZEZpbGw+PGE6bGF0aW4gdHlwZWZhY2U9XCIrbW4tbHRcIi8+PGE6ZWEgdHlwZWZhY2U9XCIrbW4tZWFcIi8+PGE6Y3MgdHlwZWZhY2U9XCIrbW4tY3NcIi8+PC9hOmRlZlJQcj48L2E6bHZsMnBQcj4nICtcbiAgICAgICAgICAgICcgIDxhOmx2bDNwUHIgbWFyTD1cIjkxNDQwMFwiIGFsZ249XCJsXCIgZGVmVGFiU3o9XCI5MTQ0MDBcIiBydGw9XCIwXCIgZWFMbkJyaz1cIjFcIiBsYXRpbkxuQnJrPVwiMFwiIGhhbmdpbmdQdW5jdD1cIjFcIj48YTpkZWZSUHIgc3o9XCIxODAwXCIga2Vybj1cIjEyMDBcIj48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD1cInR4MVwiLz48L2E6c29saWRGaWxsPjxhOmxhdGluIHR5cGVmYWNlPVwiK21uLWx0XCIvPjxhOmVhIHR5cGVmYWNlPVwiK21uLWVhXCIvPjxhOmNzIHR5cGVmYWNlPVwiK21uLWNzXCIvPjwvYTpkZWZSUHI+PC9hOmx2bDNwUHI+JyArXG4gICAgICAgICAgICAnICA8YTpsdmw0cFByIG1hckw9XCIxMzcxNjAwXCIgYWxnbj1cImxcIiBkZWZUYWJTej1cIjkxNDQwMFwiIHJ0bD1cIjBcIiBlYUxuQnJrPVwiMVwiIGxhdGluTG5Ccms9XCIwXCIgaGFuZ2luZ1B1bmN0PVwiMVwiPjxhOmRlZlJQciBzej1cIjE4MDBcIiBrZXJuPVwiMTIwMFwiPjxhOnNvbGlkRmlsbD48YTpzY2hlbWVDbHIgdmFsPVwidHgxXCIvPjwvYTpzb2xpZEZpbGw+PGE6bGF0aW4gdHlwZWZhY2U9XCIrbW4tbHRcIi8+PGE6ZWEgdHlwZWZhY2U9XCIrbW4tZWFcIi8+PGE6Y3MgdHlwZWZhY2U9XCIrbW4tY3NcIi8+PC9hOmRlZlJQcj48L2E6bHZsNHBQcj4nICtcbiAgICAgICAgICAgICcgIDxhOmx2bDVwUHIgbWFyTD1cIjE4Mjg4MDBcIiBhbGduPVwibFwiIGRlZlRhYlN6PVwiOTE0NDAwXCIgcnRsPVwiMFwiIGVhTG5Ccms9XCIxXCIgbGF0aW5MbkJyaz1cIjBcIiBoYW5naW5nUHVuY3Q9XCIxXCI+PGE6ZGVmUlByIHN6PVwiMTgwMFwiIGtlcm49XCIxMjAwXCI+PGE6c29saWRGaWxsPjxhOnNjaGVtZUNsciB2YWw9XCJ0eDFcIi8+PC9hOnNvbGlkRmlsbD48YTpsYXRpbiB0eXBlZmFjZT1cIittbi1sdFwiLz48YTplYSB0eXBlZmFjZT1cIittbi1lYVwiLz48YTpjcyB0eXBlZmFjZT1cIittbi1jc1wiLz48L2E6ZGVmUlByPjwvYTpsdmw1cFByPicgK1xuICAgICAgICAgICAgJyAgPGE6bHZsNnBQciBtYXJMPVwiMjI4NjAwMFwiIGFsZ249XCJsXCIgZGVmVGFiU3o9XCI5MTQ0MDBcIiBydGw9XCIwXCIgZWFMbkJyaz1cIjFcIiBsYXRpbkxuQnJrPVwiMFwiIGhhbmdpbmdQdW5jdD1cIjFcIj48YTpkZWZSUHIgc3o9XCIxODAwXCIga2Vybj1cIjEyMDBcIj48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD1cInR4MVwiLz48L2E6c29saWRGaWxsPjxhOmxhdGluIHR5cGVmYWNlPVwiK21uLWx0XCIvPjxhOmVhIHR5cGVmYWNlPVwiK21uLWVhXCIvPjxhOmNzIHR5cGVmYWNlPVwiK21uLWNzXCIvPjwvYTpkZWZSUHI+PC9hOmx2bDZwUHI+JyArXG4gICAgICAgICAgICAnICA8YTpsdmw3cFByIG1hckw9XCIyNzQzMjAwXCIgYWxnbj1cImxcIiBkZWZUYWJTej1cIjkxNDQwMFwiIHJ0bD1cIjBcIiBlYUxuQnJrPVwiMVwiIGxhdGluTG5Ccms9XCIwXCIgaGFuZ2luZ1B1bmN0PVwiMVwiPjxhOmRlZlJQciBzej1cIjE4MDBcIiBrZXJuPVwiMTIwMFwiPjxhOnNvbGlkRmlsbD48YTpzY2hlbWVDbHIgdmFsPVwidHgxXCIvPjwvYTpzb2xpZEZpbGw+PGE6bGF0aW4gdHlwZWZhY2U9XCIrbW4tbHRcIi8+PGE6ZWEgdHlwZWZhY2U9XCIrbW4tZWFcIi8+PGE6Y3MgdHlwZWZhY2U9XCIrbW4tY3NcIi8+PC9hOmRlZlJQcj48L2E6bHZsN3BQcj4nICtcbiAgICAgICAgICAgICcgIDxhOmx2bDhwUHIgbWFyTD1cIjMyMDA0MDBcIiBhbGduPVwibFwiIGRlZlRhYlN6PVwiOTE0NDAwXCIgcnRsPVwiMFwiIGVhTG5Ccms9XCIxXCIgbGF0aW5MbkJyaz1cIjBcIiBoYW5naW5nUHVuY3Q9XCIxXCI+PGE6ZGVmUlByIHN6PVwiMTgwMFwiIGtlcm49XCIxMjAwXCI+PGE6c29saWRGaWxsPjxhOnNjaGVtZUNsciB2YWw9XCJ0eDFcIi8+PC9hOnNvbGlkRmlsbD48YTpsYXRpbiB0eXBlZmFjZT1cIittbi1sdFwiLz48YTplYSB0eXBlZmFjZT1cIittbi1lYVwiLz48YTpjcyB0eXBlZmFjZT1cIittbi1jc1wiLz48L2E6ZGVmUlByPjwvYTpsdmw4cFByPicgK1xuICAgICAgICAgICAgJyAgPGE6bHZsOXBQciBtYXJMPVwiMzY1NzYwMFwiIGFsZ249XCJsXCIgZGVmVGFiU3o9XCI5MTQ0MDBcIiBydGw9XCIwXCIgZWFMbkJyaz1cIjFcIiBsYXRpbkxuQnJrPVwiMFwiIGhhbmdpbmdQdW5jdD1cIjFcIj48YTpkZWZSUHIgc3o9XCIxODAwXCIga2Vybj1cIjEyMDBcIj48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD1cInR4MVwiLz48L2E6c29saWRGaWxsPjxhOmxhdGluIHR5cGVmYWNlPVwiK21uLWx0XCIvPjxhOmVhIHR5cGVmYWNlPVwiK21uLWVhXCIvPjxhOmNzIHR5cGVmYWNlPVwiK21uLWNzXCIvPjwvYTpkZWZSUHI+PC9hOmx2bDlwUHI+JyArXG4gICAgICAgICAgICAnIDwvcDpvdGhlclN0eWxlPicgK1xuICAgICAgICAgICAgJzwvcDp0eFN0eWxlcz4nO1xuICAgIHN0clhtbCArPSAnPC9wOnNsZE1hc3Rlcj4nO1xuICAgIHJldHVybiBzdHJYbWw7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBYTUwgc3RyaW5nIGZvciBhIHNsaWRlIGxheW91dCByZWxhdGlvbiBmaWxlXG4gKiBAcGFyYW0ge251bWJlcn0gbGF5b3V0TnVtYmVyIC0gMS1pbmRleGVkIG51bWJlciBvZiBhIGxheW91dCB0aGF0IHJlbGF0aW9ucyBhcmUgZ2VuZXJhdGVkIGZvclxuICogQHBhcmFtIHtTbGlkZUxheW91dFtdfSBzbGlkZUxheW91dHMgLSBTbGlkZSBMYXlvdXRzXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFhNTFxuICovXG5mdW5jdGlvbiBtYWtlWG1sU2xpZGVMYXlvdXRSZWwobGF5b3V0TnVtYmVyLCBzbGlkZUxheW91dHMpIHtcbiAgICByZXR1cm4gc2xpZGVPYmplY3RSZWxhdGlvbnNUb1htbChzbGlkZUxheW91dHNbbGF5b3V0TnVtYmVyIC0gMV0sIFtcbiAgICAgICAge1xuICAgICAgICAgICAgdGFyZ2V0OiAnLi4vc2xpZGVNYXN0ZXJzL3NsaWRlTWFzdGVyMS54bWwnLFxuICAgICAgICAgICAgdHlwZTogJ2h0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHMvc2xpZGVNYXN0ZXInLFxuICAgICAgICB9LFxuICAgIF0pO1xufVxuLyoqXG4gKiBDcmVhdGVzIGBwcHQvX3JlbHMvc2xpZGUqLnhtbC5yZWxzYFxuICogQHBhcmFtIHtQcmVzU2xpZGVbXX0gc2xpZGVzXG4gKiBAcGFyYW0ge1NsaWRlTGF5b3V0W119IHNsaWRlTGF5b3V0cyAtIFNsaWRlIExheW91dChzKVxuICogQHBhcmFtIHtudW1iZXJ9IGBzbGlkZU51bWJlcmAgMS1pbmRleGVkIG51bWJlciBvZiBhIGxheW91dCB0aGF0IHJlbGF0aW9ucyBhcmUgZ2VuZXJhdGVkIGZvclxuICogQHJldHVybiB7c3RyaW5nfSBYTUxcbiAqL1xuZnVuY3Rpb24gbWFrZVhtbFNsaWRlUmVsKHNsaWRlcywgc2xpZGVMYXlvdXRzLCBzbGlkZU51bWJlcikge1xuICAgIHJldHVybiBzbGlkZU9iamVjdFJlbGF0aW9uc1RvWG1sKHNsaWRlc1tzbGlkZU51bWJlciAtIDFdLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRhcmdldDogYC4uL3NsaWRlTGF5b3V0cy9zbGlkZUxheW91dCR7Z2V0TGF5b3V0SWR4Rm9yU2xpZGUoc2xpZGVzLCBzbGlkZUxheW91dHMsIHNsaWRlTnVtYmVyKX0ueG1sYCxcbiAgICAgICAgICAgIHR5cGU6ICdodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL3NsaWRlTGF5b3V0JyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGFyZ2V0OiBgLi4vbm90ZXNTbGlkZXMvbm90ZXNTbGlkZSR7c2xpZGVOdW1iZXJ9LnhtbGAsXG4gICAgICAgICAgICB0eXBlOiAnaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcy9ub3Rlc1NsaWRlJyxcbiAgICAgICAgfSxcbiAgICBdKTtcbn1cbi8qKlxuICogR2VuZXJhdGVzIFhNTCBzdHJpbmcgZm9yIGEgc2xpZGUgcmVsYXRpb24gZmlsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzbGlkZU51bWJlciAtIDEtaW5kZXhlZCBudW1iZXIgb2YgYSBsYXlvdXQgdGhhdCByZWxhdGlvbnMgYXJlIGdlbmVyYXRlZCBmb3JcbiAqIEByZXR1cm4ge3N0cmluZ30gWE1MXG4gKi9cbmZ1bmN0aW9uIG1ha2VYbWxOb3Rlc1NsaWRlUmVsKHNsaWRlTnVtYmVyKSB7XG4gICAgcmV0dXJuIGA8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiIHN0YW5kYWxvbmU9XCJ5ZXNcIj8+XG5cdFx0PFJlbGF0aW9uc2hpcHMgeG1sbnM9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvcGFja2FnZS8yMDA2L3JlbGF0aW9uc2hpcHNcIj5cblx0XHRcdDxSZWxhdGlvbnNoaXAgSWQ9XCJySWQxXCIgVHlwZT1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHMvbm90ZXNNYXN0ZXJcIiBUYXJnZXQ9XCIuLi9ub3Rlc01hc3RlcnMvbm90ZXNNYXN0ZXIxLnhtbFwiLz5cblx0XHRcdDxSZWxhdGlvbnNoaXAgSWQ9XCJySWQyXCIgVHlwZT1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHMvc2xpZGVcIiBUYXJnZXQ9XCIuLi9zbGlkZXMvc2xpZGUke3NsaWRlTnVtYmVyfS54bWxcIi8+XG5cdFx0PC9SZWxhdGlvbnNoaXBzPmA7XG59XG4vKipcbiAqIENyZWF0ZXMgYHBwdC9zbGlkZU1hc3RlcnMvX3JlbHMvc2xpZGVNYXN0ZXIxLnhtbC5yZWxzYFxuICogQHBhcmFtIHtQcmVzU2xpZGV9IG1hc3RlclNsaWRlIC0gU2xpZGUgb2JqZWN0XG4gKiBAcGFyYW0ge1NsaWRlTGF5b3V0W119IHNsaWRlTGF5b3V0cyAtIFNsaWRlIExheW91dHNcbiAqIEByZXR1cm4ge3N0cmluZ30gWE1MXG4gKi9cbmZ1bmN0aW9uIG1ha2VYbWxNYXN0ZXJSZWwobWFzdGVyU2xpZGUsIHNsaWRlTGF5b3V0cykge1xuICAgIGNvbnN0IGRlZmF1bHRSZWxzID0gc2xpZGVMYXlvdXRzLm1hcCgoX2xheW91dERlZiwgaWR4KSA9PiAoe1xuICAgICAgICB0YXJnZXQ6IGAuLi9zbGlkZUxheW91dHMvc2xpZGVMYXlvdXQke2lkeCArIDF9LnhtbGAsXG4gICAgICAgIHR5cGU6ICdodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL3NsaWRlTGF5b3V0JyxcbiAgICB9KSk7XG4gICAgZGVmYXVsdFJlbHMucHVzaCh7IHRhcmdldDogJy4uL3RoZW1lL3RoZW1lMS54bWwnLCB0eXBlOiAnaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcy90aGVtZScgfSk7XG4gICAgcmV0dXJuIHNsaWRlT2JqZWN0UmVsYXRpb25zVG9YbWwobWFzdGVyU2xpZGUsIGRlZmF1bHRSZWxzKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBgcHB0L25vdGVzTWFzdGVycy9fcmVscy9ub3Rlc01hc3RlcjEueG1sLnJlbHNgXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFhNTFxuICovXG5mdW5jdGlvbiBtYWtlWG1sTm90ZXNNYXN0ZXJSZWwoKSB7XG4gICAgcmV0dXJuIGA8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiIHN0YW5kYWxvbmU9XCJ5ZXNcIj8+JHtDUkxGfTxSZWxhdGlvbnNoaXBzIHhtbG5zPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3BhY2thZ2UvMjAwNi9yZWxhdGlvbnNoaXBzXCI+XG5cdFx0PFJlbGF0aW9uc2hpcCBJZD1cInJJZDFcIiBUeXBlPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcy90aGVtZVwiIFRhcmdldD1cIi4uL3RoZW1lL3RoZW1lMS54bWxcIi8+XG5cdFx0PC9SZWxhdGlvbnNoaXBzPmA7XG59XG4vKipcbiAqIEZvciB0aGUgcGFzc2VkIHNsaWRlIG51bWJlciwgcmVzb2x2ZXMgbmFtZSBvZiBhIGxheW91dCB0aGF0IGlzIHVzZWQgZm9yLlxuICogQHBhcmFtIHtQcmVzU2xpZGVbXX0gc2xpZGVzIC0gc3JyYXkgb2Ygc2xpZGVzXG4gKiBAcGFyYW0ge1NsaWRlTGF5b3V0W119IHNsaWRlTGF5b3V0cyAtIGFycmF5IG9mIHNsaWRlTGF5b3V0c1xuICogQHBhcmFtIHtudW1iZXJ9IHNsaWRlTnVtYmVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHNsaWRlIG51bWJlclxuICovXG5mdW5jdGlvbiBnZXRMYXlvdXRJZHhGb3JTbGlkZShzbGlkZXMsIHNsaWRlTGF5b3V0cywgc2xpZGVOdW1iZXIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlTGF5b3V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2xpZGVMYXlvdXRzW2ldLl9uYW1lID09PSBzbGlkZXNbc2xpZGVOdW1iZXIgLSAxXS5fc2xpZGVMYXlvdXQuX25hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJTVBPUlRBTlQ6IFJldHVybiAxIChmb3IgYHNsaWRlTGF5b3V0MS54bWxgKSB3aGVuIG5vIGRlZiBpcyBmb3VuZFxuICAgIC8vIFNvIGFsbCBvYmplY3RzIGFyZSBpbiBMYXlvdXQxIGFuZCBldmVyeSBzbGlkZSB0aGF0IHJlZmVyZW5jZXMgaXQgdXNlcyB0aGlzIGxheW91dC5cbiAgICByZXR1cm4gMTtcbn1cbi8vIFhNTC1HRU46IExhc3QgNSBmdW5jdGlvbnMgY3JlYXRlIHJvb3QgL3BwdCBmaWxlc1xuLyoqXG4gKiBDcmVhdGVzIGBwcHQvdGhlbWUvdGhlbWUxLnhtbGBcbiAqIEByZXR1cm4ge3N0cmluZ30gWE1MXG4gKi9cbmZ1bmN0aW9uIG1ha2VYbWxUaGVtZShwcmVzKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IG1ham9yRm9udCA9ICgoX2EgPSBwcmVzLnRoZW1lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhZEZvbnRGYWNlKSA/IGA8YTpsYXRpbiB0eXBlZmFjZT1cIiR7KF9iID0gcHJlcy50aGVtZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhlYWRGb250RmFjZX1cIi8+YCA6ICc8YTpsYXRpbiB0eXBlZmFjZT1cIkNhbGlicmkgTGlnaHRcIiBwYW5vc2U9XCIwMjBGMDMwMjAyMDIwNDAzMDIwNFwiLz4nO1xuICAgIGNvbnN0IG1pbm9yRm9udCA9ICgoX2MgPSBwcmVzLnRoZW1lKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYm9keUZvbnRGYWNlKSA/IGA8YTpsYXRpbiB0eXBlZmFjZT1cIiR7KF9kID0gcHJlcy50aGVtZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmJvZHlGb250RmFjZX1cIi8+YCA6ICc8YTpsYXRpbiB0eXBlZmFjZT1cIkNhbGlicmlcIiBwYW5vc2U9XCIwMjBGMDUwMjAyMDIwNDAzMDIwNFwiLz4nO1xuICAgIHJldHVybiBgPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIiBzdGFuZGFsb25lPVwieWVzXCI/PjxhOnRoZW1lIHhtbG5zOmE9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvZHJhd2luZ21sLzIwMDYvbWFpblwiIG5hbWU9XCJPZmZpY2UgVGhlbWVcIj48YTp0aGVtZUVsZW1lbnRzPjxhOmNsclNjaGVtZSBuYW1lPVwiT2ZmaWNlXCI+PGE6ZGsxPjxhOnN5c0NsciB2YWw9XCJ3aW5kb3dUZXh0XCIgbGFzdENscj1cIjAwMDAwMFwiLz48L2E6ZGsxPjxhOmx0MT48YTpzeXNDbHIgdmFsPVwid2luZG93XCIgbGFzdENscj1cIkZGRkZGRlwiLz48L2E6bHQxPjxhOmRrMj48YTpzcmdiQ2xyIHZhbD1cIjQ0NTQ2QVwiLz48L2E6ZGsyPjxhOmx0Mj48YTpzcmdiQ2xyIHZhbD1cIkU3RTZFNlwiLz48L2E6bHQyPjxhOmFjY2VudDE+PGE6c3JnYkNsciB2YWw9XCI0NDcyQzRcIi8+PC9hOmFjY2VudDE+PGE6YWNjZW50Mj48YTpzcmdiQ2xyIHZhbD1cIkVEN0QzMVwiLz48L2E6YWNjZW50Mj48YTphY2NlbnQzPjxhOnNyZ2JDbHIgdmFsPVwiQTVBNUE1XCIvPjwvYTphY2NlbnQzPjxhOmFjY2VudDQ+PGE6c3JnYkNsciB2YWw9XCJGRkMwMDBcIi8+PC9hOmFjY2VudDQ+PGE6YWNjZW50NT48YTpzcmdiQ2xyIHZhbD1cIjVCOUJENVwiLz48L2E6YWNjZW50NT48YTphY2NlbnQ2PjxhOnNyZ2JDbHIgdmFsPVwiNzBBRDQ3XCIvPjwvYTphY2NlbnQ2PjxhOmhsaW5rPjxhOnNyZ2JDbHIgdmFsPVwiMDU2M0MxXCIvPjwvYTpobGluaz48YTpmb2xIbGluaz48YTpzcmdiQ2xyIHZhbD1cIjk1NEY3MlwiLz48L2E6Zm9sSGxpbms+PC9hOmNsclNjaGVtZT48YTpmb250U2NoZW1lIG5hbWU9XCJPZmZpY2VcIj48YTptYWpvckZvbnQ+JHttYWpvckZvbnR9PGE6ZWEgdHlwZWZhY2U9XCJcIi8+PGE6Y3MgdHlwZWZhY2U9XCJcIi8+PGE6Zm9udCBzY3JpcHQ9XCJKcGFuXCIgdHlwZWZhY2U9XCLmuLjjgrTjgrfjg4Pjgq8gTGlnaHRcIi8+PGE6Zm9udCBzY3JpcHQ9XCJIYW5nXCIgdHlwZWZhY2U9XCLrp5HsnYAg6rOg65SVXCIvPjxhOmZvbnQgc2NyaXB0PVwiSGFuc1wiIHR5cGVmYWNlPVwi562J57q/IExpZ2h0XCIvPjxhOmZvbnQgc2NyaXB0PVwiSGFudFwiIHR5cGVmYWNlPVwi5paw57Sw5piO6auUXCIvPjxhOmZvbnQgc2NyaXB0PVwiQXJhYlwiIHR5cGVmYWNlPVwiVGltZXMgTmV3IFJvbWFuXCIvPjxhOmZvbnQgc2NyaXB0PVwiSGViclwiIHR5cGVmYWNlPVwiVGltZXMgTmV3IFJvbWFuXCIvPjxhOmZvbnQgc2NyaXB0PVwiVGhhaVwiIHR5cGVmYWNlPVwiQW5nc2FuYSBOZXdcIi8+PGE6Zm9udCBzY3JpcHQ9XCJFdGhpXCIgdHlwZWZhY2U9XCJOeWFsYVwiLz48YTpmb250IHNjcmlwdD1cIkJlbmdcIiB0eXBlZmFjZT1cIlZyaW5kYVwiLz48YTpmb250IHNjcmlwdD1cIkd1anJcIiB0eXBlZmFjZT1cIlNocnV0aVwiLz48YTpmb250IHNjcmlwdD1cIktobXJcIiB0eXBlZmFjZT1cIk1vb2xCb3JhblwiLz48YTpmb250IHNjcmlwdD1cIktuZGFcIiB0eXBlZmFjZT1cIlR1bmdhXCIvPjxhOmZvbnQgc2NyaXB0PVwiR3VydVwiIHR5cGVmYWNlPVwiUmFhdmlcIi8+PGE6Zm9udCBzY3JpcHQ9XCJDYW5zXCIgdHlwZWZhY2U9XCJFdXBoZW1pYVwiLz48YTpmb250IHNjcmlwdD1cIkNoZXJcIiB0eXBlZmFjZT1cIlBsYW50YWdlbmV0IENoZXJva2VlXCIvPjxhOmZvbnQgc2NyaXB0PVwiWWlpaVwiIHR5cGVmYWNlPVwiTWljcm9zb2Z0IFlpIEJhaXRpXCIvPjxhOmZvbnQgc2NyaXB0PVwiVGlidFwiIHR5cGVmYWNlPVwiTWljcm9zb2Z0IEhpbWFsYXlhXCIvPjxhOmZvbnQgc2NyaXB0PVwiVGhhYVwiIHR5cGVmYWNlPVwiTVYgQm9saVwiLz48YTpmb250IHNjcmlwdD1cIkRldmFcIiB0eXBlZmFjZT1cIk1hbmdhbFwiLz48YTpmb250IHNjcmlwdD1cIlRlbHVcIiB0eXBlZmFjZT1cIkdhdXRhbWlcIi8+PGE6Zm9udCBzY3JpcHQ9XCJUYW1sXCIgdHlwZWZhY2U9XCJMYXRoYVwiLz48YTpmb250IHNjcmlwdD1cIlN5cmNcIiB0eXBlZmFjZT1cIkVzdHJhbmdlbG8gRWRlc3NhXCIvPjxhOmZvbnQgc2NyaXB0PVwiT3J5YVwiIHR5cGVmYWNlPVwiS2FsaW5nYVwiLz48YTpmb250IHNjcmlwdD1cIk1seW1cIiB0eXBlZmFjZT1cIkthcnRpa2FcIi8+PGE6Zm9udCBzY3JpcHQ9XCJMYW9vXCIgdHlwZWZhY2U9XCJEb2tDaGFtcGFcIi8+PGE6Zm9udCBzY3JpcHQ9XCJTaW5oXCIgdHlwZWZhY2U9XCJJc2tvb2xhIFBvdGFcIi8+PGE6Zm9udCBzY3JpcHQ9XCJNb25nXCIgdHlwZWZhY2U9XCJNb25nb2xpYW4gQmFpdGlcIi8+PGE6Zm9udCBzY3JpcHQ9XCJWaWV0XCIgdHlwZWZhY2U9XCJUaW1lcyBOZXcgUm9tYW5cIi8+PGE6Zm9udCBzY3JpcHQ9XCJVaWdoXCIgdHlwZWZhY2U9XCJNaWNyb3NvZnQgVWlnaHVyXCIvPjxhOmZvbnQgc2NyaXB0PVwiR2VvclwiIHR5cGVmYWNlPVwiU3lsZmFlblwiLz48YTpmb250IHNjcmlwdD1cIkFybW5cIiB0eXBlZmFjZT1cIkFyaWFsXCIvPjxhOmZvbnQgc2NyaXB0PVwiQnVnaVwiIHR5cGVmYWNlPVwiTGVlbGF3YWRlZSBVSVwiLz48YTpmb250IHNjcmlwdD1cIkJvcG9cIiB0eXBlZmFjZT1cIk1pY3Jvc29mdCBKaGVuZ0hlaVwiLz48YTpmb250IHNjcmlwdD1cIkphdmFcIiB0eXBlZmFjZT1cIkphdmFuZXNlIFRleHRcIi8+PGE6Zm9udCBzY3JpcHQ9XCJMaXN1XCIgdHlwZWZhY2U9XCJTZWdvZSBVSVwiLz48YTpmb250IHNjcmlwdD1cIk15bXJcIiB0eXBlZmFjZT1cIk15YW5tYXIgVGV4dFwiLz48YTpmb250IHNjcmlwdD1cIk5rb29cIiB0eXBlZmFjZT1cIkVicmltYVwiLz48YTpmb250IHNjcmlwdD1cIk9sY2tcIiB0eXBlZmFjZT1cIk5pcm1hbGEgVUlcIi8+PGE6Zm9udCBzY3JpcHQ9XCJPc21hXCIgdHlwZWZhY2U9XCJFYnJpbWFcIi8+PGE6Zm9udCBzY3JpcHQ9XCJQaGFnXCIgdHlwZWZhY2U9XCJQaGFnc3BhXCIvPjxhOmZvbnQgc2NyaXB0PVwiU3lyblwiIHR5cGVmYWNlPVwiRXN0cmFuZ2VsbyBFZGVzc2FcIi8+PGE6Zm9udCBzY3JpcHQ9XCJTeXJqXCIgdHlwZWZhY2U9XCJFc3RyYW5nZWxvIEVkZXNzYVwiLz48YTpmb250IHNjcmlwdD1cIlN5cmVcIiB0eXBlZmFjZT1cIkVzdHJhbmdlbG8gRWRlc3NhXCIvPjxhOmZvbnQgc2NyaXB0PVwiU29yYVwiIHR5cGVmYWNlPVwiTmlybWFsYSBVSVwiLz48YTpmb250IHNjcmlwdD1cIlRhbGVcIiB0eXBlZmFjZT1cIk1pY3Jvc29mdCBUYWkgTGVcIi8+PGE6Zm9udCBzY3JpcHQ9XCJUYWx1XCIgdHlwZWZhY2U9XCJNaWNyb3NvZnQgTmV3IFRhaSBMdWVcIi8+PGE6Zm9udCBzY3JpcHQ9XCJUZm5nXCIgdHlwZWZhY2U9XCJFYnJpbWFcIi8+PC9hOm1ham9yRm9udD48YTptaW5vckZvbnQ+JHttaW5vckZvbnR9PGE6ZWEgdHlwZWZhY2U9XCJcIi8+PGE6Y3MgdHlwZWZhY2U9XCJcIi8+PGE6Zm9udCBzY3JpcHQ9XCJKcGFuXCIgdHlwZWZhY2U9XCLmuLjjgrTjgrfjg4Pjgq9cIi8+PGE6Zm9udCBzY3JpcHQ9XCJIYW5nXCIgdHlwZWZhY2U9XCLrp5HsnYAg6rOg65SVXCIvPjxhOmZvbnQgc2NyaXB0PVwiSGFuc1wiIHR5cGVmYWNlPVwi562J57q/XCIvPjxhOmZvbnQgc2NyaXB0PVwiSGFudFwiIHR5cGVmYWNlPVwi5paw57Sw5piO6auUXCIvPjxhOmZvbnQgc2NyaXB0PVwiQXJhYlwiIHR5cGVmYWNlPVwiQXJpYWxcIi8+PGE6Zm9udCBzY3JpcHQ9XCJIZWJyXCIgdHlwZWZhY2U9XCJBcmlhbFwiLz48YTpmb250IHNjcmlwdD1cIlRoYWlcIiB0eXBlZmFjZT1cIkNvcmRpYSBOZXdcIi8+PGE6Zm9udCBzY3JpcHQ9XCJFdGhpXCIgdHlwZWZhY2U9XCJOeWFsYVwiLz48YTpmb250IHNjcmlwdD1cIkJlbmdcIiB0eXBlZmFjZT1cIlZyaW5kYVwiLz48YTpmb250IHNjcmlwdD1cIkd1anJcIiB0eXBlZmFjZT1cIlNocnV0aVwiLz48YTpmb250IHNjcmlwdD1cIktobXJcIiB0eXBlZmFjZT1cIkRhdW5QZW5oXCIvPjxhOmZvbnQgc2NyaXB0PVwiS25kYVwiIHR5cGVmYWNlPVwiVHVuZ2FcIi8+PGE6Zm9udCBzY3JpcHQ9XCJHdXJ1XCIgdHlwZWZhY2U9XCJSYWF2aVwiLz48YTpmb250IHNjcmlwdD1cIkNhbnNcIiB0eXBlZmFjZT1cIkV1cGhlbWlhXCIvPjxhOmZvbnQgc2NyaXB0PVwiQ2hlclwiIHR5cGVmYWNlPVwiUGxhbnRhZ2VuZXQgQ2hlcm9rZWVcIi8+PGE6Zm9udCBzY3JpcHQ9XCJZaWlpXCIgdHlwZWZhY2U9XCJNaWNyb3NvZnQgWWkgQmFpdGlcIi8+PGE6Zm9udCBzY3JpcHQ9XCJUaWJ0XCIgdHlwZWZhY2U9XCJNaWNyb3NvZnQgSGltYWxheWFcIi8+PGE6Zm9udCBzY3JpcHQ9XCJUaGFhXCIgdHlwZWZhY2U9XCJNViBCb2xpXCIvPjxhOmZvbnQgc2NyaXB0PVwiRGV2YVwiIHR5cGVmYWNlPVwiTWFuZ2FsXCIvPjxhOmZvbnQgc2NyaXB0PVwiVGVsdVwiIHR5cGVmYWNlPVwiR2F1dGFtaVwiLz48YTpmb250IHNjcmlwdD1cIlRhbWxcIiB0eXBlZmFjZT1cIkxhdGhhXCIvPjxhOmZvbnQgc2NyaXB0PVwiU3lyY1wiIHR5cGVmYWNlPVwiRXN0cmFuZ2VsbyBFZGVzc2FcIi8+PGE6Zm9udCBzY3JpcHQ9XCJPcnlhXCIgdHlwZWZhY2U9XCJLYWxpbmdhXCIvPjxhOmZvbnQgc2NyaXB0PVwiTWx5bVwiIHR5cGVmYWNlPVwiS2FydGlrYVwiLz48YTpmb250IHNjcmlwdD1cIkxhb29cIiB0eXBlZmFjZT1cIkRva0NoYW1wYVwiLz48YTpmb250IHNjcmlwdD1cIlNpbmhcIiB0eXBlZmFjZT1cIklza29vbGEgUG90YVwiLz48YTpmb250IHNjcmlwdD1cIk1vbmdcIiB0eXBlZmFjZT1cIk1vbmdvbGlhbiBCYWl0aVwiLz48YTpmb250IHNjcmlwdD1cIlZpZXRcIiB0eXBlZmFjZT1cIkFyaWFsXCIvPjxhOmZvbnQgc2NyaXB0PVwiVWlnaFwiIHR5cGVmYWNlPVwiTWljcm9zb2Z0IFVpZ2h1clwiLz48YTpmb250IHNjcmlwdD1cIkdlb3JcIiB0eXBlZmFjZT1cIlN5bGZhZW5cIi8+PGE6Zm9udCBzY3JpcHQ9XCJBcm1uXCIgdHlwZWZhY2U9XCJBcmlhbFwiLz48YTpmb250IHNjcmlwdD1cIkJ1Z2lcIiB0eXBlZmFjZT1cIkxlZWxhd2FkZWUgVUlcIi8+PGE6Zm9udCBzY3JpcHQ9XCJCb3BvXCIgdHlwZWZhY2U9XCJNaWNyb3NvZnQgSmhlbmdIZWlcIi8+PGE6Zm9udCBzY3JpcHQ9XCJKYXZhXCIgdHlwZWZhY2U9XCJKYXZhbmVzZSBUZXh0XCIvPjxhOmZvbnQgc2NyaXB0PVwiTGlzdVwiIHR5cGVmYWNlPVwiU2Vnb2UgVUlcIi8+PGE6Zm9udCBzY3JpcHQ9XCJNeW1yXCIgdHlwZWZhY2U9XCJNeWFubWFyIFRleHRcIi8+PGE6Zm9udCBzY3JpcHQ9XCJOa29vXCIgdHlwZWZhY2U9XCJFYnJpbWFcIi8+PGE6Zm9udCBzY3JpcHQ9XCJPbGNrXCIgdHlwZWZhY2U9XCJOaXJtYWxhIFVJXCIvPjxhOmZvbnQgc2NyaXB0PVwiT3NtYVwiIHR5cGVmYWNlPVwiRWJyaW1hXCIvPjxhOmZvbnQgc2NyaXB0PVwiUGhhZ1wiIHR5cGVmYWNlPVwiUGhhZ3NwYVwiLz48YTpmb250IHNjcmlwdD1cIlN5cm5cIiB0eXBlZmFjZT1cIkVzdHJhbmdlbG8gRWRlc3NhXCIvPjxhOmZvbnQgc2NyaXB0PVwiU3lyalwiIHR5cGVmYWNlPVwiRXN0cmFuZ2VsbyBFZGVzc2FcIi8+PGE6Zm9udCBzY3JpcHQ9XCJTeXJlXCIgdHlwZWZhY2U9XCJFc3RyYW5nZWxvIEVkZXNzYVwiLz48YTpmb250IHNjcmlwdD1cIlNvcmFcIiB0eXBlZmFjZT1cIk5pcm1hbGEgVUlcIi8+PGE6Zm9udCBzY3JpcHQ9XCJUYWxlXCIgdHlwZWZhY2U9XCJNaWNyb3NvZnQgVGFpIExlXCIvPjxhOmZvbnQgc2NyaXB0PVwiVGFsdVwiIHR5cGVmYWNlPVwiTWljcm9zb2Z0IE5ldyBUYWkgTHVlXCIvPjxhOmZvbnQgc2NyaXB0PVwiVGZuZ1wiIHR5cGVmYWNlPVwiRWJyaW1hXCIvPjwvYTptaW5vckZvbnQ+PC9hOmZvbnRTY2hlbWU+PGE6Zm10U2NoZW1lIG5hbWU9XCJPZmZpY2VcIj48YTpmaWxsU3R5bGVMc3Q+PGE6c29saWRGaWxsPjxhOnNjaGVtZUNsciB2YWw9XCJwaENsclwiLz48L2E6c29saWRGaWxsPjxhOmdyYWRGaWxsIHJvdFdpdGhTaGFwZT1cIjFcIj48YTpnc0xzdD48YTpncyBwb3M9XCIwXCI+PGE6c2NoZW1lQ2xyIHZhbD1cInBoQ2xyXCI+PGE6bHVtTW9kIHZhbD1cIjExMDAwMFwiLz48YTpzYXRNb2QgdmFsPVwiMTA1MDAwXCIvPjxhOnRpbnQgdmFsPVwiNjcwMDBcIi8+PC9hOnNjaGVtZUNscj48L2E6Z3M+PGE6Z3MgcG9zPVwiNTAwMDBcIj48YTpzY2hlbWVDbHIgdmFsPVwicGhDbHJcIj48YTpsdW1Nb2QgdmFsPVwiMTA1MDAwXCIvPjxhOnNhdE1vZCB2YWw9XCIxMDMwMDBcIi8+PGE6dGludCB2YWw9XCI3MzAwMFwiLz48L2E6c2NoZW1lQ2xyPjwvYTpncz48YTpncyBwb3M9XCIxMDAwMDBcIj48YTpzY2hlbWVDbHIgdmFsPVwicGhDbHJcIj48YTpsdW1Nb2QgdmFsPVwiMTA1MDAwXCIvPjxhOnNhdE1vZCB2YWw9XCIxMDkwMDBcIi8+PGE6dGludCB2YWw9XCI4MTAwMFwiLz48L2E6c2NoZW1lQ2xyPjwvYTpncz48L2E6Z3NMc3Q+PGE6bGluIGFuZz1cIjU0MDAwMDBcIiBzY2FsZWQ9XCIwXCIvPjwvYTpncmFkRmlsbD48YTpncmFkRmlsbCByb3RXaXRoU2hhcGU9XCIxXCI+PGE6Z3NMc3Q+PGE6Z3MgcG9zPVwiMFwiPjxhOnNjaGVtZUNsciB2YWw9XCJwaENsclwiPjxhOnNhdE1vZCB2YWw9XCIxMDMwMDBcIi8+PGE6bHVtTW9kIHZhbD1cIjEwMjAwMFwiLz48YTp0aW50IHZhbD1cIjk0MDAwXCIvPjwvYTpzY2hlbWVDbHI+PC9hOmdzPjxhOmdzIHBvcz1cIjUwMDAwXCI+PGE6c2NoZW1lQ2xyIHZhbD1cInBoQ2xyXCI+PGE6c2F0TW9kIHZhbD1cIjExMDAwMFwiLz48YTpsdW1Nb2QgdmFsPVwiMTAwMDAwXCIvPjxhOnNoYWRlIHZhbD1cIjEwMDAwMFwiLz48L2E6c2NoZW1lQ2xyPjwvYTpncz48YTpncyBwb3M9XCIxMDAwMDBcIj48YTpzY2hlbWVDbHIgdmFsPVwicGhDbHJcIj48YTpsdW1Nb2QgdmFsPVwiOTkwMDBcIi8+PGE6c2F0TW9kIHZhbD1cIjEyMDAwMFwiLz48YTpzaGFkZSB2YWw9XCI3ODAwMFwiLz48L2E6c2NoZW1lQ2xyPjwvYTpncz48L2E6Z3NMc3Q+PGE6bGluIGFuZz1cIjU0MDAwMDBcIiBzY2FsZWQ9XCIwXCIvPjwvYTpncmFkRmlsbD48L2E6ZmlsbFN0eWxlTHN0PjxhOmxuU3R5bGVMc3Q+PGE6bG4gdz1cIjYzNTBcIiBjYXA9XCJmbGF0XCIgY21wZD1cInNuZ1wiIGFsZ249XCJjdHJcIj48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD1cInBoQ2xyXCIvPjwvYTpzb2xpZEZpbGw+PGE6cHJzdERhc2ggdmFsPVwic29saWRcIi8+PGE6bWl0ZXIgbGltPVwiODAwMDAwXCIvPjwvYTpsbj48YTpsbiB3PVwiMTI3MDBcIiBjYXA9XCJmbGF0XCIgY21wZD1cInNuZ1wiIGFsZ249XCJjdHJcIj48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD1cInBoQ2xyXCIvPjwvYTpzb2xpZEZpbGw+PGE6cHJzdERhc2ggdmFsPVwic29saWRcIi8+PGE6bWl0ZXIgbGltPVwiODAwMDAwXCIvPjwvYTpsbj48YTpsbiB3PVwiMTkwNTBcIiBjYXA9XCJmbGF0XCIgY21wZD1cInNuZ1wiIGFsZ249XCJjdHJcIj48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD1cInBoQ2xyXCIvPjwvYTpzb2xpZEZpbGw+PGE6cHJzdERhc2ggdmFsPVwic29saWRcIi8+PGE6bWl0ZXIgbGltPVwiODAwMDAwXCIvPjwvYTpsbj48L2E6bG5TdHlsZUxzdD48YTplZmZlY3RTdHlsZUxzdD48YTplZmZlY3RTdHlsZT48YTplZmZlY3RMc3QvPjwvYTplZmZlY3RTdHlsZT48YTplZmZlY3RTdHlsZT48YTplZmZlY3RMc3QvPjwvYTplZmZlY3RTdHlsZT48YTplZmZlY3RTdHlsZT48YTplZmZlY3RMc3Q+PGE6b3V0ZXJTaGR3IGJsdXJSYWQ9XCI1NzE1MFwiIGRpc3Q9XCIxOTA1MFwiIGRpcj1cIjU0MDAwMDBcIiBhbGduPVwiY3RyXCIgcm90V2l0aFNoYXBlPVwiMFwiPjxhOnNyZ2JDbHIgdmFsPVwiMDAwMDAwXCI+PGE6YWxwaGEgdmFsPVwiNjMwMDBcIi8+PC9hOnNyZ2JDbHI+PC9hOm91dGVyU2hkdz48L2E6ZWZmZWN0THN0PjwvYTplZmZlY3RTdHlsZT48L2E6ZWZmZWN0U3R5bGVMc3Q+PGE6YmdGaWxsU3R5bGVMc3Q+PGE6c29saWRGaWxsPjxhOnNjaGVtZUNsciB2YWw9XCJwaENsclwiLz48L2E6c29saWRGaWxsPjxhOnNvbGlkRmlsbD48YTpzY2hlbWVDbHIgdmFsPVwicGhDbHJcIj48YTp0aW50IHZhbD1cIjk1MDAwXCIvPjxhOnNhdE1vZCB2YWw9XCIxNzAwMDBcIi8+PC9hOnNjaGVtZUNscj48L2E6c29saWRGaWxsPjxhOmdyYWRGaWxsIHJvdFdpdGhTaGFwZT1cIjFcIj48YTpnc0xzdD48YTpncyBwb3M9XCIwXCI+PGE6c2NoZW1lQ2xyIHZhbD1cInBoQ2xyXCI+PGE6dGludCB2YWw9XCI5MzAwMFwiLz48YTpzYXRNb2QgdmFsPVwiMTUwMDAwXCIvPjxhOnNoYWRlIHZhbD1cIjk4MDAwXCIvPjxhOmx1bU1vZCB2YWw9XCIxMDIwMDBcIi8+PC9hOnNjaGVtZUNscj48L2E6Z3M+PGE6Z3MgcG9zPVwiNTAwMDBcIj48YTpzY2hlbWVDbHIgdmFsPVwicGhDbHJcIj48YTp0aW50IHZhbD1cIjk4MDAwXCIvPjxhOnNhdE1vZCB2YWw9XCIxMzAwMDBcIi8+PGE6c2hhZGUgdmFsPVwiOTAwMDBcIi8+PGE6bHVtTW9kIHZhbD1cIjEwMzAwMFwiLz48L2E6c2NoZW1lQ2xyPjwvYTpncz48YTpncyBwb3M9XCIxMDAwMDBcIj48YTpzY2hlbWVDbHIgdmFsPVwicGhDbHJcIj48YTpzaGFkZSB2YWw9XCI2MzAwMFwiLz48YTpzYXRNb2QgdmFsPVwiMTIwMDAwXCIvPjwvYTpzY2hlbWVDbHI+PC9hOmdzPjwvYTpnc0xzdD48YTpsaW4gYW5nPVwiNTQwMDAwMFwiIHNjYWxlZD1cIjBcIi8+PC9hOmdyYWRGaWxsPjwvYTpiZ0ZpbGxTdHlsZUxzdD48L2E6Zm10U2NoZW1lPjwvYTp0aGVtZUVsZW1lbnRzPjxhOm9iamVjdERlZmF1bHRzLz48YTpleHRyYUNsclNjaGVtZUxzdC8+PGE6ZXh0THN0PjxhOmV4dCB1cmk9XCJ7MDVBNEMyNUMtMDg1RS00MzQwLTg1QTMtQTU1MzFFNTEwREIyfVwiPjx0aG0xNTp0aGVtZUZhbWlseSB4bWxuczp0aG0xNT1cImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3RoZW1lbWwvMjAxMi9tYWluXCIgbmFtZT1cIk9mZmljZSBUaGVtZVwiIGlkPVwiezYyRjkzOUI2LTkzQUYtNERCOC05QzZCLUQ2QzdERkRDNTg5Rn1cIiB2aWQ9XCJ7NEEzQzQ2RTgtNjFDQy00NjAzLUE1ODktNzQyMkE0N0E4RTRBfVwiLz48L2E6ZXh0PjwvYTpleHRMc3Q+PC9hOnRoZW1lPmA7XG59XG4vKipcbiAqIENyZWF0ZSBwcmVzZW50YXRpb24gZmlsZSAoYHBwdC9wcmVzZW50YXRpb24ueG1sYClcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvb2ZmaWNlL29wZW4teG1sL3N0cnVjdHVyZS1vZi1hLXByZXNlbnRhdGlvbm1sLWRvY3VtZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cuZGF0eXBpYy5jb20vc2Mvb294bWwvdC1wX0NUX1ByZXNlbnRhdGlvbi5odG1sXG4gKiBAcGFyYW0ge0lQcmVzZW50YXRpb25Qcm9wc30gcHJlcyAtIHByZXNlbnRhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBYTUxcbiAqL1xuZnVuY3Rpb24gbWFrZVhtbFByZXNlbnRhdGlvbihwcmVzKSB7XG4gICAgbGV0IHN0clhtbCA9IGA8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiIHN0YW5kYWxvbmU9XCJ5ZXNcIj8+JHtDUkxGfWAgK1xuICAgICAgICAnPHA6cHJlc2VudGF0aW9uIHhtbG5zOmE9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvZHJhd2luZ21sLzIwMDYvbWFpblwiIHhtbG5zOnI9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzXCIgJyArXG4gICAgICAgIGB4bWxuczpwPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3ByZXNlbnRhdGlvbm1sLzIwMDYvbWFpblwiICR7cHJlcy5ydGxNb2RlID8gJ3J0bD1cIjFcIicgOiAnJ30gc2F2ZVN1YnNldEZvbnRzPVwiMVwiIGF1dG9Db21wcmVzc1BpY3R1cmVzPVwiMFwiPmA7XG4gICAgLy8gU1RFUCAxOiBBZGQgc2xpZGUgbWFzdGVyIChTUEVDOiB0YWcgMSB1bmRlciA8cHJlc2VudGF0aW9uPilcbiAgICBzdHJYbWwgKz0gJzxwOnNsZE1hc3RlcklkTHN0PjxwOnNsZE1hc3RlcklkIGlkPVwiMjE0NzQ4MzY0OFwiIHI6aWQ9XCJySWQxXCIvPjwvcDpzbGRNYXN0ZXJJZExzdD4nO1xuICAgIC8vIFNURVAgMjogQWRkIGFsbCBTbGlkZXMgKFNQRUM6IHRhZyAzIHVuZGVyIDxwcmVzZW50YXRpb24+KVxuICAgIHN0clhtbCArPSAnPHA6c2xkSWRMc3Q+JztcbiAgICBwcmVzLnNsaWRlcy5mb3JFYWNoKHNsaWRlID0+IChzdHJYbWwgKz0gYDxwOnNsZElkIGlkPVwiJHtzbGlkZS5fc2xpZGVJZH1cIiByOmlkPVwicklkJHtzbGlkZS5fcklkfVwiLz5gKSk7XG4gICAgc3RyWG1sICs9ICc8L3A6c2xkSWRMc3Q+JztcbiAgICAvLyBTVEVQIDM6IEFkZCBOb3RlcyBNYXN0ZXIgKFNQRUM6IHRhZyAyIHVuZGVyIDxwcmVzZW50YXRpb24+KVxuICAgIC8vIChOT1RFOiBsZW5ndGgrMiBpcyBmcm9tIGBwcmVzZW50YXRpb24ueG1sLnJlbHNgIGZ1bmMgKHNpbmNlIHdlIGhhdmUgdG8gbWF0Y2ggdGhpcyBySWQsIHdlIGp1c3QgdXNlIHNhbWUgbG9naWMpKVxuICAgIC8vIElNUE9SVEFOVDogSW4gdGhpcyBvcmRlciAobWF0Y2hlcyBQUFQyMDE5KSBQUFQgd2lsbCBnaXZlIGNvcnJ1cHRpb24gbWVzc2FnZSBvbiBvcGVuIVxuICAgIC8vIElNUE9SVEFOVDogUGxhY2luZyB0aGlzIGJlZm9yZSBgPHA6c2xkSWRMc3Q+YCBjYXVzZXMgd2FybmluZyBpbiBtb2Rlcm4gcG93ZXJwb2ludCFcbiAgICAvLyBJTVBPUlRBTlQ6IFByZXNlbnRhdGlvbnMgb3BlbiB3aXRob3V0IHdhcm5pbmcgV2l0aG91dCB0aGlzIGxpbmUsIGhvd2V2ZXIsIHRoZSBwcmVzIGlzbnQgcHJldmlldyBpbiBGaW5kZXIgYW55bW9yZSBvciB2aWV3YWJsZSBpbiBpT1MhXG4gICAgc3RyWG1sICs9IGA8cDpub3Rlc01hc3RlcklkTHN0PjxwOm5vdGVzTWFzdGVySWQgcjppZD1cInJJZCR7cHJlcy5zbGlkZXMubGVuZ3RoICsgMn1cIi8+PC9wOm5vdGVzTWFzdGVySWRMc3Q+YDtcbiAgICAvLyBTVEVQIDQ6IEFkZCBzaXplc1xuICAgIHN0clhtbCArPSBgPHA6c2xkU3ogY3g9XCIke3ByZXMucHJlc0xheW91dC53aWR0aH1cIiBjeT1cIiR7cHJlcy5wcmVzTGF5b3V0LmhlaWdodH1cIi8+YDtcbiAgICBzdHJYbWwgKz0gYDxwOm5vdGVzU3ogY3g9XCIke3ByZXMucHJlc0xheW91dC5oZWlnaHR9XCIgY3k9XCIke3ByZXMucHJlc0xheW91dC53aWR0aH1cIi8+YDtcbiAgICAvLyBTVEVQIDU6IEFkZCB0ZXh0IHN0eWxlc1xuICAgIHN0clhtbCArPSAnPHA6ZGVmYXVsdFRleHRTdHlsZT4nO1xuICAgIGZvciAobGV0IGlkeSA9IDE7IGlkeSA8IDEwOyBpZHkrKykge1xuICAgICAgICBzdHJYbWwgKz1cbiAgICAgICAgICAgIGA8YTpsdmwke2lkeX1wUHIgbWFyTD1cIiR7KGlkeSAtIDEpICogNDU3MjAwfVwiIGFsZ249XCJsXCIgZGVmVGFiU3o9XCI5MTQ0MDBcIiBydGw9XCIwXCIgZWFMbkJyaz1cIjFcIiBsYXRpbkxuQnJrPVwiMFwiIGhhbmdpbmdQdW5jdD1cIjFcIj5gICtcbiAgICAgICAgICAgICAgICAnPGE6ZGVmUlByIHN6PVwiMTgwMFwiIGtlcm49XCIxMjAwXCI+PGE6c29saWRGaWxsPjxhOnNjaGVtZUNsciB2YWw9XCJ0eDFcIi8+PC9hOnNvbGlkRmlsbD48YTpsYXRpbiB0eXBlZmFjZT1cIittbi1sdFwiLz48YTplYSB0eXBlZmFjZT1cIittbi1lYVwiLz48YTpjcyB0eXBlZmFjZT1cIittbi1jc1wiLz4nICtcbiAgICAgICAgICAgICAgICBgPC9hOmRlZlJQcj48L2E6bHZsJHtpZHl9cFByPmA7XG4gICAgfVxuICAgIHN0clhtbCArPSAnPC9wOmRlZmF1bHRUZXh0U3R5bGU+JztcbiAgICAvLyBTVEVQIDY6IEFkZCBTZWN0aW9ucyAoaWYgYW55KVxuICAgIGlmIChwcmVzLnNlY3Rpb25zICYmIHByZXMuc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBzdHJYbWwgKz0gJzxwOmV4dExzdD48cDpleHQgdXJpPVwiezUyMTQxNUQ5LTM2RjctNDNFMi1BQjJGLUI5MEFGMjZCNUU4NH1cIj4nO1xuICAgICAgICBzdHJYbWwgKz0gJzxwMTQ6c2VjdGlvbkxzdCB4bWxuczpwMTQ9XCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9wb3dlcnBvaW50LzIwMTAvbWFpblwiPic7XG4gICAgICAgIHByZXMuc2VjdGlvbnMuZm9yRWFjaChzZWN0ID0+IHtcbiAgICAgICAgICAgIHN0clhtbCArPSBgPHAxNDpzZWN0aW9uIG5hbWU9XCIke2VuY29kZVhtbEVudGl0aWVzKHNlY3QudGl0bGUpfVwiIGlkPVwieyR7Z2V0VXVpZCgneHh4eHh4eHgteHh4eC14eHh4LXh4eHgteHh4eHh4eHh4eHh4Jyl9fVwiPjxwMTQ6c2xkSWRMc3Q+YDtcbiAgICAgICAgICAgIHNlY3QuX3NsaWRlcy5mb3JFYWNoKHNsaWRlID0+IChzdHJYbWwgKz0gYDxwMTQ6c2xkSWQgaWQ9XCIke3NsaWRlLl9zbGlkZUlkfVwiLz5gKSk7XG4gICAgICAgICAgICBzdHJYbWwgKz0gJzwvcDE0OnNsZElkTHN0PjwvcDE0OnNlY3Rpb24+JztcbiAgICAgICAgfSk7XG4gICAgICAgIHN0clhtbCArPSAnPC9wMTQ6c2VjdGlvbkxzdD48L3A6ZXh0Pic7XG4gICAgICAgIHN0clhtbCArPSAnPHA6ZXh0IHVyaT1cIntFRkFGQjIzMy0wNjNGLTQyQjUtODEzNy05REYzRjUxQkExMEF9XCI+PHAxNTpzbGRHdWlkZUxzdCB4bWxuczpwMTU9XCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9wb3dlcnBvaW50LzIwMTIvbWFpblwiLz48L3A6ZXh0Pic7XG4gICAgICAgIHN0clhtbCArPSAnPC9wOmV4dExzdD4nO1xuICAgIH1cbiAgICAvLyBEb25lXG4gICAgc3RyWG1sICs9ICc8L3A6cHJlc2VudGF0aW9uPic7XG4gICAgcmV0dXJuIHN0clhtbDtcbn1cbi8qKlxuICogQ3JlYXRlIGBwcHQvcHJlc1Byb3BzLnhtbGBcbiAqIEByZXR1cm4ge3N0cmluZ30gWE1MXG4gKi9cbmZ1bmN0aW9uIG1ha2VYbWxQcmVzUHJvcHMoKSB7XG4gICAgcmV0dXJuIGA8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiIHN0YW5kYWxvbmU9XCJ5ZXNcIj8+JHtDUkxGfTxwOnByZXNlbnRhdGlvblByIHhtbG5zOmE9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvZHJhd2luZ21sLzIwMDYvbWFpblwiIHhtbG5zOnI9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzXCIgeG1sbnM6cD1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9wcmVzZW50YXRpb25tbC8yMDA2L21haW5cIi8+YDtcbn1cbi8qKlxuICogQ3JlYXRlIGBwcHQvdGFibGVTdHlsZXMueG1sYFxuICogQHNlZTogaHR0cDovL29wZW54bWxkZXZlbG9wZXIub3JnL2Rpc2N1c3Npb25zL2Zvcm1hdHMvZi8xMy9wLzIzOTgvODEwNy5hc3B4XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFhNTFxuICovXG5mdW5jdGlvbiBtYWtlWG1sVGFibGVTdHlsZXMoKSB7XG4gICAgcmV0dXJuIGA8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiIHN0YW5kYWxvbmU9XCJ5ZXNcIj8+JHtDUkxGfTxhOnRibFN0eWxlTHN0IHhtbG5zOmE9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvZHJhd2luZ21sLzIwMDYvbWFpblwiIGRlZj1cIns1QzIyNTQ0QS03RUU2LTQzNDItQjA0OC04NUJEQzlGRDFDM0F9XCIvPmA7XG59XG4vKipcbiAqIENyZWF0ZXMgYHBwdC92aWV3UHJvcHMueG1sYFxuICogQHJldHVybiB7c3RyaW5nfSBYTUxcbiAqL1xuZnVuY3Rpb24gbWFrZVhtbFZpZXdQcm9wcygpIHtcbiAgICByZXR1cm4gYDw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCIgc3RhbmRhbG9uZT1cInllc1wiPz4ke0NSTEZ9PHA6dmlld1ByIHhtbG5zOmE9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvZHJhd2luZ21sLzIwMDYvbWFpblwiIHhtbG5zOnI9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzXCIgeG1sbnM6cD1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9wcmVzZW50YXRpb25tbC8yMDA2L21haW5cIj48cDpub3JtYWxWaWV3UHIgaG9yekJhclN0YXRlPVwibWF4aW1pemVkXCI+PHA6cmVzdG9yZWRMZWZ0IHN6PVwiMTU2MTFcIi8+PHA6cmVzdG9yZWRUb3Agc3o9XCI5NDYxMFwiLz48L3A6bm9ybWFsVmlld1ByPjxwOnNsaWRlVmlld1ByPjxwOmNTbGRWaWV3UHIgc25hcFRvR3JpZD1cIjBcIiBzbmFwVG9PYmplY3RzPVwiMVwiPjxwOmNWaWV3UHIgdmFyU2NhbGU9XCIxXCI+PHA6c2NhbGU+PGE6c3ggbj1cIjEzNlwiIGQ9XCIxMDBcIi8+PGE6c3kgbj1cIjEzNlwiIGQ9XCIxMDBcIi8+PC9wOnNjYWxlPjxwOm9yaWdpbiB4PVwiMjE2XCIgeT1cIjMxMlwiLz48L3A6Y1ZpZXdQcj48cDpndWlkZUxzdC8+PC9wOmNTbGRWaWV3UHI+PC9wOnNsaWRlVmlld1ByPjxwOm5vdGVzVGV4dFZpZXdQcj48cDpjVmlld1ByPjxwOnNjYWxlPjxhOnN4IG49XCIxXCIgZD1cIjFcIi8+PGE6c3kgbj1cIjFcIiBkPVwiMVwiLz48L3A6c2NhbGU+PHA6b3JpZ2luIHg9XCIwXCIgeT1cIjBcIi8+PC9wOmNWaWV3UHI+PC9wOm5vdGVzVGV4dFZpZXdQcj48cDpncmlkU3BhY2luZyBjeD1cIjc2MjAwXCIgY3k9XCI3NjIwMFwiLz48L3A6dmlld1ByPmA7XG59XG5cbi8qKlxuICogIDo6IHBwdHhnZW4udHMgOjpcbiAqXG4gKiAgSmF2YVNjcmlwdCBmcmFtZXdvcmsgdGhhdCBjcmVhdGVzIFBvd2VyUG9pbnQgKHBwdHgpIHByZXNlbnRhdGlvbnNcbiAqICBodHRwczovL2dpdGh1Yi5jb20vZ2l0YnJlbnQvUHB0eEdlbkpTXG4gKlxuICogIFRoaXMgZnJhbWV3b3JrIGlzIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgUHVibGljIExpY2Vuc2UgKE1JVClcbiAqXG4gKiAgUHB0eEdlbkpTIChDKSAyMDE1LXByZXNlbnQgQnJlbnQgRWx5IC0tIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRicmVudFxuICpcbiAqICBTb21lIGNvZGUgZGVyaXZlZCBmcm9tIHRoZSBPZmZpY2VHZW4gcHJvamVjdDpcbiAqICBnaXRodWIuY29tL1ppdi1CYXJiZXIvb2ZmaWNlZ2VuLyAoQ29weXJpZ2h0IDIwMTMgWml2IEJhcmJlcilcbiAqXG4gKiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqICBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiAgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqICBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqICBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqICBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiAgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqICBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogIFNPRlRXQVJFLlxuICovXG5jb25zdCBWRVJTSU9OID0gJzQuMC4xJztcbmNsYXNzIFBwdHhHZW5KUyB7XG4gICAgc2V0IGxheW91dCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBuZXdMYXlvdXQgPSB0aGlzLkxBWU9VVFNbdmFsdWVdO1xuICAgICAgICBpZiAobmV3TGF5b3V0KSB7XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXNMYXlvdXQgPSBuZXdMYXlvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VOS05PV04tTEFZT1VUJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGxheW91dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheW91dDtcbiAgICB9XG4gICAgZ2V0IHZlcnNpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92ZXJzaW9uO1xuICAgIH1cbiAgICBzZXQgYXV0aG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2F1dGhvciA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgYXV0aG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXV0aG9yO1xuICAgIH1cbiAgICBzZXQgY29tcGFueSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jb21wYW55ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBjb21wYW55KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcGFueTtcbiAgICB9XG4gICAgc2V0IHJldmlzaW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3JldmlzaW9uID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCByZXZpc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldmlzaW9uO1xuICAgIH1cbiAgICBzZXQgc3ViamVjdCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zdWJqZWN0ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBzdWJqZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3ViamVjdDtcbiAgICB9XG4gICAgc2V0IHRoZW1lKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3RoZW1lID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCB0aGVtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RoZW1lO1xuICAgIH1cbiAgICBzZXQgdGl0bGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdGl0bGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHRpdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGl0bGU7XG4gICAgfVxuICAgIHNldCBydGxNb2RlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3J0bE1vZGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHJ0bE1vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ydGxNb2RlO1xuICAgIH1cbiAgICBnZXQgbWFzdGVyU2xpZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXN0ZXJTbGlkZTtcbiAgICB9XG4gICAgZ2V0IHNsaWRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NsaWRlcztcbiAgICB9XG4gICAgZ2V0IHNlY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VjdGlvbnM7XG4gICAgfVxuICAgIGdldCBzbGlkZUxheW91dHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zbGlkZUxheW91dHM7XG4gICAgfVxuICAgIGdldCBBbGlnbkgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbGlnbkg7XG4gICAgfVxuICAgIGdldCBBbGlnblYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbGlnblY7XG4gICAgfVxuICAgIGdldCBDaGFydFR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFydFR5cGU7XG4gICAgfVxuICAgIGdldCBPdXRwdXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3V0cHV0VHlwZTtcbiAgICB9XG4gICAgZ2V0IHByZXNMYXlvdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcmVzTGF5b3V0O1xuICAgIH1cbiAgICBnZXQgU2NoZW1lQ29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2hlbWVDb2xvcjtcbiAgICB9XG4gICAgZ2V0IFNoYXBlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NoYXBlVHlwZTtcbiAgICB9XG4gICAgZ2V0IGNoYXJ0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYXJ0cztcbiAgICB9XG4gICAgZ2V0IGNvbG9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9ycztcbiAgICB9XG4gICAgZ2V0IHNoYXBlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NoYXBlcztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcHR4R2VuSlMgTGlicmFyeSBWZXJzaW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gVkVSU0lPTjtcbiAgICAgICAgLy8gRXhwb3NlZCBjbGFzcyBwcm9wc1xuICAgICAgICB0aGlzLl9hbGlnbkggPSBBbGlnbkg7XG4gICAgICAgIHRoaXMuX2FsaWduViA9IEFsaWduVjtcbiAgICAgICAgdGhpcy5fY2hhcnRUeXBlID0gQ2hhcnRUeXBlO1xuICAgICAgICB0aGlzLl9vdXRwdXRUeXBlID0gT3V0cHV0VHlwZTtcbiAgICAgICAgdGhpcy5fc2NoZW1lQ29sb3IgPSBTY2hlbWVDb2xvcjtcbiAgICAgICAgdGhpcy5fc2hhcGVUeXBlID0gU2hhcGVUeXBlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJpY2F0ZWQgdXNlIGBDaGFydFR5cGVgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jaGFydHMgPSBDSEFSVF9UWVBFO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJpY2F0ZWQgdXNlIGBTY2hlbWVDb2xvcmBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NvbG9ycyA9IFNDSEVNRV9DT0xPUl9OQU1FUztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByaWNhdGVkIHVzZSBgU2hhcGVUeXBlYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2hhcGVzID0gU0hBUEVfVFlQRTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3ZpZGVzIGFuIEFQSSBmb3IgYGFkZFRhYmxlRGVmaW5pdGlvbmAgdG8gY3JlYXRlIHNsaWRlcyBhcyBuZWVkZWQgZm9yIGF1dG8tcGFnaW5nXG4gICAgICAgICAqIEBwYXJhbSB7QWRkU2xpZGVQcm9wc30gb3B0aW9ucyAtIHNsaWRlIG1hc3Rlck5hbWUgYW5kL29yIHNlY3Rpb25UaXRsZVxuICAgICAgICAgKiBAcmV0dXJuIHtQcmVzU2xpZGV9IG5ldyBTbGlkZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hZGROZXdTbGlkZSA9IChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAvLyBDb250aW51ZSB1c2luZyBzZWN0aW9ucyBpZiB0aGUgZmlyc3Qgc2xpZGUgdXNpbmcgYXV0by1wYWdpbmcgaGFzIGEgU2VjdGlvblxuICAgICAgICAgICAgY29uc3Qgc2VjdEFscmVhZHlJblVzZSA9IHRoaXMuc2VjdGlvbnMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc2VjdGlvbnNbdGhpcy5zZWN0aW9ucy5sZW5ndGggLSAxXS5fc2xpZGVzLmZpbHRlcihzbGlkZSA9PiBzbGlkZS5fc2xpZGVOdW0gPT09IHRoaXMuc2xpZGVzW3RoaXMuc2xpZGVzLmxlbmd0aCAtIDFdLl9zbGlkZU51bSkubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIG9wdGlvbnMuc2VjdGlvblRpdGxlID0gc2VjdEFscmVhZHlJblVzZSA/IHRoaXMuc2VjdGlvbnNbdGhpcy5zZWN0aW9ucy5sZW5ndGggLSAxXS50aXRsZSA6IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRTbGlkZShvcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3ZpZGVzIGFuIEFQSSBmb3IgYGFkZFRhYmxlRGVmaW5pdGlvbmAgdG8gZ2V0IHNsaWRlIHJlZmVyZW5jZSBieSBudW1iZXJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHNsaWRlTnVtIC0gc2xpZGUgbnVtYmVyXG4gICAgICAgICAqIEByZXR1cm4ge1ByZXNTbGlkZX0gU2xpZGVcbiAgICAgICAgICogQHNpbmNlIDMuMC4wXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFNsaWRlID0gKHNsaWRlTnVtKSA9PiB0aGlzLnNsaWRlcy5maWx0ZXIoc2xpZGUgPT4gc2xpZGUuX3NsaWRlTnVtID09PSBzbGlkZU51bSlbMF07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGVzIHRoZSBgU2xpZGVgIGNsYXNzIHRvIHNldCBQcHR4R2VuSlMgW1ByZXNlbnRhdGlvbl0gbWFzdGVyL2xheW91dCBzbGlkZW51bWJlcnNcbiAgICAgICAgICogQHBhcmFtIHtTbGlkZU51bWJlclByb3BzfSBzbGlkZU51bSAtIHNsaWRlIG51bWJlciBjb25maWdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0U2xpZGVOdW1iZXIgPSAoc2xpZGVOdW0pID0+IHtcbiAgICAgICAgICAgIC8vIDE6IEFkZCBzbGlkZU51bWJlciB0byBzbGlkZU1hc3RlcjEueG1sXG4gICAgICAgICAgICB0aGlzLm1hc3RlclNsaWRlLl9zbGlkZU51bWJlclByb3BzID0gc2xpZGVOdW07XG4gICAgICAgICAgICAvLyAyOiBBZGQgc2xpZGVOdW1iZXIgdG8gREVGX1BSRVNfTEFZT1VUX05BTUUgbGF5b3V0XG4gICAgICAgICAgICB0aGlzLnNsaWRlTGF5b3V0cy5maWx0ZXIobGF5b3V0ID0+IGxheW91dC5fbmFtZSA9PT0gREVGX1BSRVNfTEFZT1VUX05BTUUpWzBdLl9zbGlkZU51bWJlclByb3BzID0gc2xpZGVOdW07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYWxsIGNoYXJ0IGFuZCBtZWRpYSByZWxzIGZvciB0aGlzIFByZXNlbnRhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1ByZXNTbGlkZSB8IFNsaWRlTGF5b3V0fSBzbGlkZSAtIHNsaWRlIHdpdGggcmVsc1xuICAgICAgICAgKiBAcGFyYW0ge0pTWmlwfSB6aXAgLSBKU1ppcCBpbnN0YW5jZVxuICAgICAgICAgKiBAcGFyYW0ge1Byb21pc2U8c3RyaW5nPltdfSBjaGFydFByb21pc2VzIC0gcHJvbWlzZSBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVDaGFydE1lZGlhUmVscyA9IChzbGlkZSwgemlwLCBjaGFydFByb21pc2VzKSA9PiB7XG4gICAgICAgICAgICBzbGlkZS5fcmVsc0NoYXJ0LmZvckVhY2gocmVsID0+IGNoYXJ0UHJvbWlzZXMucHVzaChjcmVhdGVFeGNlbFdvcmtzaGVldChyZWwsIHppcCkpKTtcbiAgICAgICAgICAgIHNsaWRlLl9yZWxzTWVkaWEuZm9yRWFjaChyZWwgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZWwudHlwZSAhPT0gJ29ubGluZScgJiYgcmVsLnR5cGUgIT09ICdoeXBlcmxpbmsnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEE6IExvb3AgdmFyc1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IHJlbC5kYXRhICYmIHR5cGVvZiByZWwuZGF0YSA9PT0gJ3N0cmluZycgPyByZWwuZGF0YSA6ICcnO1xuICAgICAgICAgICAgICAgICAgICAvLyBCOiBVc2VycyB3aWxsIHVuZG91YnRlZGx5IHBhc3MgdmFyaW91cyBzdHJpbmcgZm9ybWF0cywgc28gY29ycmVjdCBwcmVmaXhlcyBhcyBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLmluY2x1ZGVzKCcsJykgJiYgIWRhdGEuaW5jbHVkZXMoJzsnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSAnaW1hZ2UvcG5nO2Jhc2U2NCwnICsgZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWRhdGEuaW5jbHVkZXMoJywnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSAnaW1hZ2UvcG5nO2Jhc2U2NCwnICsgZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWRhdGEuaW5jbHVkZXMoJzsnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSAnaW1hZ2UvcG5nOycgKyBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAvLyBDOiBBZGQgbWVkaWFcbiAgICAgICAgICAgICAgICAgICAgemlwLmZpbGUocmVsLlRhcmdldC5yZXBsYWNlKCcuLicsICdwcHQnKSwgZGF0YS5zcGxpdCgnLCcpLnBvcCgpLCB7IGJhc2U2NDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhbmQgZXhwb3J0IHRoZSAucHB0eCBmaWxlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHBvcnROYW1lIC0gb3V0cHV0IGZpbGUgdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0Jsb2J9IGJsb2JDb250ZW50IC0gQmxvYiBjb250ZW50XG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn0gUHJvbWlzZSB3aXRoIGZpbGUgbmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53cml0ZUZpbGVUb0Jyb3dzZXIgPSAoZXhwb3J0TmFtZSwgYmxvYkNvbnRlbnQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFNURVAgMTogQ3JlYXRlIGVsZW1lbnRcbiAgICAgICAgICAgIGNvbnN0IGVsZUxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgICAgICBlbGVMaW5rLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTpub25lOycpO1xuICAgICAgICAgICAgZWxlTGluay5kYXRhc2V0LmludGVyY2VwdGlvbiA9ICdvZmYnOyAvLyBAc2VlIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3NoYXJlcG9pbnQvZGV2L3NwZngvaHlwZXJsaW5raW5nXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZUxpbmspO1xuICAgICAgICAgICAgLy8gU1RFUCAyOiBEb3dubG9hZCBmaWxlIHRvIGJyb3dzZXJcbiAgICAgICAgICAgIC8vIERFU0lHTjogVXNlIGBjcmVhdGVPYmplY3RVUkwoKWAgdG8gRC9MIGZpbGVzIGluIGNsaWVudCBicm93c2VycyAoRllJOiBzeW5jaHJvbm91c2x5IGV4ZWN1dGVkKVxuICAgICAgICAgICAgaWYgKHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW2Jsb2JDb250ZW50XSwgeyB0eXBlOiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnByZXNlbnRhdGlvbicgfSkpO1xuICAgICAgICAgICAgICAgIGVsZUxpbmsuaHJlZiA9IHVybDtcbiAgICAgICAgICAgICAgICBlbGVMaW5rLmRvd25sb2FkID0gZXhwb3J0TmFtZTtcbiAgICAgICAgICAgICAgICBlbGVMaW5rLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4tdXAgKE5PVEU6IEFkZCBhIHNsaWdodCBkZWxheSBiZWZvcmUgcmVtb3ZpbmcgdG8gYXZvaWQgJ2Jsb2I6bnVsbCcgZXJyb3IgaW4gRmlyZWZveCBJc3N1ZSM4MSlcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbGVMaW5rKTtcbiAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgICAgIC8vIERvbmVcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgUHJvbWlzZS5yZXNvbHZlKGV4cG9ydE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhbmQgZXhwb3J0IHRoZSAucHB0eCBmaWxlXG4gICAgICAgICAqIEBwYXJhbSB7V1JJVEVfT1VUUFVUX1RZUEV9IG91dHB1dFR5cGUgLSBvdXRwdXQgZmlsZSB0eXBlXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nIHwgQXJyYXlCdWZmZXIgfCBCbG9iIHwgQnVmZmVyIHwgVWludDhBcnJheT59IFByb21pc2Ugd2l0aCBkYXRhIG9yIHN0cmVhbSAobm9kZSkgb3IgZmlsZW5hbWUgKGJyb3dzZXIpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4cG9ydFByZXNlbnRhdGlvbiA9IChwcm9wcykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYXJyQ2hhcnRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgbGV0IGFyck1lZGlhUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHppcCA9IG5ldyBKU1ppcCgpO1xuICAgICAgICAgICAgLy8gU1RFUCAxOiBSZWFkL0VuY29kZSBhbGwgTWVkaWEgYmVmb3JlIHppcCBhcyBiYXNlNjQgY29udGVudCwgZXRjLiBpcyByZXF1aXJlZFxuICAgICAgICAgICAgdGhpcy5zbGlkZXMuZm9yRWFjaChzbGlkZSA9PiB7XG4gICAgICAgICAgICAgICAgYXJyTWVkaWFQcm9taXNlcyA9IGFyck1lZGlhUHJvbWlzZXMuY29uY2F0KGVuY29kZVNsaWRlTWVkaWFSZWxzKHNsaWRlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2xpZGVMYXlvdXRzLmZvckVhY2gobGF5b3V0ID0+IHtcbiAgICAgICAgICAgICAgICBhcnJNZWRpYVByb21pc2VzID0gYXJyTWVkaWFQcm9taXNlcy5jb25jYXQoZW5jb2RlU2xpZGVNZWRpYVJlbHMobGF5b3V0KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFyck1lZGlhUHJvbWlzZXMgPSBhcnJNZWRpYVByb21pc2VzLmNvbmNhdChlbmNvZGVTbGlkZU1lZGlhUmVscyh0aGlzLm1hc3RlclNsaWRlKSk7XG4gICAgICAgICAgICAvLyBTVEVQIDI6IFdhaXQgZm9yIFByb21pc2VzIChpZiBhbnkpIHRoZW4gZ2VuZXJhdGUgdGhlIFBQVFggZmlsZVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIFByb21pc2UuYWxsKGFyck1lZGlhUHJvbWlzZXMpLnRoZW4oKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIC8vIEE6IEFkZCBlbXB0eSBwbGFjZWhvbGRlciBvYmplY3RzIHRvIHNsaWRlcyB0aGF0IGRvbid0IGFscmVhZHkgaGF2ZSB0aGVtXG4gICAgICAgICAgICAgICAgdGhpcy5zbGlkZXMuZm9yRWFjaChzbGlkZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbGlkZS5fc2xpZGVMYXlvdXQpXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRQbGFjZWhvbGRlcnNUb1NsaWRlTGF5b3V0cyhzbGlkZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gQjogQWRkIGFsbCByZXF1aXJlZCBmb2xkZXJzIGFuZCBmaWxlc1xuICAgICAgICAgICAgICAgIHppcC5mb2xkZXIoJ19yZWxzJyk7XG4gICAgICAgICAgICAgICAgemlwLmZvbGRlcignZG9jUHJvcHMnKTtcbiAgICAgICAgICAgICAgICB6aXAuZm9sZGVyKCdwcHQnKS5mb2xkZXIoJ19yZWxzJyk7XG4gICAgICAgICAgICAgICAgemlwLmZvbGRlcigncHB0L2NoYXJ0cycpLmZvbGRlcignX3JlbHMnKTtcbiAgICAgICAgICAgICAgICB6aXAuZm9sZGVyKCdwcHQvZW1iZWRkaW5ncycpO1xuICAgICAgICAgICAgICAgIHppcC5mb2xkZXIoJ3BwdC9tZWRpYScpO1xuICAgICAgICAgICAgICAgIHppcC5mb2xkZXIoJ3BwdC9zbGlkZUxheW91dHMnKS5mb2xkZXIoJ19yZWxzJyk7XG4gICAgICAgICAgICAgICAgemlwLmZvbGRlcigncHB0L3NsaWRlTWFzdGVycycpLmZvbGRlcignX3JlbHMnKTtcbiAgICAgICAgICAgICAgICB6aXAuZm9sZGVyKCdwcHQvc2xpZGVzJykuZm9sZGVyKCdfcmVscycpO1xuICAgICAgICAgICAgICAgIHppcC5mb2xkZXIoJ3BwdC90aGVtZScpO1xuICAgICAgICAgICAgICAgIHppcC5mb2xkZXIoJ3BwdC9ub3Rlc01hc3RlcnMnKS5mb2xkZXIoJ19yZWxzJyk7XG4gICAgICAgICAgICAgICAgemlwLmZvbGRlcigncHB0L25vdGVzU2xpZGVzJykuZm9sZGVyKCdfcmVscycpO1xuICAgICAgICAgICAgICAgIHppcC5maWxlKCdbQ29udGVudF9UeXBlc10ueG1sJywgbWFrZVhtbENvbnRUeXBlcyh0aGlzLnNsaWRlcywgdGhpcy5zbGlkZUxheW91dHMsIHRoaXMubWFzdGVyU2xpZGUpKTsgLy8gVE9ETzogcGFzcyBvbmx5IGB0aGlzYCBsaWtlIGJlbG93ISAyMDIwMDIwNlxuICAgICAgICAgICAgICAgIHppcC5maWxlKCdfcmVscy8ucmVscycsIG1ha2VYbWxSb290UmVscygpKTtcbiAgICAgICAgICAgICAgICB6aXAuZmlsZSgnZG9jUHJvcHMvYXBwLnhtbCcsIG1ha2VYbWxBcHAodGhpcy5zbGlkZXMsIHRoaXMuY29tcGFueSkpOyAvLyBUT0RPOiBwYXNzIG9ubHkgYHRoaXNgIGxpa2UgYmVsb3chIDIwMjAwMjA2XG4gICAgICAgICAgICAgICAgemlwLmZpbGUoJ2RvY1Byb3BzL2NvcmUueG1sJywgbWFrZVhtbENvcmUodGhpcy50aXRsZSwgdGhpcy5zdWJqZWN0LCB0aGlzLmF1dGhvciwgdGhpcy5yZXZpc2lvbikpOyAvLyBUT0RPOiBwYXNzIG9ubHkgYHRoaXNgIGxpa2UgYmVsb3chIDIwMjAwMjA2XG4gICAgICAgICAgICAgICAgemlwLmZpbGUoJ3BwdC9fcmVscy9wcmVzZW50YXRpb24ueG1sLnJlbHMnLCBtYWtlWG1sUHJlc2VudGF0aW9uUmVscyh0aGlzLnNsaWRlcykpO1xuICAgICAgICAgICAgICAgIHppcC5maWxlKCdwcHQvdGhlbWUvdGhlbWUxLnhtbCcsIG1ha2VYbWxUaGVtZSh0aGlzKSk7XG4gICAgICAgICAgICAgICAgemlwLmZpbGUoJ3BwdC9wcmVzZW50YXRpb24ueG1sJywgbWFrZVhtbFByZXNlbnRhdGlvbih0aGlzKSk7XG4gICAgICAgICAgICAgICAgemlwLmZpbGUoJ3BwdC9wcmVzUHJvcHMueG1sJywgbWFrZVhtbFByZXNQcm9wcygpKTtcbiAgICAgICAgICAgICAgICB6aXAuZmlsZSgncHB0L3RhYmxlU3R5bGVzLnhtbCcsIG1ha2VYbWxUYWJsZVN0eWxlcygpKTtcbiAgICAgICAgICAgICAgICB6aXAuZmlsZSgncHB0L3ZpZXdQcm9wcy54bWwnLCBtYWtlWG1sVmlld1Byb3BzKCkpO1xuICAgICAgICAgICAgICAgIC8vIEM6IENyZWF0ZSBhIExheW91dC9NYXN0ZXIvUmVsL1NsaWRlIGZpbGUgZm9yIGVhY2ggU2xpZGVMYXlvdXQgYW5kIFNsaWRlXG4gICAgICAgICAgICAgICAgdGhpcy5zbGlkZUxheW91dHMuZm9yRWFjaCgobGF5b3V0LCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgemlwLmZpbGUoYHBwdC9zbGlkZUxheW91dHMvc2xpZGVMYXlvdXQke2lkeCArIDF9LnhtbGAsIG1ha2VYbWxMYXlvdXQobGF5b3V0KSk7XG4gICAgICAgICAgICAgICAgICAgIHppcC5maWxlKGBwcHQvc2xpZGVMYXlvdXRzL19yZWxzL3NsaWRlTGF5b3V0JHtpZHggKyAxfS54bWwucmVsc2AsIG1ha2VYbWxTbGlkZUxheW91dFJlbChpZHggKyAxLCB0aGlzLnNsaWRlTGF5b3V0cykpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2xpZGVzLmZvckVhY2goKHNsaWRlLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgemlwLmZpbGUoYHBwdC9zbGlkZXMvc2xpZGUke2lkeCArIDF9LnhtbGAsIG1ha2VYbWxTbGlkZShzbGlkZSkpO1xuICAgICAgICAgICAgICAgICAgICB6aXAuZmlsZShgcHB0L3NsaWRlcy9fcmVscy9zbGlkZSR7aWR4ICsgMX0ueG1sLnJlbHNgLCBtYWtlWG1sU2xpZGVSZWwodGhpcy5zbGlkZXMsIHRoaXMuc2xpZGVMYXlvdXRzLCBpZHggKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhbGwgc2xpZGUgbm90ZXMgcmVsYXRlZCBpdGVtcy4gTm90ZXMgb2YgZW1wdHkgc3RyaW5ncyBhcmUgY3JlYXRlZCBmb3Igc2xpZGVzIHdoaWNoIGRvIG5vdCBoYXZlIG5vdGVzIHNwZWNpZmllZCwgdG8ga2VlcCB0cmFjayBvZiBfcmVscy5cbiAgICAgICAgICAgICAgICAgICAgemlwLmZpbGUoYHBwdC9ub3Rlc1NsaWRlcy9ub3Rlc1NsaWRlJHtpZHggKyAxfS54bWxgLCBtYWtlWG1sTm90ZXNTbGlkZShzbGlkZSkpO1xuICAgICAgICAgICAgICAgICAgICB6aXAuZmlsZShgcHB0L25vdGVzU2xpZGVzL19yZWxzL25vdGVzU2xpZGUke2lkeCArIDF9LnhtbC5yZWxzYCwgbWFrZVhtbE5vdGVzU2xpZGVSZWwoaWR4ICsgMSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHppcC5maWxlKCdwcHQvc2xpZGVNYXN0ZXJzL3NsaWRlTWFzdGVyMS54bWwnLCBtYWtlWG1sTWFzdGVyKHRoaXMubWFzdGVyU2xpZGUsIHRoaXMuc2xpZGVMYXlvdXRzKSk7XG4gICAgICAgICAgICAgICAgemlwLmZpbGUoJ3BwdC9zbGlkZU1hc3RlcnMvX3JlbHMvc2xpZGVNYXN0ZXIxLnhtbC5yZWxzJywgbWFrZVhtbE1hc3RlclJlbCh0aGlzLm1hc3RlclNsaWRlLCB0aGlzLnNsaWRlTGF5b3V0cykpO1xuICAgICAgICAgICAgICAgIHppcC5maWxlKCdwcHQvbm90ZXNNYXN0ZXJzL25vdGVzTWFzdGVyMS54bWwnLCBtYWtlWG1sTm90ZXNNYXN0ZXIoKSk7XG4gICAgICAgICAgICAgICAgemlwLmZpbGUoJ3BwdC9ub3Rlc01hc3RlcnMvX3JlbHMvbm90ZXNNYXN0ZXIxLnhtbC5yZWxzJywgbWFrZVhtbE5vdGVzTWFzdGVyUmVsKCkpO1xuICAgICAgICAgICAgICAgIC8vIEQ6IENyZWF0ZSBhbGwgUmVscyAoaW1hZ2VzLCBtZWRpYSwgY2hhcnQgZGF0YSlcbiAgICAgICAgICAgICAgICB0aGlzLnNsaWRlTGF5b3V0cy5mb3JFYWNoKGxheW91dCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlQ2hhcnRNZWRpYVJlbHMobGF5b3V0LCB6aXAsIGFyckNoYXJ0UHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2xpZGVzLmZvckVhY2goc2xpZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUNoYXJ0TWVkaWFSZWxzKHNsaWRlLCB6aXAsIGFyckNoYXJ0UHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlQ2hhcnRNZWRpYVJlbHModGhpcy5tYXN0ZXJTbGlkZSwgemlwLCBhcnJDaGFydFByb21pc2VzKTtcbiAgICAgICAgICAgICAgICAvLyBFOiBXYWl0IGZvciBQcm9taXNlcyAoaWYgYW55KSB0aGVuIGdlbmVyYXRlIHRoZSBQUFRYIGZpbGVcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgUHJvbWlzZS5hbGwoYXJyQ2hhcnRQcm9taXNlcykudGhlbigoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wcy5vdXRwdXRUeXBlID09PSAnU1RSRUFNJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQTogc3RyZWFtIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB6aXAuZ2VuZXJhdGVBc3luYyh7IHR5cGU6ICdub2RlYnVmZmVyJywgY29tcHJlc3Npb246IHByb3BzLmNvbXByZXNzaW9uID8gJ0RFRkxBVEUnIDogJ1NUT1JFJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9wcy5vdXRwdXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCOiBOb2RlIFtmc106IE91dHB1dCB0eXBlIHVzZXIgb3B0aW9uIG9yIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB6aXAuZ2VuZXJhdGVBc3luYyh7IHR5cGU6IHByb3BzLm91dHB1dFR5cGUgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDOiBCcm93c2VyOiBPdXRwdXQgYmxvYiBhcyBhcHAvbXMtcHB0eFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHppcC5nZW5lcmF0ZUFzeW5jKHsgdHlwZTogJ2Jsb2InLCBjb21wcmVzc2lvbjogcHJvcHMuY29tcHJlc3Npb24gPyAnREVGTEFURScgOiAnU1RPUkUnIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbGF5b3V0NHgzID0geyBuYW1lOiAnc2NyZWVuNHgzJywgd2lkdGg6IDkxNDQwMDAsIGhlaWdodDogNjg1ODAwMCB9O1xuICAgICAgICBjb25zdCBsYXlvdXQxNng5ID0geyBuYW1lOiAnc2NyZWVuMTZ4OScsIHdpZHRoOiA5MTQ0MDAwLCBoZWlnaHQ6IDUxNDM1MDAgfTtcbiAgICAgICAgY29uc3QgbGF5b3V0MTZ4MTAgPSB7IG5hbWU6ICdzY3JlZW4xNngxMCcsIHdpZHRoOiA5MTQ0MDAwLCBoZWlnaHQ6IDU3MTUwMDAgfTtcbiAgICAgICAgY29uc3QgbGF5b3V0V2lkZSA9IHsgbmFtZTogJ2N1c3RvbScsIHdpZHRoOiAxMjE5MjAwMCwgaGVpZ2h0OiA2ODU4MDAwIH07XG4gICAgICAgIC8vIFNldCBhdmFpbGFibGUgbGF5b3V0c1xuICAgICAgICB0aGlzLkxBWU9VVFMgPSB7XG4gICAgICAgICAgICBMQVlPVVRfNHgzOiBsYXlvdXQ0eDMsXG4gICAgICAgICAgICBMQVlPVVRfMTZ4OTogbGF5b3V0MTZ4OSxcbiAgICAgICAgICAgIExBWU9VVF8xNngxMDogbGF5b3V0MTZ4MTAsXG4gICAgICAgICAgICBMQVlPVVRfV0lERTogbGF5b3V0V2lkZSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ29yZVxuICAgICAgICB0aGlzLl9hdXRob3IgPSAnUHB0eEdlbkpTJztcbiAgICAgICAgdGhpcy5fY29tcGFueSA9ICdQcHR4R2VuSlMnO1xuICAgICAgICB0aGlzLl9yZXZpc2lvbiA9ICcxJzsgLy8gTm90ZTogTXVzdCBiZSBhIHdob2xlIG51bWJlclxuICAgICAgICB0aGlzLl9zdWJqZWN0ID0gJ1BwdHhHZW5KUyBQcmVzZW50YXRpb24nO1xuICAgICAgICB0aGlzLl90aXRsZSA9ICdQcHR4R2VuSlMgUHJlc2VudGF0aW9uJztcbiAgICAgICAgLy8gUHB0eEdlbkpTIHByb3BzXG4gICAgICAgIHRoaXMuX3ByZXNMYXlvdXQgPSB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLkxBWU9VVFNbREVGX1BSRVNfTEFZT1VUXS5uYW1lLFxuICAgICAgICAgICAgX3NpemVXOiB0aGlzLkxBWU9VVFNbREVGX1BSRVNfTEFZT1VUXS53aWR0aCxcbiAgICAgICAgICAgIF9zaXplSDogdGhpcy5MQVlPVVRTW0RFRl9QUkVTX0xBWU9VVF0uaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IHRoaXMuTEFZT1VUU1tERUZfUFJFU19MQVlPVVRdLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLkxBWU9VVFNbREVGX1BSRVNfTEFZT1VUXS5oZWlnaHQsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3J0bE1vZGUgPSBmYWxzZTtcbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5fc2xpZGVMYXlvdXRzID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIF9tYXJnaW46IERFRl9TTElERV9NQVJHSU5fSU4sXG4gICAgICAgICAgICAgICAgX25hbWU6IERFRl9QUkVTX0xBWU9VVF9OQU1FLFxuICAgICAgICAgICAgICAgIF9wcmVzTGF5b3V0OiB0aGlzLl9wcmVzTGF5b3V0LFxuICAgICAgICAgICAgICAgIF9yZWxzOiBbXSxcbiAgICAgICAgICAgICAgICBfcmVsc0NoYXJ0OiBbXSxcbiAgICAgICAgICAgICAgICBfcmVsc01lZGlhOiBbXSxcbiAgICAgICAgICAgICAgICBfc2xpZGU6IG51bGwsXG4gICAgICAgICAgICAgICAgX3NsaWRlTnVtOiAxMDAwLFxuICAgICAgICAgICAgICAgIF9zbGlkZU51bWJlclByb3BzOiBudWxsLFxuICAgICAgICAgICAgICAgIF9zbGlkZU9iamVjdHM6IFtdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5fc2xpZGVzID0gW107XG4gICAgICAgIHRoaXMuX3NlY3Rpb25zID0gW107XG4gICAgICAgIHRoaXMuX21hc3RlclNsaWRlID0ge1xuICAgICAgICAgICAgYWRkQ2hhcnQ6IG51bGwsXG4gICAgICAgICAgICBhZGRJbWFnZTogbnVsbCxcbiAgICAgICAgICAgIGFkZE1lZGlhOiBudWxsLFxuICAgICAgICAgICAgYWRkTm90ZXM6IG51bGwsXG4gICAgICAgICAgICBhZGRTaGFwZTogbnVsbCxcbiAgICAgICAgICAgIGFkZFRhYmxlOiBudWxsLFxuICAgICAgICAgICAgYWRkVGV4dDogbnVsbCxcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBfbmFtZTogbnVsbCxcbiAgICAgICAgICAgIF9wcmVzTGF5b3V0OiB0aGlzLl9wcmVzTGF5b3V0LFxuICAgICAgICAgICAgX3JJZDogbnVsbCxcbiAgICAgICAgICAgIF9yZWxzOiBbXSxcbiAgICAgICAgICAgIF9yZWxzQ2hhcnQ6IFtdLFxuICAgICAgICAgICAgX3JlbHNNZWRpYTogW10sXG4gICAgICAgICAgICBfc2xpZGVJZDogbnVsbCxcbiAgICAgICAgICAgIF9zbGlkZUxheW91dDogbnVsbCxcbiAgICAgICAgICAgIF9zbGlkZU51bTogbnVsbCxcbiAgICAgICAgICAgIF9zbGlkZU51bWJlclByb3BzOiBudWxsLFxuICAgICAgICAgICAgX3NsaWRlT2JqZWN0czogW10sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEVYUE9SVCBNRVRIT0RTXG4gICAgLyoqXG4gICAgICogRXhwb3J0IHRoZSBjdXJyZW50IFByZXNlbnRhdGlvbiB0byBzdHJlYW1cbiAgICAgKiBAcGFyYW0ge1dyaXRlQmFzZVByb3BzfSBwcm9wcyAtIG91dHB1dCBwcm9wZXJ0aWVzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nIHwgQXJyYXlCdWZmZXIgfCBCbG9iIHwgQnVmZmVyIHwgVWludDhBcnJheT59IGZpbGUgc3RyZWFtXG4gICAgICovXG4gICAgc3RyZWFtKHByb3BzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5leHBvcnRQcmVzZW50YXRpb24oe1xuICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uOiBwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMuY29tcHJlc3Npb24sXG4gICAgICAgICAgICAgICAgb3V0cHV0VHlwZTogJ1NUUkVBTScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9ydCB0aGUgY3VycmVudCBQcmVzZW50YXRpb24gYXMgSlNaaXAgY29udGVudCB3aXRoIHRoZSBzZWxlY3RlZCB0eXBlXG4gICAgICogQHBhcmFtIHtXcml0ZVByb3BzfSBwcm9wcyBvdXRwdXQgcHJvcGVydGllc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZyB8IEFycmF5QnVmZmVyIHwgQmxvYiB8IEJ1ZmZlciB8IFVpbnQ4QXJyYXk+fSBmaWxlIGNvbnRlbnQgaW4gc2VsZWN0ZWQgdHlwZVxuICAgICAqL1xuICAgIHdyaXRlKHByb3BzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBERVBSRUNBVEVEOiBAZGVwcmVjYXRlZCB2My41LjAgLSBvdXRwdXRUeXBlIC0gW1tyZW1vdmUgaW4gdjQuMC4wXV1cbiAgICAgICAgICAgIGNvbnN0IHByb3BzT3V0cFR5cGUgPSB0eXBlb2YgcHJvcHMgPT09ICdvYmplY3QnICYmIChwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMub3V0cHV0VHlwZSkgPyBwcm9wcy5vdXRwdXRUeXBlIDogcHJvcHMgPyBwcm9wcyA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCBwcm9wc0NvbXByZXNzID0gdHlwZW9mIHByb3BzID09PSAnb2JqZWN0JyAmJiAocHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzLmNvbXByZXNzaW9uKSA/IHByb3BzLmNvbXByZXNzaW9uIDogZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5leHBvcnRQcmVzZW50YXRpb24oe1xuICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uOiBwcm9wc0NvbXByZXNzLFxuICAgICAgICAgICAgICAgIG91dHB1dFR5cGU6IHByb3BzT3V0cFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9ydCB0aGUgY3VycmVudCBQcmVzZW50YXRpb24uXG4gICAgICogV3JpdGUgdGhlIGdlbmVyYXRlZCBwcmVzZW50YXRpb24gdG8gZGlzayAoTm9kZSkgb3IgdHJpZ2dlciBhIGRvd25sb2FkIChicm93c2VyKS5cbiAgICAgKiBAcGFyYW0ge1dyaXRlRmlsZVByb3BzfSBwcm9wcyAtIG91dHB1dCBmaWxlIHByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSB0aGUgcHJlc2VudGF0aW9uIG5hbWVcbiAgICAgKi9cbiAgICB3cml0ZUZpbGUocHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAvLyBTVEVQIDE6IEZpZ3VyZSBvdXQgd2hlcmUgd2UgYXJlIHJ1bm5pbmdcbiAgICAgICAgICAgIGNvbnN0IGlzTm9kZSA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAhISgoX2EgPSBwcm9jZXNzLnZlcnNpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9kZSkgJiYgKChfYiA9IHByb2Nlc3MucmVsZWFzZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm5hbWUpID09PSAnbm9kZSc7XG4gICAgICAgICAgICAvLyBTVEVQIDI6IE5vcm1hbGlzZSB0aGUgdXNlciBhcmd1bWVudHNcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gREVQUkVDQVRFRDogQGRlcHJlY2F0ZWQgdjMuNS4wIC0gZmlsZU5hbWUgLSBbW3JlbW92ZSBpbiB2NC4wLjBdXVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignW1dBUk5JTkddIHdyaXRlRmlsZShzdHJpbmcpIGlzIGRlcHJlY2F0ZWQgLSBwYXNzIHsgZmlsZU5hbWUgfSBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgICAgIHByb3BzID0geyBmaWxlTmFtZTogcHJvcHMgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZmlsZU5hbWU6IHJhd05hbWUgPSAnUHJlc2VudGF0aW9uLnBwdHgnLCBjb21wcmVzc2lvbiA9IGZhbHNlIH0gPSBwcm9wcztcbiAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gcmF3TmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKCcucHB0eCcpID8gcmF3TmFtZSA6IGAke3Jhd05hbWV9LnBwdHhgO1xuICAgICAgICAgICAgLy8gU1RFUCAzOiBHZXQgdGhlIGJpbmFyeS9CbG9iIGZyb20gZXhwb3J0UHJlc2VudGF0aW9uKClcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dFR5cGUgPSBpc05vZGUgPyAnbm9kZWJ1ZmZlcicgOiBudWxsO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHRoaXMuZXhwb3J0UHJlc2VudGF0aW9uKHsgY29tcHJlc3Npb24sIG91dHB1dFR5cGUgfSk7XG4gICAgICAgICAgICAvLyBTVEVQIDQ6IFdyaXRlIHRoZSBmaWxlIG91dFxuICAgICAgICAgICAgaWYgKGlzTm9kZSkge1xuICAgICAgICAgICAgICAgIC8vIER5bmFtaWNhbGx5IGltcG9ydCB0byBhdm9pZCBidW5kbGluZyBmcyBpbiB0aGUgYnJvd3NlciBidWlsZFxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJvbWlzZXM6IGZzIH0gPSB5aWVsZCBpbXBvcnQoJ25vZGU6ZnMnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHdyaXRlRmlsZSB9ID0gZnM7XG4gICAgICAgICAgICAgICAgeWllbGQgd3JpdGVGaWxlKGZpbGVOYW1lLCBkYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZU5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCcm93c2VyIGJyYW5jaCAtIHB1c2ggYSBkb3dubG9hZFxuICAgICAgICAgICAgeWllbGQgdGhpcy53cml0ZUZpbGVUb0Jyb3dzZXIoZmlsZU5hbWUsIGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbGVOYW1lO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gUFJFU0VOVEFUSU9OIE1FVEhPRFNcbiAgICAvKipcbiAgICAgKiBBZGQgYSBuZXcgU2VjdGlvbiB0byBQcmVzZW50YXRpb25cbiAgICAgKiBAcGFyYW0ge0lTZWN0aW9uUHJvcHN9IHNlY3Rpb24gLSBzZWN0aW9uIHByb3BlcnRpZXNcbiAgICAgKiBAZXhhbXBsZSBwcHR4LmFkZFNlY3Rpb24oeyB0aXRsZTonQ2hhcnRzJyB9KTtcbiAgICAgKi9cbiAgICBhZGRTZWN0aW9uKHNlY3Rpb24pIHtcbiAgICAgICAgaWYgKCFzZWN0aW9uKVxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZGRTZWN0aW9uIHJlcXVpcmVzIGFuIGFyZ3VtZW50Jyk7XG4gICAgICAgIGVsc2UgaWYgKCFzZWN0aW9uLnRpdGxlKVxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZGRTZWN0aW9uIHJlcXVpcmVzIGEgdGl0bGUnKTtcbiAgICAgICAgY29uc3QgbmV3U2VjdGlvbiA9IHtcbiAgICAgICAgICAgIF90eXBlOiAndXNlcicsXG4gICAgICAgICAgICBfc2xpZGVzOiBbXSxcbiAgICAgICAgICAgIHRpdGxlOiBzZWN0aW9uLnRpdGxlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2VjdGlvbi5vcmRlcilcbiAgICAgICAgICAgIHRoaXMuc2VjdGlvbnMuc3BsaWNlKHNlY3Rpb24ub3JkZXIsIDAsIG5ld1NlY3Rpb24pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLl9zZWN0aW9ucy5wdXNoKG5ld1NlY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBuZXcgU2xpZGUgdG8gUHJlc2VudGF0aW9uXG4gICAgICogQHBhcmFtIHtBZGRTbGlkZVByb3BzfSBvcHRpb25zIC0gc2xpZGUgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtQcmVzU2xpZGV9IHRoZSBuZXcgU2xpZGVcbiAgICAgKi9cbiAgICBhZGRTbGlkZShvcHRpb25zKSB7XG4gICAgICAgIC8vIFRPRE86IERFUFJFQ0FURUQ6IGFyZzAgc3RyaW5nIFwibWFzdGVyU2xpZGVOYW1lXCIgZGVwIGFzIG9mIDMuMi4wXG4gICAgICAgIGNvbnN0IG1hc3RlclNsaWRlTmFtZSA9IHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJyA/IG9wdGlvbnMgOiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1hc3Rlck5hbWUpID8gb3B0aW9ucy5tYXN0ZXJOYW1lIDogJyc7XG4gICAgICAgIGxldCBzbGlkZUxheW91dCA9IHtcbiAgICAgICAgICAgIF9uYW1lOiB0aGlzLkxBWU9VVFNbREVGX1BSRVNfTEFZT1VUXS5uYW1lLFxuICAgICAgICAgICAgX3ByZXNMYXlvdXQ6IHRoaXMucHJlc0xheW91dCxcbiAgICAgICAgICAgIF9yZWxzOiBbXSxcbiAgICAgICAgICAgIF9yZWxzQ2hhcnQ6IFtdLFxuICAgICAgICAgICAgX3JlbHNNZWRpYTogW10sXG4gICAgICAgICAgICBfc2xpZGVOdW06IHRoaXMuc2xpZGVzLmxlbmd0aCArIDEsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtYXN0ZXJTbGlkZU5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHRtcExheW91dCA9IHRoaXMuc2xpZGVMYXlvdXRzLmZpbHRlcihsYXlvdXQgPT4gbGF5b3V0Ll9uYW1lID09PSBtYXN0ZXJTbGlkZU5hbWUpWzBdO1xuICAgICAgICAgICAgaWYgKHRtcExheW91dClcbiAgICAgICAgICAgICAgICBzbGlkZUxheW91dCA9IHRtcExheW91dDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdTbGlkZSA9IG5ldyBTbGlkZSh7XG4gICAgICAgICAgICBhZGRTbGlkZTogdGhpcy5hZGROZXdTbGlkZSxcbiAgICAgICAgICAgIGdldFNsaWRlOiB0aGlzLmdldFNsaWRlLFxuICAgICAgICAgICAgcHJlc0xheW91dDogdGhpcy5wcmVzTGF5b3V0LFxuICAgICAgICAgICAgc2V0U2xpZGVOdW06IHRoaXMuc2V0U2xpZGVOdW1iZXIsXG4gICAgICAgICAgICBzbGlkZUlkOiB0aGlzLnNsaWRlcy5sZW5ndGggKyAyNTYsXG4gICAgICAgICAgICBzbGlkZVJJZDogdGhpcy5zbGlkZXMubGVuZ3RoICsgMixcbiAgICAgICAgICAgIHNsaWRlTnVtYmVyOiB0aGlzLnNsaWRlcy5sZW5ndGggKyAxLFxuICAgICAgICAgICAgc2xpZGVMYXlvdXQsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBOiBBZGQgc2xpZGUgdG8gcHJlc1xuICAgICAgICB0aGlzLl9zbGlkZXMucHVzaChuZXdTbGlkZSk7XG4gICAgICAgIC8vIEI6IFNlY3Rpb25zXG4gICAgICAgIC8vIEItMTogQWRkIHNsaWRlIHRvIHNlY3Rpb24gKGlmIGFueSBwcm92aWRlZClcbiAgICAgICAgLy8gQi0yOiBIYW5kbGUgc2xpZGVzIHdpdGhvdXQgYSBzZWN0aW9uIHdoZW4gc2VjdGlvbnMgYXJlIGFscmVhZHkgaXMgdXNlIChcImxvb3NlXCIgc2xpZGVzIGFyZW50IGFsbG93ZWQsIHRoZXkgYWxsIG5lZWQgYSBzZWN0aW9uKVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNlY3Rpb25UaXRsZSkge1xuICAgICAgICAgICAgY29uc3Qgc2VjdCA9IHRoaXMuc2VjdGlvbnMuZmlsdGVyKHNlY3Rpb24gPT4gc2VjdGlvbi50aXRsZSA9PT0gb3B0aW9ucy5zZWN0aW9uVGl0bGUpWzBdO1xuICAgICAgICAgICAgaWYgKCFzZWN0KVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgYWRkU2xpZGU6IHVuYWJsZSB0byBmaW5kIHNlY3Rpb24gd2l0aCB0aXRsZTogXCIke29wdGlvbnMuc2VjdGlvblRpdGxlfVwiYCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VjdC5fc2xpZGVzLnB1c2gobmV3U2xpZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2VjdGlvbnMgJiYgdGhpcy5zZWN0aW9ucy5sZW5ndGggPiAwICYmICghKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zZWN0aW9uVGl0bGUpKSkge1xuICAgICAgICAgICAgY29uc3QgbGFzdFNlY3QgPSB0aGlzLl9zZWN0aW9uc1t0aGlzLnNlY3Rpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgLy8gQ0FTRSAxOiBUaGUgbGF0ZXN0IHNlY3Rpb24gaXMgYSBkZWZhdWx0IHR5cGUgLSBqdXN0IGFkZCB0aGlzIG9uZVxuICAgICAgICAgICAgaWYgKGxhc3RTZWN0Ll90eXBlID09PSAnZGVmYXVsdCcpXG4gICAgICAgICAgICAgICAgbGFzdFNlY3QuX3NsaWRlcy5wdXNoKG5ld1NsaWRlKTtcbiAgICAgICAgICAgIC8vIENBU0UgMjogVGhlcmUgbGF0ZXN0IHNlY3Rpb24gaXMgTk9UIGEgZGVmYXVsdCB0eXBlIC0gY3JlYXRlIHRoZSBkZWZ1YWx0LCBhZGQgdGhpcyBzbGlkZVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBgRGVmYXVsdC0ke3RoaXMuc2VjdGlvbnMuZmlsdGVyKHNlY3QgPT4gc2VjdC5fdHlwZSA9PT0gJ2RlZmF1bHQnKS5sZW5ndGggKyAxfWAsXG4gICAgICAgICAgICAgICAgICAgIF90eXBlOiAnZGVmYXVsdCcsXG4gICAgICAgICAgICAgICAgICAgIF9zbGlkZXM6IFtuZXdTbGlkZV0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1NsaWRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjdXN0b20gU2xpZGUgTGF5b3V0IGluIGFueSBzaXplXG4gICAgICogQHBhcmFtIHtQcmVzTGF5b3V0fSBsYXlvdXQgLSBsYXlvdXQgcHJvcGVydGllc1xuICAgICAqIEBleGFtcGxlIHBwdHguZGVmaW5lTGF5b3V0KHsgbmFtZTonQTMnLCB3aWR0aDoxNi41LCBoZWlnaHQ6MTEuNyB9KTtcbiAgICAgKi9cbiAgICBkZWZpbmVMYXlvdXQobGF5b3V0KSB7XG4gICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9zdXBwb3J0Lm9mZmljZS5jb20vZW4tdXMvYXJ0aWNsZS9DaGFuZ2UtdGhlLXNpemUtb2YteW91ci1zbGlkZXMtMDQwYTgxMWMtYmU0My00MGI5LThkMDQtMGRlNWVkNzk5ODdlXG4gICAgICAgIGlmICghbGF5b3V0KVxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdkZWZpbmVMYXlvdXQgcmVxdWlyZXMgYHtuYW1lLCB3aWR0aCwgaGVpZ2h0fWAnKTtcbiAgICAgICAgZWxzZSBpZiAoIWxheW91dC5uYW1lKVxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdkZWZpbmVMYXlvdXQgcmVxdWlyZXMgYG5hbWVgJyk7XG4gICAgICAgIGVsc2UgaWYgKCFsYXlvdXQud2lkdGgpXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2RlZmluZUxheW91dCByZXF1aXJlcyBgd2lkdGhgJyk7XG4gICAgICAgIGVsc2UgaWYgKCFsYXlvdXQuaGVpZ2h0KVxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdkZWZpbmVMYXlvdXQgcmVxdWlyZXMgYGhlaWdodGAnKTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGxheW91dC5oZWlnaHQgIT09ICdudW1iZXInKVxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdkZWZpbmVMYXlvdXQgYGhlaWdodGAgc2hvdWxkIGJlIGEgbnVtYmVyIChpbmNoZXMpJyk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsYXlvdXQud2lkdGggIT09ICdudW1iZXInKVxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdkZWZpbmVMYXlvdXQgYHdpZHRoYCBzaG91bGQgYmUgYSBudW1iZXIgKGluY2hlcyknKTtcbiAgICAgICAgdGhpcy5MQVlPVVRTW2xheW91dC5uYW1lXSA9IHtcbiAgICAgICAgICAgIG5hbWU6IGxheW91dC5uYW1lLFxuICAgICAgICAgICAgX3NpemVXOiBNYXRoLnJvdW5kKE51bWJlcihsYXlvdXQud2lkdGgpICogRU1VKSxcbiAgICAgICAgICAgIF9zaXplSDogTWF0aC5yb3VuZChOdW1iZXIobGF5b3V0LmhlaWdodCkgKiBFTVUpLFxuICAgICAgICAgICAgd2lkdGg6IE1hdGgucm91bmQoTnVtYmVyKGxheW91dC53aWR0aCkgKiBFTVUpLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKE51bWJlcihsYXlvdXQuaGVpZ2h0KSAqIEVNVSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBzbGlkZSBtYXN0ZXIgW2xheW91dF0gZm9yIHRoZSBQcmVzZW50YXRpb25cbiAgICAgKiBAcGFyYW0ge1NsaWRlTWFzdGVyUHJvcHN9IHByb3BzIC0gbGF5b3V0IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBkZWZpbmVTbGlkZU1hc3Rlcihwcm9wcykge1xuICAgICAgICAvLyAoSVNTVUUjNDA2O1BVTEwjMTE3NikgZGVlcCBjbG9uZSB0aGUgcHJvcHMgb2JqZWN0IHRvIGF2b2lkIG11dGF0aW5nIHRoZSBvcmlnaW5hbCBvYmplY3RcbiAgICAgICAgY29uc3QgcHJvcHNDbG9uZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocHJvcHMpKTtcbiAgICAgICAgaWYgKCFwcm9wc0Nsb25lLnRpdGxlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZWZpbmVTbGlkZU1hc3RlcigpIG9iamVjdCBhcmd1bWVudCByZXF1aXJlcyBhIGB0aXRsZWAgdmFsdWUuIChodHRwczovL2dpdGJyZW50LmdpdGh1Yi5pby9QcHR4R2VuSlMvZG9jcy9tYXN0ZXJzLmh0bWwpJyk7XG4gICAgICAgIGNvbnN0IG5ld0xheW91dCA9IHtcbiAgICAgICAgICAgIF9tYXJnaW46IHByb3BzQ2xvbmUubWFyZ2luIHx8IERFRl9TTElERV9NQVJHSU5fSU4sXG4gICAgICAgICAgICBfbmFtZTogcHJvcHNDbG9uZS50aXRsZSxcbiAgICAgICAgICAgIF9wcmVzTGF5b3V0OiB0aGlzLnByZXNMYXlvdXQsXG4gICAgICAgICAgICBfcmVsczogW10sXG4gICAgICAgICAgICBfcmVsc0NoYXJ0OiBbXSxcbiAgICAgICAgICAgIF9yZWxzTWVkaWE6IFtdLFxuICAgICAgICAgICAgX3NsaWRlOiBudWxsLFxuICAgICAgICAgICAgX3NsaWRlTnVtOiAxMDAwICsgdGhpcy5zbGlkZUxheW91dHMubGVuZ3RoICsgMSxcbiAgICAgICAgICAgIF9zbGlkZU51bWJlclByb3BzOiBwcm9wc0Nsb25lLnNsaWRlTnVtYmVyIHx8IG51bGwsXG4gICAgICAgICAgICBfc2xpZGVPYmplY3RzOiBbXSxcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IHByb3BzQ2xvbmUuYmFja2dyb3VuZCB8fCBudWxsLFxuICAgICAgICAgICAgYmtnZDogcHJvcHNDbG9uZS5ia2dkIHx8IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFNURVAgMTogQ3JlYXRlIHRoZSBTbGlkZSBNYXN0ZXIvTGF5b3V0XG4gICAgICAgIGNyZWF0ZVNsaWRlTWFzdGVyKHByb3BzQ2xvbmUsIG5ld0xheW91dCk7XG4gICAgICAgIC8vIFNURVAgMjogQWRkIGl0IHRvIGxheW91dCBkZWZzXG4gICAgICAgIHRoaXMuc2xpZGVMYXlvdXRzLnB1c2gobmV3TGF5b3V0KTtcbiAgICAgICAgLy8gU1RFUCAzOiBBZGQgYmFja2dyb3VuZCAoaW1hZ2UgZGF0YS9wYXRoIG11c3QgYmUgY2FwdHVyZWQgYmVmb3JlIGBleHBvcnRQcmVzZW50YXRpb24oKWAgaXMgY2FsbGVkKVxuICAgICAgICBpZiAocHJvcHNDbG9uZS5iYWNrZ3JvdW5kIHx8IHByb3BzQ2xvbmUuYmtnZClcbiAgICAgICAgICAgIGFkZEJhY2tncm91bmREZWZpbml0aW9uKHByb3BzQ2xvbmUuYmFja2dyb3VuZCwgbmV3TGF5b3V0KTtcbiAgICAgICAgLy8gU1RFUCA0OiBBZGQgc2xpZGVOdW1iZXIgdG8gbWFzdGVyIHNsaWRlIChpZiBhbnkpXG4gICAgICAgIGlmIChuZXdMYXlvdXQuX3NsaWRlTnVtYmVyUHJvcHMgJiYgIXRoaXMubWFzdGVyU2xpZGUuX3NsaWRlTnVtYmVyUHJvcHMpXG4gICAgICAgICAgICB0aGlzLm1hc3RlclNsaWRlLl9zbGlkZU51bWJlclByb3BzID0gbmV3TGF5b3V0Ll9zbGlkZU51bWJlclByb3BzO1xuICAgIH1cbiAgICAvLyBIVE1MLVRPLVNMSURFUyBNRVRIT0RTXG4gICAgLyoqXG4gICAgICogUmVwcm9kdWNlcyBhbiBIVE1MIHRhYmxlIGFzIGEgUG93ZXJQb2ludCB0YWJsZSAtIGluY2x1ZGluZyBjb2x1bW4gd2lkdGhzLCBzdHlsZSwgZXRjLiAtIGNyZWF0ZXMgMSBvciBtb3JlIHNsaWRlcyBhcyBuZWVkZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlSWQgLSB0YWJsZSBIVE1MIGVsZW1lbnQgSURcbiAgICAgKiBAcGFyYW0ge1RhYmxlVG9TbGlkZXNQcm9wc30gb3B0aW9ucyAtIGdlbmVyYXRpb24gb3B0aW9uc1xuICAgICAqL1xuICAgIHRhYmxlVG9TbGlkZXMoZWxlSWQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvLyBAbm90ZSBgdmVyYm9zZWAgb3B0aW9uIGlzIHVuZG9jdW1lbnRlZDsgdXNlZCBmb3IgdmVyYm9zZSBvdXRwdXQgb2YgbGF5b3V0IHByb2Nlc3NcbiAgICAgICAgZ2VuVGFibGVUb1NsaWRlcyh0aGlzLCBlbGVJZCwgb3B0aW9ucywgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tYXN0ZXJTbGlkZU5hbWUpID8gdGhpcy5zbGlkZUxheW91dHMuZmlsdGVyKGxheW91dCA9PiBsYXlvdXQuX25hbWUgPT09IG9wdGlvbnMubWFzdGVyU2xpZGVOYW1lKVswXSA6IG51bGwpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgUHB0eEdlbkpTIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pptxgenjs/dist/pptxgen.es.js\n");

/***/ })

};
;